diff --git a/third_party/fiat/p256_64.h b/third_party/fiat/p256_64.h
index 81a90013d..17bb23f0b 100644
--- a/third_party/fiat/p256_64.h
+++ b/third_party/fiat/p256_64.h
@@ -1,3 +1,9 @@
+#include "../../crypto/internal.h"
+#if !defined(OPENSSL_NO_ASM) && defined(__GNUC__) && defined(__x86_64__)
+void fiat_p256_adx_mul(uint64_t*, const uint64_t*, const uint64_t*);
+void fiat_p256_adx_sqr(uint64_t*, const uint64_t*);
+#endif
+
 /* Autogenerated: 'src/ExtractionOCaml/bedrock2_word_by_word_montgomery' --lang bedrock2 --static --no-wide-int --widen-carry --widen-bytes --split-multiret --no-select --no-field-element-typedefs p256 64 '2^256 - 2^224 + 2^192 + 2^96 - 1' mul square add sub opp from_montgomery to_montgomery nonzero selectznz to_bytes from_bytes one msat divstep divstep_precomp */
 /* curve description: p256 */
 /* machine_wordsize = 64 (from "64") */
@@ -426,6 +432,13 @@ void internal_fiat_p256_mul(uintptr_t out0, uintptr_t in0, uintptr_t in1) {
 
 /* NOTE: The following wrapper function is not covered by Coq proofs */
 static void fiat_p256_mul(uint64_t out1[4], const uint64_t arg1[4], const uint64_t arg2[4]) {
+#if !defined(OPENSSL_NO_ASM) && defined(__GNUC__) && defined(__x86_64__)
+  if (CRYPTO_is_BMI1_capable() && CRYPTO_is_BMI2_capable() &&
+    CRYPTO_is_ADX_capable()) {
+      fiat_p256_adx_mul(out1, arg1, arg2);
+      return;
+  }
+#endif
   internal_fiat_p256_mul((uintptr_t)out1, (uintptr_t)arg1, (uintptr_t)arg2);
 }
 
@@ -769,6 +782,13 @@ void internal_fiat_p256_square(uintptr_t out0, uintptr_t in0) {
 
 /* NOTE: The following wrapper function is not covered by Coq proofs */
 static void fiat_p256_square(uint64_t out1[4], const uint64_t arg1[4]) {
+#if !defined(OPENSSL_NO_ASM) && defined(__GNUC__) && defined(__x86_64__)
+  if (CRYPTO_is_BMI1_capable() && CRYPTO_is_BMI2_capable() &&
+    CRYPTO_is_ADX_capable()) {
+      fiat_p256_adx_sqr(out1, arg1);
+      return;
+  }
+#endif
   internal_fiat_p256_square((uintptr_t)out1, (uintptr_t)arg1);
 }
 
