montladder_body = 
fun (width : Z) (BW : Bitwidth width) (word : word width) (mem : map.map word byte) (word_ok : word.ok word) (mem_ok : map.ok mem)
  (field_parameters : FieldParameters) (scalar_field_parameters : ScalarFieldParameters) (field_representaton : FieldRepresentation) =>
noreassign
  (noskips
     (cmd.stackalloc "X1" size_in_bytes
        (cmd.seq (cmd.call [] felem_small_literal ["X1"; 1])
           (cmd.stackalloc "Z1" size_in_bytes
              (cmd.seq (cmd.call [] felem_small_literal ["Z1"; 0])
                 (cmd.stackalloc "X2" size_in_bytes
                    (cmd.seq (cmd.call [] felem_copy ["X2"; "U"])
                       (cmd.stackalloc "Z2" size_in_bytes
                          (cmd.seq (cmd.call [] felem_small_literal ["Z2"; 1])
                             (cmd.seq (cmd.set "swap" (word.unsigned (word.b2w false)))
                                (cmd.seq (cmd.set "count" (word.unsigned (word.of_Z scalarbits)))
                                   (cmd_downto_fresh (gs "_gs_i0") (word.unsigned (word.of_Z (Z.of_nat (Z.to_nat scalarbits))))
                                      (cmd.seq (cmd.call ["s_i"] sctestbit ["K"; "_gs_i0"])
                                         (cmd.seq (cmd.set "swap" (expr.op bopname.xor "swap" "s_i"))
                                            (cmd.seq (cmd.call [] felem_cswap ["swap"; "X1"; "X2"])
                                               (cmd.seq (cmd.call [] felem_cswap ["swap"; "Z1"; "Z2"])
                                                  (cmd.seq (cmd.call [] "ladderstep" ["U"; "X1"; "Z1"; "X2"; "Z2"])
                                                     (cmd.seq (cmd.set "swap" "s_i")
                                                        (fold_right (fun (v : string) (c : cmd) => cmd.seq (cmd.unset v) c) cmd.skip ["s_i"])))))))
                                      (cmd.seq (cmd.call [] felem_cswap ["swap"; "X1"; "X2"])
                                         (cmd.seq (cmd.call [] felem_cswap ["swap"; "Z1"; "Z2"])
                                            (cmd.seq (cmd.call [] inv ["OUT"; "Z1"])
                                               (cmd.seq (cmd.call [] mul ["OUT"; "X1"; "OUT"])
                                                  (fold_right (fun (v : string) (c : cmd) => cmd.seq (cmd.unset v) c) cmd.skip [])))))))))))))))))
     : forall (width : Z) (BW : Bitwidth width) (word : word width) (mem : map.map word byte),
       word.ok word -> map.ok mem -> forall field_parameters : FieldParameters, ScalarFieldParameters -> FieldRepresentation -> cmd

Arguments montladder_body {width}%Z_scope {BW word mem word_ok mem_ok field_parameters scalar_field_parameters field_representaton}
