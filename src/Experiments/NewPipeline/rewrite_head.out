rewrite_head = 
match idc in (ident t) return (Compile.value' true t) with
| @ident.Literal t v =>
    match
      t as t0
      return
        (base.base_interp t0 ->
         UnderLets.UnderLets base.type ident var (expr (type.base t0)))
    with
    | base.type.unit => fun v0 : unit => UnderLets.Base ##(v0)%expr
    | base.type.Z => fun v0 : Z => UnderLets.Base ##(v0)%expr
    | base.type.bool => fun v0 : bool => UnderLets.Base ##(v0)%expr
    | base.type.nat => fun v0 : nat => UnderLets.Base ##(v0)%expr
    end v
| ident.Nat_succ =>
    fun x : expr (type.base base.type.nat) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option nat) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun _ : Z => None
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun v0 : nat => Some v0
              end v
          | _ => None
          end
        with
        | Some args => UnderLets.Base ##(Nat.succ args)%expr
        | None => UnderLets.Base (#(ident.Nat_succ)%expr @ x)%expr_pat
        end
    | _ => UnderLets.Base (#(ident.Nat_succ)%expr @ x)%expr_pat
    end
| ident.Nat_pred =>
    fun x : expr (type.base base.type.nat) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option nat) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun _ : Z => None
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun v0 : nat => Some v0
              end v
          | _ => None
          end
        with
        | Some args => UnderLets.Base ##(Nat.pred args)%expr
        | None => UnderLets.Base (#(ident.Nat_pred)%expr @ x)%expr_pat
        end
    | _ => UnderLets.Base (#(ident.Nat_pred)%expr @ x)%expr_pat
    end
| ident.Nat_max =>
    fun x x0 : expr (type.base base.type.nat) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option nat) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun _ : Z => None
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun v0 : nat => Some v0
              end v
          | _ => None
          end
        with
        | Some args =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option nat)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun _ : Z => None
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun v0 : nat => Some v0
                      end v
                  | _ => None
                  end
                with
                | Some args0 => UnderLets.Base ##(Nat.max args args0)%expr
                | None =>
                    UnderLets.Base (#(ident.Nat_max)%expr @ x @ x0)%expr_pat
                end
            | _ => UnderLets.Base (#(ident.Nat_max)%expr @ x @ x0)%expr_pat
            end
        | None => UnderLets.Base (#(ident.Nat_max)%expr @ x @ x0)%expr_pat
        end
    | _ => UnderLets.Base (#(ident.Nat_max)%expr @ x @ x0)%expr_pat
    end
| ident.Nat_mul =>
    fun x x0 : expr (type.base base.type.nat) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option nat) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun _ : Z => None
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun v0 : nat => Some v0
              end v
          | _ => None
          end
        with
        | Some args =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option nat)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun _ : Z => None
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun v0 : nat => Some v0
                      end v
                  | _ => None
                  end
                with
                | Some args0 => UnderLets.Base ##((args * args0)%nat)%expr
                | None =>
                    UnderLets.Base (#(ident.Nat_mul)%expr @ x @ x0)%expr_pat
                end
            | _ => UnderLets.Base (#(ident.Nat_mul)%expr @ x @ x0)%expr_pat
            end
        | None => UnderLets.Base (#(ident.Nat_mul)%expr @ x @ x0)%expr_pat
        end
    | _ => UnderLets.Base (#(ident.Nat_mul)%expr @ x @ x0)%expr_pat
    end
| ident.Nat_add =>
    fun x x0 : expr (type.base base.type.nat) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option nat) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun _ : Z => None
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun v0 : nat => Some v0
              end v
          | _ => None
          end
        with
        | Some args =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option nat)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun _ : Z => None
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun v0 : nat => Some v0
                      end v
                  | _ => None
                  end
                with
                | Some args0 => UnderLets.Base ##((args + args0)%nat)%expr
                | None =>
                    UnderLets.Base (#(ident.Nat_add)%expr @ x @ x0)%expr_pat
                end
            | _ => UnderLets.Base (#(ident.Nat_add)%expr @ x @ x0)%expr_pat
            end
        | None => UnderLets.Base (#(ident.Nat_add)%expr @ x @ x0)%expr_pat
        end
    | _ => UnderLets.Base (#(ident.Nat_add)%expr @ x @ x0)%expr_pat
    end
| ident.Nat_sub =>
    fun x x0 : expr (type.base base.type.nat) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option nat) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun _ : Z => None
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun v0 : nat => Some v0
              end v
          | _ => None
          end
        with
        | Some args =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option nat)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun _ : Z => None
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun v0 : nat => Some v0
                      end v
                  | _ => None
                  end
                with
                | Some args0 => UnderLets.Base ##((args - args0)%nat)%expr
                | None =>
                    UnderLets.Base (#(ident.Nat_sub)%expr @ x @ x0)%expr_pat
                end
            | _ => UnderLets.Base (#(ident.Nat_sub)%expr @ x @ x0)%expr_pat
            end
        | None => UnderLets.Base (#(ident.Nat_sub)%expr @ x @ x0)%expr_pat
        end
    | _ => UnderLets.Base (#(ident.Nat_sub)%expr @ x @ x0)%expr_pat
    end
| @ident.nil t => UnderLets.Base []%expr_pat
| @ident.cons t =>
    fun (x : expr (type.base t)) (x0 : expr (type.base (base.type.list t)))
    => UnderLets.Base (x :: x0)%expr_pat
| @ident.pair A B =>
    fun (x : expr (type.base A)) (x0 : expr (type.base B)) =>
    UnderLets.Base (x, x0)%expr_pat
| @ident.fst A B =>
    fun x : expr (type.base (A * B)%etype) =>
    match x with
    | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ #(idc)%expr_pat x1) x0 =>
        match
          match idc with
          | @ident.pair A0 B0 => Some (A0, B0)
          | _ => None
          end
        with
        | Some _ =>
            match
              s0 as t2
              return
                (Compile.value' false t2 ->
                 UnderLets.UnderLets base.type ident var (expr (type.base A)))
            with
            | type.base t2 =>
                fun v : expr (type.base t2) =>
                match
                  s as t3
                  return
                    (Compile.value' false t3 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base A)))
                with
                | type.base t3 =>
                    fun _ : expr (type.base t3) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => expr (type.base t0)) t2 A
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base A)))
                      (fun
                         a : option
                               (expr (type.base t2) -> expr (type.base A)) =>
                       match a with
                       | Some x' => UnderLets.Base (x' v)
                       | None =>
                           UnderLets.Base (#(ident.fst)%expr @ x)%expr_pat
                       end)
                | (s1 -> d1)%ptype =>
                    fun _ : Compile.value' false s1 -> Compile.value' true d1
                    => UnderLets.Base (#(ident.fst)%expr @ x)%expr_pat
                end (Compile.reflect x0)
            | (s1 -> d1)%ptype =>
                fun _ : Compile.value' false s1 -> Compile.value' true d1 =>
                UnderLets.Base (#(ident.fst)%expr @ x)%expr_pat
            end (Compile.reflect x1)
        | None => UnderLets.Base (#(ident.fst)%expr @ x)%expr_pat
        end
    | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ ($_)%expr _) _ | @expr.App _
      _ _ s _ (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _) _ | @expr.App
      _ _ _ s _ (@expr.App _ _ _ s0 _ (_ @ _)%expr_pat _) _ | @expr.App _ _ _
      s _ (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _) _ =>
        UnderLets.Base (#(ident.fst)%expr @ x)%expr_pat
    | @expr.App _ _ _ s _ #(_)%expr_pat _ | @expr.App _ _ _ s _ ($_)%expr _ |
      @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _
      (@expr.LetIn _ _ _ _ _ _ _) _ =>
        UnderLets.Base (#(ident.fst)%expr @ x)%expr_pat
    | _ => UnderLets.Base (#(ident.fst)%expr @ x)%expr_pat
    end
| @ident.snd A B =>
    fun x : expr (type.base (A * B)%etype) =>
    match x with
    | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ #(idc)%expr_pat x1) x0 =>
        match
          match idc with
          | @ident.pair A0 B0 => Some (A0, B0)
          | _ => None
          end
        with
        | Some _ =>
            match
              s0 as t2
              return
                (Compile.value' false t2 ->
                 UnderLets.UnderLets base.type ident var (expr (type.base B)))
            with
            | type.base t2 =>
                fun _ : expr (type.base t2) =>
                match
                  s as t3
                  return
                    (Compile.value' false t3 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base B)))
                with
                | type.base t3 =>
                    fun v0 : expr (type.base t3) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => expr (type.base t0)) t3 B
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base B)))
                      (fun
                         a : option
                               (expr (type.base t3) -> expr (type.base B)) =>
                       match a with
                       | Some x' => UnderLets.Base (x' v0)
                       | None =>
                           UnderLets.Base (#(ident.snd)%expr @ x)%expr_pat
                       end)
                | (s1 -> d1)%ptype =>
                    fun _ : Compile.value' false s1 -> Compile.value' true d1
                    => UnderLets.Base (#(ident.snd)%expr @ x)%expr_pat
                end (Compile.reflect x0)
            | (s1 -> d1)%ptype =>
                fun _ : Compile.value' false s1 -> Compile.value' true d1 =>
                UnderLets.Base (#(ident.snd)%expr @ x)%expr_pat
            end (Compile.reflect x1)
        | None => UnderLets.Base (#(ident.snd)%expr @ x)%expr_pat
        end
    | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ ($_)%expr _) _ | @expr.App _
      _ _ s _ (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _) _ | @expr.App
      _ _ _ s _ (@expr.App _ _ _ s0 _ (_ @ _)%expr_pat _) _ | @expr.App _ _ _
      s _ (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _) _ =>
        UnderLets.Base (#(ident.snd)%expr @ x)%expr_pat
    | @expr.App _ _ _ s _ #(_)%expr_pat _ | @expr.App _ _ _ s _ ($_)%expr _ |
      @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _
      (@expr.LetIn _ _ _ _ _ _ _) _ =>
        UnderLets.Base (#(ident.snd)%expr @ x)%expr_pat
    | _ => UnderLets.Base (#(ident.snd)%expr @ x)%expr_pat
    end
| @ident.prod_rect A B T =>
    fun
      (x : expr (type.base A) ->
           expr (type.base B) ->
           UnderLets.UnderLets base.type ident var (expr (type.base T)))
      (x0 : expr (type.base (A * B)%etype)) =>
    match x0 with
    | @expr.App _ _ _ s _ #(_)%expr_pat _ | @expr.App _ _ _ s _ ($_)%expr _ |
      @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ =>
        UnderLets.Base
          (#(ident.prod_rect)%expr @
           (λ (x2 : var (type.base A))(x3 : var (type.base B)),
            UnderLets.to_expr (x ($x2) ($x3)))%expr @ x0)%expr_pat
    | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ #(idc)%expr_pat x2) x1 =>
        match
          match idc with
          | @ident.pair A0 B0 => Some (A0, B0)
          | _ => None
          end
        with
        | Some _ =>
            match
              s0 as t2
              return
                (Compile.value' false t2 ->
                 UnderLets.UnderLets base.type ident var (expr (type.base T)))
            with
            | type.base t2 =>
                fun v : expr (type.base t2) =>
                match
                  s as t3
                  return
                    (Compile.value' false t3 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base T)))
                with
                | type.base t3 =>
                    fun v0 : expr (type.base t3) =>
                    Compile.castbe v
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base T)))
                      (fun x3 : option (expr (type.base A)) =>
                       match x3 with
                       | Some x4 =>
                           Compile.castbe v0
                             (UnderLets.UnderLets base.type ident var
                                (expr (type.base T)))
                             (fun y : option (expr (type.base B)) =>
                              match y with
                              | Some y0 =>
                                  (fv <-- (e <-- x x4 y0;
                                           UnderLets.Base
                                             {|
                                             anyexpr_ty := T;
                                             unwrap := e |});
                                   base.try_make_transport_cps
                                     (fun t0 : base.type =>
                                      expr (type.base t0))
                                     (let (anyexpr_ty, _) := fv in anyexpr_ty)
                                     T
                                     (UnderLets.UnderLets base.type ident var
                                        (expr (type.base T)))
                                     (fun
                                        a : option
                                              (expr
                                                 (type.base
                                                    (let (anyexpr_ty, _) :=
                                                       fv in
                                                     anyexpr_ty)) ->
                                               expr (type.base T)) =>
                                      match a with
                                      | Some x' =>
                                          UnderLets.Base
                                            (x'
                                               (let
                                                  (anyexpr_ty, unwrap) as a0
                                                   return
                                                     (expr
                                                        (type.base
                                                           (let
                                                              (anyexpr_ty,
                                                               _) := a0 in
                                                            anyexpr_ty))) :=
                                                  fv in
                                                unwrap))
                                      | None =>
                                          UnderLets.Base
                                            (#(ident.prod_rect)%expr @
                                             (λ (x5 : var (type.base A))
                                              (x6 : var (type.base B)),
                                              UnderLets.to_expr
                                                (x ($x5) ($x6)))%expr @ x0)%expr_pat
                                      end))%under_lets
                              | None =>
                                  UnderLets.Base
                                    (#(ident.prod_rect)%expr @
                                     (λ (x5 : var (type.base A))(x6 : 
                                                                 var
                                                                   (type.base
                                                                    B)),
                                      UnderLets.to_expr (x ($x5) ($x6)))%expr @
                                     x0)%expr_pat
                              end)
                       | None =>
                           UnderLets.Base
                             (#(ident.prod_rect)%expr @
                              (λ (x4 : var (type.base A))(x5 : var
                                                                 (type.base B)),
                               UnderLets.to_expr (x ($x4) ($x5)))%expr @ x0)%expr_pat
                       end)
                | (s1 -> d1)%ptype =>
                    fun _ : Compile.value' false s1 -> Compile.value' true d1
                    =>
                    UnderLets.Base
                      (#(ident.prod_rect)%expr @
                       (λ (x3 : var (type.base A))(x4 : var (type.base B)),
                        UnderLets.to_expr (x ($x3) ($x4)))%expr @ x0)%expr_pat
                end (Compile.reflect x1)
            | (s1 -> d1)%ptype =>
                fun _ : Compile.value' false s1 -> Compile.value' true d1 =>
                UnderLets.Base
                  (#(ident.prod_rect)%expr @
                   (λ (x3 : var (type.base A))(x4 : var (type.base B)),
                    UnderLets.to_expr (x ($x3) ($x4)))%expr @ x0)%expr_pat
            end (Compile.reflect x2)
        | None =>
            UnderLets.Base
              (#(ident.prod_rect)%expr @
               (λ (x3 : var (type.base A))(x4 : var (type.base B)),
                UnderLets.to_expr (x ($x3) ($x4)))%expr @ x0)%expr_pat
        end
    | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ ($_)%expr _) _ | @expr.App _
      _ _ s _ (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _) _ =>
        UnderLets.Base
          (#(ident.prod_rect)%expr @
           (λ (x3 : var (type.base A))(x4 : var (type.base B)),
            UnderLets.to_expr (x ($x3) ($x4)))%expr @ x0)%expr_pat
    | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ (_ @ _)%expr_pat _) _ |
      @expr.App _ _ _ s _
      (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _) _ =>
        UnderLets.Base
          (#(ident.prod_rect)%expr @
           (λ (x4 : var (type.base A))(x5 : var (type.base B)),
            UnderLets.to_expr (x ($x4) ($x5)))%expr @ x0)%expr_pat
    | @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
        UnderLets.Base
          (#(ident.prod_rect)%expr @
           (λ (x3 : var (type.base A))(x4 : var (type.base B)),
            UnderLets.to_expr (x ($x3) ($x4)))%expr @ x0)%expr_pat
    | @expr.LetIn _ _ _ _ _ _ _ =>
        UnderLets.Base
          (#(ident.prod_rect)%expr @
           (λ (x2 : var (type.base A))(x3 : var (type.base B)),
            UnderLets.to_expr (x ($x2) ($x3)))%expr @ x0)%expr_pat
    | _ =>
        UnderLets.Base
          (#(ident.prod_rect)%expr @
           (λ (x1 : var (type.base A))(x2 : var (type.base B)),
            UnderLets.to_expr (x ($x1) ($x2)))%expr @ x0)%expr_pat
    end
| @ident.bool_rect T =>
    fun
      (x
       x0 : expr (type.base base.type.unit) ->
            UnderLets.UnderLets base.type ident var (expr (type.base T)))
      (x1 : expr (type.base base.type.bool)) =>
    match x1 with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option bool) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun _ : Z => None
              | base.type.bool => fun v0 : bool => Some v0
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            (fv <-- (e <-- (if args as b
                             return
                               (UnderLets.UnderLets base.type ident var
                                  (expr (type.base (if b then T else T))))
                            then x ##(tt)%expr
                            else x0 ##(tt)%expr);
                     UnderLets.Base
                       {| anyexpr_ty := if args then T else T; unwrap := e |});
             base.try_make_transport_cps
               (fun t0 : base.type => expr (type.base t0))
               (let (anyexpr_ty, _) := fv in anyexpr_ty) T
               (UnderLets.UnderLets base.type ident var (expr (type.base T)))
               (fun
                  a : option
                        (expr
                           (type.base
                              (let (anyexpr_ty, _) := fv in anyexpr_ty)) ->
                         expr (type.base T)) =>
                match a with
                | Some x' =>
                    UnderLets.Base
                      (x'
                         (let
                            (anyexpr_ty, unwrap) as a0
                             return
                               (expr
                                  (type.base
                                     (let (anyexpr_ty, _) := a0 in anyexpr_ty))) :=
                            fv in
                          unwrap))
                | None =>
                    UnderLets.Base
                      (#(ident.bool_rect)%expr @
                       (λ x2 : var (type.base base.type.unit),
                        UnderLets.to_expr (x ($x2)))%expr @
                       (λ x2 : var (type.base base.type.unit),
                        UnderLets.to_expr (x0 ($x2)))%expr @ x1)%expr_pat
                end))%under_lets
        | None =>
            UnderLets.Base
              (#(ident.bool_rect)%expr @
               (λ x2 : var (type.base base.type.unit),
                UnderLets.to_expr (x ($x2)))%expr @
               (λ x2 : var (type.base base.type.unit),
                UnderLets.to_expr (x0 ($x2)))%expr @ x1)%expr_pat
        end
    | ($_)%expr | @expr.Abs _ _ _ _ _ _ =>
        UnderLets.Base
          (#(ident.bool_rect)%expr @
           (λ x2 : var (type.base base.type.unit),
            UnderLets.to_expr (x ($x2)))%expr @
           (λ x2 : var (type.base base.type.unit),
            UnderLets.to_expr (x0 ($x2)))%expr @ x1)%expr_pat
    | _ =>
        UnderLets.Base
          (#(ident.bool_rect)%expr @
           (λ x3 : var (type.base base.type.unit),
            UnderLets.to_expr (x ($x3)))%expr @
           (λ x3 : var (type.base base.type.unit),
            UnderLets.to_expr (x0 ($x3)))%expr @ x1)%expr_pat
    end
| @ident.nat_rect P =>
    fun
      (x : expr (type.base base.type.unit) ->
           UnderLets.UnderLets base.type ident var (expr (type.base P)))
      (x0 : expr (type.base base.type.nat) ->
            expr (type.base P) ->
            UnderLets.UnderLets base.type ident var (expr (type.base P)))
      (x1 : expr (type.base base.type.nat)) =>
    match x1 with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option nat) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun _ : Z => None
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun v0 : nat => Some v0
              end v
          | _ => None
          end
        with
        | Some args =>
            Compile.castv x0
              (UnderLets.UnderLets base.type ident var (expr (type.base P)))
              (fun
                 S_case : option
                            (expr (type.base base.type.nat) ->
                             expr (type.base P) ->
                             UnderLets.UnderLets base.type ident var
                               (expr (type.base P))) =>
               match S_case with
               | Some S_case0 =>
                   (fv <-- (e <-- nat_rect
                                    (fun _ : nat =>
                                     UnderLets.UnderLets base.type ident var
                                       (expr (type.base P))) (x ##(tt)%expr)
                                    (fun (n' : nat)
                                       (rec : UnderLets.UnderLets base.type
                                                ident var
                                                (expr (type.base P))) =>
                                     rec0 <-- rec;
                                     S_case0 ##(n')%expr rec0) args;
                            UnderLets.Base {| anyexpr_ty := P; unwrap := e |});
                    base.try_make_transport_cps
                      (fun t0 : base.type => expr (type.base t0))
                      (let (anyexpr_ty, _) := fv in anyexpr_ty) P
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base P)))
                      (fun
                         a : option
                               (expr
                                  (type.base
                                     (let (anyexpr_ty, _) := fv in anyexpr_ty)) ->
                                expr (type.base P)) =>
                       match a with
                       | Some x' =>
                           UnderLets.Base
                             (x'
                                (let
                                   (anyexpr_ty, unwrap) as a0
                                    return
                                      (expr
                                         (type.base
                                            (let (anyexpr_ty, _) := a0 in
                                             anyexpr_ty))) := fv in
                                 unwrap))
                       | None =>
                           UnderLets.Base
                             (#(ident.nat_rect)%expr @
                              (λ x2 : var (type.base base.type.unit),
                               UnderLets.to_expr (x ($x2)))%expr @
                              (λ (x2 : var (type.base base.type.nat))
                               (x3 : var (type.base P)),
                               UnderLets.to_expr (x0 ($x2) ($x3)))%expr @ x1)%expr_pat
                       end))%under_lets
               | None =>
                   UnderLets.Base
                     (#(ident.nat_rect)%expr @
                      (λ x2 : var (type.base base.type.unit),
                       UnderLets.to_expr (x ($x2)))%expr @
                      (λ (x2 : var (type.base base.type.nat))(x3 : var
                                                                    (type.base
                                                                    P)),
                       UnderLets.to_expr (x0 ($x2) ($x3)))%expr @ x1)%expr_pat
               end)
        | None =>
            UnderLets.Base
              (#(ident.nat_rect)%expr @
               (λ x2 : var (type.base base.type.unit),
                UnderLets.to_expr (x ($x2)))%expr @
               (λ (x2 : var (type.base base.type.nat))(x3 : var (type.base P)),
                UnderLets.to_expr (x0 ($x2) ($x3)))%expr @ x1)%expr_pat
        end
    | ($_)%expr | @expr.Abs _ _ _ _ _ _ =>
        UnderLets.Base
          (#(ident.nat_rect)%expr @
           (λ x2 : var (type.base base.type.unit),
            UnderLets.to_expr (x ($x2)))%expr @
           (λ (x2 : var (type.base base.type.nat))(x3 : var (type.base P)),
            UnderLets.to_expr (x0 ($x2) ($x3)))%expr @ x1)%expr_pat
    | _ =>
        UnderLets.Base
          (#(ident.nat_rect)%expr @
           (λ x3 : var (type.base base.type.unit),
            UnderLets.to_expr (x ($x3)))%expr @
           (λ (x3 : var (type.base base.type.nat))(x4 : var (type.base P)),
            UnderLets.to_expr (x0 ($x3) ($x4)))%expr @ x1)%expr_pat
    end
| @ident.list_rect A P =>
    fun
      (x : expr (type.base base.type.unit) ->
           UnderLets.UnderLets base.type ident var (expr (type.base P)))
      (x0 : expr (type.base A) ->
            expr (type.base (base.type.list A)) ->
            expr (type.base P) ->
            UnderLets.UnderLets base.type ident var (expr (type.base P)))
      (x1 : expr (type.base (base.type.list A))) =>
    Compile.castv x0
      (UnderLets.UnderLets base.type ident var (expr (type.base P)))
      (fun
         Pcons : option
                   (expr (type.base A) ->
                    expr (type.base (base.type.list A)) ->
                    expr (type.base P) ->
                    UnderLets.UnderLets base.type ident var
                      (expr (type.base P))) =>
       match Pcons with
       | Some Pcons0 =>
           reflect_list_cps x1
             (fun ls : option (list (expr (type.base A))) =>
              match ls with
              | Some ls0 =>
                  (fv <-- (e <-- list_rect
                                   (fun _ : list (expr (type.base A)) =>
                                    UnderLets.UnderLets base.type ident var
                                      (expr (type.base P))) (x ##(tt)%expr)
                                   (fun (x2 : expr (type.base A))
                                      (xs : list (expr (type.base A)))
                                      (rec : UnderLets.UnderLets base.type
                                               ident var (expr (type.base P)))
                                    =>
                                    rec' <-- rec;
                                    Pcons0 x2 (reify_list xs) rec') ls0;
                           UnderLets.Base {| anyexpr_ty := P; unwrap := e |});
                   base.try_make_transport_cps
                     (fun t : base.type => expr (type.base t))
                     (let (anyexpr_ty, _) := fv in anyexpr_ty) P
                     (UnderLets.UnderLets base.type ident var
                        (expr (type.base P)))
                     (fun
                        a : option
                              (expr
                                 (type.base
                                    (let (anyexpr_ty, _) := fv in anyexpr_ty)) ->
                               expr (type.base P)) =>
                      match a with
                      | Some x' =>
                          UnderLets.Base
                            (x'
                               (let
                                  (anyexpr_ty, unwrap) as a0
                                   return
                                     (expr
                                        (type.base
                                           (let (anyexpr_ty, _) := a0 in
                                            anyexpr_ty))) := fv in
                                unwrap))
                      | None =>
                          UnderLets.Base
                            (#(ident.list_rect)%expr @
                             (λ x2 : var (type.base base.type.unit),
                              UnderLets.to_expr (x ($x2)))%expr @
                             (λ (x2 : var (type.base A))(x3 : var
                                                                (type.base
                                                                   (base.type.list
                                                                    A)))
                              (x4 : var (type.base P)),
                              UnderLets.to_expr (x0 ($x2) ($x3) ($x4)))%expr @
                             x1)%expr_pat
                      end))%under_lets
              | None =>
                  UnderLets.Base
                    (#(ident.list_rect)%expr @
                     (λ x2 : var (type.base base.type.unit),
                      UnderLets.to_expr (x ($x2)))%expr @
                     (λ (x2 : var (type.base A))(x3 : var
                                                        (type.base
                                                           (base.type.list A)))
                      (x4 : var (type.base P)),
                      UnderLets.to_expr (x0 ($x2) ($x3) ($x4)))%expr @ x1)%expr_pat
              end)
       | None =>
           UnderLets.Base
             (#(ident.list_rect)%expr @
              (λ x2 : var (type.base base.type.unit),
               UnderLets.to_expr (x ($x2)))%expr @
              (λ (x2 : var (type.base A))(x3 : var
                                                 (type.base
                                                    (base.type.list A)))
               (x4 : var (type.base P)),
               UnderLets.to_expr (x0 ($x2) ($x3) ($x4)))%expr @ x1)%expr_pat
       end)
| @ident.list_case A P =>
    fun
      (x : expr (type.base base.type.unit) ->
           UnderLets.UnderLets base.type ident var (expr (type.base P)))
      (x0 : expr (type.base A) ->
            expr (type.base (base.type.list A)) ->
            UnderLets.UnderLets base.type ident var (expr (type.base P)))
      (x1 : expr (type.base (base.type.list A))) =>
    match x1 with
    | #(idc)%expr_pat =>
        match match idc with
              | @ident.nil t0 => Some t0
              | _ => None
              end with
        | Some _ =>
            (fv <-- (e <-- x ##(tt)%expr;
                     UnderLets.Base {| anyexpr_ty := P; unwrap := e |});
             base.try_make_transport_cps
               (fun t0 : base.type => expr (type.base t0))
               (let (anyexpr_ty, _) := fv in anyexpr_ty) P
               (UnderLets.UnderLets base.type ident var (expr (type.base P)))
               (fun
                  a : option
                        (expr
                           (type.base
                              (let (anyexpr_ty, _) := fv in anyexpr_ty)) ->
                         expr (type.base P)) =>
                match a with
                | Some x' =>
                    UnderLets.Base
                      (x'
                         (let
                            (anyexpr_ty, unwrap) as a0
                             return
                               (expr
                                  (type.base
                                     (let (anyexpr_ty, _) := a0 in anyexpr_ty))) :=
                            fv in
                          unwrap))
                | None =>
                    UnderLets.Base
                      (#(ident.list_case)%expr @
                       (λ x2 : var (type.base base.type.unit),
                        UnderLets.to_expr (x ($x2)))%expr @
                       (λ (x2 : var (type.base A))(x3 : var
                                                          (type.base
                                                             (base.type.list
                                                                A))),
                        UnderLets.to_expr (x0 ($x2) ($x3)))%expr @ x1)%expr_pat
                end))%under_lets
        | None =>
            UnderLets.Base
              (#(ident.list_case)%expr @
               (λ x2 : var (type.base base.type.unit),
                UnderLets.to_expr (x ($x2)))%expr @
               (λ (x2 : var (type.base A))(x3 : var
                                                  (type.base
                                                     (base.type.list A))),
                UnderLets.to_expr (x0 ($x2) ($x3)))%expr @ x1)%expr_pat
        end
    | @expr.App _ _ _ s _ #(_)%expr_pat _ | @expr.App _ _ _ s _ ($_)%expr _ |
      @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ =>
        UnderLets.Base
          (#(ident.list_case)%expr @
           (λ x3 : var (type.base base.type.unit),
            UnderLets.to_expr (x ($x3)))%expr @
           (λ (x3 : var (type.base A))(x4 : var
                                              (type.base (base.type.list A))),
            UnderLets.to_expr (x0 ($x3) ($x4)))%expr @ x1)%expr_pat
    | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ #(idc)%expr_pat x3) x2 =>
        match match idc with
              | @ident.cons t0 => Some t0
              | _ => None
              end with
        | Some _ =>
            match
              s0 as t2
              return
                (Compile.value' false t2 ->
                 UnderLets.UnderLets base.type ident var (expr (type.base P)))
            with
            | type.base t2 =>
                fun v : expr (type.base t2) =>
                match
                  s as t3
                  return
                    (Compile.value' false t3 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base P)))
                with
                | type.base t3 =>
                    fun v0 : expr (type.base t3) =>
                    Compile.castbe v
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base P)))
                      (fun x4 : option (expr (type.base A)) =>
                       match x4 with
                       | Some x5 =>
                           Compile.castbe v0
                             (UnderLets.UnderLets base.type ident var
                                (expr (type.base P)))
                             (fun
                                xs : option
                                       (expr (type.base (base.type.list A)))
                              =>
                              match xs with
                              | Some xs0 =>
                                  (fv <-- (e <-- x0 x5 xs0;
                                           UnderLets.Base
                                             {|
                                             anyexpr_ty := P;
                                             unwrap := e |});
                                   base.try_make_transport_cps
                                     (fun t0 : base.type =>
                                      expr (type.base t0))
                                     (let (anyexpr_ty, _) := fv in anyexpr_ty)
                                     P
                                     (UnderLets.UnderLets base.type ident var
                                        (expr (type.base P)))
                                     (fun
                                        a : option
                                              (expr
                                                 (type.base
                                                    (let (anyexpr_ty, _) :=
                                                       fv in
                                                     anyexpr_ty)) ->
                                               expr (type.base P)) =>
                                      match a with
                                      | Some x' =>
                                          UnderLets.Base
                                            (x'
                                               (let
                                                  (anyexpr_ty, unwrap) as a0
                                                   return
                                                     (expr
                                                        (type.base
                                                           (let
                                                              (anyexpr_ty,
                                                               _) := a0 in
                                                            anyexpr_ty))) :=
                                                  fv in
                                                unwrap))
                                      | None =>
                                          UnderLets.Base
                                            (#(ident.list_case)%expr @
                                             (λ x6 : var
                                                       (type.base
                                                          base.type.unit),
                                              UnderLets.to_expr (x ($x6)))%expr @
                                             (λ (x6 : var (type.base A))
                                              (x7 : var
                                                      (type.base
                                                         (base.type.list A))),
                                              UnderLets.to_expr
                                                (x0 ($x6) ($x7)))%expr @ x1)%expr_pat
                                      end))%under_lets
                              | None =>
                                  UnderLets.Base
                                    (#(ident.list_case)%expr @
                                     (λ x6 : var (type.base base.type.unit),
                                      UnderLets.to_expr (x ($x6)))%expr @
                                     (λ (x6 : var (type.base A))(x7 : 
                                                                 var
                                                                   (type.base
                                                                    (base.type.list
                                                                    A))),
                                      UnderLets.to_expr (x0 ($x6) ($x7)))%expr @
                                     x1)%expr_pat
                              end)
                       | None =>
                           UnderLets.Base
                             (#(ident.list_case)%expr @
                              (λ x5 : var (type.base base.type.unit),
                               UnderLets.to_expr (x ($x5)))%expr @
                              (λ (x5 : var (type.base A))(x6 : var
                                                                 (type.base
                                                                    (base.type.list
                                                                    A))),
                               UnderLets.to_expr (x0 ($x5) ($x6)))%expr @ x1)%expr_pat
                       end)
                | (s1 -> d1)%ptype =>
                    fun _ : Compile.value' false s1 -> Compile.value' true d1
                    =>
                    UnderLets.Base
                      (#(ident.list_case)%expr @
                       (λ x4 : var (type.base base.type.unit),
                        UnderLets.to_expr (x ($x4)))%expr @
                       (λ (x4 : var (type.base A))(x5 : var
                                                          (type.base
                                                             (base.type.list
                                                                A))),
                        UnderLets.to_expr (x0 ($x4) ($x5)))%expr @ x1)%expr_pat
                end (Compile.reflect x2)
            | (s1 -> d1)%ptype =>
                fun _ : Compile.value' false s1 -> Compile.value' true d1 =>
                UnderLets.Base
                  (#(ident.list_case)%expr @
                   (λ x4 : var (type.base base.type.unit),
                    UnderLets.to_expr (x ($x4)))%expr @
                   (λ (x4 : var (type.base A))(x5 : var
                                                      (type.base
                                                         (base.type.list A))),
                    UnderLets.to_expr (x0 ($x4) ($x5)))%expr @ x1)%expr_pat
            end (Compile.reflect x3)
        | None =>
            UnderLets.Base
              (#(ident.list_case)%expr @
               (λ x4 : var (type.base base.type.unit),
                UnderLets.to_expr (x ($x4)))%expr @
               (λ (x4 : var (type.base A))(x5 : var
                                                  (type.base
                                                     (base.type.list A))),
                UnderLets.to_expr (x0 ($x4) ($x5)))%expr @ x1)%expr_pat
        end
    | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ ($_)%expr _) _ | @expr.App _
      _ _ s _ (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _) _ =>
        UnderLets.Base
          (#(ident.list_case)%expr @
           (λ x4 : var (type.base base.type.unit),
            UnderLets.to_expr (x ($x4)))%expr @
           (λ (x4 : var (type.base A))(x5 : var
                                              (type.base (base.type.list A))),
            UnderLets.to_expr (x0 ($x4) ($x5)))%expr @ x1)%expr_pat
    | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ (_ @ _)%expr_pat _) _ |
      @expr.App _ _ _ s _
      (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _) _ =>
        UnderLets.Base
          (#(ident.list_case)%expr @
           (λ x5 : var (type.base base.type.unit),
            UnderLets.to_expr (x ($x5)))%expr @
           (λ (x5 : var (type.base A))(x6 : var
                                              (type.base (base.type.list A))),
            UnderLets.to_expr (x0 ($x5) ($x6)))%expr @ x1)%expr_pat
    | @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
        UnderLets.Base
          (#(ident.list_case)%expr @
           (λ x4 : var (type.base base.type.unit),
            UnderLets.to_expr (x ($x4)))%expr @
           (λ (x4 : var (type.base A))(x5 : var
                                              (type.base (base.type.list A))),
            UnderLets.to_expr (x0 ($x4) ($x5)))%expr @ x1)%expr_pat
    | @expr.LetIn _ _ _ _ _ _ _ =>
        UnderLets.Base
          (#(ident.list_case)%expr @
           (λ x3 : var (type.base base.type.unit),
            UnderLets.to_expr (x ($x3)))%expr @
           (λ (x3 : var (type.base A))(x4 : var
                                              (type.base (base.type.list A))),
            UnderLets.to_expr (x0 ($x3) ($x4)))%expr @ x1)%expr_pat
    | _ =>
        UnderLets.Base
          (#(ident.list_case)%expr @
           (λ x2 : var (type.base base.type.unit),
            UnderLets.to_expr (x ($x2)))%expr @
           (λ (x2 : var (type.base A))(x3 : var
                                              (type.base (base.type.list A))),
            UnderLets.to_expr (x0 ($x2) ($x3)))%expr @ x1)%expr_pat
    end
| @ident.List_length T =>
    fun x : expr (type.base (base.type.list T)) =>
    reflect_list_cps x
      (fun xs : option (list (expr (type.base T))) =>
       match xs with
       | Some xs0 => UnderLets.Base ##(length xs0)%expr
       | None => UnderLets.Base (#(ident.List_length)%expr @ x)%expr_pat
       end)
| ident.List_seq =>
    fun x x0 : expr (type.base base.type.nat) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option nat) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun _ : Z => None
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun v0 : nat => Some v0
              end v
          | _ => None
          end
        with
        | Some args =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option nat)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun _ : Z => None
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun v0 : nat => Some v0
                      end v
                  | _ => None
                  end
                with
                | Some args0 =>
                    UnderLets.Base
                      (fold_right
                         (fun (x1 : expr (type.base base.type.nat))
                            (xs : expr
                                    (type.base (base.type.list base.type.nat)))
                          => (x1 :: xs)%expr_pat) []%expr_pat
                         (map (fun v : nat => ##(v)%expr) (seq args args0)))
                | None =>
                    UnderLets.Base (#(ident.List_seq)%expr @ x @ x0)%expr_pat
                end
            | _ => UnderLets.Base (#(ident.List_seq)%expr @ x @ x0)%expr_pat
            end
        | None => UnderLets.Base (#(ident.List_seq)%expr @ x @ x0)%expr_pat
        end
    | _ => UnderLets.Base (#(ident.List_seq)%expr @ x @ x0)%expr_pat
    end
| @ident.List_repeat A =>
    fun (x : expr (type.base A)) (x0 : expr (type.base base.type.nat)) =>
    match x0 with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option nat) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun _ : Z => None
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun v0 : nat => Some v0
              end v
          | _ => None
          end
        with
        | Some args =>
            base.try_make_transport_cps
              (fun A0 : base.type => expr (type.base (base.type.list A0))) A
              A
              (UnderLets.UnderLets base.type ident var
                 (expr (type.base (base.type.list A))))
              (fun
                 a : option
                       (expr (type.base (base.type.list A)) ->
                        expr (type.base (base.type.list A))) =>
               match a with
               | Some x' => UnderLets.Base (x' (reify_list (repeat x args)))
               | None =>
                   UnderLets.Base
                     (#(ident.List_repeat)%expr @ x @ x0)%expr_pat
               end)
        | None =>
            UnderLets.Base (#(ident.List_repeat)%expr @ x @ x0)%expr_pat
        end
    | _ => UnderLets.Base (#(ident.List_repeat)%expr @ x @ x0)%expr_pat
    end
| @ident.List_combine A B =>
    fun (x : expr (type.base (base.type.list A)))
      (x0 : expr (type.base (base.type.list B))) =>
    reflect_list_cps x
      (fun xs : option (list (expr (type.base A))) =>
       match xs with
       | Some xs0 =>
           reflect_list_cps x0
             (fun ys : option (list (expr (type.base B))) =>
              match ys with
              | Some ys0 =>
                  (trA <-- base.try_make_transport_cps
                             (fun A0 : base.type =>
                              expr (type.base (base.type.list (A0 * B)))) A A;
                   trB <-- base.try_make_transport_cps
                             (fun B0 : base.type =>
                              expr (type.base (base.type.list (A * B0)))) B B;
                   return Some
                            (fun
                               v : expr (type.base (base.type.list (A * B)))
                             => trB (trA v)))%cps
                    (UnderLets.UnderLets base.type ident var
                       (expr (type.base (base.type.list (A * B)))))
                    (fun
                       a : option
                             (expr (type.base (base.type.list (A * B))) ->
                              expr (type.base (base.type.list (A * B)))) =>
                     match a with
                     | Some x' =>
                         UnderLets.Base
                           (x'
                              (reify_list
                                 (map (fun '(x1, y) => (x1, y)%expr_pat)
                                    (combine xs0 ys0))))
                     | None =>
                         UnderLets.Base
                           (#(ident.List_combine)%expr @ x @ x0)%expr_pat
                     end)
              | None =>
                  UnderLets.Base
                    (#(ident.List_combine)%expr @ x @ x0)%expr_pat
              end)
       | None =>
           UnderLets.Base (#(ident.List_combine)%expr @ x @ x0)%expr_pat
       end)
| @ident.List_map A B =>
    fun
      (x : expr (type.base A) ->
           UnderLets.UnderLets base.type ident var (expr (type.base B)))
      (x0 : expr (type.base (base.type.list A))) =>
    Compile.castbe x0
      (UnderLets.UnderLets base.type ident var
         (expr (type.base (base.type.list B))))
      (fun e : option (expr (type.base (base.type.list A))) =>
       match e with
       | Some e0 =>
           reflect_list_cps e0
             (fun ls : option (list (expr (type.base A))) =>
              match ls with
              | Some ls0 =>
                  (fv <-- (e1 <-- list_rect
                                    (fun _ : list (expr (type.base A)) =>
                                     UnderLets.UnderLets base.type ident var
                                       (expr (type.base (base.type.list B))))
                                    (UnderLets.Base []%expr_pat)
                                    (fun (x1 : expr (type.base A))
                                       (_ : list (expr (type.base A)))
                                       (rec : UnderLets.UnderLets base.type
                                                ident var
                                                (expr
                                                   (type.base
                                                      (base.type.list B))))
                                     =>
                                     rec' <-- rec;
                                     fx <-- x x1;
                                     UnderLets.Base (fx :: rec')%expr_pat)
                                    ls0;
                           UnderLets.Base
                             {|
                             anyexpr_ty := base.type.list B;
                             unwrap := e1 |});
                   base.try_make_transport_cps
                     (fun t : base.type => expr (type.base t))
                     (let (anyexpr_ty, _) := fv in anyexpr_ty)
                     (base.type.list B)
                     (UnderLets.UnderLets base.type ident var
                        (expr (type.base (base.type.list B))))
                     (fun
                        a : option
                              (expr
                                 (type.base
                                    (let (anyexpr_ty, _) := fv in anyexpr_ty)) ->
                               expr (type.base (base.type.list B))) =>
                      match a with
                      | Some x' =>
                          UnderLets.Base
                            (x'
                               (let
                                  (anyexpr_ty, unwrap) as a0
                                   return
                                     (expr
                                        (type.base
                                           (let (anyexpr_ty, _) := a0 in
                                            anyexpr_ty))) := fv in
                                unwrap))
                      | None =>
                          UnderLets.Base
                            (#(ident.List_map)%expr @
                             (λ x1 : var (type.base A),
                              UnderLets.to_expr (x ($x1)))%expr @ x0)%expr_pat
                      end))%under_lets
              | None =>
                  UnderLets.Base
                    (#(ident.List_map)%expr @
                     (λ x1 : var (type.base A),
                      UnderLets.to_expr (x ($x1)))%expr @ x0)%expr_pat
              end)
       | None =>
           UnderLets.Base
             (#(ident.List_map)%expr @
              (λ x1 : var (type.base A),
               UnderLets.to_expr (x ($x1)))%expr @ x0)%expr_pat
       end)
| @ident.List_app A =>
    fun x x0 : expr (type.base (base.type.list A)) =>
    Compile.castbe x
      (UnderLets.UnderLets base.type ident var
         (expr (type.base (base.type.list A))))
      (fun e : option (expr (type.base (base.type.list A))) =>
       match e with
       | Some e0 =>
           reflect_list_cps e0
             (fun ls : option (list (expr (type.base A))) =>
              match ls with
              | Some ls0 =>
                  (fv <-- (e1 <-- list_rect
                                    (fun _ : list (expr (type.base A)) =>
                                     UnderLets.UnderLets base.type ident var
                                       (expr (type.base (base.type.list A))))
                                    (UnderLets.Base x0)
                                    (fun (x1 : expr (type.base A))
                                       (_ : list (expr (type.base A)))
                                       (rec : UnderLets.UnderLets base.type
                                                ident var
                                                (expr
                                                   (type.base
                                                      (base.type.list A))))
                                     =>
                                     rec' <-- rec;
                                     UnderLets.Base (x1 :: rec')%expr_pat)
                                    ls0;
                           UnderLets.Base
                             {|
                             anyexpr_ty := base.type.list A;
                             unwrap := e1 |});
                   base.try_make_transport_cps
                     (fun t : base.type => expr (type.base t))
                     (let (anyexpr_ty, _) := fv in anyexpr_ty)
                     (base.type.list A)
                     (UnderLets.UnderLets base.type ident var
                        (expr (type.base (base.type.list A))))
                     (fun
                        a : option
                              (expr
                                 (type.base
                                    (let (anyexpr_ty, _) := fv in anyexpr_ty)) ->
                               expr (type.base (base.type.list A))) =>
                      match a with
                      | Some x' =>
                          UnderLets.Base
                            (x'
                               (let
                                  (anyexpr_ty, unwrap) as a0
                                   return
                                     (expr
                                        (type.base
                                           (let (anyexpr_ty, _) := a0 in
                                            anyexpr_ty))) := fv in
                                unwrap))
                      | None => UnderLets.Base (x ++ x0)%expr
                      end))%under_lets
              | None => UnderLets.Base (x ++ x0)%expr
              end)
       | None => UnderLets.Base (x ++ x0)%expr
       end)
| @ident.List_rev A =>
    fun x : expr (type.base (base.type.list A)) =>
    reflect_list_cps x
      (fun xs : option (list (expr (type.base A))) =>
       match xs with
       | Some xs0 =>
           base.try_make_transport_cps
             (fun A0 : base.type => expr (type.base (base.type.list A0))) A A
             (UnderLets.UnderLets base.type ident var
                (expr (type.base (base.type.list A))))
             (fun
                a : option
                      (expr (type.base (base.type.list A)) ->
                       expr (type.base (base.type.list A))) =>
              match a with
              | Some x' => UnderLets.Base (x' (reify_list (rev xs0)))
              | None => UnderLets.Base (#(ident.List_rev)%expr @ x)%expr_pat
              end)
       | None => UnderLets.Base (#(ident.List_rev)%expr @ x)%expr_pat
       end)
| @ident.List_flat_map A B =>
    fun
      (x : expr (type.base A) ->
           UnderLets.UnderLets base.type ident var
             (expr (type.base (base.type.list B))))
      (x0 : expr (type.base (base.type.list A))) =>
    Compile.castbe x0
      (UnderLets.UnderLets base.type ident var
         (expr (type.base (base.type.list B))))
      (fun e : option (expr (type.base (base.type.list A))) =>
       match e with
       | Some e0 =>
           reflect_list_cps e0
             (fun ls : option (list (expr (type.base A))) =>
              match ls with
              | Some ls0 =>
                  (fv <-- (e1 <-- list_rect
                                    (fun _ : list (expr (type.base A)) =>
                                     UnderLets.UnderLets base.type ident var
                                       (expr (type.base (base.type.list B))))
                                    (UnderLets.Base []%expr_pat)
                                    (fun (x1 : expr (type.base A))
                                       (_ : list (expr (type.base A)))
                                       (rec : UnderLets.UnderLets base.type
                                                ident var
                                                (expr
                                                   (type.base
                                                      (base.type.list B))))
                                     =>
                                     rec' <-- rec;
                                     fx <-- x x1;
                                     UnderLets.Base ($fx ++ rec')%expr) ls0;
                           UnderLets.Base
                             {|
                             anyexpr_ty := base.type.list B;
                             unwrap := e1 |});
                   fv0 <-- do_again (let (anyexpr_ty, _) := fv in anyexpr_ty)
                             (let
                                (anyexpr_ty, unwrap) as a
                                 return
                                   (expr
                                      (type.base
                                         (let (anyexpr_ty, _) := a in
                                          anyexpr_ty))) := fv in
                              unwrap);
                   base.try_make_transport_cps
                     (fun t : base.type => expr (type.base t))
                     (let (anyexpr_ty, _) := fv in anyexpr_ty)
                     (base.type.list B)
                     (UnderLets.UnderLets base.type ident var
                        (expr (type.base (base.type.list B))))
                     (fun
                        a : option
                              (expr
                                 (type.base
                                    (let (anyexpr_ty, _) := fv in anyexpr_ty)) ->
                               expr (type.base (base.type.list B))) =>
                      match a with
                      | Some x' => UnderLets.Base (x' fv0)
                      | None =>
                          UnderLets.Base
                            (#(ident.List_flat_map)%expr @
                             (λ x1 : var (type.base A),
                              UnderLets.to_expr (x ($x1)))%expr @ x0)%expr_pat
                      end))%under_lets
              | None =>
                  UnderLets.Base
                    (#(ident.List_flat_map)%expr @
                     (λ x1 : var (type.base A),
                      UnderLets.to_expr (x ($x1)))%expr @ x0)%expr_pat
              end)
       | None =>
           UnderLets.Base
             (#(ident.List_flat_map)%expr @
              (λ x1 : var (type.base A),
               UnderLets.to_expr (x ($x1)))%expr @ x0)%expr_pat
       end)
| @ident.List_partition A =>
    fun
      (x : expr (type.base A) ->
           UnderLets.UnderLets base.type ident var
             (expr (type.base base.type.bool)))
      (x0 : expr (type.base (base.type.list A))) =>
    Compile.castbe x0
      (UnderLets.UnderLets base.type ident var
         (expr (type.base (base.type.list A * base.type.list A)%etype)))
      (fun e : option (expr (type.base (base.type.list A))) =>
       match e with
       | Some e0 =>
           reflect_list_cps e0
             (fun ls : option (list (expr (type.base A))) =>
              match ls with
              | Some ls0 =>
                  (fv <-- (e1 <-- list_rect
                                    (fun _ : list (expr (type.base A)) =>
                                     UnderLets.UnderLets base.type ident var
                                       (expr
                                          (type.base
                                             (base.type.list A *
                                              base.type.list A)%etype)))
                                    (UnderLets.Base ([], [])%expr_pat)
                                    (fun (x1 : expr (type.base A))
                                       (_ : list (expr (type.base A)))
                                       (rec : UnderLets.UnderLets base.type
                                                ident var
                                                (expr
                                                   (type.base
                                                      (base.type.list A *
                                                       base.type.list A)%etype)))
                                     =>
                                     rec' <-- rec;
                                     fx <-- id x x1;
                                     UnderLets.Base
                                       (#(ident.prod_rect)%expr @
                                        (λ g
                                            d : expr
                                                  (type.base
                                                     (base.type.list A)),
                                         (#(ident.bool_rect)%expr @
                                          (λ _ : expr
                                                   (type.base base.type.unit),
                                           ($x1 :: $g, $d)%expr_pat) @
                                          (λ _ : expr
                                                   (type.base base.type.unit),
                                           ($g, $x1 :: $d)%expr_pat) @ $fx)%expr_pat)%expr @
                                        rec')%expr_pat) ls0;
                           UnderLets.Base
                             {|
                             anyexpr_ty := (base.type.list A *
                                            base.type.list A)%etype;
                             unwrap := e1 |});
                   fv0 <-- do_again (let (anyexpr_ty, _) := fv in anyexpr_ty)
                             (let
                                (anyexpr_ty, unwrap) as a
                                 return
                                   (expr
                                      (type.base
                                         (let (anyexpr_ty, _) := a in
                                          anyexpr_ty))) := fv in
                              unwrap);
                   base.try_make_transport_cps
                     (fun t : base.type => expr (type.base t))
                     (let (anyexpr_ty, _) := fv in anyexpr_ty)
                     (base.type.list A * base.type.list A)
                     (UnderLets.UnderLets base.type ident var
                        (expr
                           (type.base
                              (base.type.list A * base.type.list A)%etype)))
                     (fun
                        a : option
                              (expr
                                 (type.base
                                    (let (anyexpr_ty, _) := fv in anyexpr_ty)) ->
                               expr
                                 (type.base
                                    (base.type.list A * base.type.list A)%etype))
                      =>
                      match a with
                      | Some x' => UnderLets.Base (x' fv0)
                      | None =>
                          UnderLets.Base
                            (#(ident.List_partition)%expr @
                             (λ x1 : var (type.base A),
                              UnderLets.to_expr (x ($x1)))%expr @ x0)%expr_pat
                      end))%under_lets
              | None =>
                  UnderLets.Base
                    (#(ident.List_partition)%expr @
                     (λ x1 : var (type.base A),
                      UnderLets.to_expr (x ($x1)))%expr @ x0)%expr_pat
              end)
       | None =>
           UnderLets.Base
             (#(ident.List_partition)%expr @
              (λ x1 : var (type.base A),
               UnderLets.to_expr (x ($x1)))%expr @ x0)%expr_pat
       end)
| @ident.List_fold_right A B =>
    fun
      (x : expr (type.base B) ->
           expr (type.base A) ->
           UnderLets.UnderLets base.type ident var (expr (type.base A)))
      (x0 : expr (type.base A)) (x1 : expr (type.base (base.type.list B))) =>
    Compile.castv x
      (UnderLets.UnderLets base.type ident var (expr (type.base A)))
      (fun
         f : option
               (expr (type.base B) ->
                expr (type.base A) ->
                UnderLets.UnderLets base.type ident var (expr (type.base A)))
       =>
       match f with
       | Some f0 =>
           reflect_list_cps x1
             (fun ls : option (list (expr (type.base B))) =>
              match ls with
              | Some ls0 =>
                  (fv <-- (e <-- list_rect
                                   (fun _ : list (expr (type.base B)) =>
                                    UnderLets.UnderLets base.type ident var
                                      (expr (type.base A)))
                                   (UnderLets.Base x0)
                                   (fun (x2 : expr (type.base B))
                                      (_ : list (expr (type.base B)))
                                      (rec : UnderLets.UnderLets base.type
                                               ident var (expr (type.base A)))
                                    => rec' <-- rec;
                                       f0 x2 rec') ls0;
                           UnderLets.Base {| anyexpr_ty := A; unwrap := e |});
                   base.try_make_transport_cps
                     (fun t : base.type => expr (type.base t))
                     (let (anyexpr_ty, _) := fv in anyexpr_ty) A
                     (UnderLets.UnderLets base.type ident var
                        (expr (type.base A)))
                     (fun
                        a : option
                              (expr
                                 (type.base
                                    (let (anyexpr_ty, _) := fv in anyexpr_ty)) ->
                               expr (type.base A)) =>
                      match a with
                      | Some x' =>
                          UnderLets.Base
                            (x'
                               (let
                                  (anyexpr_ty, unwrap) as a0
                                   return
                                     (expr
                                        (type.base
                                           (let (anyexpr_ty, _) := a0 in
                                            anyexpr_ty))) := fv in
                                unwrap))
                      | None =>
                          UnderLets.Base
                            (#(ident.List_fold_right)%expr @
                             (λ (x2 : var (type.base B))(x3 : var
                                                                (type.base A)),
                              UnderLets.to_expr (x ($x2) ($x3)))%expr @ x0 @
                             x1)%expr_pat
                      end))%under_lets
              | None =>
                  UnderLets.Base
                    (#(ident.List_fold_right)%expr @
                     (λ (x2 : var (type.base B))(x3 : var (type.base A)),
                      UnderLets.to_expr (x ($x2) ($x3)))%expr @ x0 @ x1)%expr_pat
              end)
       | None =>
           UnderLets.Base
             (#(ident.List_fold_right)%expr @
              (λ (x2 : var (type.base B))(x3 : var (type.base A)),
               UnderLets.to_expr (x ($x2) ($x3)))%expr @ x0 @ x1)%expr_pat
       end)
| @ident.List_update_nth T =>
    fun (x : expr (type.base base.type.nat))
      (x0 : expr (type.base T) ->
            UnderLets.UnderLets base.type ident var (expr (type.base T)))
      (x1 : expr (type.base (base.type.list T))) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option nat) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun _ : Z => None
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun v0 : nat => Some v0
              end v
          | _ => None
          end
        with
        | Some args =>
            Compile.castv x0
              (UnderLets.UnderLets base.type ident var
                 (expr (type.base (base.type.list T))))
              (fun
                 f : option
                       (expr (type.base T) ->
                        UnderLets.UnderLets base.type ident var
                          (expr (type.base T))) =>
               match f with
               | Some f0 =>
                   reflect_list_cps x1
                     (fun ls : option (list (expr (type.base T))) =>
                      match ls with
                      | Some ls0 =>
                          (fv <-- (e <-- (retv <---- update_nth args
                                                       (fun
                                                          x2 : UnderLets.UnderLets
                                                                 base.type
                                                                 ident var
                                                                 (expr
                                                                    (type.base
                                                                    T)) =>
                                                        x3 <-- x2;
                                                        f0 x3)
                                                       (map UnderLets.Base
                                                          ls0);
                                          UnderLets.Base (reify_list retv));
                                   UnderLets.Base
                                     {|
                                     anyexpr_ty := base.type.list T;
                                     unwrap := e |});
                           base.try_make_transport_cps
                             (fun t0 : base.type => expr (type.base t0))
                             (let (anyexpr_ty, _) := fv in anyexpr_ty)
                             (base.type.list T)
                             (UnderLets.UnderLets base.type ident var
                                (expr (type.base (base.type.list T))))
                             (fun
                                a : option
                                      (expr
                                         (type.base
                                            (let (anyexpr_ty, _) := fv in
                                             anyexpr_ty)) ->
                                       expr (type.base (base.type.list T)))
                              =>
                              match a with
                              | Some x' =>
                                  UnderLets.Base
                                    (x'
                                       (let
                                          (anyexpr_ty, unwrap) as a0
                                           return
                                             (expr
                                                (type.base
                                                   (let (anyexpr_ty, _) :=
                                                      a0 in
                                                    anyexpr_ty))) := fv in
                                        unwrap))
                              | None =>
                                  UnderLets.Base
                                    (#(ident.List_update_nth)%expr @ x @
                                     (λ x2 : var (type.base T),
                                      UnderLets.to_expr (x0 ($x2)))%expr @ x1)%expr_pat
                              end))%under_lets
                      | None =>
                          UnderLets.Base
                            (#(ident.List_update_nth)%expr @ x @
                             (λ x2 : var (type.base T),
                              UnderLets.to_expr (x0 ($x2)))%expr @ x1)%expr_pat
                      end)
               | None =>
                   UnderLets.Base
                     (#(ident.List_update_nth)%expr @ x @
                      (λ x2 : var (type.base T),
                       UnderLets.to_expr (x0 ($x2)))%expr @ x1)%expr_pat
               end)
        | None =>
            UnderLets.Base
              (#(ident.List_update_nth)%expr @ x @
               (λ x2 : var (type.base T),
                UnderLets.to_expr (x0 ($x2)))%expr @ x1)%expr_pat
        end
    | ($_)%expr | @expr.Abs _ _ _ _ _ _ =>
        UnderLets.Base
          (#(ident.List_update_nth)%expr @ x @
           (λ x2 : var (type.base T),
            UnderLets.to_expr (x0 ($x2)))%expr @ x1)%expr_pat
    | _ =>
        UnderLets.Base
          (#(ident.List_update_nth)%expr @ x @
           (λ x3 : var (type.base T),
            UnderLets.to_expr (x0 ($x3)))%expr @ x1)%expr_pat
    end
| @ident.List_nth_default T =>
    fun (x : expr (type.base T)) (x0 : expr (type.base (base.type.list T)))
      (x1 : expr (type.base base.type.nat)) =>
    match x1 with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option nat) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun _ : Z => None
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun v0 : nat => Some v0
              end v
          | _ => None
          end
        with
        | Some args =>
            Compile.castbe x
              (UnderLets.UnderLets base.type ident var (expr (type.base T)))
              (fun default : option (expr (type.base T)) =>
               match default with
               | Some default0 =>
                   reflect_list_cps x0
                     (fun ls : option (list (expr (type.base T))) =>
                      match ls with
                      | Some ls0 =>
                          base.try_make_transport_cps
                            (fun t0 : base.type => expr (type.base t0)) T T
                            (UnderLets.UnderLets base.type ident var
                               (expr (type.base T)))
                            (fun
                               a : option
                                     (expr (type.base T) ->
                                      expr (type.base T)) =>
                             match a with
                             | Some x' =>
                                 UnderLets.Base
                                   (x' (nth_default default0 ls0 args))
                             | None =>
                                 UnderLets.Base
                                   (#(ident.List_nth_default)%expr @ x @ x0 @
                                    x1)%expr_pat
                             end)
                      | None =>
                          UnderLets.Base
                            (#(ident.List_nth_default)%expr @ x @ x0 @ x1)%expr_pat
                      end)
               | None =>
                   UnderLets.Base
                     (#(ident.List_nth_default)%expr @ x @ x0 @ x1)%expr_pat
               end)
        | None =>
            UnderLets.Base
              (#(ident.List_nth_default)%expr @ x @ x0 @ x1)%expr_pat
        end
    | _ =>
        UnderLets.Base
          (#(ident.List_nth_default)%expr @ x @ x0 @ x1)%expr_pat
    end
| ident.Z_add =>
    fun x x0 : expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 => UnderLets.Base ##((args + args0)%Z)%expr
                | None =>
                    if args =? 0
                    then UnderLets.Base x0
                    else UnderLets.Base (x + x0)%expr
                end
            | @expr.App _ _ _ s _ f x1 =>
                if args =? 0
                then UnderLets.Base x0
                else
                 match f with
                 | #(idc0)%expr_pat =>
                     match
                       match idc0 with
                       | ident.Z_opp => Some tt
                       | _ => None
                       end
                     with
                     | Some _ =>
                         match
                           s as t2
                           return
                             (Compile.value' false t2 ->
                              UnderLets.UnderLets base.type ident var
                                (expr (type.base base.type.Z)))
                         with
                         | type.base t2 =>
                             fun v : expr (type.base t2) =>
                             base.try_make_transport_cps
                               (fun t1 : base.type => expr (type.base t1)) t2
                               base.type.Z
                               (UnderLets.UnderLets base.type ident var
                                  (expr (type.base base.type.Z)))
                               (fun
                                  a : option
                                        (expr (type.base t2) ->
                                         expr (type.base base.type.Z)) =>
                                match a with
                                | Some x' =>
                                    if args >? 0
                                    then
                                     UnderLets.Base (##(args) - x' v)%expr
                                    else
                                     match
                                       s as t3
                                       return
                                         (Compile.value' false t3 ->
                                          UnderLets.UnderLets base.type ident
                                            var
                                            (expr (type.base base.type.Z)))
                                     with
                                     | type.base t3 =>
                                         fun v0 : expr (type.base t3) =>
                                         base.try_make_transport_cps
                                           (fun t1 : base.type =>
                                            expr (type.base t1)) t3
                                           base.type.Z
                                           (UnderLets.UnderLets base.type
                                              ident var
                                              (expr (type.base base.type.Z)))
                                           (fun
                                              a0 : option
                                                     (expr (type.base t3) ->
                                                      expr
                                                        (type.base
                                                           base.type.Z)) =>
                                            match a0 with
                                            | Some x'0 =>
                                                if args <? 0
                                                then
                                                 UnderLets.Base
                                                   (-
                                                    (##((- args)%Z) + x'0 v0))%expr
                                                else
                                                 match
                                                   s as t4
                                                   return
                                                     (Compile.value' false t4 ->
                                                      UnderLets.UnderLets
                                                        base.type ident var
                                                        (expr
                                                           (type.base
                                                              base.type.Z)))
                                                 with
                                                 | type.base t4 =>
                                                     fun
                                                       v1 : expr
                                                              (type.base t4)
                                                     =>
                                                     base.try_make_transport_cps
                                                       (fun t1 : base.type =>
                                                        expr (type.base t1))
                                                       t4 base.type.Z
                                                       (UnderLets.UnderLets
                                                          base.type ident var
                                                          (expr
                                                             (type.base
                                                                base.type.Z)))
                                                       (fun
                                                          a1 : option
                                                                 (expr
                                                                    (type.base
                                                                    t4) ->
                                                                  expr
                                                                    (type.base
                                                                    base.type.Z))
                                                        =>
                                                        match a1 with
                                                        | Some x'1 =>
                                                            UnderLets.Base
                                                              (x - x'1 v1)%expr
                                                        | None =>
                                                            UnderLets.Base
                                                              (x + x0)%expr
                                                        end)
                                                 | (s0 -> d0)%ptype =>
                                                     fun
                                                       _ : Compile.value'
                                                             false s0 ->
                                                           Compile.value'
                                                             true d0 =>
                                                     UnderLets.Base
                                                       (x + x0)%expr
                                                 end (Compile.reflect x1)
                                            | None =>
                                                UnderLets.Base (x + x0)%expr
                                            end)
                                     | (s0 -> d0)%ptype =>
                                         fun
                                           _ : Compile.value' false s0 ->
                                               Compile.value' true d0 =>
                                         UnderLets.Base (x + x0)%expr
                                     end (Compile.reflect x1)
                                | None => UnderLets.Base (x + x0)%expr
                                end)
                         | (s0 -> d0)%ptype =>
                             fun
                               _ : Compile.value' false s0 ->
                                   Compile.value' true d0 =>
                             UnderLets.Base (x + x0)%expr
                         end (Compile.reflect x1)
                     | None => UnderLets.Base (x + x0)%expr
                     end
                 | _ => UnderLets.Base (x + x0)%expr
                 end
            | _ =>
                if args =? 0
                then UnderLets.Base x0
                else UnderLets.Base (x + x0)%expr
            end
        | None =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args =>
                    if args =? 0
                    then UnderLets.Base x
                    else UnderLets.Base (x + x0)%expr
                | None => UnderLets.Base (x + x0)%expr
                end
            | @expr.App _ _ _ s _ #(idc0)%expr_pat x1 =>
                match
                  match idc0 with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => expr (type.base t1)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (x - x' v)%expr
                           | None => UnderLets.Base (x + x0)%expr
                           end)
                    | (s0 -> d0)%ptype =>
                        fun
                          _ : Compile.value' false s0 ->
                              Compile.value' true d0 =>
                        UnderLets.Base (x + x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x + x0)%expr
                end
            | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
              (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _
              (_ @ _)%expr_pat _ | @expr.App _ _ _ s _
              (@expr.LetIn _ _ _ _ _ _ _) _ => UnderLets.Base (x + x0)%expr
            | _ => UnderLets.Base (x + x0)%expr
            end
        end
    | ($_)%expr =>
        match x0 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t1 v0 =>
                  match
                    t1 as t2 return (base.base_interp t2 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v1 : Z => Some v1
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v0
              | _ => None
              end
            with
            | Some args =>
                if args =? 0
                then UnderLets.Base x
                else UnderLets.Base (x + x0)%expr
            | None => UnderLets.Base (x + x0)%expr
            end
        | @expr.App _ _ _ s _ #(idc)%expr_pat x1 =>
            match
              match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end
            with
            | Some _ =>
                match
                  s as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base base.type.Z)))
                with
                | type.base t2 =>
                    fun v0 : expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t1 : base.type => expr (type.base t1)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base base.type.Z)))
                      (fun
                         a : option
                               (expr (type.base t2) ->
                                expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' => UnderLets.Base (x - x' v0)%expr
                       | None => UnderLets.Base (x + x0)%expr
                       end)
                | (s0 -> d0)%ptype =>
                    fun _ : Compile.value' false s0 -> Compile.value' true d0
                    => UnderLets.Base (x + x0)%expr
                end (Compile.reflect x1)
            | None => UnderLets.Base (x + x0)%expr
            end
        | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat
          _ | @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            UnderLets.Base (x + x0)%expr
        | _ => UnderLets.Base (x + x0)%expr
        end
    | @expr.Abs _ _ _ _ _ _ =>
        match x0 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t0 v =>
                  match
                    t0 as t1 return (base.base_interp t1 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v0 : Z => Some v0
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v
              | _ => None
              end
            with
            | Some args =>
                if args =? 0
                then UnderLets.Base x
                else UnderLets.Base (x + x0)%expr
            | None => UnderLets.Base (x + x0)%expr
            end
        | @expr.App _ _ _ s0 _ #(idc)%expr_pat x1 =>
            match
              match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end
            with
            | Some _ =>
                match
                  s0 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base base.type.Z)))
                with
                | type.base t2 =>
                    fun v : expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => expr (type.base t0)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base base.type.Z)))
                      (fun
                         a : option
                               (expr (type.base t2) ->
                                expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' => UnderLets.Base (x - x' v)%expr
                       | None => UnderLets.Base (x + x0)%expr
                       end)
                | (s1 -> d1)%ptype =>
                    fun _ : Compile.value' false s1 -> Compile.value' true d1
                    => UnderLets.Base (x + x0)%expr
                end (Compile.reflect x1)
            | None => UnderLets.Base (x + x0)%expr
            end
        | @expr.App _ _ _ s0 _ ($_)%expr _ | @expr.App _ _ _ s0 _
          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0 _ (_ @ _)%expr_pat
          _ | @expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            UnderLets.Base (x + x0)%expr
        | _ => UnderLets.Base (x + x0)%expr
        end
    | @expr.App _ _ _ s _ f x1 =>
        match x0 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t0 v =>
                  match
                    t0 as t1 return (base.base_interp t1 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v0 : Z => Some v0
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v
              | _ => None
              end
            with
            | Some args =>
                if args =? 0
                then UnderLets.Base x
                else
                 match f with
                 | #(idc0)%expr_pat =>
                     match
                       match idc0 with
                       | ident.Z_opp => Some tt
                       | _ => None
                       end
                     with
                     | Some _ =>
                         match
                           s as t2
                           return
                             (Compile.value' false t2 ->
                              UnderLets.UnderLets base.type ident var
                                (expr (type.base base.type.Z)))
                         with
                         | type.base t2 =>
                             fun v : expr (type.base t2) =>
                             base.try_make_transport_cps
                               (fun t1 : base.type => expr (type.base t1)) t2
                               base.type.Z
                               (UnderLets.UnderLets base.type ident var
                                  (expr (type.base base.type.Z)))
                               (fun
                                  a : option
                                        (expr (type.base t2) ->
                                         expr (type.base base.type.Z)) =>
                                match a with
                                | Some x' =>
                                    if args >? 0
                                    then
                                     UnderLets.Base (##(args) - x' v)%expr
                                    else
                                     match
                                       s as t3
                                       return
                                         (Compile.value' false t3 ->
                                          UnderLets.UnderLets base.type ident
                                            var
                                            (expr (type.base base.type.Z)))
                                     with
                                     | type.base t3 =>
                                         fun v0 : expr (type.base t3) =>
                                         base.try_make_transport_cps
                                           (fun t1 : base.type =>
                                            expr (type.base t1)) t3
                                           base.type.Z
                                           (UnderLets.UnderLets base.type
                                              ident var
                                              (expr (type.base base.type.Z)))
                                           (fun
                                              a0 : option
                                                     (expr (type.base t3) ->
                                                      expr
                                                        (type.base
                                                           base.type.Z)) =>
                                            match a0 with
                                            | Some x'0 =>
                                                if args <? 0
                                                then
                                                 UnderLets.Base
                                                   (-
                                                    (x'0 v0 + ##((- args)%Z)))%expr
                                                else
                                                 match
                                                   s as t4
                                                   return
                                                     (Compile.value' false t4 ->
                                                      UnderLets.UnderLets
                                                        base.type ident var
                                                        (expr
                                                           (type.base
                                                              base.type.Z)))
                                                 with
                                                 | type.base t4 =>
                                                     fun
                                                       v1 : expr
                                                              (type.base t4)
                                                     =>
                                                     base.try_make_transport_cps
                                                       (fun t1 : base.type =>
                                                        expr (type.base t1))
                                                       t4 base.type.Z
                                                       (UnderLets.UnderLets
                                                          base.type ident var
                                                          (expr
                                                             (type.base
                                                                base.type.Z)))
                                                       (fun
                                                          a1 : option
                                                                 (expr
                                                                    (type.base
                                                                    t4) ->
                                                                  expr
                                                                    (type.base
                                                                    base.type.Z))
                                                        =>
                                                        match a1 with
                                                        | Some x'1 =>
                                                            UnderLets.Base
                                                              (x0 - x'1 v1)%expr
                                                        | None =>
                                                            UnderLets.Base
                                                              (x + x0)%expr
                                                        end)
                                                 | (s0 -> d0)%ptype =>
                                                     fun
                                                       _ : Compile.value'
                                                             false s0 ->
                                                           Compile.value'
                                                             true d0 =>
                                                     UnderLets.Base
                                                       (x + x0)%expr
                                                 end (Compile.reflect x1)
                                            | None =>
                                                UnderLets.Base (x + x0)%expr
                                            end)
                                     | (s0 -> d0)%ptype =>
                                         fun
                                           _ : Compile.value' false s0 ->
                                               Compile.value' true d0 =>
                                         UnderLets.Base (x + x0)%expr
                                     end (Compile.reflect x1)
                                | None => UnderLets.Base (x + x0)%expr
                                end)
                         | (s0 -> d0)%ptype =>
                             fun
                               _ : Compile.value' false s0 ->
                                   Compile.value' true d0 =>
                             UnderLets.Base (x + x0)%expr
                         end (Compile.reflect x1)
                     | None => UnderLets.Base (x + x0)%expr
                     end
                 | _ => UnderLets.Base (x + x0)%expr
                 end
            | None =>
                match f with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr (type.base base.type.Z)))
                        with
                        | type.base t2 =>
                            fun v : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type => expr (type.base t1)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr (type.base base.type.Z)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' => UnderLets.Base (x0 - x' v)%expr
                               | None => UnderLets.Base (x + x0)%expr
                               end)
                        | (s0 -> d0)%ptype =>
                            fun
                              _ : Compile.value' false s0 ->
                                  Compile.value' true d0 =>
                            UnderLets.Base (x + x0)%expr
                        end (Compile.reflect x1)
                    | None => UnderLets.Base (x + x0)%expr
                    end
                | _ => UnderLets.Base (x + x0)%expr
                end
            end
        | ($_)%expr =>
            match f with
            | #(idc)%expr_pat =>
                match
                  match idc with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v0 : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => expr (type.base t1)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (x0 - x' v0)%expr
                           | None => UnderLets.Base (x + x0)%expr
                           end)
                    | (s0 -> d0)%ptype =>
                        fun
                          _ : Compile.value' false s0 ->
                              Compile.value' true d0 =>
                        UnderLets.Base (x + x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x + x0)%expr
                end
            | _ => UnderLets.Base (x + x0)%expr
            end
        | @expr.Abs _ _ _ _ _ _ =>
            match f with
            | #(idc)%expr_pat =>
                match
                  match idc with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => expr (type.base t0)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (x0 - x' v)%expr
                           | None => UnderLets.Base (x + x0)%expr
                           end)
                    | (s1 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d1 =>
                        UnderLets.Base (x + x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x + x0)%expr
                end
            | _ => UnderLets.Base (x + x0)%expr
            end
        | @expr.App _ _ _ s0 _ #(idc)%expr_pat x2 =>
            match
              match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end
            with
            | Some _ =>
                match f with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr (type.base base.type.Z)))
                        with
                        | type.base t2 =>
                            fun v : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type => expr (type.base t1)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr (type.base base.type.Z)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   match
                                     s0 as t3
                                     return
                                       (Compile.value' false t3 ->
                                        UnderLets.UnderLets base.type ident
                                          var (expr (type.base base.type.Z)))
                                   with
                                   | type.base t3 =>
                                       fun v0 : expr (type.base t3) =>
                                       base.try_make_transport_cps
                                         (fun t1 : base.type =>
                                          expr (type.base t1)) t3 base.type.Z
                                         (UnderLets.UnderLets base.type ident
                                            var
                                            (expr (type.base base.type.Z)))
                                         (fun
                                            a0 : option
                                                   (expr (type.base t3) ->
                                                    expr
                                                      (type.base base.type.Z))
                                          =>
                                          match a0 with
                                          | Some x'0 =>
                                              UnderLets.Base
                                                (- (x' v + x'0 v0))%expr
                                          | None =>
                                              UnderLets.Base (x + x0)%expr
                                          end)
                                   | (s1 -> d1)%ptype =>
                                       fun
                                         _ : Compile.value' false s1 ->
                                             Compile.value' true d1 =>
                                       UnderLets.Base (x + x0)%expr
                                   end (Compile.reflect x2)
                               | None => UnderLets.Base (x + x0)%expr
                               end)
                        | (s1 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base (x + x0)%expr
                        end (Compile.reflect x1)
                    | None =>
                        match
                          s0 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr (type.base base.type.Z)))
                        with
                        | type.base t2 =>
                            fun v : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type => expr (type.base t1)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr (type.base base.type.Z)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' => UnderLets.Base (x - x' v)%expr
                               | None => UnderLets.Base (x + x0)%expr
                               end)
                        | (s1 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base (x + x0)%expr
                        end (Compile.reflect x2)
                    end
                | ($_)%expr =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v0 : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => expr (type.base t1)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (x - x' v0)%expr
                           | None => UnderLets.Base (x + x0)%expr
                           end)
                    | (s1 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d1 =>
                        UnderLets.Base (x + x0)%expr
                    end (Compile.reflect x2)
                | @expr.LetIn _ _ _ _ _ _ _ =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => expr (type.base t0)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (x - x' v)%expr
                           | None => UnderLets.Base (x + x0)%expr
                           end)
                    | (s1 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d1 =>
                        UnderLets.Base (x + x0)%expr
                    end (Compile.reflect x2)
                | _ =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => expr (type.base t0)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (x - x' v)%expr
                           | None => UnderLets.Base (x + x0)%expr
                           end)
                    | (s2 -> d2)%ptype =>
                        fun
                          _ : Compile.value' false s2 ->
                              Compile.value' true d2 =>
                        UnderLets.Base (x + x0)%expr
                    end (Compile.reflect x2)
                end
            | None =>
                match f with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr (type.base base.type.Z)))
                        with
                        | type.base t2 =>
                            fun v : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type => expr (type.base t1)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr (type.base base.type.Z)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' => UnderLets.Base (x0 - x' v)%expr
                               | None => UnderLets.Base (x + x0)%expr
                               end)
                        | (s1 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base (x + x0)%expr
                        end (Compile.reflect x1)
                    | None => UnderLets.Base (x + x0)%expr
                    end
                | _ => UnderLets.Base (x + x0)%expr
                end
            end
        | @expr.App _ _ _ s0 _ ($_)%expr _ =>
            match f with
            | #(idc)%expr_pat =>
                match
                  match idc with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v0 : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => expr (type.base t1)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (x0 - x' v0)%expr
                           | None => UnderLets.Base (x + x0)%expr
                           end)
                    | (s1 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d1 =>
                        UnderLets.Base (x + x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x + x0)%expr
                end
            | _ => UnderLets.Base (x + x0)%expr
            end
        | @expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0
          _ (_ @ _)%expr_pat _ =>
            match f with
            | #(idc)%expr_pat =>
                match
                  match idc with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => expr (type.base t0)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (x0 - x' v)%expr
                           | None => UnderLets.Base (x + x0)%expr
                           end)
                    | (s2 -> d2)%ptype =>
                        fun
                          _ : Compile.value' false s2 ->
                              Compile.value' true d2 =>
                        UnderLets.Base (x + x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x + x0)%expr
                end
            | _ => UnderLets.Base (x + x0)%expr
            end
        | @expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            match f with
            | #(idc)%expr_pat =>
                match
                  match idc with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => expr (type.base t0)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (x0 - x' v)%expr
                           | None => UnderLets.Base (x + x0)%expr
                           end)
                    | (s1 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d1 =>
                        UnderLets.Base (x + x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x + x0)%expr
                end
            | _ => UnderLets.Base (x + x0)%expr
            end
        | @expr.LetIn _ _ _ _ _ _ _ =>
            match f with
            | #(idc)%expr_pat =>
                match
                  match idc with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => expr (type.base t0)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (x0 - x' v)%expr
                           | None => UnderLets.Base (x + x0)%expr
                           end)
                    | (s0 -> d0)%ptype =>
                        fun
                          _ : Compile.value' false s0 ->
                              Compile.value' true d0 =>
                        UnderLets.Base (x + x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x + x0)%expr
                end
            | _ => UnderLets.Base (x + x0)%expr
            end
        end
    | @expr.LetIn _ _ _ _ _ _ _ =>
        match x0 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t0 v =>
                  match
                    t0 as t1 return (base.base_interp t1 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v0 : Z => Some v0
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v
              | _ => None
              end
            with
            | Some args =>
                if args =? 0
                then UnderLets.Base x
                else UnderLets.Base (x + x0)%expr
            | None => UnderLets.Base (x + x0)%expr
            end
        | @expr.App _ _ _ s _ #(idc)%expr_pat x2 =>
            match
              match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end
            with
            | Some _ =>
                match
                  s as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base base.type.Z)))
                with
                | type.base t2 =>
                    fun v : expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => expr (type.base t0)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base base.type.Z)))
                      (fun
                         a : option
                               (expr (type.base t2) ->
                                expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' => UnderLets.Base (x - x' v)%expr
                       | None => UnderLets.Base (x + x0)%expr
                       end)
                | (s0 -> d0)%ptype =>
                    fun _ : Compile.value' false s0 -> Compile.value' true d0
                    => UnderLets.Base (x + x0)%expr
                end (Compile.reflect x2)
            | None => UnderLets.Base (x + x0)%expr
            end
        | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat
          _ | @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            UnderLets.Base (x + x0)%expr
        | _ => UnderLets.Base (x + x0)%expr
        end
    end
| ident.Z_mul =>
    fun x x0 : expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 => UnderLets.Base ##((args * args0)%Z)%expr
                | None =>
                    if args =? 0
                    then UnderLets.Base ##(0)%expr
                    else
                     if args =? 1
                     then UnderLets.Base x0
                     else
                      if args =? -1
                      then UnderLets.Base (- x0)%expr
                      else
                       if args <? 0
                       then UnderLets.Base (- (##((- args)%Z) * x0))%expr
                       else
                        if args =? 2 ^ Z.log2 args
                        then UnderLets.Base (x0 << Z.log2 args)%expr
                        else UnderLets.Base (x * x0)%expr
                end
            | @expr.App _ _ _ s _ f x1 =>
                if args =? 0
                then UnderLets.Base ##(0)%expr
                else
                 if args =? 1
                 then UnderLets.Base x0
                 else
                  match f with
                  | #(idc0)%expr_pat =>
                      match
                        match idc0 with
                        | ident.Z_opp => Some tt
                        | _ => None
                        end
                      with
                      | Some _ =>
                          match
                            s as t2
                            return
                              (Compile.value' false t2 ->
                               UnderLets.UnderLets base.type ident var
                                 (expr (type.base base.type.Z)))
                          with
                          | type.base t2 =>
                              fun v : expr (type.base t2) =>
                              base.try_make_transport_cps
                                (fun t1 : base.type => expr (type.base t1))
                                t2 base.type.Z
                                (UnderLets.UnderLets base.type ident var
                                   (expr (type.base base.type.Z)))
                                (fun
                                   a : option
                                         (expr (type.base t2) ->
                                          expr (type.base base.type.Z)) =>
                                 match a with
                                 | Some x' =>
                                     if args =? -1
                                     then UnderLets.Base (x' v)
                                     else
                                      if args =? -1
                                      then UnderLets.Base (- x0)%expr
                                      else
                                       if args <? 0
                                       then
                                        UnderLets.Base
                                          (- (##((- args)%Z) * x0))%expr
                                       else
                                        match
                                          s as t3
                                          return
                                            (Compile.value' false t3 ->
                                             UnderLets.UnderLets base.type
                                               ident var
                                               (expr (type.base base.type.Z)))
                                        with
                                        | type.base t3 =>
                                            fun v0 : expr (type.base t3) =>
                                            base.try_make_transport_cps
                                              (fun t1 : base.type =>
                                               expr (type.base t1)) t3
                                              base.type.Z
                                              (UnderLets.UnderLets base.type
                                                 ident var
                                                 (expr
                                                    (type.base base.type.Z)))
                                              (fun
                                                 a0 : option
                                                        (expr (type.base t3) ->
                                                         expr
                                                           (type.base
                                                              base.type.Z))
                                               =>
                                               match a0 with
                                               | Some x'0 =>
                                                   UnderLets.Base
                                                     (- (x * x'0 v0))%expr
                                               | None =>
                                                   UnderLets.Base
                                                     (x * x0)%expr
                                               end)
                                        | (s0 -> d0)%ptype =>
                                            fun
                                              _ : Compile.value' false s0 ->
                                                  Compile.value' true d0 =>
                                            UnderLets.Base (x * x0)%expr
                                        end (Compile.reflect x1)
                                 | None => UnderLets.Base (x * x0)%expr
                                 end)
                          | (s0 -> d0)%ptype =>
                              fun
                                _ : Compile.value' false s0 ->
                                    Compile.value' true d0 =>
                              UnderLets.Base (x * x0)%expr
                          end (Compile.reflect x1)
                      | None =>
                          if args =? -1
                          then UnderLets.Base (- x0)%expr
                          else
                           if args <? 0
                           then UnderLets.Base (- (##((- args)%Z) * x0))%expr
                           else
                            if args =? 2 ^ Z.log2 args
                            then UnderLets.Base (x0 << Z.log2 args)%expr
                            else UnderLets.Base (x * x0)%expr
                      end
                  | _ =>
                      if args =? -1
                      then UnderLets.Base (- x0)%expr
                      else
                       if args <? 0
                       then UnderLets.Base (- (##((- args)%Z) * x0))%expr
                       else
                        if args =? 2 ^ Z.log2 args
                        then UnderLets.Base (x0 << Z.log2 args)%expr
                        else UnderLets.Base (x * x0)%expr
                  end
            | _ =>
                if args =? 0
                then UnderLets.Base ##(0)%expr
                else
                 if args =? 1
                 then UnderLets.Base x0
                 else
                  if args =? -1
                  then UnderLets.Base (- x0)%expr
                  else
                   if args <? 0
                   then UnderLets.Base (- (##((- args)%Z) * x0))%expr
                   else
                    if args =? 2 ^ Z.log2 args
                    then UnderLets.Base (x0 << Z.log2 args)%expr
                    else UnderLets.Base (x * x0)%expr
            end
        | None =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args =>
                    if args =? 0
                    then UnderLets.Base ##(0)%expr
                    else
                     if args =? 1
                     then UnderLets.Base x
                     else
                      if args =? -1
                      then UnderLets.Base (- x)%expr
                      else
                       if args <? 0
                       then UnderLets.Base (- (x * ##((- args)%Z)))%expr
                       else
                        if args =? 2 ^ Z.log2 args
                        then UnderLets.Base (x << Z.log2 args)%expr
                        else UnderLets.Base (x * x0)%expr
                | None => UnderLets.Base (x * x0)%expr
                end
            | @expr.App _ _ _ s _ #(idc0)%expr_pat x1 =>
                match
                  match idc0 with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => expr (type.base t1)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (- (x * x' v))%expr
                           | None => UnderLets.Base (x * x0)%expr
                           end)
                    | (s0 -> d0)%ptype =>
                        fun
                          _ : Compile.value' false s0 ->
                              Compile.value' true d0 =>
                        UnderLets.Base (x * x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x * x0)%expr
                end
            | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
              (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _
              (_ @ _)%expr_pat _ | @expr.App _ _ _ s _
              (@expr.LetIn _ _ _ _ _ _ _) _ => UnderLets.Base (x * x0)%expr
            | _ => UnderLets.Base (x * x0)%expr
            end
        end
    | ($_)%expr =>
        match x0 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t1 v0 =>
                  match
                    t1 as t2 return (base.base_interp t2 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v1 : Z => Some v1
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v0
              | _ => None
              end
            with
            | Some args =>
                if args =? 0
                then UnderLets.Base ##(0)%expr
                else
                 if args =? 1
                 then UnderLets.Base x
                 else
                  if args =? -1
                  then UnderLets.Base (- x)%expr
                  else
                   if args <? 0
                   then UnderLets.Base (- (x * ##((- args)%Z)))%expr
                   else
                    if args =? 2 ^ Z.log2 args
                    then UnderLets.Base (x << Z.log2 args)%expr
                    else UnderLets.Base (x * x0)%expr
            | None => UnderLets.Base (x * x0)%expr
            end
        | @expr.App _ _ _ s _ #(idc)%expr_pat x1 =>
            match
              match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end
            with
            | Some _ =>
                match
                  s as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base base.type.Z)))
                with
                | type.base t2 =>
                    fun v0 : expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t1 : base.type => expr (type.base t1)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base base.type.Z)))
                      (fun
                         a : option
                               (expr (type.base t2) ->
                                expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' => UnderLets.Base (- (x * x' v0))%expr
                       | None => UnderLets.Base (x * x0)%expr
                       end)
                | (s0 -> d0)%ptype =>
                    fun _ : Compile.value' false s0 -> Compile.value' true d0
                    => UnderLets.Base (x * x0)%expr
                end (Compile.reflect x1)
            | None => UnderLets.Base (x * x0)%expr
            end
        | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat
          _ | @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            UnderLets.Base (x * x0)%expr
        | _ => UnderLets.Base (x * x0)%expr
        end
    | @expr.Abs _ _ _ _ _ _ =>
        match x0 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t0 v =>
                  match
                    t0 as t1 return (base.base_interp t1 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v0 : Z => Some v0
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v
              | _ => None
              end
            with
            | Some args =>
                if args =? 0
                then UnderLets.Base ##(0)%expr
                else
                 if args =? 1
                 then UnderLets.Base x
                 else
                  if args =? -1
                  then UnderLets.Base (- x)%expr
                  else
                   if args <? 0
                   then UnderLets.Base (- (x * ##((- args)%Z)))%expr
                   else
                    if args =? 2 ^ Z.log2 args
                    then UnderLets.Base (x << Z.log2 args)%expr
                    else UnderLets.Base (x * x0)%expr
            | None => UnderLets.Base (x * x0)%expr
            end
        | @expr.App _ _ _ s0 _ #(idc)%expr_pat x1 =>
            match
              match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end
            with
            | Some _ =>
                match
                  s0 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base base.type.Z)))
                with
                | type.base t2 =>
                    fun v : expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => expr (type.base t0)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base base.type.Z)))
                      (fun
                         a : option
                               (expr (type.base t2) ->
                                expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' => UnderLets.Base (- (x * x' v))%expr
                       | None => UnderLets.Base (x * x0)%expr
                       end)
                | (s1 -> d1)%ptype =>
                    fun _ : Compile.value' false s1 -> Compile.value' true d1
                    => UnderLets.Base (x * x0)%expr
                end (Compile.reflect x1)
            | None => UnderLets.Base (x * x0)%expr
            end
        | @expr.App _ _ _ s0 _ ($_)%expr _ | @expr.App _ _ _ s0 _
          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0 _ (_ @ _)%expr_pat
          _ | @expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            UnderLets.Base (x * x0)%expr
        | _ => UnderLets.Base (x * x0)%expr
        end
    | @expr.App _ _ _ s _ f x1 =>
        match x0 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t0 v =>
                  match
                    t0 as t1 return (base.base_interp t1 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v0 : Z => Some v0
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v
              | _ => None
              end
            with
            | Some args =>
                if args =? 0
                then UnderLets.Base ##(0)%expr
                else
                 if args =? 1
                 then UnderLets.Base x
                 else
                  match f with
                  | #(idc0)%expr_pat =>
                      match
                        match idc0 with
                        | ident.Z_opp => Some tt
                        | _ => None
                        end
                      with
                      | Some _ =>
                          match
                            s as t2
                            return
                              (Compile.value' false t2 ->
                               UnderLets.UnderLets base.type ident var
                                 (expr (type.base base.type.Z)))
                          with
                          | type.base t2 =>
                              fun v : expr (type.base t2) =>
                              base.try_make_transport_cps
                                (fun t1 : base.type => expr (type.base t1))
                                t2 base.type.Z
                                (UnderLets.UnderLets base.type ident var
                                   (expr (type.base base.type.Z)))
                                (fun
                                   a : option
                                         (expr (type.base t2) ->
                                          expr (type.base base.type.Z)) =>
                                 match a with
                                 | Some x' =>
                                     if args =? -1
                                     then UnderLets.Base (x' v)
                                     else
                                      if args =? -1
                                      then UnderLets.Base (- x)%expr
                                      else
                                       if args <? 0
                                       then
                                        UnderLets.Base
                                          (- (x * ##((- args)%Z)))%expr
                                       else
                                        match
                                          s as t3
                                          return
                                            (Compile.value' false t3 ->
                                             UnderLets.UnderLets base.type
                                               ident var
                                               (expr (type.base base.type.Z)))
                                        with
                                        | type.base t3 =>
                                            fun v0 : expr (type.base t3) =>
                                            base.try_make_transport_cps
                                              (fun t1 : base.type =>
                                               expr (type.base t1)) t3
                                              base.type.Z
                                              (UnderLets.UnderLets base.type
                                                 ident var
                                                 (expr
                                                    (type.base base.type.Z)))
                                              (fun
                                                 a0 : option
                                                        (expr (type.base t3) ->
                                                         expr
                                                           (type.base
                                                              base.type.Z))
                                               =>
                                               match a0 with
                                               | Some x'0 =>
                                                   UnderLets.Base
                                                     (- (x'0 v0 * x0))%expr
                                               | None =>
                                                   UnderLets.Base
                                                     (x * x0)%expr
                                               end)
                                        | (s0 -> d0)%ptype =>
                                            fun
                                              _ : Compile.value' false s0 ->
                                                  Compile.value' true d0 =>
                                            UnderLets.Base (x * x0)%expr
                                        end (Compile.reflect x1)
                                 | None => UnderLets.Base (x * x0)%expr
                                 end)
                          | (s0 -> d0)%ptype =>
                              fun
                                _ : Compile.value' false s0 ->
                                    Compile.value' true d0 =>
                              UnderLets.Base (x * x0)%expr
                          end (Compile.reflect x1)
                      | None =>
                          if args =? -1
                          then UnderLets.Base (- x)%expr
                          else
                           if args <? 0
                           then UnderLets.Base (- (x * ##((- args)%Z)))%expr
                           else
                            if args =? 2 ^ Z.log2 args
                            then UnderLets.Base (x << Z.log2 args)%expr
                            else UnderLets.Base (x * x0)%expr
                      end
                  | _ =>
                      if args =? -1
                      then UnderLets.Base (- x)%expr
                      else
                       if args <? 0
                       then UnderLets.Base (- (x * ##((- args)%Z)))%expr
                       else
                        if args =? 2 ^ Z.log2 args
                        then UnderLets.Base (x << Z.log2 args)%expr
                        else UnderLets.Base (x * x0)%expr
                  end
            | None =>
                match f with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr (type.base base.type.Z)))
                        with
                        | type.base t2 =>
                            fun v : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type => expr (type.base t1)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr (type.base base.type.Z)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   UnderLets.Base (- (x' v * x0))%expr
                               | None => UnderLets.Base (x * x0)%expr
                               end)
                        | (s0 -> d0)%ptype =>
                            fun
                              _ : Compile.value' false s0 ->
                                  Compile.value' true d0 =>
                            UnderLets.Base (x * x0)%expr
                        end (Compile.reflect x1)
                    | None => UnderLets.Base (x * x0)%expr
                    end
                | _ => UnderLets.Base (x * x0)%expr
                end
            end
        | ($_)%expr =>
            match f with
            | #(idc)%expr_pat =>
                match
                  match idc with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v0 : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => expr (type.base t1)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (- (x' v0 * x0))%expr
                           | None => UnderLets.Base (x * x0)%expr
                           end)
                    | (s0 -> d0)%ptype =>
                        fun
                          _ : Compile.value' false s0 ->
                              Compile.value' true d0 =>
                        UnderLets.Base (x * x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x * x0)%expr
                end
            | _ => UnderLets.Base (x * x0)%expr
            end
        | @expr.Abs _ _ _ _ _ _ =>
            match f with
            | #(idc)%expr_pat =>
                match
                  match idc with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => expr (type.base t0)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (- (x' v * x0))%expr
                           | None => UnderLets.Base (x * x0)%expr
                           end)
                    | (s1 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d1 =>
                        UnderLets.Base (x * x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x * x0)%expr
                end
            | _ => UnderLets.Base (x * x0)%expr
            end
        | @expr.App _ _ _ s0 _ #(idc)%expr_pat x2 =>
            match
              match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end
            with
            | Some _ =>
                match f with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr (type.base base.type.Z)))
                        with
                        | type.base t2 =>
                            fun v : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type => expr (type.base t1)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr (type.base base.type.Z)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   match
                                     s0 as t3
                                     return
                                       (Compile.value' false t3 ->
                                        UnderLets.UnderLets base.type ident
                                          var (expr (type.base base.type.Z)))
                                   with
                                   | type.base t3 =>
                                       fun v0 : expr (type.base t3) =>
                                       base.try_make_transport_cps
                                         (fun t1 : base.type =>
                                          expr (type.base t1)) t3 base.type.Z
                                         (UnderLets.UnderLets base.type ident
                                            var
                                            (expr (type.base base.type.Z)))
                                         (fun
                                            a0 : option
                                                   (expr (type.base t3) ->
                                                    expr
                                                      (type.base base.type.Z))
                                          =>
                                          match a0 with
                                          | Some x'0 =>
                                              UnderLets.Base
                                                (x' v * x'0 v0)%expr
                                          | None =>
                                              UnderLets.Base (x * x0)%expr
                                          end)
                                   | (s1 -> d1)%ptype =>
                                       fun
                                         _ : Compile.value' false s1 ->
                                             Compile.value' true d1 =>
                                       UnderLets.Base (x * x0)%expr
                                   end (Compile.reflect x2)
                               | None => UnderLets.Base (x * x0)%expr
                               end)
                        | (s1 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base (x * x0)%expr
                        end (Compile.reflect x1)
                    | None =>
                        match
                          s0 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr (type.base base.type.Z)))
                        with
                        | type.base t2 =>
                            fun v : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type => expr (type.base t1)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr (type.base base.type.Z)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   UnderLets.Base (- (x * x' v))%expr
                               | None => UnderLets.Base (x * x0)%expr
                               end)
                        | (s1 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base (x * x0)%expr
                        end (Compile.reflect x2)
                    end
                | ($_)%expr =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v0 : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => expr (type.base t1)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (- (x * x' v0))%expr
                           | None => UnderLets.Base (x * x0)%expr
                           end)
                    | (s1 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d1 =>
                        UnderLets.Base (x * x0)%expr
                    end (Compile.reflect x2)
                | @expr.LetIn _ _ _ _ _ _ _ =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => expr (type.base t0)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (- (x * x' v))%expr
                           | None => UnderLets.Base (x * x0)%expr
                           end)
                    | (s1 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d1 =>
                        UnderLets.Base (x * x0)%expr
                    end (Compile.reflect x2)
                | _ =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => expr (type.base t0)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (- (x * x' v))%expr
                           | None => UnderLets.Base (x * x0)%expr
                           end)
                    | (s2 -> d2)%ptype =>
                        fun
                          _ : Compile.value' false s2 ->
                              Compile.value' true d2 =>
                        UnderLets.Base (x * x0)%expr
                    end (Compile.reflect x2)
                end
            | None =>
                match f with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr (type.base base.type.Z)))
                        with
                        | type.base t2 =>
                            fun v : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type => expr (type.base t1)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr (type.base base.type.Z)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   UnderLets.Base (- (x' v * x0))%expr
                               | None => UnderLets.Base (x * x0)%expr
                               end)
                        | (s1 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base (x * x0)%expr
                        end (Compile.reflect x1)
                    | None => UnderLets.Base (x * x0)%expr
                    end
                | _ => UnderLets.Base (x * x0)%expr
                end
            end
        | @expr.App _ _ _ s0 _ ($_)%expr _ =>
            match f with
            | #(idc)%expr_pat =>
                match
                  match idc with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v0 : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => expr (type.base t1)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (- (x' v0 * x0))%expr
                           | None => UnderLets.Base (x * x0)%expr
                           end)
                    | (s1 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d1 =>
                        UnderLets.Base (x * x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x * x0)%expr
                end
            | _ => UnderLets.Base (x * x0)%expr
            end
        | @expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0
          _ (_ @ _)%expr_pat _ =>
            match f with
            | #(idc)%expr_pat =>
                match
                  match idc with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => expr (type.base t0)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (- (x' v * x0))%expr
                           | None => UnderLets.Base (x * x0)%expr
                           end)
                    | (s2 -> d2)%ptype =>
                        fun
                          _ : Compile.value' false s2 ->
                              Compile.value' true d2 =>
                        UnderLets.Base (x * x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x * x0)%expr
                end
            | _ => UnderLets.Base (x * x0)%expr
            end
        | @expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            match f with
            | #(idc)%expr_pat =>
                match
                  match idc with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => expr (type.base t0)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (- (x' v * x0))%expr
                           | None => UnderLets.Base (x * x0)%expr
                           end)
                    | (s1 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d1 =>
                        UnderLets.Base (x * x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x * x0)%expr
                end
            | _ => UnderLets.Base (x * x0)%expr
            end
        | @expr.LetIn _ _ _ _ _ _ _ =>
            match f with
            | #(idc)%expr_pat =>
                match
                  match idc with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => expr (type.base t0)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (- (x' v * x0))%expr
                           | None => UnderLets.Base (x * x0)%expr
                           end)
                    | (s0 -> d0)%ptype =>
                        fun
                          _ : Compile.value' false s0 ->
                              Compile.value' true d0 =>
                        UnderLets.Base (x * x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x * x0)%expr
                end
            | _ => UnderLets.Base (x * x0)%expr
            end
        end
    | @expr.LetIn _ _ _ _ _ _ _ =>
        match x0 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t0 v =>
                  match
                    t0 as t1 return (base.base_interp t1 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v0 : Z => Some v0
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v
              | _ => None
              end
            with
            | Some args =>
                if args =? 0
                then UnderLets.Base ##(0)%expr
                else
                 if args =? 1
                 then UnderLets.Base x
                 else
                  if args =? -1
                  then UnderLets.Base (- x)%expr
                  else
                   if args <? 0
                   then UnderLets.Base (- (x * ##((- args)%Z)))%expr
                   else
                    if args =? 2 ^ Z.log2 args
                    then UnderLets.Base (x << Z.log2 args)%expr
                    else UnderLets.Base (x * x0)%expr
            | None => UnderLets.Base (x * x0)%expr
            end
        | @expr.App _ _ _ s _ #(idc)%expr_pat x2 =>
            match
              match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end
            with
            | Some _ =>
                match
                  s as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base base.type.Z)))
                with
                | type.base t2 =>
                    fun v : expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => expr (type.base t0)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base base.type.Z)))
                      (fun
                         a : option
                               (expr (type.base t2) ->
                                expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' => UnderLets.Base (- (x * x' v))%expr
                       | None => UnderLets.Base (x * x0)%expr
                       end)
                | (s0 -> d0)%ptype =>
                    fun _ : Compile.value' false s0 -> Compile.value' true d0
                    => UnderLets.Base (x * x0)%expr
                end (Compile.reflect x2)
            | None => UnderLets.Base (x * x0)%expr
            end
        | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat
          _ | @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            UnderLets.Base (x * x0)%expr
        | _ => UnderLets.Base (x * x0)%expr
        end
    end
| ident.Z_pow =>
    fun x x0 : expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 => UnderLets.Base ##(args ^ args0)%expr
                | None =>
                    UnderLets.Base (#(ident.Z_pow)%expr @ x @ x0)%expr_pat
                end
            | _ => UnderLets.Base (#(ident.Z_pow)%expr @ x @ x0)%expr_pat
            end
        | None => UnderLets.Base (#(ident.Z_pow)%expr @ x @ x0)%expr_pat
        end
    | _ => UnderLets.Base (#(ident.Z_pow)%expr @ x @ x0)%expr_pat
    end
| ident.Z_sub =>
    fun x x0 : expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 => UnderLets.Base ##((args - args0)%Z)%expr
                | None =>
                    if args =? 0
                    then UnderLets.Base (- x0)%expr
                    else
                     if args <? 0
                     then UnderLets.Base (- (##((- args)%Z) + x0))%expr
                     else UnderLets.Base (x - x0)%expr
                end
            | @expr.App _ _ _ s _ #(idc0)%expr_pat x1 =>
                match
                  match idc0 with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => expr (type.base t1)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               if args =? 0
                               then UnderLets.Base (x' v)
                               else
                                if args =? 0
                                then UnderLets.Base (- x0)%expr
                                else
                                 match
                                   s as t3
                                   return
                                     (Compile.value' false t3 ->
                                      UnderLets.UnderLets base.type ident var
                                        (expr (type.base base.type.Z)))
                                 with
                                 | type.base t3 =>
                                     fun v0 : expr (type.base t3) =>
                                     base.try_make_transport_cps
                                       (fun t1 : base.type =>
                                        expr (type.base t1)) t3 base.type.Z
                                       (UnderLets.UnderLets base.type ident
                                          var (expr (type.base base.type.Z)))
                                       (fun
                                          a0 : option
                                                 (expr (type.base t3) ->
                                                  expr
                                                    (type.base base.type.Z))
                                        =>
                                        match a0 with
                                        | Some x'0 =>
                                            if args >? 0
                                            then
                                             UnderLets.Base
                                               (##(args) + x'0 v0)%expr
                                            else
                                             match
                                               s as t4
                                               return
                                                 (Compile.value' false t4 ->
                                                  UnderLets.UnderLets
                                                    base.type ident var
                                                    (expr
                                                       (type.base base.type.Z)))
                                             with
                                             | type.base t4 =>
                                                 fun v1 : expr (type.base t4)
                                                 =>
                                                 base.try_make_transport_cps
                                                   (fun t1 : base.type =>
                                                    expr (type.base t1)) t4
                                                   base.type.Z
                                                   (UnderLets.UnderLets
                                                      base.type ident var
                                                      (expr
                                                         (type.base
                                                            base.type.Z)))
                                                   (fun
                                                      a1 : option
                                                             (expr
                                                                (type.base t4) ->
                                                              expr
                                                                (type.base
                                                                   base.type.Z))
                                                    =>
                                                    match a1 with
                                                    | Some x'1 =>
                                                        if args <? 0
                                                        then
                                                         UnderLets.Base
                                                           (x'1 v1 -
                                                            ##((- args)%Z))%expr
                                                        else
                                                         if args <? 0
                                                         then
                                                          UnderLets.Base
                                                            (-
                                                             (##((- args)%Z) +
                                                              x0))%expr
                                                         else
                                                          match
                                                            s as t5
                                                            return
                                                              (Compile.value'
                                                                 false t5 ->
                                                               UnderLets.UnderLets
                                                                 base.type
                                                                 ident var
                                                                 (expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                          with
                                                          | type.base t5 =>
                                                              fun
                                                                v2 : 
                                                                 expr
                                                                   (type.base
                                                                    t5) =>
                                                              base.try_make_transport_cps
                                                                (fun
                                                                   t1 : base.type
                                                                 =>
                                                                 expr
                                                                   (type.base
                                                                    t1)) t5
                                                                base.type.Z
                                                                (UnderLets.UnderLets
                                                                   base.type
                                                                   ident var
                                                                   (expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                (fun
                                                                   a2 : 
                                                                    option
                                                                    (expr
                                                                    (type.base
                                                                    t5) ->
                                                                    expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                 =>
                                                                 match
                                                                   a2
                                                                 with
                                                                 | Some
                                                                   x'2 =>
                                                                    UnderLets.Base
                                                                    (x +
                                                                    x'2 v2)%expr
                                                                 | None =>
                                                                    UnderLets.Base
                                                                    (x - x0)%expr
                                                                 end)
                                                          | (s0 -> d0)%ptype =>
                                                              fun
                                                                _ : Compile.value'
                                                                    false s0 ->
                                                                    Compile.value'
                                                                    true d0
                                                              =>
                                                              UnderLets.Base
                                                                (x - x0)%expr
                                                          end
                                                            (Compile.reflect
                                                               x1)
                                                    | None =>
                                                        UnderLets.Base
                                                          (x - x0)%expr
                                                    end)
                                             | (s0 -> d0)%ptype =>
                                                 fun
                                                   _ : Compile.value' false
                                                         s0 ->
                                                       Compile.value' true d0
                                                 =>
                                                 UnderLets.Base (x - x0)%expr
                                             end (Compile.reflect x1)
                                        | None =>
                                            UnderLets.Base (x - x0)%expr
                                        end)
                                 | (s0 -> d0)%ptype =>
                                     fun
                                       _ : Compile.value' false s0 ->
                                           Compile.value' true d0 =>
                                     UnderLets.Base (x - x0)%expr
                                 end (Compile.reflect x1)
                           | None => UnderLets.Base (x - x0)%expr
                           end)
                    | (s0 -> d0)%ptype =>
                        fun
                          _ : Compile.value' false s0 ->
                              Compile.value' true d0 =>
                        UnderLets.Base (x - x0)%expr
                    end (Compile.reflect x1)
                | None =>
                    if args =? 0
                    then UnderLets.Base (- x0)%expr
                    else
                     if args <? 0
                     then UnderLets.Base (- (##((- args)%Z) + x0))%expr
                     else UnderLets.Base (x - x0)%expr
                end
            | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
              (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _
              (_ @ _)%expr_pat _ | @expr.App _ _ _ s _
              (@expr.LetIn _ _ _ _ _ _ _) _ =>
                if args =? 0
                then UnderLets.Base (- x0)%expr
                else
                 if args <? 0
                 then UnderLets.Base (- (##((- args)%Z) + x0))%expr
                 else UnderLets.Base (x - x0)%expr
            | _ =>
                if args =? 0
                then UnderLets.Base (- x0)%expr
                else
                 if args <? 0
                 then UnderLets.Base (- (##((- args)%Z) + x0))%expr
                 else UnderLets.Base (x - x0)%expr
            end
        | None =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args =>
                    if args =? 0
                    then UnderLets.Base x
                    else
                     if args <? 0
                     then UnderLets.Base (x + ##((- args)%Z))%expr
                     else UnderLets.Base (x - x0)%expr
                | None => UnderLets.Base (x - x0)%expr
                end
            | @expr.App _ _ _ s _ #(idc0)%expr_pat x1 =>
                match
                  match idc0 with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => expr (type.base t1)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (x + x' v)%expr
                           | None => UnderLets.Base (x - x0)%expr
                           end)
                    | (s0 -> d0)%ptype =>
                        fun
                          _ : Compile.value' false s0 ->
                              Compile.value' true d0 =>
                        UnderLets.Base (x - x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x - x0)%expr
                end
            | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
              (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _
              (_ @ _)%expr_pat _ | @expr.App _ _ _ s _
              (@expr.LetIn _ _ _ _ _ _ _) _ => UnderLets.Base (x - x0)%expr
            | _ => UnderLets.Base (x - x0)%expr
            end
        end
    | ($_)%expr =>
        match x0 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t1 v0 =>
                  match
                    t1 as t2 return (base.base_interp t2 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v1 : Z => Some v1
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v0
              | _ => None
              end
            with
            | Some args =>
                if args =? 0
                then UnderLets.Base x
                else
                 if args <? 0
                 then UnderLets.Base (x + ##((- args)%Z))%expr
                 else UnderLets.Base (x - x0)%expr
            | None => UnderLets.Base (x - x0)%expr
            end
        | @expr.App _ _ _ s _ #(idc)%expr_pat x1 =>
            match
              match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end
            with
            | Some _ =>
                match
                  s as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base base.type.Z)))
                with
                | type.base t2 =>
                    fun v0 : expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t1 : base.type => expr (type.base t1)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base base.type.Z)))
                      (fun
                         a : option
                               (expr (type.base t2) ->
                                expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' => UnderLets.Base (x + x' v0)%expr
                       | None => UnderLets.Base (x - x0)%expr
                       end)
                | (s0 -> d0)%ptype =>
                    fun _ : Compile.value' false s0 -> Compile.value' true d0
                    => UnderLets.Base (x - x0)%expr
                end (Compile.reflect x1)
            | None => UnderLets.Base (x - x0)%expr
            end
        | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat
          _ | @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            UnderLets.Base (x - x0)%expr
        | _ => UnderLets.Base (x - x0)%expr
        end
    | @expr.Abs _ _ _ _ _ _ =>
        match x0 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t0 v =>
                  match
                    t0 as t1 return (base.base_interp t1 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v0 : Z => Some v0
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v
              | _ => None
              end
            with
            | Some args =>
                if args =? 0
                then UnderLets.Base x
                else
                 if args <? 0
                 then UnderLets.Base (x + ##((- args)%Z))%expr
                 else UnderLets.Base (x - x0)%expr
            | None => UnderLets.Base (x - x0)%expr
            end
        | @expr.App _ _ _ s0 _ #(idc)%expr_pat x1 =>
            match
              match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end
            with
            | Some _ =>
                match
                  s0 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base base.type.Z)))
                with
                | type.base t2 =>
                    fun v : expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => expr (type.base t0)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base base.type.Z)))
                      (fun
                         a : option
                               (expr (type.base t2) ->
                                expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' => UnderLets.Base (x + x' v)%expr
                       | None => UnderLets.Base (x - x0)%expr
                       end)
                | (s1 -> d1)%ptype =>
                    fun _ : Compile.value' false s1 -> Compile.value' true d1
                    => UnderLets.Base (x - x0)%expr
                end (Compile.reflect x1)
            | None => UnderLets.Base (x - x0)%expr
            end
        | @expr.App _ _ _ s0 _ ($_)%expr _ | @expr.App _ _ _ s0 _
          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0 _ (_ @ _)%expr_pat
          _ | @expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            UnderLets.Base (x - x0)%expr
        | _ => UnderLets.Base (x - x0)%expr
        end
    | @expr.App _ _ _ s _ f x1 =>
        match x0 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t0 v =>
                  match
                    t0 as t1 return (base.base_interp t1 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v0 : Z => Some v0
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v
              | _ => None
              end
            with
            | Some args =>
                if args =? 0
                then UnderLets.Base x
                else
                 match f with
                 | #(idc0)%expr_pat =>
                     match
                       match idc0 with
                       | ident.Z_opp => Some tt
                       | _ => None
                       end
                     with
                     | Some _ =>
                         match
                           s as t2
                           return
                             (Compile.value' false t2 ->
                              UnderLets.UnderLets base.type ident var
                                (expr (type.base base.type.Z)))
                         with
                         | type.base t2 =>
                             fun v : expr (type.base t2) =>
                             base.try_make_transport_cps
                               (fun t1 : base.type => expr (type.base t1)) t2
                               base.type.Z
                               (UnderLets.UnderLets base.type ident var
                                  (expr (type.base base.type.Z)))
                               (fun
                                  a : option
                                        (expr (type.base t2) ->
                                         expr (type.base base.type.Z)) =>
                                match a with
                                | Some x' =>
                                    if args >? 0
                                    then
                                     UnderLets.Base
                                       (- (x' v + ##((- args)%Z)))%expr
                                    else
                                     match
                                       s as t3
                                       return
                                         (Compile.value' false t3 ->
                                          UnderLets.UnderLets base.type ident
                                            var
                                            (expr (type.base base.type.Z)))
                                     with
                                     | type.base t3 =>
                                         fun v0 : expr (type.base t3) =>
                                         base.try_make_transport_cps
                                           (fun t1 : base.type =>
                                            expr (type.base t1)) t3
                                           base.type.Z
                                           (UnderLets.UnderLets base.type
                                              ident var
                                              (expr (type.base base.type.Z)))
                                           (fun
                                              a0 : option
                                                     (expr (type.base t3) ->
                                                      expr
                                                        (type.base
                                                           base.type.Z)) =>
                                            match a0 with
                                            | Some x'0 =>
                                                if args <? 0
                                                then
                                                 UnderLets.Base
                                                   (##((- args)%Z) - x'0 v0)%expr
                                                else
                                                 if args <? 0
                                                 then
                                                  UnderLets.Base
                                                    (x + ##((- args)%Z))%expr
                                                 else
                                                  match
                                                    s as t4
                                                    return
                                                      (Compile.value' false
                                                         t4 ->
                                                       UnderLets.UnderLets
                                                         base.type ident var
                                                         (expr
                                                            (type.base
                                                               base.type.Z)))
                                                  with
                                                  | type.base t4 =>
                                                      fun
                                                        v1 : expr
                                                               (type.base t4)
                                                      =>
                                                      base.try_make_transport_cps
                                                        (fun t1 : base.type
                                                         =>
                                                         expr (type.base t1))
                                                        t4 base.type.Z
                                                        (UnderLets.UnderLets
                                                           base.type ident
                                                           var
                                                           (expr
                                                              (type.base
                                                                 base.type.Z)))
                                                        (fun
                                                           a1 : option
                                                                  (expr
                                                                    (type.base
                                                                    t4) ->
                                                                   expr
                                                                    (type.base
                                                                    base.type.Z))
                                                         =>
                                                         match a1 with
                                                         | Some x'1 =>
                                                             UnderLets.Base
                                                               (-
                                                                (x'1 v1 + x0))%expr
                                                         | None =>
                                                             UnderLets.Base
                                                               (x - x0)%expr
                                                         end)
                                                  | (s0 -> d0)%ptype =>
                                                      fun
                                                        _ : Compile.value'
                                                              false s0 ->
                                                            Compile.value'
                                                              true d0 =>
                                                      UnderLets.Base
                                                        (x - x0)%expr
                                                  end (Compile.reflect x1)
                                            | None =>
                                                UnderLets.Base (x - x0)%expr
                                            end)
                                     | (s0 -> d0)%ptype =>
                                         fun
                                           _ : Compile.value' false s0 ->
                                               Compile.value' true d0 =>
                                         UnderLets.Base (x - x0)%expr
                                     end (Compile.reflect x1)
                                | None => UnderLets.Base (x - x0)%expr
                                end)
                         | (s0 -> d0)%ptype =>
                             fun
                               _ : Compile.value' false s0 ->
                                   Compile.value' true d0 =>
                             UnderLets.Base (x - x0)%expr
                         end (Compile.reflect x1)
                     | None =>
                         if args <? 0
                         then UnderLets.Base (x + ##((- args)%Z))%expr
                         else UnderLets.Base (x - x0)%expr
                     end
                 | _ =>
                     if args <? 0
                     then UnderLets.Base (x + ##((- args)%Z))%expr
                     else UnderLets.Base (x - x0)%expr
                 end
            | None =>
                match f with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr (type.base base.type.Z)))
                        with
                        | type.base t2 =>
                            fun v : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type => expr (type.base t1)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr (type.base base.type.Z)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   UnderLets.Base (- (x' v + x0))%expr
                               | None => UnderLets.Base (x - x0)%expr
                               end)
                        | (s0 -> d0)%ptype =>
                            fun
                              _ : Compile.value' false s0 ->
                                  Compile.value' true d0 =>
                            UnderLets.Base (x - x0)%expr
                        end (Compile.reflect x1)
                    | None => UnderLets.Base (x - x0)%expr
                    end
                | _ => UnderLets.Base (x - x0)%expr
                end
            end
        | ($_)%expr =>
            match f with
            | #(idc)%expr_pat =>
                match
                  match idc with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v0 : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => expr (type.base t1)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (- (x' v0 + x0))%expr
                           | None => UnderLets.Base (x - x0)%expr
                           end)
                    | (s0 -> d0)%ptype =>
                        fun
                          _ : Compile.value' false s0 ->
                              Compile.value' true d0 =>
                        UnderLets.Base (x - x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x - x0)%expr
                end
            | _ => UnderLets.Base (x - x0)%expr
            end
        | @expr.Abs _ _ _ _ _ _ =>
            match f with
            | #(idc)%expr_pat =>
                match
                  match idc with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => expr (type.base t0)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (- (x' v + x0))%expr
                           | None => UnderLets.Base (x - x0)%expr
                           end)
                    | (s1 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d1 =>
                        UnderLets.Base (x - x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x - x0)%expr
                end
            | _ => UnderLets.Base (x - x0)%expr
            end
        | @expr.App _ _ _ s0 _ #(idc)%expr_pat x2 =>
            match
              match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end
            with
            | Some _ =>
                match f with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr (type.base base.type.Z)))
                        with
                        | type.base t2 =>
                            fun v : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type => expr (type.base t1)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr (type.base base.type.Z)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   match
                                     s0 as t3
                                     return
                                       (Compile.value' false t3 ->
                                        UnderLets.UnderLets base.type ident
                                          var (expr (type.base base.type.Z)))
                                   with
                                   | type.base t3 =>
                                       fun v0 : expr (type.base t3) =>
                                       base.try_make_transport_cps
                                         (fun t1 : base.type =>
                                          expr (type.base t1)) t3 base.type.Z
                                         (UnderLets.UnderLets base.type ident
                                            var
                                            (expr (type.base base.type.Z)))
                                         (fun
                                            a0 : option
                                                   (expr (type.base t3) ->
                                                    expr
                                                      (type.base base.type.Z))
                                          =>
                                          match a0 with
                                          | Some x'0 =>
                                              UnderLets.Base
                                                (x'0 v0 - x' v)%expr
                                          | None =>
                                              UnderLets.Base (x - x0)%expr
                                          end)
                                   | (s1 -> d1)%ptype =>
                                       fun
                                         _ : Compile.value' false s1 ->
                                             Compile.value' true d1 =>
                                       UnderLets.Base (x - x0)%expr
                                   end (Compile.reflect x2)
                               | None => UnderLets.Base (x - x0)%expr
                               end)
                        | (s1 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base (x - x0)%expr
                        end (Compile.reflect x1)
                    | None =>
                        match
                          s0 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr (type.base base.type.Z)))
                        with
                        | type.base t2 =>
                            fun v : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type => expr (type.base t1)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr (type.base base.type.Z)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' => UnderLets.Base (x + x' v)%expr
                               | None => UnderLets.Base (x - x0)%expr
                               end)
                        | (s1 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base (x - x0)%expr
                        end (Compile.reflect x2)
                    end
                | ($_)%expr =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v0 : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => expr (type.base t1)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (x + x' v0)%expr
                           | None => UnderLets.Base (x - x0)%expr
                           end)
                    | (s1 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d1 =>
                        UnderLets.Base (x - x0)%expr
                    end (Compile.reflect x2)
                | @expr.LetIn _ _ _ _ _ _ _ =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => expr (type.base t0)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (x + x' v)%expr
                           | None => UnderLets.Base (x - x0)%expr
                           end)
                    | (s1 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d1 =>
                        UnderLets.Base (x - x0)%expr
                    end (Compile.reflect x2)
                | _ =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => expr (type.base t0)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (x + x' v)%expr
                           | None => UnderLets.Base (x - x0)%expr
                           end)
                    | (s2 -> d2)%ptype =>
                        fun
                          _ : Compile.value' false s2 ->
                              Compile.value' true d2 =>
                        UnderLets.Base (x - x0)%expr
                    end (Compile.reflect x2)
                end
            | None =>
                match f with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr (type.base base.type.Z)))
                        with
                        | type.base t2 =>
                            fun v : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type => expr (type.base t1)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr (type.base base.type.Z)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   UnderLets.Base (- (x' v + x0))%expr
                               | None => UnderLets.Base (x - x0)%expr
                               end)
                        | (s1 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base (x - x0)%expr
                        end (Compile.reflect x1)
                    | None => UnderLets.Base (x - x0)%expr
                    end
                | _ => UnderLets.Base (x - x0)%expr
                end
            end
        | @expr.App _ _ _ s0 _ ($_)%expr _ =>
            match f with
            | #(idc)%expr_pat =>
                match
                  match idc with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v0 : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => expr (type.base t1)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (- (x' v0 + x0))%expr
                           | None => UnderLets.Base (x - x0)%expr
                           end)
                    | (s1 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d1 =>
                        UnderLets.Base (x - x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x - x0)%expr
                end
            | _ => UnderLets.Base (x - x0)%expr
            end
        | @expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0
          _ (_ @ _)%expr_pat _ =>
            match f with
            | #(idc)%expr_pat =>
                match
                  match idc with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => expr (type.base t0)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (- (x' v + x0))%expr
                           | None => UnderLets.Base (x - x0)%expr
                           end)
                    | (s2 -> d2)%ptype =>
                        fun
                          _ : Compile.value' false s2 ->
                              Compile.value' true d2 =>
                        UnderLets.Base (x - x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x - x0)%expr
                end
            | _ => UnderLets.Base (x - x0)%expr
            end
        | @expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            match f with
            | #(idc)%expr_pat =>
                match
                  match idc with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => expr (type.base t0)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (- (x' v + x0))%expr
                           | None => UnderLets.Base (x - x0)%expr
                           end)
                    | (s1 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d1 =>
                        UnderLets.Base (x - x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x - x0)%expr
                end
            | _ => UnderLets.Base (x - x0)%expr
            end
        | @expr.LetIn _ _ _ _ _ _ _ =>
            match f with
            | #(idc)%expr_pat =>
                match
                  match idc with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => expr (type.base t0)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (- (x' v + x0))%expr
                           | None => UnderLets.Base (x - x0)%expr
                           end)
                    | (s0 -> d0)%ptype =>
                        fun
                          _ : Compile.value' false s0 ->
                              Compile.value' true d0 =>
                        UnderLets.Base (x - x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x - x0)%expr
                end
            | _ => UnderLets.Base (x - x0)%expr
            end
        end
    | @expr.LetIn _ _ _ _ _ _ _ =>
        match x0 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t0 v =>
                  match
                    t0 as t1 return (base.base_interp t1 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v0 : Z => Some v0
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v
              | _ => None
              end
            with
            | Some args =>
                if args =? 0
                then UnderLets.Base x
                else
                 if args <? 0
                 then UnderLets.Base (x + ##((- args)%Z))%expr
                 else UnderLets.Base (x - x0)%expr
            | None => UnderLets.Base (x - x0)%expr
            end
        | @expr.App _ _ _ s _ #(idc)%expr_pat x2 =>
            match
              match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end
            with
            | Some _ =>
                match
                  s as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base base.type.Z)))
                with
                | type.base t2 =>
                    fun v : expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => expr (type.base t0)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base base.type.Z)))
                      (fun
                         a : option
                               (expr (type.base t2) ->
                                expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' => UnderLets.Base (x + x' v)%expr
                       | None => UnderLets.Base (x - x0)%expr
                       end)
                | (s0 -> d0)%ptype =>
                    fun _ : Compile.value' false s0 -> Compile.value' true d0
                    => UnderLets.Base (x - x0)%expr
                end (Compile.reflect x2)
            | None => UnderLets.Base (x - x0)%expr
            end
        | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat
          _ | @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            UnderLets.Base (x - x0)%expr
        | _ => UnderLets.Base (x - x0)%expr
        end
    end
| ident.Z_opp =>
    fun x : expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args => UnderLets.Base ##((- args)%Z)%expr
        | None => UnderLets.Base (- x)%expr
        end
    | @expr.App _ _ _ s _ #(idc)%expr_pat x0 =>
        match match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end with
        | Some _ =>
            match
              s as t2
              return
                (Compile.value' false t2 ->
                 UnderLets.UnderLets base.type ident var
                   (expr (type.base base.type.Z)))
            with
            | type.base t2 =>
                fun v : expr (type.base t2) =>
                base.try_make_transport_cps
                  (fun t0 : base.type => expr (type.base t0)) t2 base.type.Z
                  (UnderLets.UnderLets base.type ident var
                     (expr (type.base base.type.Z)))
                  (fun
                     a : option
                           (expr (type.base t2) ->
                            expr (type.base base.type.Z)) =>
                   match a with
                   | Some x' => UnderLets.Base (x' v)
                   | None => UnderLets.Base (- x)%expr
                   end)
            | (s0 -> d0)%ptype =>
                fun _ : Compile.value' false s0 -> Compile.value' true d0 =>
                UnderLets.Base (- x)%expr
            end (Compile.reflect x0)
        | None => UnderLets.Base (- x)%expr
        end
    | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
      (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat _ |
      @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
        UnderLets.Base (- x)%expr
    | _ => UnderLets.Base (- x)%expr
    end
| ident.Z_div =>
    fun x x0 : expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 => UnderLets.Base ##((args / args0)%Z)%expr
                | None => UnderLets.Base (x / x0)%expr
                end
            | _ => UnderLets.Base (x / x0)%expr
            end
        | None =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args =>
                    if args =? 2 ^ Z.log2 args
                    then UnderLets.Base (x >> Z.log2 args)%expr
                    else UnderLets.Base (x / x0)%expr
                | None => UnderLets.Base (x / x0)%expr
                end
            | _ => UnderLets.Base (x / x0)%expr
            end
        end
    | ($_)%expr =>
        match x0 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t1 v0 =>
                  match
                    t1 as t2 return (base.base_interp t2 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v1 : Z => Some v1
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v0
              | _ => None
              end
            with
            | Some args =>
                if args =? 2 ^ Z.log2 args
                then UnderLets.Base (x >> Z.log2 args)%expr
                else UnderLets.Base (x / x0)%expr
            | None => UnderLets.Base (x / x0)%expr
            end
        | _ => UnderLets.Base (x / x0)%expr
        end
    | _ =>
        match x0 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t0 v =>
                  match
                    t0 as t1 return (base.base_interp t1 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v0 : Z => Some v0
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v
              | _ => None
              end
            with
            | Some args =>
                if args =? 2 ^ Z.log2 args
                then UnderLets.Base (x >> Z.log2 args)%expr
                else UnderLets.Base (x / x0)%expr
            | None => UnderLets.Base (x / x0)%expr
            end
        | _ => UnderLets.Base (x / x0)%expr
        end
    end
| ident.Z_modulo =>
    fun x x0 : expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 => UnderLets.Base ##((args mod args0)%Z)%expr
                | None => UnderLets.Base (x mod x0)%expr
                end
            | _ => UnderLets.Base (x mod x0)%expr
            end
        | None =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.Z_land (args - 1))%expr @ x)%expr_pat
                    else UnderLets.Base (x mod x0)%expr
                | None => UnderLets.Base (x mod x0)%expr
                end
            | _ => UnderLets.Base (x mod x0)%expr
            end
        end
    | ($_)%expr =>
        match x0 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t1 v0 =>
                  match
                    t1 as t2 return (base.base_interp t2 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v1 : Z => Some v1
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v0
              | _ => None
              end
            with
            | Some args =>
                if args =? 2 ^ Z.log2 args
                then
                 UnderLets.Base
                   (#(ident.Z_land (args - 1))%expr @ x)%expr_pat
                else UnderLets.Base (x mod x0)%expr
            | None => UnderLets.Base (x mod x0)%expr
            end
        | _ => UnderLets.Base (x mod x0)%expr
        end
    | _ =>
        match x0 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t0 v =>
                  match
                    t0 as t1 return (base.base_interp t1 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v0 : Z => Some v0
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v
              | _ => None
              end
            with
            | Some args =>
                if args =? 2 ^ Z.log2 args
                then
                 UnderLets.Base
                   (#(ident.Z_land (args - 1))%expr @ x)%expr_pat
                else UnderLets.Base (x mod x0)%expr
            | None => UnderLets.Base (x mod x0)%expr
            end
        | _ => UnderLets.Base (x mod x0)%expr
        end
    end
| ident.Z_eqb =>
    fun x x0 : expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 => UnderLets.Base ##(args =? args0)%expr
                | None =>
                    UnderLets.Base (#(ident.Z_eqb)%expr @ x @ x0)%expr_pat
                end
            | _ => UnderLets.Base (#(ident.Z_eqb)%expr @ x @ x0)%expr_pat
            end
        | None => UnderLets.Base (#(ident.Z_eqb)%expr @ x @ x0)%expr_pat
        end
    | _ => UnderLets.Base (#(ident.Z_eqb)%expr @ x @ x0)%expr_pat
    end
| ident.Z_leb =>
    fun x x0 : expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 => UnderLets.Base ##(args <=? args0)%expr
                | None =>
                    UnderLets.Base (#(ident.Z_leb)%expr @ x @ x0)%expr_pat
                end
            | _ => UnderLets.Base (#(ident.Z_leb)%expr @ x @ x0)%expr_pat
            end
        | None => UnderLets.Base (#(ident.Z_leb)%expr @ x @ x0)%expr_pat
        end
    | _ => UnderLets.Base (#(ident.Z_leb)%expr @ x @ x0)%expr_pat
    end
| ident.Z_of_nat =>
    fun x : expr (type.base base.type.nat) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option nat) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun _ : Z => None
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun v0 : nat => Some v0
              end v
          | _ => None
          end
        with
        | Some args => UnderLets.Base ##(Z.of_nat args)%expr
        | None => UnderLets.Base (#(ident.Z_of_nat)%expr @ x)%expr_pat
        end
    | _ => UnderLets.Base (#(ident.Z_of_nat)%expr @ x)%expr_pat
    end
| ident.Z_shiftr offset =>
    fun x : expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args => UnderLets.Base ##(Z.shiftr args offset)%expr
        | None => UnderLets.Base (x >> offset)%expr
        end
    | _ => UnderLets.Base (x >> offset)%expr
    end
| ident.Z_shiftl offset =>
    fun x : expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args => UnderLets.Base ##(Z.shiftl args offset)%expr
        | None => UnderLets.Base (x << offset)%expr
        end
    | _ => UnderLets.Base (x << offset)%expr
    end
| ident.Z_land mask =>
    fun x : expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args => UnderLets.Base ##(Z.land args mask)%expr
        | None => UnderLets.Base (#(ident.Z_land mask)%expr @ x)%expr_pat
        end
    | _ => UnderLets.Base (#(ident.Z_land mask)%expr @ x)%expr_pat
    end
| ident.Z_mul_split =>
    fun x x0 x1 : expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 =>
                    match x1 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args1 =>
                            UnderLets.Base
                              (let
                               '(a, b) :=
                                Definitions.Z.mul_split args args0 args1 in
                                (##(a)%expr, ##(b)%expr)%expr_pat)
                        | None =>
                            if args0 =? 0
                            then
                             UnderLets.Base (##(0)%expr, ##(0)%expr)%expr_pat
                            else
                             if args0 =? 1
                             then UnderLets.Base (x1, ##(0)%expr)%expr_pat
                             else
                              if args0 =? -1
                              then
                               UnderLets.Base
                                 ((- x1)%expr, ##(0)%expr)%expr_pat
                              else
                               UnderLets.Base
                                 (#(ident.Z_mul_split_concrete args)%expr @
                                  x0 @ x1)%expr_pat
                        end
                    | _ =>
                        if args0 =? 0
                        then UnderLets.Base (##(0)%expr, ##(0)%expr)%expr_pat
                        else
                         if args0 =? 1
                         then UnderLets.Base (x1, ##(0)%expr)%expr_pat
                         else
                          if args0 =? -1
                          then
                           UnderLets.Base ((- x1)%expr, ##(0)%expr)%expr_pat
                          else
                           UnderLets.Base
                             (#(ident.Z_mul_split_concrete args)%expr @ x0 @
                              x1)%expr_pat
                    end
                | None =>
                    match x1 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args0 =>
                            if args0 =? 0
                            then
                             UnderLets.Base (##(0)%expr, ##(0)%expr)%expr_pat
                            else
                             if args0 =? 1
                             then UnderLets.Base (x0, ##(0)%expr)%expr_pat
                             else
                              if args0 =? -1
                              then
                               UnderLets.Base
                                 ((- x0)%expr, ##(0)%expr)%expr_pat
                              else
                               UnderLets.Base
                                 (#(ident.Z_mul_split_concrete args)%expr @
                                  x0 @ x1)%expr_pat
                        | None =>
                            UnderLets.Base
                              (#(ident.Z_mul_split_concrete args)%expr @ x0 @
                               x1)%expr_pat
                        end
                    | _ =>
                        UnderLets.Base
                          (#(ident.Z_mul_split_concrete args)%expr @ x0 @ x1)%expr_pat
                    end
                end
            | ($_)%expr =>
                match x1 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t2 v0 =>
                          match
                            t2 as t3 return (base.base_interp t3 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v1 : Z => Some v1
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v0
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        if args0 =? 0
                        then UnderLets.Base (##(0)%expr, ##(0)%expr)%expr_pat
                        else
                         if args0 =? 1
                         then UnderLets.Base (x0, ##(0)%expr)%expr_pat
                         else
                          if args0 =? -1
                          then
                           UnderLets.Base ((- x0)%expr, ##(0)%expr)%expr_pat
                          else
                           UnderLets.Base
                             (#(ident.Z_mul_split_concrete args)%expr @ x0 @
                              x1)%expr_pat
                    | None =>
                        UnderLets.Base
                          (#(ident.Z_mul_split_concrete args)%expr @ x0 @ x1)%expr_pat
                    end
                | _ =>
                    UnderLets.Base
                      (#(ident.Z_mul_split_concrete args)%expr @ x0 @ x1)%expr_pat
                end
            | _ =>
                match x1 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t1 v =>
                          match
                            t1 as t2 return (base.base_interp t2 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v0 : Z => Some v0
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        if args0 =? 0
                        then UnderLets.Base (##(0)%expr, ##(0)%expr)%expr_pat
                        else
                         if args0 =? 1
                         then UnderLets.Base (x0, ##(0)%expr)%expr_pat
                         else
                          if args0 =? -1
                          then
                           UnderLets.Base ((- x0)%expr, ##(0)%expr)%expr_pat
                          else
                           UnderLets.Base
                             (#(ident.Z_mul_split_concrete args)%expr @ x0 @
                              x1)%expr_pat
                    | None =>
                        UnderLets.Base
                          (#(ident.Z_mul_split_concrete args)%expr @ x0 @ x1)%expr_pat
                    end
                | _ =>
                    UnderLets.Base
                      (#(ident.Z_mul_split_concrete args)%expr @ x0 @ x1)%expr_pat
                end
            end
        | None =>
            UnderLets.Base (#(ident.Z_mul_split)%expr @ x @ x0 @ x1)%expr_pat
        end
    | _ => UnderLets.Base (#(ident.Z_mul_split)%expr @ x @ x0 @ x1)%expr_pat
    end
| ident.Z_mul_split_concrete s =>
    fun x x0 : expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 =>
                    UnderLets.Base
                      (let
                       '(a, b) := Definitions.Z.mul_split s args args0 in
                        (##(a)%expr, ##(b)%expr)%expr_pat)
                | None =>
                    UnderLets.Base
                      (#(ident.Z_mul_split_concrete s)%expr @ x @ x0)%expr_pat
                end
            | _ =>
                UnderLets.Base
                  (#(ident.Z_mul_split_concrete s)%expr @ x @ x0)%expr_pat
            end
        | None =>
            UnderLets.Base
              (#(ident.Z_mul_split_concrete s)%expr @ x @ x0)%expr_pat
        end
    | _ =>
        UnderLets.Base
          (#(ident.Z_mul_split_concrete s)%expr @ x @ x0)%expr_pat
    end
| ident.Z_add_get_carry =>
    fun x x0 x1 : expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 =>
                    match x1 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args1 =>
                            UnderLets.Base
                              (let
                               '(a, b) :=
                                Definitions.Z.add_get_carry_full args args0
                                  args1 in (##(a)%expr, ##(b)%expr)%expr_pat)
                        | None =>
                            if args0 =? 0
                            then UnderLets.Base (x1, ##(0)%expr)%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry_concrete args)%expr @
                                x0 @ x1)%expr_pat
                        end
                    | @expr.App _ _ _ s _ f x2 =>
                        if args0 =? 0
                        then UnderLets.Base (x1, ##(0)%expr)%expr_pat
                        else
                         match f with
                         | #(idc1)%expr_pat =>
                             match
                               match idc1 with
                               | ident.Z_opp => Some tt
                               | _ => None
                               end
                             with
                             | Some _ =>
                                 match
                                   s as t2
                                   return
                                     (Compile.value' false t2 ->
                                      UnderLets.UnderLets base.type ident var
                                        (expr
                                           (type.base
                                              (base.type.Z * base.type.Z)%etype)))
                                 with
                                 | type.base t2 =>
                                     fun v : expr (type.base t2) =>
                                     base.try_make_transport_cps
                                       (fun t3 : base.type =>
                                        expr (type.base t3)) t2 base.type.Z
                                       (UnderLets.UnderLets base.type ident
                                          var
                                          (expr
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)))
                                       (fun
                                          a : option
                                                (expr (type.base t2) ->
                                                 expr (type.base base.type.Z))
                                        =>
                                        match a with
                                        | Some x' =>
                                            UnderLets.UnderLet
                                              (#(ident.Z_sub_get_borrow_concrete
                                                   args)%expr @ x0 @ 
                                               x' v)%expr_pat
                                              (fun
                                                 v0 : var
                                                        (type.base
                                                           (base.type.Z *
                                                            base.type.Z)%etype)
                                               =>
                                               UnderLets.Base
                                                 (#(ident.fst)%expr @
                                                  ($v0)%expr,
                                                 (-
                                                  (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                        | None =>
                                            UnderLets.Base
                                              (#(ident.Z_add_get_carry)%expr @
                                               x @ x0 @ x1)%expr_pat
                                        end)
                                 | (s0 -> d0)%ptype =>
                                     fun
                                       _ : Compile.value' false s0 ->
                                           Compile.value' true d0 =>
                                     UnderLets.Base
                                       (#(ident.Z_add_get_carry)%expr @ x @
                                        x0 @ x1)%expr_pat
                                 end (Compile.reflect x2)
                             | None =>
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry_concrete args)%expr @
                                    x0 @ x1)%expr_pat
                             end
                         | _ =>
                             UnderLets.Base
                               (#(ident.Z_add_get_carry_concrete args)%expr @
                                x0 @ x1)%expr_pat
                         end
                    | _ =>
                        if args0 =? 0
                        then UnderLets.Base (x1, ##(0)%expr)%expr_pat
                        else
                         UnderLets.Base
                           (#(ident.Z_add_get_carry_concrete args)%expr @ x0 @
                            x1)%expr_pat
                    end
                | None =>
                    match x1 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args0 =>
                            if args0 =? 0
                            then UnderLets.Base (x0, ##(0)%expr)%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry_concrete args)%expr @
                                x0 @ x1)%expr_pat
                        | None =>
                            UnderLets.Base
                              (#(ident.Z_add_get_carry_concrete args)%expr @
                               x0 @ x1)%expr_pat
                        end
                    | @expr.App _ _ _ s _ #(idc1)%expr_pat x2 =>
                        match
                          match idc1 with
                          | ident.Z_opp => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match
                              s as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (expr
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)))
                            with
                            | type.base t2 =>
                                fun v : expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t3 : base.type => expr (type.base t3))
                                  t2 base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (expr
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)))
                                  (fun
                                     a : option
                                           (expr (type.base t2) ->
                                            expr (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       UnderLets.UnderLet
                                         (#(ident.Z_sub_get_borrow_concrete
                                              args)%expr @ x0 @ x' v)%expr_pat
                                         (fun
                                            v0 : var
                                                   (type.base
                                                      (base.type.Z *
                                                       base.type.Z)%etype) =>
                                          UnderLets.Base
                                            (#(ident.fst)%expr @ ($v0)%expr,
                                            (-
                                             (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                   | None =>
                                       UnderLets.Base
                                         (#(ident.Z_add_get_carry)%expr @ x @
                                          x0 @ x1)%expr_pat
                                   end)
                            | (s0 -> d0)%ptype =>
                                fun
                                  _ : Compile.value' false s0 ->
                                      Compile.value' true d0 =>
                                UnderLets.Base
                                  (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                   x1)%expr_pat
                            end (Compile.reflect x2)
                        | None =>
                            UnderLets.Base
                              (#(ident.Z_add_get_carry_concrete args)%expr @
                               x0 @ x1)%expr_pat
                        end
                    | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
                      (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _
                      (_ @ _)%expr_pat _ | @expr.App _ _ _ s _
                      (@expr.LetIn _ _ _ _ _ _ _) _ =>
                        UnderLets.Base
                          (#(ident.Z_add_get_carry_concrete args)%expr @ x0 @
                           x1)%expr_pat
                    | _ =>
                        UnderLets.Base
                          (#(ident.Z_add_get_carry_concrete args)%expr @ x0 @
                           x1)%expr_pat
                    end
                end
            | ($_)%expr =>
                match x1 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t2 v0 =>
                          match
                            t2 as t3 return (base.base_interp t3 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v1 : Z => Some v1
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v0
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        if args0 =? 0
                        then UnderLets.Base (x0, ##(0)%expr)%expr_pat
                        else
                         UnderLets.Base
                           (#(ident.Z_add_get_carry_concrete args)%expr @ x0 @
                            x1)%expr_pat
                    | None =>
                        UnderLets.Base
                          (#(ident.Z_add_get_carry_concrete args)%expr @ x0 @
                           x1)%expr_pat
                    end
                | @expr.App _ _ _ s _ #(idc0)%expr_pat x2 =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v0 : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t3 : base.type => expr (type.base t3)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   UnderLets.UnderLet
                                     (#(ident.Z_sub_get_borrow_concrete args)%expr @
                                      x0 @ x' v0)%expr_pat
                                     (fun
                                        v1 : var
                                               (type.base
                                                  (base.type.Z * base.type.Z)%etype)
                                      =>
                                      UnderLets.Base
                                        (#(ident.fst)%expr @ ($v1)%expr,
                                        (- (#(ident.snd)%expr @ $v1)%expr_pat)%expr)%expr_pat)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                      x1)%expr_pat
                               end)
                        | (s0 -> d0)%ptype =>
                            fun
                              _ : Compile.value' false s0 ->
                                  Compile.value' true d0 =>
                            UnderLets.Base
                              (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                        end (Compile.reflect x2)
                    | None =>
                        UnderLets.Base
                          (#(ident.Z_add_get_carry_concrete args)%expr @ x0 @
                           x1)%expr_pat
                    end
                | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
                  (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _
                  (_ @ _)%expr_pat _ | @expr.App _ _ _ s _
                  (@expr.LetIn _ _ _ _ _ _ _) _ =>
                    UnderLets.Base
                      (#(ident.Z_add_get_carry_concrete args)%expr @ x0 @ x1)%expr_pat
                | _ =>
                    UnderLets.Base
                      (#(ident.Z_add_get_carry_concrete args)%expr @ x0 @ x1)%expr_pat
                end
            | @expr.Abs _ _ _ _ _ _ =>
                match x1 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t1 v =>
                          match
                            t1 as t2 return (base.base_interp t2 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v0 : Z => Some v0
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        if args0 =? 0
                        then UnderLets.Base (x0, ##(0)%expr)%expr_pat
                        else
                         UnderLets.Base
                           (#(ident.Z_add_get_carry_concrete args)%expr @ x0 @
                            x1)%expr_pat
                    | None =>
                        UnderLets.Base
                          (#(ident.Z_add_get_carry_concrete args)%expr @ x0 @
                           x1)%expr_pat
                    end
                | @expr.App _ _ _ s0 _ #(idc0)%expr_pat x2 =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s0 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type => expr (type.base t1)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   UnderLets.UnderLet
                                     (#(ident.Z_sub_get_borrow_concrete args)%expr @
                                      x0 @ x' v)%expr_pat
                                     (fun
                                        v0 : var
                                               (type.base
                                                  (base.type.Z * base.type.Z)%etype)
                                      =>
                                      UnderLets.Base
                                        (#(ident.fst)%expr @ ($v0)%expr,
                                        (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                      x1)%expr_pat
                               end)
                        | (s1 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base
                              (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                        end (Compile.reflect x2)
                    | None =>
                        UnderLets.Base
                          (#(ident.Z_add_get_carry_concrete args)%expr @ x0 @
                           x1)%expr_pat
                    end
                | @expr.App _ _ _ s0 _ ($_)%expr _ | @expr.App _ _ _ s0 _
                  (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0 _
                  (_ @ _)%expr_pat _ | @expr.App _ _ _ s0 _
                  (@expr.LetIn _ _ _ _ _ _ _) _ =>
                    UnderLets.Base
                      (#(ident.Z_add_get_carry_concrete args)%expr @ x0 @ x1)%expr_pat
                | _ =>
                    UnderLets.Base
                      (#(ident.Z_add_get_carry_concrete args)%expr @ x0 @ x1)%expr_pat
                end
            | @expr.App _ _ _ s _ f x2 =>
                match x1 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t1 v =>
                          match
                            t1 as t2 return (base.base_interp t2 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v0 : Z => Some v0
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        if args0 =? 0
                        then UnderLets.Base (x0, ##(0)%expr)%expr_pat
                        else
                         match f with
                         | #(idc1)%expr_pat =>
                             match
                               match idc1 with
                               | ident.Z_opp => Some tt
                               | _ => None
                               end
                             with
                             | Some _ =>
                                 match
                                   s as t2
                                   return
                                     (Compile.value' false t2 ->
                                      UnderLets.UnderLets base.type ident var
                                        (expr
                                           (type.base
                                              (base.type.Z * base.type.Z)%etype)))
                                 with
                                 | type.base t2 =>
                                     fun v : expr (type.base t2) =>
                                     base.try_make_transport_cps
                                       (fun t3 : base.type =>
                                        expr (type.base t3)) t2 base.type.Z
                                       (UnderLets.UnderLets base.type ident
                                          var
                                          (expr
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)))
                                       (fun
                                          a : option
                                                (expr (type.base t2) ->
                                                 expr (type.base base.type.Z))
                                        =>
                                        match a with
                                        | Some x' =>
                                            UnderLets.UnderLet
                                              (#(ident.Z_sub_get_borrow_concrete
                                                   args)%expr @ x1 @ 
                                               x' v)%expr_pat
                                              (fun
                                                 v0 : var
                                                        (type.base
                                                           (base.type.Z *
                                                            base.type.Z)%etype)
                                               =>
                                               UnderLets.Base
                                                 (#(ident.fst)%expr @
                                                  ($v0)%expr,
                                                 (-
                                                  (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                        | None =>
                                            UnderLets.Base
                                              (#(ident.Z_add_get_carry)%expr @
                                               x @ x0 @ x1)%expr_pat
                                        end)
                                 | (s0 -> d0)%ptype =>
                                     fun
                                       _ : Compile.value' false s0 ->
                                           Compile.value' true d0 =>
                                     UnderLets.Base
                                       (#(ident.Z_add_get_carry)%expr @ x @
                                        x0 @ x1)%expr_pat
                                 end (Compile.reflect x2)
                             | None =>
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry_concrete args)%expr @
                                    x0 @ x1)%expr_pat
                             end
                         | _ =>
                             UnderLets.Base
                               (#(ident.Z_add_get_carry_concrete args)%expr @
                                x0 @ x1)%expr_pat
                         end
                    | None =>
                        match f with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | ident.Z_opp => Some tt
                              | _ => None
                              end
                            with
                            | Some _ =>
                                match
                                  s as t2
                                  return
                                    (Compile.value' false t2 ->
                                     UnderLets.UnderLets base.type ident var
                                       (expr
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)))
                                with
                                | type.base t2 =>
                                    fun v : expr (type.base t2) =>
                                    base.try_make_transport_cps
                                      (fun t3 : base.type =>
                                       expr (type.base t3)) t2 base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (expr
                                            (type.base
                                               (base.type.Z * base.type.Z)%etype)))
                                      (fun
                                         a : option
                                               (expr (type.base t2) ->
                                                expr (type.base base.type.Z))
                                       =>
                                       match a with
                                       | Some x' =>
                                           UnderLets.UnderLet
                                             (#(ident.Z_sub_get_borrow_concrete
                                                  args)%expr @ x1 @ x' v)%expr_pat
                                             (fun
                                                v0 : var
                                                       (type.base
                                                          (base.type.Z *
                                                           base.type.Z)%etype)
                                              =>
                                              UnderLets.Base
                                                (#(ident.fst)%expr @
                                                 ($v0)%expr,
                                                (-
                                                 (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                       | None =>
                                           UnderLets.Base
                                             (#(ident.Z_add_get_carry)%expr @
                                              x @ x0 @ x1)%expr_pat
                                       end)
                                | (s0 -> d0)%ptype =>
                                    fun
                                      _ : Compile.value' false s0 ->
                                          Compile.value' true d0 =>
                                    UnderLets.Base
                                      (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                       x1)%expr_pat
                                end (Compile.reflect x2)
                            | None =>
                                UnderLets.Base
                                  (#(ident.Z_add_get_carry_concrete args)%expr @
                                   x0 @ x1)%expr_pat
                            end
                        | _ =>
                            UnderLets.Base
                              (#(ident.Z_add_get_carry_concrete args)%expr @
                               x0 @ x1)%expr_pat
                        end
                    end
                | ($_)%expr =>
                    match f with
                    | #(idc0)%expr_pat =>
                        match
                          match idc0 with
                          | ident.Z_opp => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match
                              s as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (expr
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)))
                            with
                            | type.base t2 =>
                                fun v0 : expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t3 : base.type => expr (type.base t3))
                                  t2 base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (expr
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)))
                                  (fun
                                     a : option
                                           (expr (type.base t2) ->
                                            expr (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       UnderLets.UnderLet
                                         (#(ident.Z_sub_get_borrow_concrete
                                              args)%expr @ x1 @ x' v0)%expr_pat
                                         (fun
                                            v1 : var
                                                   (type.base
                                                      (base.type.Z *
                                                       base.type.Z)%etype) =>
                                          UnderLets.Base
                                            (#(ident.fst)%expr @ ($v1)%expr,
                                            (-
                                             (#(ident.snd)%expr @ $v1)%expr_pat)%expr)%expr_pat)
                                   | None =>
                                       UnderLets.Base
                                         (#(ident.Z_add_get_carry)%expr @ x @
                                          x0 @ x1)%expr_pat
                                   end)
                            | (s0 -> d0)%ptype =>
                                fun
                                  _ : Compile.value' false s0 ->
                                      Compile.value' true d0 =>
                                UnderLets.Base
                                  (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                   x1)%expr_pat
                            end (Compile.reflect x2)
                        | None =>
                            UnderLets.Base
                              (#(ident.Z_add_get_carry_concrete args)%expr @
                               x0 @ x1)%expr_pat
                        end
                    | _ =>
                        UnderLets.Base
                          (#(ident.Z_add_get_carry_concrete args)%expr @ x0 @
                           x1)%expr_pat
                    end
                | @expr.Abs _ _ _ _ _ _ =>
                    match f with
                    | #(idc0)%expr_pat =>
                        match
                          match idc0 with
                          | ident.Z_opp => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match
                              s as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (expr
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)))
                            with
                            | type.base t2 =>
                                fun v : expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t1 : base.type => expr (type.base t1))
                                  t2 base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (expr
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)))
                                  (fun
                                     a : option
                                           (expr (type.base t2) ->
                                            expr (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       UnderLets.UnderLet
                                         (#(ident.Z_sub_get_borrow_concrete
                                              args)%expr @ x1 @ x' v)%expr_pat
                                         (fun
                                            v0 : var
                                                   (type.base
                                                      (base.type.Z *
                                                       base.type.Z)%etype) =>
                                          UnderLets.Base
                                            (#(ident.fst)%expr @ ($v0)%expr,
                                            (-
                                             (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                   | None =>
                                       UnderLets.Base
                                         (#(ident.Z_add_get_carry)%expr @ x @
                                          x0 @ x1)%expr_pat
                                   end)
                            | (s1 -> d1)%ptype =>
                                fun
                                  _ : Compile.value' false s1 ->
                                      Compile.value' true d1 =>
                                UnderLets.Base
                                  (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                   x1)%expr_pat
                            end (Compile.reflect x2)
                        | None =>
                            UnderLets.Base
                              (#(ident.Z_add_get_carry_concrete args)%expr @
                               x0 @ x1)%expr_pat
                        end
                    | _ =>
                        UnderLets.Base
                          (#(ident.Z_add_get_carry_concrete args)%expr @ x0 @
                           x1)%expr_pat
                    end
                | @expr.App _ _ _ s0 _ f0 x3 =>
                    match f with
                    | #(idc0)%expr_pat =>
                        match
                          match idc0 with
                          | ident.Z_opp => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match
                              s as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (expr
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)))
                            with
                            | type.base t2 =>
                                fun v : expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t1 : base.type => expr (type.base t1))
                                  t2 base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (expr
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)))
                                  (fun
                                     a : option
                                           (expr (type.base t2) ->
                                            expr (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       UnderLets.UnderLet
                                         (#(ident.Z_sub_get_borrow_concrete
                                              args)%expr @ x1 @ x' v)%expr_pat
                                         (fun
                                            v0 : var
                                                   (type.base
                                                      (base.type.Z *
                                                       base.type.Z)%etype) =>
                                          UnderLets.Base
                                            (#(ident.fst)%expr @ ($v0)%expr,
                                            (-
                                             (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                   | None =>
                                       UnderLets.Base
                                         (#(ident.Z_add_get_carry)%expr @ x @
                                          x0 @ x1)%expr_pat
                                   end)
                            | (s1 -> d1)%ptype =>
                                fun
                                  _ : Compile.value' false s1 ->
                                      Compile.value' true d1 =>
                                UnderLets.Base
                                  (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                   x1)%expr_pat
                            end (Compile.reflect x2)
                        | None =>
                            match f0 with
                            | #(idc1)%expr_pat =>
                                match
                                  match idc1 with
                                  | ident.Z_opp => Some tt
                                  | _ => None
                                  end
                                with
                                | Some _ =>
                                    match
                                      s0 as t2
                                      return
                                        (Compile.value' false t2 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t2 =>
                                        fun v : expr (type.base t2) =>
                                        base.try_make_transport_cps
                                          (fun t3 : base.type =>
                                           expr (type.base t3)) t2
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (expr (type.base t2) ->
                                                    expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               UnderLets.UnderLet
                                                 (#(ident.Z_sub_get_borrow_concrete
                                                      args)%expr @ x0 @ 
                                                  x' v)%expr_pat
                                                 (fun
                                                    v0 : var
                                                           (type.base
                                                              (base.type.Z *
                                                               base.type.Z)%etype)
                                                  =>
                                                  UnderLets.Base
                                                    (#(ident.fst)%expr @
                                                     ($v0)%expr,
                                                    (-
                                                     (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_get_carry)%expr @
                                                  x @ x0 @ x1)%expr_pat
                                           end)
                                    | (s1 -> d1)%ptype =>
                                        fun
                                          _ : Compile.value' false s1 ->
                                              Compile.value' true d1 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_get_carry)%expr @ x @
                                           x0 @ x1)%expr_pat
                                    end (Compile.reflect x3)
                                | None =>
                                    UnderLets.Base
                                      (#(ident.Z_add_get_carry_concrete args)%expr @
                                       x0 @ x1)%expr_pat
                                end
                            | _ =>
                                UnderLets.Base
                                  (#(ident.Z_add_get_carry_concrete args)%expr @
                                   x0 @ x1)%expr_pat
                            end
                        end
                    | ($_)%expr =>
                        match f0 with
                        | #(idc0)%expr_pat =>
                            match
                              match idc0 with
                              | ident.Z_opp => Some tt
                              | _ => None
                              end
                            with
                            | Some _ =>
                                match
                                  s0 as t2
                                  return
                                    (Compile.value' false t2 ->
                                     UnderLets.UnderLets base.type ident var
                                       (expr
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)))
                                with
                                | type.base t2 =>
                                    fun v0 : expr (type.base t2) =>
                                    base.try_make_transport_cps
                                      (fun t3 : base.type =>
                                       expr (type.base t3)) t2 base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (expr
                                            (type.base
                                               (base.type.Z * base.type.Z)%etype)))
                                      (fun
                                         a : option
                                               (expr (type.base t2) ->
                                                expr (type.base base.type.Z))
                                       =>
                                       match a with
                                       | Some x' =>
                                           UnderLets.UnderLet
                                             (#(ident.Z_sub_get_borrow_concrete
                                                  args)%expr @ x0 @ x' v0)%expr_pat
                                             (fun
                                                v1 : var
                                                       (type.base
                                                          (base.type.Z *
                                                           base.type.Z)%etype)
                                              =>
                                              UnderLets.Base
                                                (#(ident.fst)%expr @
                                                 ($v1)%expr,
                                                (-
                                                 (#(ident.snd)%expr @ $v1)%expr_pat)%expr)%expr_pat)
                                       | None =>
                                           UnderLets.Base
                                             (#(ident.Z_add_get_carry)%expr @
                                              x @ x0 @ x1)%expr_pat
                                       end)
                                | (s1 -> d1)%ptype =>
                                    fun
                                      _ : Compile.value' false s1 ->
                                          Compile.value' true d1 =>
                                    UnderLets.Base
                                      (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                       x1)%expr_pat
                                end (Compile.reflect x3)
                            | None =>
                                UnderLets.Base
                                  (#(ident.Z_add_get_carry_concrete args)%expr @
                                   x0 @ x1)%expr_pat
                            end
                        | _ =>
                            UnderLets.Base
                              (#(ident.Z_add_get_carry_concrete args)%expr @
                               x0 @ x1)%expr_pat
                        end
                    | @expr.LetIn _ _ _ _ _ _ _ =>
                        match f0 with
                        | #(idc0)%expr_pat =>
                            match
                              match idc0 with
                              | ident.Z_opp => Some tt
                              | _ => None
                              end
                            with
                            | Some _ =>
                                match
                                  s0 as t2
                                  return
                                    (Compile.value' false t2 ->
                                     UnderLets.UnderLets base.type ident var
                                       (expr
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)))
                                with
                                | type.base t2 =>
                                    fun v : expr (type.base t2) =>
                                    base.try_make_transport_cps
                                      (fun t1 : base.type =>
                                       expr (type.base t1)) t2 base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (expr
                                            (type.base
                                               (base.type.Z * base.type.Z)%etype)))
                                      (fun
                                         a : option
                                               (expr (type.base t2) ->
                                                expr (type.base base.type.Z))
                                       =>
                                       match a with
                                       | Some x' =>
                                           UnderLets.UnderLet
                                             (#(ident.Z_sub_get_borrow_concrete
                                                  args)%expr @ x0 @ x' v)%expr_pat
                                             (fun
                                                v0 : var
                                                       (type.base
                                                          (base.type.Z *
                                                           base.type.Z)%etype)
                                              =>
                                              UnderLets.Base
                                                (#(ident.fst)%expr @
                                                 ($v0)%expr,
                                                (-
                                                 (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                       | None =>
                                           UnderLets.Base
                                             (#(ident.Z_add_get_carry)%expr @
                                              x @ x0 @ x1)%expr_pat
                                       end)
                                | (s1 -> d1)%ptype =>
                                    fun
                                      _ : Compile.value' false s1 ->
                                          Compile.value' true d1 =>
                                    UnderLets.Base
                                      (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                       x1)%expr_pat
                                end (Compile.reflect x3)
                            | None =>
                                UnderLets.Base
                                  (#(ident.Z_add_get_carry_concrete args)%expr @
                                   x0 @ x1)%expr_pat
                            end
                        | _ =>
                            UnderLets.Base
                              (#(ident.Z_add_get_carry_concrete args)%expr @
                               x0 @ x1)%expr_pat
                        end
                    | _ =>
                        match f0 with
                        | #(idc0)%expr_pat =>
                            match
                              match idc0 with
                              | ident.Z_opp => Some tt
                              | _ => None
                              end
                            with
                            | Some _ =>
                                match
                                  s0 as t2
                                  return
                                    (Compile.value' false t2 ->
                                     UnderLets.UnderLets base.type ident var
                                       (expr
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)))
                                with
                                | type.base t2 =>
                                    fun v : expr (type.base t2) =>
                                    base.try_make_transport_cps
                                      (fun t1 : base.type =>
                                       expr (type.base t1)) t2 base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (expr
                                            (type.base
                                               (base.type.Z * base.type.Z)%etype)))
                                      (fun
                                         a : option
                                               (expr (type.base t2) ->
                                                expr (type.base base.type.Z))
                                       =>
                                       match a with
                                       | Some x' =>
                                           UnderLets.UnderLet
                                             (#(ident.Z_sub_get_borrow_concrete
                                                  args)%expr @ x0 @ x' v)%expr_pat
                                             (fun
                                                v0 : var
                                                       (type.base
                                                          (base.type.Z *
                                                           base.type.Z)%etype)
                                              =>
                                              UnderLets.Base
                                                (#(ident.fst)%expr @
                                                 ($v0)%expr,
                                                (-
                                                 (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                       | None =>
                                           UnderLets.Base
                                             (#(ident.Z_add_get_carry)%expr @
                                              x @ x0 @ x1)%expr_pat
                                       end)
                                | (s2 -> d2)%ptype =>
                                    fun
                                      _ : Compile.value' false s2 ->
                                          Compile.value' true d2 =>
                                    UnderLets.Base
                                      (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                       x1)%expr_pat
                                end (Compile.reflect x3)
                            | None =>
                                UnderLets.Base
                                  (#(ident.Z_add_get_carry_concrete args)%expr @
                                   x0 @ x1)%expr_pat
                            end
                        | _ =>
                            UnderLets.Base
                              (#(ident.Z_add_get_carry_concrete args)%expr @
                               x0 @ x1)%expr_pat
                        end
                    end
                | @expr.LetIn _ _ _ _ _ _ _ =>
                    match f with
                    | #(idc0)%expr_pat =>
                        match
                          match idc0 with
                          | ident.Z_opp => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match
                              s as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (expr
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)))
                            with
                            | type.base t2 =>
                                fun v : expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t1 : base.type => expr (type.base t1))
                                  t2 base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (expr
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)))
                                  (fun
                                     a : option
                                           (expr (type.base t2) ->
                                            expr (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       UnderLets.UnderLet
                                         (#(ident.Z_sub_get_borrow_concrete
                                              args)%expr @ x1 @ x' v)%expr_pat
                                         (fun
                                            v0 : var
                                                   (type.base
                                                      (base.type.Z *
                                                       base.type.Z)%etype) =>
                                          UnderLets.Base
                                            (#(ident.fst)%expr @ ($v0)%expr,
                                            (-
                                             (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                   | None =>
                                       UnderLets.Base
                                         (#(ident.Z_add_get_carry)%expr @ x @
                                          x0 @ x1)%expr_pat
                                   end)
                            | (s0 -> d0)%ptype =>
                                fun
                                  _ : Compile.value' false s0 ->
                                      Compile.value' true d0 =>
                                UnderLets.Base
                                  (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                   x1)%expr_pat
                            end (Compile.reflect x2)
                        | None =>
                            UnderLets.Base
                              (#(ident.Z_add_get_carry_concrete args)%expr @
                               x0 @ x1)%expr_pat
                        end
                    | _ =>
                        UnderLets.Base
                          (#(ident.Z_add_get_carry_concrete args)%expr @ x0 @
                           x1)%expr_pat
                    end
                end
            | @expr.LetIn _ _ _ _ _ _ _ =>
                match x1 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t1 v =>
                          match
                            t1 as t2 return (base.base_interp t2 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v0 : Z => Some v0
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        if args0 =? 0
                        then UnderLets.Base (x0, ##(0)%expr)%expr_pat
                        else
                         UnderLets.Base
                           (#(ident.Z_add_get_carry_concrete args)%expr @ x0 @
                            x1)%expr_pat
                    | None =>
                        UnderLets.Base
                          (#(ident.Z_add_get_carry_concrete args)%expr @ x0 @
                           x1)%expr_pat
                    end
                | @expr.App _ _ _ s _ #(idc0)%expr_pat x3 =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type => expr (type.base t1)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   UnderLets.UnderLet
                                     (#(ident.Z_sub_get_borrow_concrete args)%expr @
                                      x0 @ x' v)%expr_pat
                                     (fun
                                        v0 : var
                                               (type.base
                                                  (base.type.Z * base.type.Z)%etype)
                                      =>
                                      UnderLets.Base
                                        (#(ident.fst)%expr @ ($v0)%expr,
                                        (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                      x1)%expr_pat
                               end)
                        | (s0 -> d0)%ptype =>
                            fun
                              _ : Compile.value' false s0 ->
                                  Compile.value' true d0 =>
                            UnderLets.Base
                              (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                        end (Compile.reflect x3)
                    | None =>
                        UnderLets.Base
                          (#(ident.Z_add_get_carry_concrete args)%expr @ x0 @
                           x1)%expr_pat
                    end
                | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
                  (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _
                  (_ @ _)%expr_pat _ | @expr.App _ _ _ s _
                  (@expr.LetIn _ _ _ _ _ _ _) _ =>
                    UnderLets.Base
                      (#(ident.Z_add_get_carry_concrete args)%expr @ x0 @ x1)%expr_pat
                | _ =>
                    UnderLets.Base
                      (#(ident.Z_add_get_carry_concrete args)%expr @ x0 @ x1)%expr_pat
                end
            end
        | None =>
            UnderLets.Base
              (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
        end
    | _ =>
        UnderLets.Base (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
    end
| ident.Z_add_get_carry_concrete s =>
    fun x x0 : expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 =>
                    UnderLets.Base
                      (let
                       '(a, b) :=
                        Definitions.Z.add_get_carry_full s args args0 in
                        (##(a)%expr, ##(b)%expr)%expr_pat)
                | None =>
                    if args <=? 0
                    then
                     UnderLets.UnderLet
                       (#(ident.Z_sub_get_borrow_concrete s)%expr @ x0 @
                        ##((- args)%Z)%expr)%expr_pat
                       (fun
                          v : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v)%expr,
                          (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
                    else
                     if args =? 0
                     then UnderLets.Base (x0, ##(0)%expr)%expr_pat
                     else
                      UnderLets.Base
                        (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                end
            | ($_)%expr =>
                if args <=? 0
                then
                 UnderLets.UnderLet
                   (#(ident.Z_sub_get_borrow_concrete s)%expr @ x0 @
                    ##((- args)%Z)%expr)%expr_pat
                   (fun
                      v0 : var (type.base (base.type.Z * base.type.Z)%etype)
                    =>
                    UnderLets.Base
                      (#(ident.fst)%expr @ ($v0)%expr,
                      (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                else
                 if args =? 0
                 then UnderLets.Base (x0, ##(0)%expr)%expr_pat
                 else
                  UnderLets.Base
                    (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
            | @expr.App _ _ _ s0 _ #(idc0)%expr_pat x1 =>
                match
                  match idc0 with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => expr (type.base t1)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               UnderLets.UnderLet
                                 (#(ident.Z_sub_get_borrow_concrete s)%expr @
                                  x @ x' v)%expr_pat
                                 (fun
                                    v0 : var
                                           (type.base
                                              (base.type.Z * base.type.Z)%etype)
                                  =>
                                  UnderLets.Base
                                    (#(ident.fst)%expr @ ($v0)%expr,
                                    (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_add_get_carry_concrete s)%expr @
                                  x @ x0)%expr_pat
                           end)
                    | (s1 -> d0)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d0 =>
                        UnderLets.Base
                          (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                    end (Compile.reflect x1)
                | None =>
                    if args <=? 0
                    then
                     UnderLets.UnderLet
                       (#(ident.Z_sub_get_borrow_concrete s)%expr @ x0 @
                        ##((- args)%Z)%expr)%expr_pat
                       (fun
                          v : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v)%expr,
                          (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
                    else
                     if args =? 0
                     then UnderLets.Base (x0, ##(0)%expr)%expr_pat
                     else
                      UnderLets.Base
                        (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                end
            | @expr.App _ _ _ s0 _ ($_)%expr _ =>
                if args <=? 0
                then
                 UnderLets.UnderLet
                   (#(ident.Z_sub_get_borrow_concrete s)%expr @ x0 @
                    ##((- args)%Z)%expr)%expr_pat
                   (fun
                      v0 : var (type.base (base.type.Z * base.type.Z)%etype)
                    =>
                    UnderLets.Base
                      (#(ident.fst)%expr @ ($v0)%expr,
                      (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                else
                 if args =? 0
                 then UnderLets.Base (x0, ##(0)%expr)%expr_pat
                 else
                  UnderLets.Base
                    (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
            | @expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _
              _ s0 _ (_ @ _)%expr_pat _ | @expr.App _ _ _ s0 _
              (@expr.LetIn _ _ _ _ _ _ _) _ =>
                if args <=? 0
                then
                 UnderLets.UnderLet
                   (#(ident.Z_sub_get_borrow_concrete s)%expr @ x0 @
                    ##((- args)%Z)%expr)%expr_pat
                   (fun v : var (type.base (base.type.Z * base.type.Z)%etype)
                    =>
                    UnderLets.Base
                      (#(ident.fst)%expr @ ($v)%expr,
                      (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
                else
                 if args =? 0
                 then UnderLets.Base (x0, ##(0)%expr)%expr_pat
                 else
                  UnderLets.Base
                    (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
            | _ =>
                if args <=? 0
                then
                 UnderLets.UnderLet
                   (#(ident.Z_sub_get_borrow_concrete s)%expr @ x0 @
                    ##((- args)%Z)%expr)%expr_pat
                   (fun v : var (type.base (base.type.Z * base.type.Z)%etype)
                    =>
                    UnderLets.Base
                      (#(ident.fst)%expr @ ($v)%expr,
                      (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
                else
                 if args =? 0
                 then UnderLets.Base (x0, ##(0)%expr)%expr_pat
                 else
                  UnderLets.Base
                    (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
            end
        | None =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args =>
                    if args <=? 0
                    then
                     UnderLets.UnderLet
                       (#(ident.Z_sub_get_borrow_concrete s)%expr @ x @
                        ##((- args)%Z)%expr)%expr_pat
                       (fun
                          v : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v)%expr,
                          (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
                    else
                     if args =? 0
                     then UnderLets.Base (x, ##(0)%expr)%expr_pat
                     else
                      UnderLets.Base
                        (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                | None =>
                    UnderLets.Base
                      (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                end
            | @expr.App _ _ _ s0 _ #(idc0)%expr_pat x1 =>
                match
                  match idc0 with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => expr (type.base t1)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               UnderLets.UnderLet
                                 (#(ident.Z_sub_get_borrow_concrete s)%expr @
                                  x @ x' v)%expr_pat
                                 (fun
                                    v0 : var
                                           (type.base
                                              (base.type.Z * base.type.Z)%etype)
                                  =>
                                  UnderLets.Base
                                    (#(ident.fst)%expr @ ($v0)%expr,
                                    (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_add_get_carry_concrete s)%expr @
                                  x @ x0)%expr_pat
                           end)
                    | (s1 -> d0)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d0 =>
                        UnderLets.Base
                          (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                    end (Compile.reflect x1)
                | None =>
                    UnderLets.Base
                      (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                end
            | @expr.App _ _ _ s0 _ ($_)%expr _ | @expr.App _ _ _ s0 _
              (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0 _
              (_ @ _)%expr_pat _ | @expr.App _ _ _ s0 _
              (@expr.LetIn _ _ _ _ _ _ _) _ =>
                UnderLets.Base
                  (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
            | _ =>
                UnderLets.Base
                  (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
            end
        end
    | ($_)%expr =>
        match x0 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t1 v0 =>
                  match
                    t1 as t2 return (base.base_interp t2 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v1 : Z => Some v1
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v0
              | _ => None
              end
            with
            | Some args =>
                if args <=? 0
                then
                 UnderLets.UnderLet
                   (#(ident.Z_sub_get_borrow_concrete s)%expr @ x @
                    ##((- args)%Z)%expr)%expr_pat
                   (fun
                      v0 : var (type.base (base.type.Z * base.type.Z)%etype)
                    =>
                    UnderLets.Base
                      (#(ident.fst)%expr @ ($v0)%expr,
                      (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                else
                 if args =? 0
                 then UnderLets.Base (x, ##(0)%expr)%expr_pat
                 else
                  UnderLets.Base
                    (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
            | None =>
                UnderLets.Base
                  (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
            end
        | @expr.App _ _ _ s0 _ #(idc)%expr_pat x1 =>
            match
              match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end
            with
            | Some _ =>
                match
                  s0 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base (base.type.Z * base.type.Z)%etype)))
                with
                | type.base t2 =>
                    fun v0 : expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t1 : base.type => expr (type.base t1)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base (base.type.Z * base.type.Z)%etype)))
                      (fun
                         a : option
                               (expr (type.base t2) ->
                                expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' =>
                           UnderLets.UnderLet
                             (#(ident.Z_sub_get_borrow_concrete s)%expr @ x @
                              x' v0)%expr_pat
                             (fun
                                v1 : var
                                       (type.base
                                          (base.type.Z * base.type.Z)%etype)
                              =>
                              UnderLets.Base
                                (#(ident.fst)%expr @ ($v1)%expr,
                                (- (#(ident.snd)%expr @ $v1)%expr_pat)%expr)%expr_pat)
                       | None =>
                           UnderLets.Base
                             (#(ident.Z_add_get_carry_concrete s)%expr @ x @
                              x0)%expr_pat
                       end)
                | (s1 -> d0)%ptype =>
                    fun _ : Compile.value' false s1 -> Compile.value' true d0
                    =>
                    UnderLets.Base
                      (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                end (Compile.reflect x1)
            | None =>
                UnderLets.Base
                  (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
            end
        | @expr.App _ _ _ s0 _ ($_)%expr _ | @expr.App _ _ _ s0 _
          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0 _ (_ @ _)%expr_pat
          _ | @expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            UnderLets.Base
              (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
        | _ =>
            UnderLets.Base
              (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
        end
    | @expr.Abs _ _ _ _ _ _ =>
        match x0 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t0 v =>
                  match
                    t0 as t1 return (base.base_interp t1 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v0 : Z => Some v0
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v
              | _ => None
              end
            with
            | Some args =>
                if args <=? 0
                then
                 UnderLets.UnderLet
                   (#(ident.Z_sub_get_borrow_concrete s)%expr @ x @
                    ##((- args)%Z)%expr)%expr_pat
                   (fun v : var (type.base (base.type.Z * base.type.Z)%etype)
                    =>
                    UnderLets.Base
                      (#(ident.fst)%expr @ ($v)%expr,
                      (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
                else
                 if args =? 0
                 then UnderLets.Base (x, ##(0)%expr)%expr_pat
                 else
                  UnderLets.Base
                    (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
            | None =>
                UnderLets.Base
                  (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
            end
        | @expr.App _ _ _ s1 _ #(idc)%expr_pat x1 =>
            match
              match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end
            with
            | Some _ =>
                match
                  s1 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base (base.type.Z * base.type.Z)%etype)))
                with
                | type.base t2 =>
                    fun v : expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => expr (type.base t0)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base (base.type.Z * base.type.Z)%etype)))
                      (fun
                         a : option
                               (expr (type.base t2) ->
                                expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' =>
                           UnderLets.UnderLet
                             (#(ident.Z_sub_get_borrow_concrete s)%expr @ x @
                              x' v)%expr_pat
                             (fun
                                v0 : var
                                       (type.base
                                          (base.type.Z * base.type.Z)%etype)
                              =>
                              UnderLets.Base
                                (#(ident.fst)%expr @ ($v0)%expr,
                                (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                       | None =>
                           UnderLets.Base
                             (#(ident.Z_add_get_carry_concrete s)%expr @ x @
                              x0)%expr_pat
                       end)
                | (s2 -> d1)%ptype =>
                    fun _ : Compile.value' false s2 -> Compile.value' true d1
                    =>
                    UnderLets.Base
                      (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                end (Compile.reflect x1)
            | None =>
                UnderLets.Base
                  (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
            end
        | @expr.App _ _ _ s1 _ ($_)%expr _ | @expr.App _ _ _ s1 _
          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s1 _ (_ @ _)%expr_pat
          _ | @expr.App _ _ _ s1 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            UnderLets.Base
              (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
        | _ =>
            UnderLets.Base
              (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
        end
    | @expr.App _ _ _ s0 _ #(idc)%expr_pat x1 =>
        match match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end with
        | Some _ =>
            match
              s0 as t2
              return
                (Compile.value' false t2 ->
                 UnderLets.UnderLets base.type ident var
                   (expr (type.base (base.type.Z * base.type.Z)%etype)))
            with
            | type.base t2 =>
                fun v : expr (type.base t2) =>
                base.try_make_transport_cps
                  (fun t0 : base.type => expr (type.base t0)) t2 base.type.Z
                  (UnderLets.UnderLets base.type ident var
                     (expr (type.base (base.type.Z * base.type.Z)%etype)))
                  (fun
                     a : option
                           (expr (type.base t2) ->
                            expr (type.base base.type.Z)) =>
                   match a with
                   | Some x' =>
                       UnderLets.UnderLet
                         (#(ident.Z_sub_get_borrow_concrete s)%expr @ x0 @
                          x' v)%expr_pat
                         (fun
                            v0 : var
                                   (type.base
                                      (base.type.Z * base.type.Z)%etype) =>
                          UnderLets.Base
                            (#(ident.fst)%expr @ ($v0)%expr,
                            (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                   | None =>
                       UnderLets.Base
                         (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                   end)
            | (s1 -> d0)%ptype =>
                fun _ : Compile.value' false s1 -> Compile.value' true d0 =>
                UnderLets.Base
                  (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
            end (Compile.reflect x1)
        | None =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args =>
                    if args <=? 0
                    then
                     UnderLets.UnderLet
                       (#(ident.Z_sub_get_borrow_concrete s)%expr @ x @
                        ##((- args)%Z)%expr)%expr_pat
                       (fun
                          v : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v)%expr,
                          (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
                    else
                     if args =? 0
                     then UnderLets.Base (x, ##(0)%expr)%expr_pat
                     else
                      UnderLets.Base
                        (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                | None =>
                    UnderLets.Base
                      (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                end
            | @expr.App _ _ _ s1 _ #(idc0)%expr_pat x2 =>
                match
                  match idc0 with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s1 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => expr (type.base t1)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               UnderLets.UnderLet
                                 (#(ident.Z_sub_get_borrow_concrete s)%expr @
                                  x @ x' v)%expr_pat
                                 (fun
                                    v0 : var
                                           (type.base
                                              (base.type.Z * base.type.Z)%etype)
                                  =>
                                  UnderLets.Base
                                    (#(ident.fst)%expr @ ($v0)%expr,
                                    (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_add_get_carry_concrete s)%expr @
                                  x @ x0)%expr_pat
                           end)
                    | (s2 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s2 ->
                              Compile.value' true d1 =>
                        UnderLets.Base
                          (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                    end (Compile.reflect x2)
                | None =>
                    UnderLets.Base
                      (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                end
            | @expr.App _ _ _ s1 _ ($_)%expr _ | @expr.App _ _ _ s1 _
              (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s1 _
              (_ @ _)%expr_pat _ | @expr.App _ _ _ s1 _
              (@expr.LetIn _ _ _ _ _ _ _) _ =>
                UnderLets.Base
                  (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
            | _ =>
                UnderLets.Base
                  (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
            end
        end
    | @expr.App _ _ _ s0 _ ($_)%expr _ =>
        match x0 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t1 v0 =>
                  match
                    t1 as t2 return (base.base_interp t2 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v1 : Z => Some v1
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v0
              | _ => None
              end
            with
            | Some args =>
                if args <=? 0
                then
                 UnderLets.UnderLet
                   (#(ident.Z_sub_get_borrow_concrete s)%expr @ x @
                    ##((- args)%Z)%expr)%expr_pat
                   (fun
                      v0 : var (type.base (base.type.Z * base.type.Z)%etype)
                    =>
                    UnderLets.Base
                      (#(ident.fst)%expr @ ($v0)%expr,
                      (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                else
                 if args =? 0
                 then UnderLets.Base (x, ##(0)%expr)%expr_pat
                 else
                  UnderLets.Base
                    (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
            | None =>
                UnderLets.Base
                  (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
            end
        | @expr.App _ _ _ s1 _ #(idc)%expr_pat x2 =>
            match
              match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end
            with
            | Some _ =>
                match
                  s1 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base (base.type.Z * base.type.Z)%etype)))
                with
                | type.base t2 =>
                    fun v0 : expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t1 : base.type => expr (type.base t1)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base (base.type.Z * base.type.Z)%etype)))
                      (fun
                         a : option
                               (expr (type.base t2) ->
                                expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' =>
                           UnderLets.UnderLet
                             (#(ident.Z_sub_get_borrow_concrete s)%expr @ x @
                              x' v0)%expr_pat
                             (fun
                                v1 : var
                                       (type.base
                                          (base.type.Z * base.type.Z)%etype)
                              =>
                              UnderLets.Base
                                (#(ident.fst)%expr @ ($v1)%expr,
                                (- (#(ident.snd)%expr @ $v1)%expr_pat)%expr)%expr_pat)
                       | None =>
                           UnderLets.Base
                             (#(ident.Z_add_get_carry_concrete s)%expr @ x @
                              x0)%expr_pat
                       end)
                | (s2 -> d1)%ptype =>
                    fun _ : Compile.value' false s2 -> Compile.value' true d1
                    =>
                    UnderLets.Base
                      (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                end (Compile.reflect x2)
            | None =>
                UnderLets.Base
                  (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
            end
        | @expr.App _ _ _ s1 _ ($_)%expr _ | @expr.App _ _ _ s1 _
          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s1 _ (_ @ _)%expr_pat
          _ | @expr.App _ _ _ s1 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            UnderLets.Base
              (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
        | _ =>
            UnderLets.Base
              (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
        end
    | @expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ =>
        match x0 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t0 v =>
                  match
                    t0 as t1 return (base.base_interp t1 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v0 : Z => Some v0
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v
              | _ => None
              end
            with
            | Some args =>
                if args <=? 0
                then
                 UnderLets.UnderLet
                   (#(ident.Z_sub_get_borrow_concrete s)%expr @ x @
                    ##((- args)%Z)%expr)%expr_pat
                   (fun v : var (type.base (base.type.Z * base.type.Z)%etype)
                    =>
                    UnderLets.Base
                      (#(ident.fst)%expr @ ($v)%expr,
                      (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
                else
                 if args =? 0
                 then UnderLets.Base (x, ##(0)%expr)%expr_pat
                 else
                  UnderLets.Base
                    (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
            | None =>
                UnderLets.Base
                  (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
            end
        | @expr.App _ _ _ s2 _ #(idc)%expr_pat x2 =>
            match
              match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end
            with
            | Some _ =>
                match
                  s2 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base (base.type.Z * base.type.Z)%etype)))
                with
                | type.base t2 =>
                    fun v : expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => expr (type.base t0)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base (base.type.Z * base.type.Z)%etype)))
                      (fun
                         a : option
                               (expr (type.base t2) ->
                                expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' =>
                           UnderLets.UnderLet
                             (#(ident.Z_sub_get_borrow_concrete s)%expr @ x @
                              x' v)%expr_pat
                             (fun
                                v0 : var
                                       (type.base
                                          (base.type.Z * base.type.Z)%etype)
                              =>
                              UnderLets.Base
                                (#(ident.fst)%expr @ ($v0)%expr,
                                (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                       | None =>
                           UnderLets.Base
                             (#(ident.Z_add_get_carry_concrete s)%expr @ x @
                              x0)%expr_pat
                       end)
                | (s3 -> d2)%ptype =>
                    fun _ : Compile.value' false s3 -> Compile.value' true d2
                    =>
                    UnderLets.Base
                      (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                end (Compile.reflect x2)
            | None =>
                UnderLets.Base
                  (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
            end
        | @expr.App _ _ _ s2 _ ($_)%expr _ | @expr.App _ _ _ s2 _
          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s2 _ (_ @ _)%expr_pat
          _ | @expr.App _ _ _ s2 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            UnderLets.Base
              (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
        | _ =>
            UnderLets.Base
              (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
        end
    | @expr.App _ _ _ s0 _ (_ @ _)%expr_pat _ =>
        match x0 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t0 v =>
                  match
                    t0 as t1 return (base.base_interp t1 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v0 : Z => Some v0
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v
              | _ => None
              end
            with
            | Some args =>
                if args <=? 0
                then
                 UnderLets.UnderLet
                   (#(ident.Z_sub_get_borrow_concrete s)%expr @ x @
                    ##((- args)%Z)%expr)%expr_pat
                   (fun v : var (type.base (base.type.Z * base.type.Z)%etype)
                    =>
                    UnderLets.Base
                      (#(ident.fst)%expr @ ($v)%expr,
                      (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
                else
                 if args =? 0
                 then UnderLets.Base (x, ##(0)%expr)%expr_pat
                 else
                  UnderLets.Base
                    (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
            | None =>
                UnderLets.Base
                  (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
            end
        | @expr.App _ _ _ s2 _ #(idc)%expr_pat x3 =>
            match
              match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end
            with
            | Some _ =>
                match
                  s2 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base (base.type.Z * base.type.Z)%etype)))
                with
                | type.base t2 =>
                    fun v : expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => expr (type.base t0)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base (base.type.Z * base.type.Z)%etype)))
                      (fun
                         a : option
                               (expr (type.base t2) ->
                                expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' =>
                           UnderLets.UnderLet
                             (#(ident.Z_sub_get_borrow_concrete s)%expr @ x @
                              x' v)%expr_pat
                             (fun
                                v0 : var
                                       (type.base
                                          (base.type.Z * base.type.Z)%etype)
                              =>
                              UnderLets.Base
                                (#(ident.fst)%expr @ ($v0)%expr,
                                (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                       | None =>
                           UnderLets.Base
                             (#(ident.Z_add_get_carry_concrete s)%expr @ x @
                              x0)%expr_pat
                       end)
                | (s3 -> d2)%ptype =>
                    fun _ : Compile.value' false s3 -> Compile.value' true d2
                    =>
                    UnderLets.Base
                      (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                end (Compile.reflect x3)
            | None =>
                UnderLets.Base
                  (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
            end
        | @expr.App _ _ _ s2 _ ($_)%expr _ | @expr.App _ _ _ s2 _
          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s2 _ (_ @ _)%expr_pat
          _ | @expr.App _ _ _ s2 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            UnderLets.Base
              (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
        | _ =>
            UnderLets.Base
              (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
        end
    | @expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
        match x0 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t0 v =>
                  match
                    t0 as t1 return (base.base_interp t1 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v0 : Z => Some v0
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v
              | _ => None
              end
            with
            | Some args =>
                if args <=? 0
                then
                 UnderLets.UnderLet
                   (#(ident.Z_sub_get_borrow_concrete s)%expr @ x @
                    ##((- args)%Z)%expr)%expr_pat
                   (fun v : var (type.base (base.type.Z * base.type.Z)%etype)
                    =>
                    UnderLets.Base
                      (#(ident.fst)%expr @ ($v)%expr,
                      (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
                else
                 if args =? 0
                 then UnderLets.Base (x, ##(0)%expr)%expr_pat
                 else
                  UnderLets.Base
                    (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
            | None =>
                UnderLets.Base
                  (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
            end
        | @expr.App _ _ _ s1 _ #(idc)%expr_pat x3 =>
            match
              match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end
            with
            | Some _ =>
                match
                  s1 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base (base.type.Z * base.type.Z)%etype)))
                with
                | type.base t2 =>
                    fun v : expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => expr (type.base t0)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base (base.type.Z * base.type.Z)%etype)))
                      (fun
                         a : option
                               (expr (type.base t2) ->
                                expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' =>
                           UnderLets.UnderLet
                             (#(ident.Z_sub_get_borrow_concrete s)%expr @ x @
                              x' v)%expr_pat
                             (fun
                                v0 : var
                                       (type.base
                                          (base.type.Z * base.type.Z)%etype)
                              =>
                              UnderLets.Base
                                (#(ident.fst)%expr @ ($v0)%expr,
                                (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                       | None =>
                           UnderLets.Base
                             (#(ident.Z_add_get_carry_concrete s)%expr @ x @
                              x0)%expr_pat
                       end)
                | (s2 -> d1)%ptype =>
                    fun _ : Compile.value' false s2 -> Compile.value' true d1
                    =>
                    UnderLets.Base
                      (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                end (Compile.reflect x3)
            | None =>
                UnderLets.Base
                  (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
            end
        | @expr.App _ _ _ s1 _ ($_)%expr _ | @expr.App _ _ _ s1 _
          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s1 _ (_ @ _)%expr_pat
          _ | @expr.App _ _ _ s1 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            UnderLets.Base
              (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
        | _ =>
            UnderLets.Base
              (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
        end
    | @expr.LetIn _ _ _ _ _ _ _ =>
        match x0 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t0 v =>
                  match
                    t0 as t1 return (base.base_interp t1 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v0 : Z => Some v0
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v
              | _ => None
              end
            with
            | Some args =>
                if args <=? 0
                then
                 UnderLets.UnderLet
                   (#(ident.Z_sub_get_borrow_concrete s)%expr @ x @
                    ##((- args)%Z)%expr)%expr_pat
                   (fun v : var (type.base (base.type.Z * base.type.Z)%etype)
                    =>
                    UnderLets.Base
                      (#(ident.fst)%expr @ ($v)%expr,
                      (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
                else
                 if args =? 0
                 then UnderLets.Base (x, ##(0)%expr)%expr_pat
                 else
                  UnderLets.Base
                    (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
            | None =>
                UnderLets.Base
                  (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
            end
        | @expr.App _ _ _ s0 _ #(idc)%expr_pat x2 =>
            match
              match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end
            with
            | Some _ =>
                match
                  s0 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base (base.type.Z * base.type.Z)%etype)))
                with
                | type.base t2 =>
                    fun v : expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => expr (type.base t0)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base (base.type.Z * base.type.Z)%etype)))
                      (fun
                         a : option
                               (expr (type.base t2) ->
                                expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' =>
                           UnderLets.UnderLet
                             (#(ident.Z_sub_get_borrow_concrete s)%expr @ x @
                              x' v)%expr_pat
                             (fun
                                v0 : var
                                       (type.base
                                          (base.type.Z * base.type.Z)%etype)
                              =>
                              UnderLets.Base
                                (#(ident.fst)%expr @ ($v0)%expr,
                                (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                       | None =>
                           UnderLets.Base
                             (#(ident.Z_add_get_carry_concrete s)%expr @ x @
                              x0)%expr_pat
                       end)
                | (s1 -> d0)%ptype =>
                    fun _ : Compile.value' false s1 -> Compile.value' true d0
                    =>
                    UnderLets.Base
                      (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                end (Compile.reflect x2)
            | None =>
                UnderLets.Base
                  (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
            end
        | @expr.App _ _ _ s0 _ ($_)%expr _ | @expr.App _ _ _ s0 _
          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0 _ (_ @ _)%expr_pat
          _ | @expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            UnderLets.Base
              (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
        | _ =>
            UnderLets.Base
              (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
        end
    end
| ident.Z_add_with_carry =>
    fun x x0 x1 : expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 =>
                    match x1 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args1 =>
                            UnderLets.Base
                              ##(Definitions.Z.add_with_carry args args0
                                   args1)%expr
                        | None =>
                            if args =? 0
                            then UnderLets.Base (x0 + x1)%expr
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_carry)%expr @ x @ x0 @ x1)%expr_pat
                        end
                    | _ =>
                        if args =? 0
                        then UnderLets.Base (x0 + x1)%expr
                        else
                         UnderLets.Base
                           (#(ident.Z_add_with_carry)%expr @ x @ x0 @ x1)%expr_pat
                    end
                | None =>
                    if args =? 0
                    then UnderLets.Base (x0 + x1)%expr
                    else
                     UnderLets.Base
                       (#(ident.Z_add_with_carry)%expr @ x @ x0 @ x1)%expr_pat
                end
            | _ =>
                if args =? 0
                then UnderLets.Base (x0 + x1)%expr
                else
                 UnderLets.Base
                   (#(ident.Z_add_with_carry)%expr @ x @ x0 @ x1)%expr_pat
            end
        | None =>
            UnderLets.Base
              (#(ident.Z_add_with_carry)%expr @ x @ x0 @ x1)%expr_pat
        end
    | _ =>
        UnderLets.Base
          (#(ident.Z_add_with_carry)%expr @ x @ x0 @ x1)%expr_pat
    end
| ident.Z_add_with_get_carry =>
    fun x x0 x1 x2 : expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 =>
                    match x1 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args1 =>
                            match x2 with
                            | #(idc2)%expr_pat =>
                                match
                                  match idc2 with
                                  | @ident.Literal t3 v =>
                                      match
                                        t3 as t4
                                        return
                                          (base.base_interp t4 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args2 =>
                                    UnderLets.Base
                                      (let
                                       '(a, b) :=
                                        Definitions.Z.add_with_get_carry_full
                                          args args0 args1 args2 in
                                        (##(a)%expr, ##(b)%expr)%expr_pat)
                                | None =>
                                    if (args0 =? 0) && (args1 =? 0)
                                    then
                                     UnderLets.Base (x2, ##(0)%expr)%expr_pat
                                    else
                                     if args0 =? 0
                                     then
                                      UnderLets.Base
                                        (#(ident.Z_add_get_carry_concrete
                                             args)%expr @ x1 @ x2)%expr_pat
                                     else
                                      UnderLets.Base
                                        (#(ident.Z_add_with_get_carry_concrete
                                             args)%expr @ x0 @ x1 @ x2)%expr_pat
                                end
                            | _ =>
                                if (args0 =? 0) && (args1 =? 0)
                                then UnderLets.Base (x2, ##(0)%expr)%expr_pat
                                else
                                 if args0 =? 0
                                 then
                                  UnderLets.Base
                                    (#(ident.Z_add_get_carry_concrete args)%expr @
                                     x1 @ x2)%expr_pat
                                 else
                                  UnderLets.Base
                                    (#(ident.Z_add_with_get_carry_concrete
                                         args)%expr @ x0 @ x1 @ x2)%expr_pat
                            end
                        | None =>
                            match x2 with
                            | #(idc2)%expr_pat =>
                                match
                                  match idc2 with
                                  | @ident.Literal t3 v =>
                                      match
                                        t3 as t4
                                        return
                                          (base.base_interp t4 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    if (args0 =? 0) && (args1 =? 0)
                                    then
                                     UnderLets.Base (x1, ##(0)%expr)%expr_pat
                                    else
                                     if args0 =? 0
                                     then
                                      UnderLets.Base
                                        (#(ident.Z_add_get_carry_concrete
                                             args)%expr @ x1 @ x2)%expr_pat
                                     else
                                      UnderLets.Base
                                        (#(ident.Z_add_with_get_carry_concrete
                                             args)%expr @ x0 @ x1 @ x2)%expr_pat
                                | None =>
                                    if args0 =? 0
                                    then
                                     UnderLets.Base
                                       (#(ident.Z_add_get_carry_concrete args)%expr @
                                        x1 @ x2)%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_with_get_carry_concrete
                                            args)%expr @ x0 @ x1 @ x2)%expr_pat
                                end
                            | _ =>
                                if args0 =? 0
                                then
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry_concrete args)%expr @
                                    x1 @ x2)%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry_concrete
                                        args)%expr @ x0 @ x1 @ x2)%expr_pat
                            end
                        end
                    | ($_)%expr =>
                        match x2 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t3 v0 =>
                                  match
                                    t3 as t4
                                    return (base.base_interp t4 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v1 : Z => Some v1
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v0
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                if (args0 =? 0) && (args1 =? 0)
                                then UnderLets.Base (x1, ##(0)%expr)%expr_pat
                                else
                                 if args0 =? 0
                                 then
                                  UnderLets.Base
                                    (#(ident.Z_add_get_carry_concrete args)%expr @
                                     x1 @ x2)%expr_pat
                                 else
                                  UnderLets.Base
                                    (#(ident.Z_add_with_get_carry_concrete
                                         args)%expr @ x0 @ x1 @ x2)%expr_pat
                            | None =>
                                if args0 =? 0
                                then
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry_concrete args)%expr @
                                    x1 @ x2)%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry_concrete
                                        args)%expr @ x0 @ x1 @ x2)%expr_pat
                            end
                        | _ =>
                            if args0 =? 0
                            then
                             UnderLets.Base
                               (#(ident.Z_add_get_carry_concrete args)%expr @
                                x1 @ x2)%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry_concrete args)%expr @
                                x0 @ x1 @ x2)%expr_pat
                        end
                    | _ =>
                        match x2 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t2 v =>
                                  match
                                    t2 as t3
                                    return (base.base_interp t3 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v0 : Z => Some v0
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                if (args0 =? 0) && (args1 =? 0)
                                then UnderLets.Base (x1, ##(0)%expr)%expr_pat
                                else
                                 if args0 =? 0
                                 then
                                  UnderLets.Base
                                    (#(ident.Z_add_get_carry_concrete args)%expr @
                                     x1 @ x2)%expr_pat
                                 else
                                  UnderLets.Base
                                    (#(ident.Z_add_with_get_carry_concrete
                                         args)%expr @ x0 @ x1 @ x2)%expr_pat
                            | None =>
                                if args0 =? 0
                                then
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry_concrete args)%expr @
                                    x1 @ x2)%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry_concrete
                                        args)%expr @ x0 @ x1 @ x2)%expr_pat
                            end
                        | _ =>
                            if args0 =? 0
                            then
                             UnderLets.Base
                               (#(ident.Z_add_get_carry_concrete args)%expr @
                                x1 @ x2)%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry_concrete args)%expr @
                                x0 @ x1 @ x2)%expr_pat
                        end
                    end
                | None =>
                    match x1 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args0 =>
                            match x2 with
                            | #(idc2)%expr_pat =>
                                match
                                  match idc2 with
                                  | @ident.Literal t3 v =>
                                      match
                                        t3 as t4
                                        return
                                          (base.base_interp t4 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    if (args0 =? 0) && (args1 =? 0)
                                    then
                                     UnderLets.Base
                                       (#(ident.Z_add_with_get_carry_concrete
                                            args)%expr @ x0 @ x1 @ x2)%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_with_get_carry_concrete
                                            args)%expr @ x0 @ x1 @ x2)%expr_pat
                                | None =>
                                    UnderLets.Base
                                      (#(ident.Z_add_with_get_carry_concrete
                                           args)%expr @ x0 @ x1 @ x2)%expr_pat
                                end
                            | _ =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry_concrete args)%expr @
                                   x0 @ x1 @ x2)%expr_pat
                            end
                        | None =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete args)%expr @
                               x0 @ x1 @ x2)%expr_pat
                        end
                    | _ =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete args)%expr @
                           x0 @ x1 @ x2)%expr_pat
                    end
                end
            | ($_)%expr =>
                match x1 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t2 v0 =>
                          match
                            t2 as t3 return (base.base_interp t3 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v1 : Z => Some v1
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v0
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        match x2 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t3 v0 =>
                                  match
                                    t3 as t4
                                    return (base.base_interp t4 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v1 : Z => Some v1
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v0
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                if (args0 =? 0) && (args1 =? 0)
                                then
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry_concrete
                                        args)%expr @ x0 @ x1 @ x2)%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry_concrete
                                        args)%expr @ x0 @ x1 @ x2)%expr_pat
                            | None =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry_concrete args)%expr @
                                   x0 @ x1 @ x2)%expr_pat
                            end
                        | _ =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete args)%expr @
                               x0 @ x1 @ x2)%expr_pat
                        end
                    | None =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete args)%expr @
                           x0 @ x1 @ x2)%expr_pat
                    end
                | _ =>
                    UnderLets.Base
                      (#(ident.Z_add_with_get_carry_concrete args)%expr @ x0 @
                       x1 @ x2)%expr_pat
                end
            | @expr.App _ _ _ s _ f x3 =>
                match x1 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t1 v =>
                          match
                            t1 as t2 return (base.base_interp t2 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v0 : Z => Some v0
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        match x2 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t2 v =>
                                  match
                                    t2 as t3
                                    return (base.base_interp t3 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v0 : Z => Some v0
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                if (args0 =? 0) && (args1 =? 0)
                                then
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry_concrete
                                        args)%expr @ x0 @ x1 @ x2)%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry_concrete
                                        args)%expr @ x0 @ x1 @ x2)%expr_pat
                            | None =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry_concrete args)%expr @
                                   x0 @ x1 @ x2)%expr_pat
                            end
                        | @expr.App _ _ _ s0 _ #(idc1)%expr_pat x4 =>
                            match
                              match idc1 with
                              | ident.Z_opp => Some tt
                              | _ => None
                              end
                            with
                            | Some _ =>
                                match f with
                                | #(idc2)%expr_pat =>
                                    match
                                      match idc2 with
                                      | ident.Z_opp => Some tt
                                      | _ => None
                                      end
                                    with
                                    | Some _ =>
                                        match
                                          s as t3
                                          return
                                            (Compile.value' false t3 ->
                                             UnderLets.UnderLets base.type
                                               ident var
                                               (expr
                                                  (type.base
                                                     (base.type.Z *
                                                      base.type.Z)%etype)))
                                        with
                                        | type.base t3 =>
                                            fun v : expr (type.base t3) =>
                                            base.try_make_transport_cps
                                              (fun t4 : base.type =>
                                               expr (type.base t4)) t3
                                              base.type.Z
                                              (UnderLets.UnderLets base.type
                                                 ident var
                                                 (expr
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)))
                                              (fun
                                                 a : option
                                                       (expr (type.base t3) ->
                                                        expr
                                                          (type.base
                                                             base.type.Z)) =>
                                               match a with
                                               | Some x' =>
                                                   match
                                                     s0 as t4
                                                     return
                                                       (Compile.value' false
                                                          t4 ->
                                                        UnderLets.UnderLets
                                                          base.type ident var
                                                          (expr
                                                             (type.base
                                                                (base.type.Z *
                                                                 base.type.Z)%etype)))
                                                   with
                                                   | type.base t4 =>
                                                       fun
                                                         v0 : expr
                                                                (type.base t4)
                                                       =>
                                                       base.try_make_transport_cps
                                                         (fun t5 : base.type
                                                          =>
                                                          expr (type.base t5))
                                                         t4 base.type.Z
                                                         (UnderLets.UnderLets
                                                            base.type ident
                                                            var
                                                            (expr
                                                               (type.base
                                                                  (base.type.Z *
                                                                   base.type.Z)%etype)))
                                                         (fun
                                                            a0 : option
                                                                   (expr
                                                                    (type.base
                                                                    t4) ->
                                                                    expr
                                                                    (type.base
                                                                    base.type.Z))
                                                          =>
                                                          match a0 with
                                                          | Some x'0 =>
                                                              UnderLets.UnderLet
                                                                (#(ident.Z_sub_with_get_borrow_concrete
                                                                    args)%expr @
                                                                 x' v @ x1 @
                                                                 x'0 v0)%expr_pat
                                                                (fun
                                                                   v1 : 
                                                                    var
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                                 =>
                                                                 UnderLets.Base
                                                                   (#
                                                                    (ident.fst)%expr @
                                                                    ($v1)%expr,
                                                                   (-
                                                                    (#
                                                                    (ident.snd)%expr @
                                                                    $v1)%expr_pat)%expr)%expr_pat)
                                                          | None =>
                                                              UnderLets.Base
                                                                (#(ident.Z_add_with_get_carry)%expr @
                                                                 x @ x0 @ x1 @
                                                                 x2)%expr_pat
                                                          end)
                                                   | (s1 -> d1)%ptype =>
                                                       fun
                                                         _ : Compile.value'
                                                               false s1 ->
                                                             Compile.value'
                                                               true d1 =>
                                                       UnderLets.Base
                                                         (#(ident.Z_add_with_get_carry)%expr @
                                                          x @ x0 @ x1 @ x2)%expr_pat
                                                   end (Compile.reflect x4)
                                               | None =>
                                                   UnderLets.Base
                                                     (#(ident.Z_add_with_get_carry)%expr @
                                                      x @ x0 @ x1 @ x2)%expr_pat
                                               end)
                                        | (s1 -> d1)%ptype =>
                                            fun
                                              _ : Compile.value' false s1 ->
                                                  Compile.value' true d1 =>
                                            UnderLets.Base
                                              (#(ident.Z_add_with_get_carry)%expr @
                                               x @ x0 @ x1 @ x2)%expr_pat
                                        end (Compile.reflect x3)
                                    | None =>
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry_concrete
                                               args)%expr @ x0 @ x1 @ x2)%expr_pat
                                    end
                                | _ =>
                                    UnderLets.Base
                                      (#(ident.Z_add_with_get_carry_concrete
                                           args)%expr @ x0 @ x1 @ x2)%expr_pat
                                end
                            | None =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry_concrete args)%expr @
                                   x0 @ x1 @ x2)%expr_pat
                            end
                        | @expr.App _ _ _ s0 _ ($_)%expr _ | @expr.App _ _ _
                          s0 _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0
                          _ (_ @ _)%expr_pat _ | @expr.App _ _ _ s0 _
                          (@expr.LetIn _ _ _ _ _ _ _) _ =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete args)%expr @
                               x0 @ x1 @ x2)%expr_pat
                        | _ =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete args)%expr @
                               x0 @ x1 @ x2)%expr_pat
                        end
                    | None =>
                        match f with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | ident.Z_opp => Some tt
                              | _ => None
                              end
                            with
                            | Some _ =>
                                match x2 with
                                | @expr.App _ _ _ s0 _ #(idc2)%expr_pat x4 =>
                                    match
                                      match idc2 with
                                      | ident.Z_opp => Some tt
                                      | _ => None
                                      end
                                    with
                                    | Some _ =>
                                        match
                                          s as t3
                                          return
                                            (Compile.value' false t3 ->
                                             UnderLets.UnderLets base.type
                                               ident var
                                               (expr
                                                  (type.base
                                                     (base.type.Z *
                                                      base.type.Z)%etype)))
                                        with
                                        | type.base t3 =>
                                            fun v : expr (type.base t3) =>
                                            base.try_make_transport_cps
                                              (fun t4 : base.type =>
                                               expr (type.base t4)) t3
                                              base.type.Z
                                              (UnderLets.UnderLets base.type
                                                 ident var
                                                 (expr
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)))
                                              (fun
                                                 a : option
                                                       (expr (type.base t3) ->
                                                        expr
                                                          (type.base
                                                             base.type.Z)) =>
                                               match a with
                                               | Some x' =>
                                                   match
                                                     s0 as t4
                                                     return
                                                       (Compile.value' false
                                                          t4 ->
                                                        UnderLets.UnderLets
                                                          base.type ident var
                                                          (expr
                                                             (type.base
                                                                (base.type.Z *
                                                                 base.type.Z)%etype)))
                                                   with
                                                   | type.base t4 =>
                                                       fun
                                                         v0 : expr
                                                                (type.base t4)
                                                       =>
                                                       base.try_make_transport_cps
                                                         (fun t5 : base.type
                                                          =>
                                                          expr (type.base t5))
                                                         t4 base.type.Z
                                                         (UnderLets.UnderLets
                                                            base.type ident
                                                            var
                                                            (expr
                                                               (type.base
                                                                  (base.type.Z *
                                                                   base.type.Z)%etype)))
                                                         (fun
                                                            a0 : option
                                                                   (expr
                                                                    (type.base
                                                                    t4) ->
                                                                    expr
                                                                    (type.base
                                                                    base.type.Z))
                                                          =>
                                                          match a0 with
                                                          | Some x'0 =>
                                                              UnderLets.UnderLet
                                                                (#(ident.Z_sub_with_get_borrow_concrete
                                                                    args)%expr @
                                                                 x' v @ x1 @
                                                                 x'0 v0)%expr_pat
                                                                (fun
                                                                   v1 : 
                                                                    var
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                                 =>
                                                                 UnderLets.Base
                                                                   (#
                                                                    (ident.fst)%expr @
                                                                    ($v1)%expr,
                                                                   (-
                                                                    (#
                                                                    (ident.snd)%expr @
                                                                    $v1)%expr_pat)%expr)%expr_pat)
                                                          | None =>
                                                              UnderLets.Base
                                                                (#(ident.Z_add_with_get_carry)%expr @
                                                                 x @ x0 @ x1 @
                                                                 x2)%expr_pat
                                                          end)
                                                   | (s1 -> d1)%ptype =>
                                                       fun
                                                         _ : Compile.value'
                                                               false s1 ->
                                                             Compile.value'
                                                               true d1 =>
                                                       UnderLets.Base
                                                         (#(ident.Z_add_with_get_carry)%expr @
                                                          x @ x0 @ x1 @ x2)%expr_pat
                                                   end (Compile.reflect x4)
                                               | None =>
                                                   UnderLets.Base
                                                     (#(ident.Z_add_with_get_carry)%expr @
                                                      x @ x0 @ x1 @ x2)%expr_pat
                                               end)
                                        | (s1 -> d1)%ptype =>
                                            fun
                                              _ : Compile.value' false s1 ->
                                                  Compile.value' true d1 =>
                                            UnderLets.Base
                                              (#(ident.Z_add_with_get_carry)%expr @
                                               x @ x0 @ x1 @ x2)%expr_pat
                                        end (Compile.reflect x3)
                                    | None =>
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry_concrete
                                               args)%expr @ x0 @ x1 @ x2)%expr_pat
                                    end
                                | @expr.App _ _ _ s0 _ ($_)%expr _ |
                                  @expr.App _ _ _ s0 _
                                  (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _
                                  s0 _ (_ @ _)%expr_pat _ | @expr.App _ _ _
                                  s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
                                    UnderLets.Base
                                      (#(ident.Z_add_with_get_carry_concrete
                                           args)%expr @ x0 @ x1 @ x2)%expr_pat
                                | _ =>
                                    UnderLets.Base
                                      (#(ident.Z_add_with_get_carry_concrete
                                           args)%expr @ x0 @ x1 @ x2)%expr_pat
                                end
                            | None =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry_concrete args)%expr @
                                   x0 @ x1 @ x2)%expr_pat
                            end
                        | _ =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete args)%expr @
                               x0 @ x1 @ x2)%expr_pat
                        end
                    end
                | ($_)%expr =>
                    match f with
                    | #(idc0)%expr_pat =>
                        match
                          match idc0 with
                          | ident.Z_opp => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match x2 with
                            | @expr.App _ _ _ s0 _ #(idc1)%expr_pat x4 =>
                                match
                                  match idc1 with
                                  | ident.Z_opp => Some tt
                                  | _ => None
                                  end
                                with
                                | Some _ =>
                                    match
                                      s as t3
                                      return
                                        (Compile.value' false t3 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t3 =>
                                        fun v0 : expr (type.base t3) =>
                                        base.try_make_transport_cps
                                          (fun t4 : base.type =>
                                           expr (type.base t4)) t3
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (expr (type.base t3) ->
                                                    expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               match
                                                 s0 as t4
                                                 return
                                                   (Compile.value' false t4 ->
                                                    UnderLets.UnderLets
                                                      base.type ident var
                                                      (expr
                                                         (type.base
                                                            (base.type.Z *
                                                             base.type.Z)%etype)))
                                               with
                                               | type.base t4 =>
                                                   fun
                                                     v1 : expr (type.base t4)
                                                   =>
                                                   base.try_make_transport_cps
                                                     (fun t5 : base.type =>
                                                      expr (type.base t5)) t4
                                                     base.type.Z
                                                     (UnderLets.UnderLets
                                                        base.type ident var
                                                        (expr
                                                           (type.base
                                                              (base.type.Z *
                                                               base.type.Z)%etype)))
                                                     (fun
                                                        a0 : option
                                                               (expr
                                                                  (type.base
                                                                    t4) ->
                                                                expr
                                                                  (type.base
                                                                    base.type.Z))
                                                      =>
                                                      match a0 with
                                                      | Some x'0 =>
                                                          UnderLets.UnderLet
                                                            (#(ident.Z_sub_with_get_borrow_concrete
                                                                 args)%expr @
                                                             x' v0 @ x1 @
                                                             x'0 v1)%expr_pat
                                                            (fun
                                                               v2 : var
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                             =>
                                                             UnderLets.Base
                                                               (#(ident.fst)%expr @
                                                                ($v2)%expr,
                                                               (-
                                                                (#(ident.snd)%expr @
                                                                 $v2)%expr_pat)%expr)%expr_pat)
                                                      | None =>
                                                          UnderLets.Base
                                                            (#(ident.Z_add_with_get_carry)%expr @
                                                             x @ x0 @ x1 @ x2)%expr_pat
                                                      end)
                                               | (s1 -> d1)%ptype =>
                                                   fun
                                                     _ : Compile.value' false
                                                           s1 ->
                                                         Compile.value' true
                                                           d1 =>
                                                   UnderLets.Base
                                                     (#(ident.Z_add_with_get_carry)%expr @
                                                      x @ x0 @ x1 @ x2)%expr_pat
                                               end (Compile.reflect x4)
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_with_get_carry)%expr @
                                                  x @ x0 @ x1 @ x2)%expr_pat
                                           end)
                                    | (s1 -> d1)%ptype =>
                                        fun
                                          _ : Compile.value' false s1 ->
                                              Compile.value' true d1 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ x1 @ x2)%expr_pat
                                    end (Compile.reflect x3)
                                | None =>
                                    UnderLets.Base
                                      (#(ident.Z_add_with_get_carry_concrete
                                           args)%expr @ x0 @ x1 @ x2)%expr_pat
                                end
                            | @expr.App _ _ _ s0 _ ($_)%expr _ | @expr.App _
                              _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App
                              _ _ _ s0 _ (_ @ _)%expr_pat _ | @expr.App _ _ _
                              s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry_concrete args)%expr @
                                   x0 @ x1 @ x2)%expr_pat
                            | _ =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry_concrete args)%expr @
                                   x0 @ x1 @ x2)%expr_pat
                            end
                        | None =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete args)%expr @
                               x0 @ x1 @ x2)%expr_pat
                        end
                    | _ =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete args)%expr @
                           x0 @ x1 @ x2)%expr_pat
                    end
                | @expr.Abs _ _ _ _ _ _ =>
                    match f with
                    | #(idc0)%expr_pat =>
                        match
                          match idc0 with
                          | ident.Z_opp => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match x2 with
                            | @expr.App _ _ _ s1 _ #(idc1)%expr_pat x4 =>
                                match
                                  match idc1 with
                                  | ident.Z_opp => Some tt
                                  | _ => None
                                  end
                                with
                                | Some _ =>
                                    match
                                      s as t2
                                      return
                                        (Compile.value' false t2 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t2 =>
                                        fun v : expr (type.base t2) =>
                                        base.try_make_transport_cps
                                          (fun t3 : base.type =>
                                           expr (type.base t3)) t2
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (expr (type.base t2) ->
                                                    expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               match
                                                 s1 as t3
                                                 return
                                                   (Compile.value' false t3 ->
                                                    UnderLets.UnderLets
                                                      base.type ident var
                                                      (expr
                                                         (type.base
                                                            (base.type.Z *
                                                             base.type.Z)%etype)))
                                               with
                                               | type.base t3 =>
                                                   fun
                                                     v0 : expr (type.base t3)
                                                   =>
                                                   base.try_make_transport_cps
                                                     (fun t4 : base.type =>
                                                      expr (type.base t4)) t3
                                                     base.type.Z
                                                     (UnderLets.UnderLets
                                                        base.type ident var
                                                        (expr
                                                           (type.base
                                                              (base.type.Z *
                                                               base.type.Z)%etype)))
                                                     (fun
                                                        a0 : option
                                                               (expr
                                                                  (type.base
                                                                    t3) ->
                                                                expr
                                                                  (type.base
                                                                    base.type.Z))
                                                      =>
                                                      match a0 with
                                                      | Some x'0 =>
                                                          UnderLets.UnderLet
                                                            (#(ident.Z_sub_with_get_borrow_concrete
                                                                 args)%expr @
                                                             x' v @ x1 @
                                                             x'0 v0)%expr_pat
                                                            (fun
                                                               v1 : var
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                             =>
                                                             UnderLets.Base
                                                               (#(ident.fst)%expr @
                                                                ($v1)%expr,
                                                               (-
                                                                (#(ident.snd)%expr @
                                                                 $v1)%expr_pat)%expr)%expr_pat)
                                                      | None =>
                                                          UnderLets.Base
                                                            (#(ident.Z_add_with_get_carry)%expr @
                                                             x @ x0 @ x1 @ x2)%expr_pat
                                                      end)
                                               | (s2 -> d2)%ptype =>
                                                   fun
                                                     _ : Compile.value' false
                                                           s2 ->
                                                         Compile.value' true
                                                           d2 =>
                                                   UnderLets.Base
                                                     (#(ident.Z_add_with_get_carry)%expr @
                                                      x @ x0 @ x1 @ x2)%expr_pat
                                               end (Compile.reflect x4)
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_with_get_carry)%expr @
                                                  x @ x0 @ x1 @ x2)%expr_pat
                                           end)
                                    | (s2 -> d2)%ptype =>
                                        fun
                                          _ : Compile.value' false s2 ->
                                              Compile.value' true d2 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ x1 @ x2)%expr_pat
                                    end (Compile.reflect x3)
                                | None =>
                                    UnderLets.Base
                                      (#(ident.Z_add_with_get_carry_concrete
                                           args)%expr @ x0 @ x1 @ x2)%expr_pat
                                end
                            | @expr.App _ _ _ s1 _ ($_)%expr _ | @expr.App _
                              _ _ s1 _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App
                              _ _ _ s1 _ (_ @ _)%expr_pat _ | @expr.App _ _ _
                              s1 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry_concrete args)%expr @
                                   x0 @ x1 @ x2)%expr_pat
                            | _ =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry_concrete args)%expr @
                                   x0 @ x1 @ x2)%expr_pat
                            end
                        | None =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete args)%expr @
                               x0 @ x1 @ x2)%expr_pat
                        end
                    | _ =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete args)%expr @
                           x0 @ x1 @ x2)%expr_pat
                    end
                | @expr.App _ _ _ s0 _ #(idc0)%expr_pat x4 =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match f with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | ident.Z_opp => Some tt
                              | _ => None
                              end
                            with
                            | Some _ =>
                                match
                                  s as t2
                                  return
                                    (Compile.value' false t2 ->
                                     UnderLets.UnderLets base.type ident var
                                       (expr
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)))
                                with
                                | type.base t2 =>
                                    fun v : expr (type.base t2) =>
                                    base.try_make_transport_cps
                                      (fun t3 : base.type =>
                                       expr (type.base t3)) t2 base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (expr
                                            (type.base
                                               (base.type.Z * base.type.Z)%etype)))
                                      (fun
                                         a : option
                                               (expr (type.base t2) ->
                                                expr (type.base base.type.Z))
                                       =>
                                       match a with
                                       | Some x' =>
                                           match
                                             s0 as t3
                                             return
                                               (Compile.value' false t3 ->
                                                UnderLets.UnderLets base.type
                                                  ident var
                                                  (expr
                                                     (type.base
                                                        (base.type.Z *
                                                         base.type.Z)%etype)))
                                           with
                                           | type.base t3 =>
                                               fun v0 : expr (type.base t3)
                                               =>
                                               base.try_make_transport_cps
                                                 (fun t4 : base.type =>
                                                  expr (type.base t4)) t3
                                                 base.type.Z
                                                 (UnderLets.UnderLets
                                                    base.type ident var
                                                    (expr
                                                       (type.base
                                                          (base.type.Z *
                                                           base.type.Z)%etype)))
                                                 (fun
                                                    a0 : option
                                                           (expr
                                                              (type.base t3) ->
                                                            expr
                                                              (type.base
                                                                 base.type.Z))
                                                  =>
                                                  match a0 with
                                                  | Some x'0 =>
                                                      UnderLets.UnderLet
                                                        (#(ident.Z_sub_with_get_borrow_concrete
                                                             args)%expr @
                                                         x' v @ x2 @ 
                                                         x'0 v0)%expr_pat
                                                        (fun
                                                           v1 : var
                                                                  (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                         =>
                                                         UnderLets.Base
                                                           (#(ident.fst)%expr @
                                                            ($v1)%expr,
                                                           (-
                                                            (#(ident.snd)%expr @
                                                             $v1)%expr_pat)%expr)%expr_pat)
                                                  | None =>
                                                      UnderLets.Base
                                                        (#(ident.Z_add_with_get_carry)%expr @
                                                         x @ x0 @ x1 @ x2)%expr_pat
                                                  end)
                                           | (s1 -> d1)%ptype =>
                                               fun
                                                 _ : Compile.value' false s1 ->
                                                     Compile.value' true d1
                                               =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_with_get_carry)%expr @
                                                  x @ x0 @ x1 @ x2)%expr_pat
                                           end (Compile.reflect x4)
                                       | None =>
                                           UnderLets.Base
                                             (#(ident.Z_add_with_get_carry)%expr @
                                              x @ x0 @ x1 @ x2)%expr_pat
                                       end)
                                | (s1 -> d1)%ptype =>
                                    fun
                                      _ : Compile.value' false s1 ->
                                          Compile.value' true d1 =>
                                    UnderLets.Base
                                      (#(ident.Z_add_with_get_carry)%expr @ x @
                                       x0 @ x1 @ x2)%expr_pat
                                end (Compile.reflect x3)
                            | None =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry_concrete args)%expr @
                                   x0 @ x1 @ x2)%expr_pat
                            end
                        | _ =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete args)%expr @
                               x0 @ x1 @ x2)%expr_pat
                        end
                    | None =>
                        match f with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | ident.Z_opp => Some tt
                              | _ => None
                              end
                            with
                            | Some _ =>
                                match x2 with
                                | @expr.App _ _ _ s1 _ #(idc2)%expr_pat x5 =>
                                    match
                                      match idc2 with
                                      | ident.Z_opp => Some tt
                                      | _ => None
                                      end
                                    with
                                    | Some _ =>
                                        match
                                          s as t3
                                          return
                                            (Compile.value' false t3 ->
                                             UnderLets.UnderLets base.type
                                               ident var
                                               (expr
                                                  (type.base
                                                     (base.type.Z *
                                                      base.type.Z)%etype)))
                                        with
                                        | type.base t3 =>
                                            fun v : expr (type.base t3) =>
                                            base.try_make_transport_cps
                                              (fun t4 : base.type =>
                                               expr (type.base t4)) t3
                                              base.type.Z
                                              (UnderLets.UnderLets base.type
                                                 ident var
                                                 (expr
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)))
                                              (fun
                                                 a : option
                                                       (expr (type.base t3) ->
                                                        expr
                                                          (type.base
                                                             base.type.Z)) =>
                                               match a with
                                               | Some x' =>
                                                   match
                                                     s1 as t4
                                                     return
                                                       (Compile.value' false
                                                          t4 ->
                                                        UnderLets.UnderLets
                                                          base.type ident var
                                                          (expr
                                                             (type.base
                                                                (base.type.Z *
                                                                 base.type.Z)%etype)))
                                                   with
                                                   | type.base t4 =>
                                                       fun
                                                         v0 : expr
                                                                (type.base t4)
                                                       =>
                                                       base.try_make_transport_cps
                                                         (fun t5 : base.type
                                                          =>
                                                          expr (type.base t5))
                                                         t4 base.type.Z
                                                         (UnderLets.UnderLets
                                                            base.type ident
                                                            var
                                                            (expr
                                                               (type.base
                                                                  (base.type.Z *
                                                                   base.type.Z)%etype)))
                                                         (fun
                                                            a0 : option
                                                                   (expr
                                                                    (type.base
                                                                    t4) ->
                                                                    expr
                                                                    (type.base
                                                                    base.type.Z))
                                                          =>
                                                          match a0 with
                                                          | Some x'0 =>
                                                              UnderLets.UnderLet
                                                                (#(ident.Z_sub_with_get_borrow_concrete
                                                                    args)%expr @
                                                                 x' v @ x1 @
                                                                 x'0 v0)%expr_pat
                                                                (fun
                                                                   v1 : 
                                                                    var
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                                 =>
                                                                 UnderLets.Base
                                                                   (#
                                                                    (ident.fst)%expr @
                                                                    ($v1)%expr,
                                                                   (-
                                                                    (#
                                                                    (ident.snd)%expr @
                                                                    $v1)%expr_pat)%expr)%expr_pat)
                                                          | None =>
                                                              UnderLets.Base
                                                                (#(ident.Z_add_with_get_carry)%expr @
                                                                 x @ x0 @ x1 @
                                                                 x2)%expr_pat
                                                          end)
                                                   | (s2 -> d2)%ptype =>
                                                       fun
                                                         _ : Compile.value'
                                                               false s2 ->
                                                             Compile.value'
                                                               true d2 =>
                                                       UnderLets.Base
                                                         (#(ident.Z_add_with_get_carry)%expr @
                                                          x @ x0 @ x1 @ x2)%expr_pat
                                                   end (Compile.reflect x5)
                                               | None =>
                                                   UnderLets.Base
                                                     (#(ident.Z_add_with_get_carry)%expr @
                                                      x @ x0 @ x1 @ x2)%expr_pat
                                               end)
                                        | (s2 -> d2)%ptype =>
                                            fun
                                              _ : Compile.value' false s2 ->
                                                  Compile.value' true d2 =>
                                            UnderLets.Base
                                              (#(ident.Z_add_with_get_carry)%expr @
                                               x @ x0 @ x1 @ x2)%expr_pat
                                        end (Compile.reflect x3)
                                    | None =>
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry_concrete
                                               args)%expr @ x0 @ x1 @ x2)%expr_pat
                                    end
                                | @expr.App _ _ _ s1 _ ($_)%expr _ |
                                  @expr.App _ _ _ s1 _
                                  (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _
                                  s1 _ (_ @ _)%expr_pat _ | @expr.App _ _ _
                                  s1 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
                                    UnderLets.Base
                                      (#(ident.Z_add_with_get_carry_concrete
                                           args)%expr @ x0 @ x1 @ x2)%expr_pat
                                | _ =>
                                    UnderLets.Base
                                      (#(ident.Z_add_with_get_carry_concrete
                                           args)%expr @ x0 @ x1 @ x2)%expr_pat
                                end
                            | None =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry_concrete args)%expr @
                                   x0 @ x1 @ x2)%expr_pat
                            end
                        | _ =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete args)%expr @
                               x0 @ x1 @ x2)%expr_pat
                        end
                    end
                | @expr.App _ _ _ s0 _ ($_)%expr _ =>
                    match f with
                    | #(idc0)%expr_pat =>
                        match
                          match idc0 with
                          | ident.Z_opp => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match x2 with
                            | @expr.App _ _ _ s1 _ #(idc1)%expr_pat x5 =>
                                match
                                  match idc1 with
                                  | ident.Z_opp => Some tt
                                  | _ => None
                                  end
                                with
                                | Some _ =>
                                    match
                                      s as t3
                                      return
                                        (Compile.value' false t3 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t3 =>
                                        fun v0 : expr (type.base t3) =>
                                        base.try_make_transport_cps
                                          (fun t4 : base.type =>
                                           expr (type.base t4)) t3
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (expr (type.base t3) ->
                                                    expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               match
                                                 s1 as t4
                                                 return
                                                   (Compile.value' false t4 ->
                                                    UnderLets.UnderLets
                                                      base.type ident var
                                                      (expr
                                                         (type.base
                                                            (base.type.Z *
                                                             base.type.Z)%etype)))
                                               with
                                               | type.base t4 =>
                                                   fun
                                                     v1 : expr (type.base t4)
                                                   =>
                                                   base.try_make_transport_cps
                                                     (fun t5 : base.type =>
                                                      expr (type.base t5)) t4
                                                     base.type.Z
                                                     (UnderLets.UnderLets
                                                        base.type ident var
                                                        (expr
                                                           (type.base
                                                              (base.type.Z *
                                                               base.type.Z)%etype)))
                                                     (fun
                                                        a0 : option
                                                               (expr
                                                                  (type.base
                                                                    t4) ->
                                                                expr
                                                                  (type.base
                                                                    base.type.Z))
                                                      =>
                                                      match a0 with
                                                      | Some x'0 =>
                                                          UnderLets.UnderLet
                                                            (#(ident.Z_sub_with_get_borrow_concrete
                                                                 args)%expr @
                                                             x' v0 @ x1 @
                                                             x'0 v1)%expr_pat
                                                            (fun
                                                               v2 : var
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                             =>
                                                             UnderLets.Base
                                                               (#(ident.fst)%expr @
                                                                ($v2)%expr,
                                                               (-
                                                                (#(ident.snd)%expr @
                                                                 $v2)%expr_pat)%expr)%expr_pat)
                                                      | None =>
                                                          UnderLets.Base
                                                            (#(ident.Z_add_with_get_carry)%expr @
                                                             x @ x0 @ x1 @ x2)%expr_pat
                                                      end)
                                               | (s2 -> d2)%ptype =>
                                                   fun
                                                     _ : Compile.value' false
                                                           s2 ->
                                                         Compile.value' true
                                                           d2 =>
                                                   UnderLets.Base
                                                     (#(ident.Z_add_with_get_carry)%expr @
                                                      x @ x0 @ x1 @ x2)%expr_pat
                                               end (Compile.reflect x5)
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_with_get_carry)%expr @
                                                  x @ x0 @ x1 @ x2)%expr_pat
                                           end)
                                    | (s2 -> d2)%ptype =>
                                        fun
                                          _ : Compile.value' false s2 ->
                                              Compile.value' true d2 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ x1 @ x2)%expr_pat
                                    end (Compile.reflect x3)
                                | None =>
                                    UnderLets.Base
                                      (#(ident.Z_add_with_get_carry_concrete
                                           args)%expr @ x0 @ x1 @ x2)%expr_pat
                                end
                            | @expr.App _ _ _ s1 _ ($_)%expr _ | @expr.App _
                              _ _ s1 _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App
                              _ _ _ s1 _ (_ @ _)%expr_pat _ | @expr.App _ _ _
                              s1 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry_concrete args)%expr @
                                   x0 @ x1 @ x2)%expr_pat
                            | _ =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry_concrete args)%expr @
                                   x0 @ x1 @ x2)%expr_pat
                            end
                        | None =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete args)%expr @
                               x0 @ x1 @ x2)%expr_pat
                        end
                    | _ =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete args)%expr @
                           x0 @ x1 @ x2)%expr_pat
                    end
                | @expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ =>
                    match f with
                    | #(idc0)%expr_pat =>
                        match
                          match idc0 with
                          | ident.Z_opp => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match x2 with
                            | @expr.App _ _ _ s2 _ #(idc1)%expr_pat x5 =>
                                match
                                  match idc1 with
                                  | ident.Z_opp => Some tt
                                  | _ => None
                                  end
                                with
                                | Some _ =>
                                    match
                                      s as t2
                                      return
                                        (Compile.value' false t2 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t2 =>
                                        fun v : expr (type.base t2) =>
                                        base.try_make_transport_cps
                                          (fun t3 : base.type =>
                                           expr (type.base t3)) t2
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (expr (type.base t2) ->
                                                    expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               match
                                                 s2 as t3
                                                 return
                                                   (Compile.value' false t3 ->
                                                    UnderLets.UnderLets
                                                      base.type ident var
                                                      (expr
                                                         (type.base
                                                            (base.type.Z *
                                                             base.type.Z)%etype)))
                                               with
                                               | type.base t3 =>
                                                   fun
                                                     v0 : expr (type.base t3)
                                                   =>
                                                   base.try_make_transport_cps
                                                     (fun t4 : base.type =>
                                                      expr (type.base t4)) t3
                                                     base.type.Z
                                                     (UnderLets.UnderLets
                                                        base.type ident var
                                                        (expr
                                                           (type.base
                                                              (base.type.Z *
                                                               base.type.Z)%etype)))
                                                     (fun
                                                        a0 : option
                                                               (expr
                                                                  (type.base
                                                                    t3) ->
                                                                expr
                                                                  (type.base
                                                                    base.type.Z))
                                                      =>
                                                      match a0 with
                                                      | Some x'0 =>
                                                          UnderLets.UnderLet
                                                            (#(ident.Z_sub_with_get_borrow_concrete
                                                                 args)%expr @
                                                             x' v @ x1 @
                                                             x'0 v0)%expr_pat
                                                            (fun
                                                               v1 : var
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                             =>
                                                             UnderLets.Base
                                                               (#(ident.fst)%expr @
                                                                ($v1)%expr,
                                                               (-
                                                                (#(ident.snd)%expr @
                                                                 $v1)%expr_pat)%expr)%expr_pat)
                                                      | None =>
                                                          UnderLets.Base
                                                            (#(ident.Z_add_with_get_carry)%expr @
                                                             x @ x0 @ x1 @ x2)%expr_pat
                                                      end)
                                               | (s3 -> d3)%ptype =>
                                                   fun
                                                     _ : Compile.value' false
                                                           s3 ->
                                                         Compile.value' true
                                                           d3 =>
                                                   UnderLets.Base
                                                     (#(ident.Z_add_with_get_carry)%expr @
                                                      x @ x0 @ x1 @ x2)%expr_pat
                                               end (Compile.reflect x5)
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_with_get_carry)%expr @
                                                  x @ x0 @ x1 @ x2)%expr_pat
                                           end)
                                    | (s3 -> d3)%ptype =>
                                        fun
                                          _ : Compile.value' false s3 ->
                                              Compile.value' true d3 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ x1 @ x2)%expr_pat
                                    end (Compile.reflect x3)
                                | None =>
                                    UnderLets.Base
                                      (#(ident.Z_add_with_get_carry_concrete
                                           args)%expr @ x0 @ x1 @ x2)%expr_pat
                                end
                            | @expr.App _ _ _ s2 _ ($_)%expr _ | @expr.App _
                              _ _ s2 _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App
                              _ _ _ s2 _ (_ @ _)%expr_pat _ | @expr.App _ _ _
                              s2 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry_concrete args)%expr @
                                   x0 @ x1 @ x2)%expr_pat
                            | _ =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry_concrete args)%expr @
                                   x0 @ x1 @ x2)%expr_pat
                            end
                        | None =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete args)%expr @
                               x0 @ x1 @ x2)%expr_pat
                        end
                    | _ =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete args)%expr @
                           x0 @ x1 @ x2)%expr_pat
                    end
                | @expr.App _ _ _ s0 _ (_ @ _)%expr_pat _ =>
                    match f with
                    | #(idc0)%expr_pat =>
                        match
                          match idc0 with
                          | ident.Z_opp => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match x2 with
                            | @expr.App _ _ _ s2 _ #(idc1)%expr_pat x6 =>
                                match
                                  match idc1 with
                                  | ident.Z_opp => Some tt
                                  | _ => None
                                  end
                                with
                                | Some _ =>
                                    match
                                      s as t2
                                      return
                                        (Compile.value' false t2 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t2 =>
                                        fun v : expr (type.base t2) =>
                                        base.try_make_transport_cps
                                          (fun t3 : base.type =>
                                           expr (type.base t3)) t2
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (expr (type.base t2) ->
                                                    expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               match
                                                 s2 as t3
                                                 return
                                                   (Compile.value' false t3 ->
                                                    UnderLets.UnderLets
                                                      base.type ident var
                                                      (expr
                                                         (type.base
                                                            (base.type.Z *
                                                             base.type.Z)%etype)))
                                               with
                                               | type.base t3 =>
                                                   fun
                                                     v0 : expr (type.base t3)
                                                   =>
                                                   base.try_make_transport_cps
                                                     (fun t4 : base.type =>
                                                      expr (type.base t4)) t3
                                                     base.type.Z
                                                     (UnderLets.UnderLets
                                                        base.type ident var
                                                        (expr
                                                           (type.base
                                                              (base.type.Z *
                                                               base.type.Z)%etype)))
                                                     (fun
                                                        a0 : option
                                                               (expr
                                                                  (type.base
                                                                    t3) ->
                                                                expr
                                                                  (type.base
                                                                    base.type.Z))
                                                      =>
                                                      match a0 with
                                                      | Some x'0 =>
                                                          UnderLets.UnderLet
                                                            (#(ident.Z_sub_with_get_borrow_concrete
                                                                 args)%expr @
                                                             x' v @ x1 @
                                                             x'0 v0)%expr_pat
                                                            (fun
                                                               v1 : var
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                             =>
                                                             UnderLets.Base
                                                               (#(ident.fst)%expr @
                                                                ($v1)%expr,
                                                               (-
                                                                (#(ident.snd)%expr @
                                                                 $v1)%expr_pat)%expr)%expr_pat)
                                                      | None =>
                                                          UnderLets.Base
                                                            (#(ident.Z_add_with_get_carry)%expr @
                                                             x @ x0 @ x1 @ x2)%expr_pat
                                                      end)
                                               | (s3 -> d3)%ptype =>
                                                   fun
                                                     _ : Compile.value' false
                                                           s3 ->
                                                         Compile.value' true
                                                           d3 =>
                                                   UnderLets.Base
                                                     (#(ident.Z_add_with_get_carry)%expr @
                                                      x @ x0 @ x1 @ x2)%expr_pat
                                               end (Compile.reflect x6)
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_with_get_carry)%expr @
                                                  x @ x0 @ x1 @ x2)%expr_pat
                                           end)
                                    | (s3 -> d3)%ptype =>
                                        fun
                                          _ : Compile.value' false s3 ->
                                              Compile.value' true d3 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ x1 @ x2)%expr_pat
                                    end (Compile.reflect x3)
                                | None =>
                                    UnderLets.Base
                                      (#(ident.Z_add_with_get_carry_concrete
                                           args)%expr @ x0 @ x1 @ x2)%expr_pat
                                end
                            | @expr.App _ _ _ s2 _ ($_)%expr _ | @expr.App _
                              _ _ s2 _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App
                              _ _ _ s2 _ (_ @ _)%expr_pat _ | @expr.App _ _ _
                              s2 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry_concrete args)%expr @
                                   x0 @ x1 @ x2)%expr_pat
                            | _ =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry_concrete args)%expr @
                                   x0 @ x1 @ x2)%expr_pat
                            end
                        | None =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete args)%expr @
                               x0 @ x1 @ x2)%expr_pat
                        end
                    | _ =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete args)%expr @
                           x0 @ x1 @ x2)%expr_pat
                    end
                | @expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
                    match f with
                    | #(idc0)%expr_pat =>
                        match
                          match idc0 with
                          | ident.Z_opp => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match x2 with
                            | @expr.App _ _ _ s1 _ #(idc1)%expr_pat x6 =>
                                match
                                  match idc1 with
                                  | ident.Z_opp => Some tt
                                  | _ => None
                                  end
                                with
                                | Some _ =>
                                    match
                                      s as t2
                                      return
                                        (Compile.value' false t2 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t2 =>
                                        fun v : expr (type.base t2) =>
                                        base.try_make_transport_cps
                                          (fun t3 : base.type =>
                                           expr (type.base t3)) t2
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (expr (type.base t2) ->
                                                    expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               match
                                                 s1 as t3
                                                 return
                                                   (Compile.value' false t3 ->
                                                    UnderLets.UnderLets
                                                      base.type ident var
                                                      (expr
                                                         (type.base
                                                            (base.type.Z *
                                                             base.type.Z)%etype)))
                                               with
                                               | type.base t3 =>
                                                   fun
                                                     v0 : expr (type.base t3)
                                                   =>
                                                   base.try_make_transport_cps
                                                     (fun t4 : base.type =>
                                                      expr (type.base t4)) t3
                                                     base.type.Z
                                                     (UnderLets.UnderLets
                                                        base.type ident var
                                                        (expr
                                                           (type.base
                                                              (base.type.Z *
                                                               base.type.Z)%etype)))
                                                     (fun
                                                        a0 : option
                                                               (expr
                                                                  (type.base
                                                                    t3) ->
                                                                expr
                                                                  (type.base
                                                                    base.type.Z))
                                                      =>
                                                      match a0 with
                                                      | Some x'0 =>
                                                          UnderLets.UnderLet
                                                            (#(ident.Z_sub_with_get_borrow_concrete
                                                                 args)%expr @
                                                             x' v @ x1 @
                                                             x'0 v0)%expr_pat
                                                            (fun
                                                               v1 : var
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                             =>
                                                             UnderLets.Base
                                                               (#(ident.fst)%expr @
                                                                ($v1)%expr,
                                                               (-
                                                                (#(ident.snd)%expr @
                                                                 $v1)%expr_pat)%expr)%expr_pat)
                                                      | None =>
                                                          UnderLets.Base
                                                            (#(ident.Z_add_with_get_carry)%expr @
                                                             x @ x0 @ x1 @ x2)%expr_pat
                                                      end)
                                               | (s2 -> d2)%ptype =>
                                                   fun
                                                     _ : Compile.value' false
                                                           s2 ->
                                                         Compile.value' true
                                                           d2 =>
                                                   UnderLets.Base
                                                     (#(ident.Z_add_with_get_carry)%expr @
                                                      x @ x0 @ x1 @ x2)%expr_pat
                                               end (Compile.reflect x6)
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_with_get_carry)%expr @
                                                  x @ x0 @ x1 @ x2)%expr_pat
                                           end)
                                    | (s2 -> d2)%ptype =>
                                        fun
                                          _ : Compile.value' false s2 ->
                                              Compile.value' true d2 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ x1 @ x2)%expr_pat
                                    end (Compile.reflect x3)
                                | None =>
                                    UnderLets.Base
                                      (#(ident.Z_add_with_get_carry_concrete
                                           args)%expr @ x0 @ x1 @ x2)%expr_pat
                                end
                            | @expr.App _ _ _ s1 _ ($_)%expr _ | @expr.App _
                              _ _ s1 _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App
                              _ _ _ s1 _ (_ @ _)%expr_pat _ | @expr.App _ _ _
                              s1 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry_concrete args)%expr @
                                   x0 @ x1 @ x2)%expr_pat
                            | _ =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry_concrete args)%expr @
                                   x0 @ x1 @ x2)%expr_pat
                            end
                        | None =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete args)%expr @
                               x0 @ x1 @ x2)%expr_pat
                        end
                    | _ =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete args)%expr @
                           x0 @ x1 @ x2)%expr_pat
                    end
                | @expr.LetIn _ _ _ _ _ _ _ =>
                    match f with
                    | #(idc0)%expr_pat =>
                        match
                          match idc0 with
                          | ident.Z_opp => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match x2 with
                            | @expr.App _ _ _ s0 _ #(idc1)%expr_pat x5 =>
                                match
                                  match idc1 with
                                  | ident.Z_opp => Some tt
                                  | _ => None
                                  end
                                with
                                | Some _ =>
                                    match
                                      s as t2
                                      return
                                        (Compile.value' false t2 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t2 =>
                                        fun v : expr (type.base t2) =>
                                        base.try_make_transport_cps
                                          (fun t3 : base.type =>
                                           expr (type.base t3)) t2
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (expr (type.base t2) ->
                                                    expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               match
                                                 s0 as t3
                                                 return
                                                   (Compile.value' false t3 ->
                                                    UnderLets.UnderLets
                                                      base.type ident var
                                                      (expr
                                                         (type.base
                                                            (base.type.Z *
                                                             base.type.Z)%etype)))
                                               with
                                               | type.base t3 =>
                                                   fun
                                                     v0 : expr (type.base t3)
                                                   =>
                                                   base.try_make_transport_cps
                                                     (fun t4 : base.type =>
                                                      expr (type.base t4)) t3
                                                     base.type.Z
                                                     (UnderLets.UnderLets
                                                        base.type ident var
                                                        (expr
                                                           (type.base
                                                              (base.type.Z *
                                                               base.type.Z)%etype)))
                                                     (fun
                                                        a0 : option
                                                               (expr
                                                                  (type.base
                                                                    t3) ->
                                                                expr
                                                                  (type.base
                                                                    base.type.Z))
                                                      =>
                                                      match a0 with
                                                      | Some x'0 =>
                                                          UnderLets.UnderLet
                                                            (#(ident.Z_sub_with_get_borrow_concrete
                                                                 args)%expr @
                                                             x' v @ x1 @
                                                             x'0 v0)%expr_pat
                                                            (fun
                                                               v1 : var
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                             =>
                                                             UnderLets.Base
                                                               (#(ident.fst)%expr @
                                                                ($v1)%expr,
                                                               (-
                                                                (#(ident.snd)%expr @
                                                                 $v1)%expr_pat)%expr)%expr_pat)
                                                      | None =>
                                                          UnderLets.Base
                                                            (#(ident.Z_add_with_get_carry)%expr @
                                                             x @ x0 @ x1 @ x2)%expr_pat
                                                      end)
                                               | (s1 -> d1)%ptype =>
                                                   fun
                                                     _ : Compile.value' false
                                                           s1 ->
                                                         Compile.value' true
                                                           d1 =>
                                                   UnderLets.Base
                                                     (#(ident.Z_add_with_get_carry)%expr @
                                                      x @ x0 @ x1 @ x2)%expr_pat
                                               end (Compile.reflect x5)
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_with_get_carry)%expr @
                                                  x @ x0 @ x1 @ x2)%expr_pat
                                           end)
                                    | (s1 -> d1)%ptype =>
                                        fun
                                          _ : Compile.value' false s1 ->
                                              Compile.value' true d1 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ x1 @ x2)%expr_pat
                                    end (Compile.reflect x3)
                                | None =>
                                    UnderLets.Base
                                      (#(ident.Z_add_with_get_carry_concrete
                                           args)%expr @ x0 @ x1 @ x2)%expr_pat
                                end
                            | @expr.App _ _ _ s0 _ ($_)%expr _ | @expr.App _
                              _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App
                              _ _ _ s0 _ (_ @ _)%expr_pat _ | @expr.App _ _ _
                              s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry_concrete args)%expr @
                                   x0 @ x1 @ x2)%expr_pat
                            | _ =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry_concrete args)%expr @
                                   x0 @ x1 @ x2)%expr_pat
                            end
                        | None =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete args)%expr @
                               x0 @ x1 @ x2)%expr_pat
                        end
                    | _ =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete args)%expr @
                           x0 @ x1 @ x2)%expr_pat
                    end
                end
            | _ =>
                match x1 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t1 v =>
                          match
                            t1 as t2 return (base.base_interp t2 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v0 : Z => Some v0
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        match x2 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t2 v =>
                                  match
                                    t2 as t3
                                    return (base.base_interp t3 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v0 : Z => Some v0
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                if (args0 =? 0) && (args1 =? 0)
                                then
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry_concrete
                                        args)%expr @ x0 @ x1 @ x2)%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry_concrete
                                        args)%expr @ x0 @ x1 @ x2)%expr_pat
                            | None =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry_concrete args)%expr @
                                   x0 @ x1 @ x2)%expr_pat
                            end
                        | _ =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete args)%expr @
                               x0 @ x1 @ x2)%expr_pat
                        end
                    | None =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete args)%expr @
                           x0 @ x1 @ x2)%expr_pat
                    end
                | _ =>
                    UnderLets.Base
                      (#(ident.Z_add_with_get_carry_concrete args)%expr @ x0 @
                       x1 @ x2)%expr_pat
                end
            end
        | None =>
            UnderLets.Base
              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
        end
    | _ =>
        UnderLets.Base
          (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
    end
| ident.Z_add_with_get_carry_concrete s =>
    fun x x0 x1 : expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 =>
                    match x1 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args1 =>
                            UnderLets.Base
                              (let
                               '(a, b) :=
                                Definitions.Z.add_with_get_carry_full s args
                                  args0 args1 in
                                (##(a)%expr, ##(b)%expr)%expr_pat)
                        | None =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete s)%expr @
                               x @ x0 @ x1)%expr_pat
                        end
                    | _ =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                           x0 @ x1)%expr_pat
                    end
                | None =>
                    UnderLets.Base
                      (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @
                       x1)%expr_pat
                end
            | _ =>
                UnderLets.Base
                  (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @
                   x1)%expr_pat
            end
        | None =>
            UnderLets.Base
              (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @ x1)%expr_pat
        end
    | @expr.App _ _ _ s0 _ #(idc)%expr_pat x2 =>
        match match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end with
        | Some _ =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 =>
                    match x1 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args1 =>
                            match
                              s0 as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (expr
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)))
                            with
                            | type.base t2 =>
                                fun v : expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t3 : base.type => expr (type.base t3))
                                  t2 base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (expr
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)))
                                  (fun
                                     a : option
                                           (expr (type.base t2) ->
                                            expr (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       if args0 <=? 0
                                       then
                                        UnderLets.UnderLet
                                          (#(ident.Z_sub_with_get_borrow_concrete
                                               s)%expr @ x' v @ x1 @
                                           ##((- args0)%Z)%expr)%expr_pat
                                          (fun
                                             v0 : var
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)
                                           =>
                                           UnderLets.Base
                                             (#(ident.fst)%expr @ ($v0)%expr,
                                             (-
                                              (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                       else
                                        match
                                          s0 as t3
                                          return
                                            (Compile.value' false t3 ->
                                             UnderLets.UnderLets base.type
                                               ident var
                                               (expr
                                                  (type.base
                                                     (base.type.Z *
                                                      base.type.Z)%etype)))
                                        with
                                        | type.base t3 =>
                                            fun v0 : expr (type.base t3) =>
                                            base.try_make_transport_cps
                                              (fun t4 : base.type =>
                                               expr (type.base t4)) t3
                                              base.type.Z
                                              (UnderLets.UnderLets base.type
                                                 ident var
                                                 (expr
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)))
                                              (fun
                                                 a0 : option
                                                        (expr (type.base t3) ->
                                                         expr
                                                           (type.base
                                                              base.type.Z))
                                               =>
                                               match a0 with
                                               | Some x'0 =>
                                                   if args1 <=? 0
                                                   then
                                                    UnderLets.UnderLet
                                                      (#(ident.Z_sub_with_get_borrow_concrete
                                                           s)%expr @ 
                                                       x'0 v0 @ x0 @
                                                       ##((- args1)%Z)%expr)%expr_pat
                                                      (fun
                                                         v1 : var
                                                                (type.base
                                                                   (base.type.Z *
                                                                    base.type.Z)%etype)
                                                       =>
                                                       UnderLets.Base
                                                         (#(ident.fst)%expr @
                                                          ($v1)%expr,
                                                         (-
                                                          (#(ident.snd)%expr @
                                                           $v1)%expr_pat)%expr)%expr_pat)
                                                   else
                                                    UnderLets.Base
                                                      (#(ident.Z_add_with_get_carry_concrete
                                                           s)%expr @ x @ x0 @
                                                       x1)%expr_pat
                                               | None =>
                                                   UnderLets.Base
                                                     (#(ident.Z_add_with_get_carry_concrete
                                                          s)%expr @ x @ x0 @
                                                      x1)%expr_pat
                                               end)
                                        | (s1 -> d0)%ptype =>
                                            fun
                                              _ : Compile.value' false s1 ->
                                                  Compile.value' true d0 =>
                                            UnderLets.Base
                                              (#(ident.Z_add_with_get_carry_concrete
                                                   s)%expr @ x @ x0 @ x1)%expr_pat
                                        end (Compile.reflect x2)
                                   | None =>
                                       UnderLets.Base
                                         (#(ident.Z_add_with_get_carry_concrete
                                              s)%expr @ x @ x0 @ x1)%expr_pat
                                   end)
                            | (s1 -> d0)%ptype =>
                                fun
                                  _ : Compile.value' false s1 ->
                                      Compile.value' true d0 =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                   x @ x0 @ x1)%expr_pat
                            end (Compile.reflect x2)
                        | None =>
                            match
                              s0 as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (expr
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)))
                            with
                            | type.base t2 =>
                                fun v : expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t3 : base.type => expr (type.base t3))
                                  t2 base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (expr
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)))
                                  (fun
                                     a : option
                                           (expr (type.base t2) ->
                                            expr (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       if args0 <=? 0
                                       then
                                        UnderLets.UnderLet
                                          (#(ident.Z_sub_with_get_borrow_concrete
                                               s)%expr @ x' v @ x1 @
                                           ##((- args0)%Z)%expr)%expr_pat
                                          (fun
                                             v0 : var
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)
                                           =>
                                           UnderLets.Base
                                             (#(ident.fst)%expr @ ($v0)%expr,
                                             (-
                                              (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                       else
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry_concrete
                                               s)%expr @ x @ x0 @ x1)%expr_pat
                                   | None =>
                                       UnderLets.Base
                                         (#(ident.Z_add_with_get_carry_concrete
                                              s)%expr @ x @ x0 @ x1)%expr_pat
                                   end)
                            | (s1 -> d0)%ptype =>
                                fun
                                  _ : Compile.value' false s1 ->
                                      Compile.value' true d0 =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                   x @ x0 @ x1)%expr_pat
                            end (Compile.reflect x2)
                        end
                    | ($_)%expr =>
                        match
                          s0 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v0 : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t3 : base.type => expr (type.base t3)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   if args0 <=? 0
                                   then
                                    UnderLets.UnderLet
                                      (#(ident.Z_sub_with_get_borrow_concrete
                                           s)%expr @ x' v0 @ x1 @
                                       ##((- args0)%Z)%expr)%expr_pat
                                      (fun
                                         v1 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v1)%expr,
                                         (-
                                          (#(ident.snd)%expr @ $v1)%expr_pat)%expr)%expr_pat)
                                   else
                                    UnderLets.Base
                                      (#(ident.Z_add_with_get_carry_concrete
                                           s)%expr @ x @ x0 @ x1)%expr_pat
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                      x @ x0 @ x1)%expr_pat
                               end)
                        | (s1 -> d0)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d0 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete s)%expr @
                               x @ x0 @ x1)%expr_pat
                        end (Compile.reflect x2)
                    | @expr.Abs _ _ _ _ _ _ =>
                        match
                          s0 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type => expr (type.base t1)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   if args0 <=? 0
                                   then
                                    UnderLets.UnderLet
                                      (#(ident.Z_sub_with_get_borrow_concrete
                                           s)%expr @ x' v @ x1 @
                                       ##((- args0)%Z)%expr)%expr_pat
                                      (fun
                                         v0 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v0)%expr,
                                         (-
                                          (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                   else
                                    UnderLets.Base
                                      (#(ident.Z_add_with_get_carry_concrete
                                           s)%expr @ x @ x0 @ x1)%expr_pat
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                      x @ x0 @ x1)%expr_pat
                               end)
                        | (s2 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s2 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete s)%expr @
                               x @ x0 @ x1)%expr_pat
                        end (Compile.reflect x2)
                    | @expr.App _ _ _ s1 _ #(idc1)%expr_pat x3 =>
                        match
                          match idc1 with
                          | ident.Z_opp => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match
                              s0 as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (expr
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)))
                            with
                            | type.base t2 =>
                                fun v : expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t3 : base.type => expr (type.base t3))
                                  t2 base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (expr
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)))
                                  (fun
                                     a : option
                                           (expr (type.base t2) ->
                                            expr (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       match
                                         s1 as t3
                                         return
                                           (Compile.value' false t3 ->
                                            UnderLets.UnderLets base.type
                                              ident var
                                              (expr
                                                 (type.base
                                                    (base.type.Z *
                                                     base.type.Z)%etype)))
                                       with
                                       | type.base t3 =>
                                           fun v0 : expr (type.base t3) =>
                                           base.try_make_transport_cps
                                             (fun t4 : base.type =>
                                              expr (type.base t4)) t3
                                             base.type.Z
                                             (UnderLets.UnderLets base.type
                                                ident var
                                                (expr
                                                   (type.base
                                                      (base.type.Z *
                                                       base.type.Z)%etype)))
                                             (fun
                                                a0 : option
                                                       (expr (type.base t3) ->
                                                        expr
                                                          (type.base
                                                             base.type.Z)) =>
                                              match a0 with
                                              | Some x'0 =>
                                                  UnderLets.UnderLet
                                                    (#(ident.Z_sub_with_get_borrow_concrete
                                                         s)%expr @ x' v @ x0 @
                                                     x'0 v0)%expr_pat
                                                    (fun
                                                       v1 : var
                                                              (type.base
                                                                 (base.type.Z *
                                                                  base.type.Z)%etype)
                                                     =>
                                                     UnderLets.Base
                                                       (#(ident.fst)%expr @
                                                        ($v1)%expr,
                                                       (-
                                                        (#(ident.snd)%expr @
                                                         $v1)%expr_pat)%expr)%expr_pat)
                                              | None =>
                                                  UnderLets.Base
                                                    (#(ident.Z_add_with_get_carry_concrete
                                                         s)%expr @ x @ x0 @
                                                     x1)%expr_pat
                                              end)
                                       | (s2 -> d1)%ptype =>
                                           fun
                                             _ : Compile.value' false s2 ->
                                                 Compile.value' true d1 =>
                                           UnderLets.Base
                                             (#(ident.Z_add_with_get_carry_concrete
                                                  s)%expr @ x @ x0 @ x1)%expr_pat
                                       end (Compile.reflect x3)
                                   | None =>
                                       UnderLets.Base
                                         (#(ident.Z_add_with_get_carry_concrete
                                              s)%expr @ x @ x0 @ x1)%expr_pat
                                   end)
                            | (s2 -> d1)%ptype =>
                                fun
                                  _ : Compile.value' false s2 ->
                                      Compile.value' true d1 =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                   x @ x0 @ x1)%expr_pat
                            end (Compile.reflect x2)
                        | None =>
                            match
                              s0 as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (expr
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)))
                            with
                            | type.base t2 =>
                                fun v : expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t3 : base.type => expr (type.base t3))
                                  t2 base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (expr
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)))
                                  (fun
                                     a : option
                                           (expr (type.base t2) ->
                                            expr (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       if args0 <=? 0
                                       then
                                        UnderLets.UnderLet
                                          (#(ident.Z_sub_with_get_borrow_concrete
                                               s)%expr @ x' v @ x1 @
                                           ##((- args0)%Z)%expr)%expr_pat
                                          (fun
                                             v0 : var
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)
                                           =>
                                           UnderLets.Base
                                             (#(ident.fst)%expr @ ($v0)%expr,
                                             (-
                                              (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                       else
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry_concrete
                                               s)%expr @ x @ x0 @ x1)%expr_pat
                                   | None =>
                                       UnderLets.Base
                                         (#(ident.Z_add_with_get_carry_concrete
                                              s)%expr @ x @ x0 @ x1)%expr_pat
                                   end)
                            | (s2 -> d1)%ptype =>
                                fun
                                  _ : Compile.value' false s2 ->
                                      Compile.value' true d1 =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                   x @ x0 @ x1)%expr_pat
                            end (Compile.reflect x2)
                        end
                    | @expr.App _ _ _ s1 _ ($_)%expr _ =>
                        match
                          s0 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v0 : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t3 : base.type => expr (type.base t3)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   if args0 <=? 0
                                   then
                                    UnderLets.UnderLet
                                      (#(ident.Z_sub_with_get_borrow_concrete
                                           s)%expr @ x' v0 @ x1 @
                                       ##((- args0)%Z)%expr)%expr_pat
                                      (fun
                                         v1 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v1)%expr,
                                         (-
                                          (#(ident.snd)%expr @ $v1)%expr_pat)%expr)%expr_pat)
                                   else
                                    UnderLets.Base
                                      (#(ident.Z_add_with_get_carry_concrete
                                           s)%expr @ x @ x0 @ x1)%expr_pat
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                      x @ x0 @ x1)%expr_pat
                               end)
                        | (s2 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s2 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete s)%expr @
                               x @ x0 @ x1)%expr_pat
                        end (Compile.reflect x2)
                    | @expr.App _ _ _ s1 _ (@expr.Abs _ _ _ _ _ _) _ |
                      @expr.App _ _ _ s1 _ (_ @ _)%expr_pat _ =>
                        match
                          s0 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type => expr (type.base t1)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   if args0 <=? 0
                                   then
                                    UnderLets.UnderLet
                                      (#(ident.Z_sub_with_get_borrow_concrete
                                           s)%expr @ x' v @ x1 @
                                       ##((- args0)%Z)%expr)%expr_pat
                                      (fun
                                         v0 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v0)%expr,
                                         (-
                                          (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                   else
                                    UnderLets.Base
                                      (#(ident.Z_add_with_get_carry_concrete
                                           s)%expr @ x @ x0 @ x1)%expr_pat
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                      x @ x0 @ x1)%expr_pat
                               end)
                        | (s3 -> d2)%ptype =>
                            fun
                              _ : Compile.value' false s3 ->
                                  Compile.value' true d2 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete s)%expr @
                               x @ x0 @ x1)%expr_pat
                        end (Compile.reflect x2)
                    | @expr.App _ _ _ s1 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
                        match
                          s0 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type => expr (type.base t1)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   if args0 <=? 0
                                   then
                                    UnderLets.UnderLet
                                      (#(ident.Z_sub_with_get_borrow_concrete
                                           s)%expr @ x' v @ x1 @
                                       ##((- args0)%Z)%expr)%expr_pat
                                      (fun
                                         v0 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v0)%expr,
                                         (-
                                          (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                   else
                                    UnderLets.Base
                                      (#(ident.Z_add_with_get_carry_concrete
                                           s)%expr @ x @ x0 @ x1)%expr_pat
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                      x @ x0 @ x1)%expr_pat
                               end)
                        | (s2 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s2 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete s)%expr @
                               x @ x0 @ x1)%expr_pat
                        end (Compile.reflect x2)
                    | @expr.LetIn _ _ _ _ _ _ _ =>
                        match
                          s0 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type => expr (type.base t1)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   if args0 <=? 0
                                   then
                                    UnderLets.UnderLet
                                      (#(ident.Z_sub_with_get_borrow_concrete
                                           s)%expr @ x' v @ x1 @
                                       ##((- args0)%Z)%expr)%expr_pat
                                      (fun
                                         v0 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v0)%expr,
                                         (-
                                          (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                   else
                                    UnderLets.Base
                                      (#(ident.Z_add_with_get_carry_concrete
                                           s)%expr @ x @ x0 @ x1)%expr_pat
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                      x @ x0 @ x1)%expr_pat
                               end)
                        | (s1 -> d0)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d0 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete s)%expr @
                               x @ x0 @ x1)%expr_pat
                        end (Compile.reflect x2)
                    end
                | None =>
                    match x1 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args0 =>
                            match
                              s0 as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (expr
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)))
                            with
                            | type.base t2 =>
                                fun v : expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t3 : base.type => expr (type.base t3))
                                  t2 base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (expr
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)))
                                  (fun
                                     a : option
                                           (expr (type.base t2) ->
                                            expr (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       if args0 <=? 0
                                       then
                                        UnderLets.UnderLet
                                          (#(ident.Z_sub_with_get_borrow_concrete
                                               s)%expr @ x' v @ x0 @
                                           ##((- args0)%Z)%expr)%expr_pat
                                          (fun
                                             v0 : var
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)
                                           =>
                                           UnderLets.Base
                                             (#(ident.fst)%expr @ ($v0)%expr,
                                             (-
                                              (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                       else
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry_concrete
                                               s)%expr @ x @ x0 @ x1)%expr_pat
                                   | None =>
                                       UnderLets.Base
                                         (#(ident.Z_add_with_get_carry_concrete
                                              s)%expr @ x @ x0 @ x1)%expr_pat
                                   end)
                            | (s1 -> d0)%ptype =>
                                fun
                                  _ : Compile.value' false s1 ->
                                      Compile.value' true d0 =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                   x @ x0 @ x1)%expr_pat
                            end (Compile.reflect x2)
                        | None =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete s)%expr @
                               x @ x0 @ x1)%expr_pat
                        end
                    | @expr.App _ _ _ s1 _ #(idc1)%expr_pat x3 =>
                        match
                          match idc1 with
                          | ident.Z_opp => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match
                              s0 as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (expr
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)))
                            with
                            | type.base t2 =>
                                fun v : expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t3 : base.type => expr (type.base t3))
                                  t2 base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (expr
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)))
                                  (fun
                                     a : option
                                           (expr (type.base t2) ->
                                            expr (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       match
                                         s1 as t3
                                         return
                                           (Compile.value' false t3 ->
                                            UnderLets.UnderLets base.type
                                              ident var
                                              (expr
                                                 (type.base
                                                    (base.type.Z *
                                                     base.type.Z)%etype)))
                                       with
                                       | type.base t3 =>
                                           fun v0 : expr (type.base t3) =>
                                           base.try_make_transport_cps
                                             (fun t4 : base.type =>
                                              expr (type.base t4)) t3
                                             base.type.Z
                                             (UnderLets.UnderLets base.type
                                                ident var
                                                (expr
                                                   (type.base
                                                      (base.type.Z *
                                                       base.type.Z)%etype)))
                                             (fun
                                                a0 : option
                                                       (expr (type.base t3) ->
                                                        expr
                                                          (type.base
                                                             base.type.Z)) =>
                                              match a0 with
                                              | Some x'0 =>
                                                  UnderLets.UnderLet
                                                    (#(ident.Z_sub_with_get_borrow_concrete
                                                         s)%expr @ x' v @ x0 @
                                                     x'0 v0)%expr_pat
                                                    (fun
                                                       v1 : var
                                                              (type.base
                                                                 (base.type.Z *
                                                                  base.type.Z)%etype)
                                                     =>
                                                     UnderLets.Base
                                                       (#(ident.fst)%expr @
                                                        ($v1)%expr,
                                                       (-
                                                        (#(ident.snd)%expr @
                                                         $v1)%expr_pat)%expr)%expr_pat)
                                              | None =>
                                                  UnderLets.Base
                                                    (#(ident.Z_add_with_get_carry_concrete
                                                         s)%expr @ x @ x0 @
                                                     x1)%expr_pat
                                              end)
                                       | (s2 -> d1)%ptype =>
                                           fun
                                             _ : Compile.value' false s2 ->
                                                 Compile.value' true d1 =>
                                           UnderLets.Base
                                             (#(ident.Z_add_with_get_carry_concrete
                                                  s)%expr @ x @ x0 @ x1)%expr_pat
                                       end (Compile.reflect x3)
                                   | None =>
                                       UnderLets.Base
                                         (#(ident.Z_add_with_get_carry_concrete
                                              s)%expr @ x @ x0 @ x1)%expr_pat
                                   end)
                            | (s2 -> d1)%ptype =>
                                fun
                                  _ : Compile.value' false s2 ->
                                      Compile.value' true d1 =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                   x @ x0 @ x1)%expr_pat
                            end (Compile.reflect x2)
                        | None =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete s)%expr @
                               x @ x0 @ x1)%expr_pat
                        end
                    | @expr.App _ _ _ s1 _ ($_)%expr _ | @expr.App _ _ _ s1 _
                      (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s1 _
                      (_ @ _)%expr_pat _ | @expr.App _ _ _ s1 _
                      (@expr.LetIn _ _ _ _ _ _ _) _ =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                           x0 @ x1)%expr_pat
                    | _ =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                           x0 @ x1)%expr_pat
                    end
                end
            | ($_)%expr =>
                match x1 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t2 v0 =>
                          match
                            t2 as t3 return (base.base_interp t3 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v1 : Z => Some v1
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v0
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        match
                          s0 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v0 : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t3 : base.type => expr (type.base t3)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   if args0 <=? 0
                                   then
                                    UnderLets.UnderLet
                                      (#(ident.Z_sub_with_get_borrow_concrete
                                           s)%expr @ x' v0 @ x0 @
                                       ##((- args0)%Z)%expr)%expr_pat
                                      (fun
                                         v1 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v1)%expr,
                                         (-
                                          (#(ident.snd)%expr @ $v1)%expr_pat)%expr)%expr_pat)
                                   else
                                    UnderLets.Base
                                      (#(ident.Z_add_with_get_carry_concrete
                                           s)%expr @ x @ x0 @ x1)%expr_pat
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                      x @ x0 @ x1)%expr_pat
                               end)
                        | (s1 -> d0)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d0 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete s)%expr @
                               x @ x0 @ x1)%expr_pat
                        end (Compile.reflect x2)
                    | None =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                           x0 @ x1)%expr_pat
                    end
                | @expr.App _ _ _ s1 _ #(idc0)%expr_pat x3 =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s0 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v0 : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t3 : base.type => expr (type.base t3)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   match
                                     s1 as t3
                                     return
                                       (Compile.value' false t3 ->
                                        UnderLets.UnderLets base.type ident
                                          var
                                          (expr
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)))
                                   with
                                   | type.base t3 =>
                                       fun v1 : expr (type.base t3) =>
                                       base.try_make_transport_cps
                                         (fun t4 : base.type =>
                                          expr (type.base t4)) t3 base.type.Z
                                         (UnderLets.UnderLets base.type ident
                                            var
                                            (expr
                                               (type.base
                                                  (base.type.Z * base.type.Z)%etype)))
                                         (fun
                                            a0 : option
                                                   (expr (type.base t3) ->
                                                    expr
                                                      (type.base base.type.Z))
                                          =>
                                          match a0 with
                                          | Some x'0 =>
                                              UnderLets.UnderLet
                                                (#(ident.Z_sub_with_get_borrow_concrete
                                                     s)%expr @ x' v0 @ x0 @
                                                 x'0 v1)%expr_pat
                                                (fun
                                                   v2 : var
                                                          (type.base
                                                             (base.type.Z *
                                                              base.type.Z)%etype)
                                                 =>
                                                 UnderLets.Base
                                                   (#(ident.fst)%expr @
                                                    ($v2)%expr,
                                                   (-
                                                    (#(ident.snd)%expr @ $v2)%expr_pat)%expr)%expr_pat)
                                          | None =>
                                              UnderLets.Base
                                                (#(ident.Z_add_with_get_carry_concrete
                                                     s)%expr @ x @ x0 @ x1)%expr_pat
                                          end)
                                   | (s2 -> d1)%ptype =>
                                       fun
                                         _ : Compile.value' false s2 ->
                                             Compile.value' true d1 =>
                                       UnderLets.Base
                                         (#(ident.Z_add_with_get_carry_concrete
                                              s)%expr @ x @ x0 @ x1)%expr_pat
                                   end (Compile.reflect x3)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                      x @ x0 @ x1)%expr_pat
                               end)
                        | (s2 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s2 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete s)%expr @
                               x @ x0 @ x1)%expr_pat
                        end (Compile.reflect x2)
                    | None =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                           x0 @ x1)%expr_pat
                    end
                | @expr.App _ _ _ s1 _ ($_)%expr _ | @expr.App _ _ _ s1 _
                  (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s1 _
                  (_ @ _)%expr_pat _ | @expr.App _ _ _ s1 _
                  (@expr.LetIn _ _ _ _ _ _ _) _ =>
                    UnderLets.Base
                      (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @
                       x1)%expr_pat
                | _ =>
                    UnderLets.Base
                      (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @
                       x1)%expr_pat
                end
            | @expr.Abs _ _ _ _ _ _ =>
                match x1 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t1 v =>
                          match
                            t1 as t2 return (base.base_interp t2 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v0 : Z => Some v0
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        match
                          s0 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type => expr (type.base t1)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   if args0 <=? 0
                                   then
                                    UnderLets.UnderLet
                                      (#(ident.Z_sub_with_get_borrow_concrete
                                           s)%expr @ x' v @ x0 @
                                       ##((- args0)%Z)%expr)%expr_pat
                                      (fun
                                         v0 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v0)%expr,
                                         (-
                                          (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                   else
                                    UnderLets.Base
                                      (#(ident.Z_add_with_get_carry_concrete
                                           s)%expr @ x @ x0 @ x1)%expr_pat
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                      x @ x0 @ x1)%expr_pat
                               end)
                        | (s2 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s2 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete s)%expr @
                               x @ x0 @ x1)%expr_pat
                        end (Compile.reflect x2)
                    | None =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                           x0 @ x1)%expr_pat
                    end
                | @expr.App _ _ _ s2 _ #(idc0)%expr_pat x3 =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s0 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type => expr (type.base t1)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   match
                                     s2 as t3
                                     return
                                       (Compile.value' false t3 ->
                                        UnderLets.UnderLets base.type ident
                                          var
                                          (expr
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)))
                                   with
                                   | type.base t3 =>
                                       fun v0 : expr (type.base t3) =>
                                       base.try_make_transport_cps
                                         (fun t1 : base.type =>
                                          expr (type.base t1)) t3 base.type.Z
                                         (UnderLets.UnderLets base.type ident
                                            var
                                            (expr
                                               (type.base
                                                  (base.type.Z * base.type.Z)%etype)))
                                         (fun
                                            a0 : option
                                                   (expr (type.base t3) ->
                                                    expr
                                                      (type.base base.type.Z))
                                          =>
                                          match a0 with
                                          | Some x'0 =>
                                              UnderLets.UnderLet
                                                (#(ident.Z_sub_with_get_borrow_concrete
                                                     s)%expr @ x' v @ x0 @
                                                 x'0 v0)%expr_pat
                                                (fun
                                                   v1 : var
                                                          (type.base
                                                             (base.type.Z *
                                                              base.type.Z)%etype)
                                                 =>
                                                 UnderLets.Base
                                                   (#(ident.fst)%expr @
                                                    ($v1)%expr,
                                                   (-
                                                    (#(ident.snd)%expr @ $v1)%expr_pat)%expr)%expr_pat)
                                          | None =>
                                              UnderLets.Base
                                                (#(ident.Z_add_with_get_carry_concrete
                                                     s)%expr @ x @ x0 @ x1)%expr_pat
                                          end)
                                   | (s3 -> d2)%ptype =>
                                       fun
                                         _ : Compile.value' false s3 ->
                                             Compile.value' true d2 =>
                                       UnderLets.Base
                                         (#(ident.Z_add_with_get_carry_concrete
                                              s)%expr @ x @ x0 @ x1)%expr_pat
                                   end (Compile.reflect x3)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                      x @ x0 @ x1)%expr_pat
                               end)
                        | (s3 -> d2)%ptype =>
                            fun
                              _ : Compile.value' false s3 ->
                                  Compile.value' true d2 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete s)%expr @
                               x @ x0 @ x1)%expr_pat
                        end (Compile.reflect x2)
                    | None =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                           x0 @ x1)%expr_pat
                    end
                | @expr.App _ _ _ s2 _ ($_)%expr _ | @expr.App _ _ _ s2 _
                  (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s2 _
                  (_ @ _)%expr_pat _ | @expr.App _ _ _ s2 _
                  (@expr.LetIn _ _ _ _ _ _ _) _ =>
                    UnderLets.Base
                      (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @
                       x1)%expr_pat
                | _ =>
                    UnderLets.Base
                      (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @
                       x1)%expr_pat
                end
            | @expr.App _ _ _ s1 _ #(idc0)%expr_pat x3 =>
                match
                  match idc0 with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => expr (type.base t1)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               match
                                 s1 as t3
                                 return
                                   (Compile.value' false t3 ->
                                    UnderLets.UnderLets base.type ident var
                                      (expr
                                         (type.base
                                            (base.type.Z * base.type.Z)%etype)))
                               with
                               | type.base t3 =>
                                   fun v0 : expr (type.base t3) =>
                                   base.try_make_transport_cps
                                     (fun t1 : base.type =>
                                      expr (type.base t1)) t3 base.type.Z
                                     (UnderLets.UnderLets base.type ident var
                                        (expr
                                           (type.base
                                              (base.type.Z * base.type.Z)%etype)))
                                     (fun
                                        a0 : option
                                               (expr (type.base t3) ->
                                                expr (type.base base.type.Z))
                                      =>
                                      match a0 with
                                      | Some x'0 =>
                                          UnderLets.UnderLet
                                            (#(ident.Z_sub_with_get_borrow_concrete
                                                 s)%expr @ x' v @ x1 @ 
                                             x'0 v0)%expr_pat
                                            (fun
                                               v1 : var
                                                      (type.base
                                                         (base.type.Z *
                                                          base.type.Z)%etype)
                                             =>
                                             UnderLets.Base
                                               (#(ident.fst)%expr @
                                                ($v1)%expr,
                                               (-
                                                (#(ident.snd)%expr @ $v1)%expr_pat)%expr)%expr_pat)
                                      | None =>
                                          UnderLets.Base
                                            (#(ident.Z_add_with_get_carry_concrete
                                                 s)%expr @ x @ x0 @ x1)%expr_pat
                                      end)
                               | (s2 -> d1)%ptype =>
                                   fun
                                     _ : Compile.value' false s2 ->
                                         Compile.value' true d1 =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                      x @ x0 @ x1)%expr_pat
                               end (Compile.reflect x3)
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                  x @ x0 @ x1)%expr_pat
                           end)
                    | (s2 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s2 ->
                              Compile.value' true d1 =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                           x0 @ x1)%expr_pat
                    end (Compile.reflect x2)
                | None =>
                    match x1 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args0 =>
                            match
                              s0 as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (expr
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)))
                            with
                            | type.base t2 =>
                                fun v : expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t3 : base.type => expr (type.base t3))
                                  t2 base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (expr
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)))
                                  (fun
                                     a : option
                                           (expr (type.base t2) ->
                                            expr (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       if args0 <=? 0
                                       then
                                        UnderLets.UnderLet
                                          (#(ident.Z_sub_with_get_borrow_concrete
                                               s)%expr @ x' v @ x0 @
                                           ##((- args0)%Z)%expr)%expr_pat
                                          (fun
                                             v0 : var
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)
                                           =>
                                           UnderLets.Base
                                             (#(ident.fst)%expr @ ($v0)%expr,
                                             (-
                                              (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                       else
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry_concrete
                                               s)%expr @ x @ x0 @ x1)%expr_pat
                                   | None =>
                                       UnderLets.Base
                                         (#(ident.Z_add_with_get_carry_concrete
                                              s)%expr @ x @ x0 @ x1)%expr_pat
                                   end)
                            | (s2 -> d1)%ptype =>
                                fun
                                  _ : Compile.value' false s2 ->
                                      Compile.value' true d1 =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                   x @ x0 @ x1)%expr_pat
                            end (Compile.reflect x2)
                        | None =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete s)%expr @
                               x @ x0 @ x1)%expr_pat
                        end
                    | @expr.App _ _ _ s2 _ #(idc1)%expr_pat x4 =>
                        match
                          match idc1 with
                          | ident.Z_opp => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match
                              s0 as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (expr
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)))
                            with
                            | type.base t2 =>
                                fun v : expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t3 : base.type => expr (type.base t3))
                                  t2 base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (expr
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)))
                                  (fun
                                     a : option
                                           (expr (type.base t2) ->
                                            expr (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       match
                                         s2 as t3
                                         return
                                           (Compile.value' false t3 ->
                                            UnderLets.UnderLets base.type
                                              ident var
                                              (expr
                                                 (type.base
                                                    (base.type.Z *
                                                     base.type.Z)%etype)))
                                       with
                                       | type.base t3 =>
                                           fun v0 : expr (type.base t3) =>
                                           base.try_make_transport_cps
                                             (fun t4 : base.type =>
                                              expr (type.base t4)) t3
                                             base.type.Z
                                             (UnderLets.UnderLets base.type
                                                ident var
                                                (expr
                                                   (type.base
                                                      (base.type.Z *
                                                       base.type.Z)%etype)))
                                             (fun
                                                a0 : option
                                                       (expr (type.base t3) ->
                                                        expr
                                                          (type.base
                                                             base.type.Z)) =>
                                              match a0 with
                                              | Some x'0 =>
                                                  UnderLets.UnderLet
                                                    (#(ident.Z_sub_with_get_borrow_concrete
                                                         s)%expr @ x' v @ x0 @
                                                     x'0 v0)%expr_pat
                                                    (fun
                                                       v1 : var
                                                              (type.base
                                                                 (base.type.Z *
                                                                  base.type.Z)%etype)
                                                     =>
                                                     UnderLets.Base
                                                       (#(ident.fst)%expr @
                                                        ($v1)%expr,
                                                       (-
                                                        (#(ident.snd)%expr @
                                                         $v1)%expr_pat)%expr)%expr_pat)
                                              | None =>
                                                  UnderLets.Base
                                                    (#(ident.Z_add_with_get_carry_concrete
                                                         s)%expr @ x @ x0 @
                                                     x1)%expr_pat
                                              end)
                                       | (s3 -> d2)%ptype =>
                                           fun
                                             _ : Compile.value' false s3 ->
                                                 Compile.value' true d2 =>
                                           UnderLets.Base
                                             (#(ident.Z_add_with_get_carry_concrete
                                                  s)%expr @ x @ x0 @ x1)%expr_pat
                                       end (Compile.reflect x4)
                                   | None =>
                                       UnderLets.Base
                                         (#(ident.Z_add_with_get_carry_concrete
                                              s)%expr @ x @ x0 @ x1)%expr_pat
                                   end)
                            | (s3 -> d2)%ptype =>
                                fun
                                  _ : Compile.value' false s3 ->
                                      Compile.value' true d2 =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                   x @ x0 @ x1)%expr_pat
                            end (Compile.reflect x2)
                        | None =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete s)%expr @
                               x @ x0 @ x1)%expr_pat
                        end
                    | @expr.App _ _ _ s2 _ ($_)%expr _ | @expr.App _ _ _ s2 _
                      (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s2 _
                      (_ @ _)%expr_pat _ | @expr.App _ _ _ s2 _
                      (@expr.LetIn _ _ _ _ _ _ _) _ =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                           x0 @ x1)%expr_pat
                    | _ =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                           x0 @ x1)%expr_pat
                    end
                end
            | @expr.App _ _ _ s1 _ ($_)%expr _ =>
                match x1 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t2 v0 =>
                          match
                            t2 as t3 return (base.base_interp t3 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v1 : Z => Some v1
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v0
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        match
                          s0 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v0 : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t3 : base.type => expr (type.base t3)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   if args0 <=? 0
                                   then
                                    UnderLets.UnderLet
                                      (#(ident.Z_sub_with_get_borrow_concrete
                                           s)%expr @ x' v0 @ x0 @
                                       ##((- args0)%Z)%expr)%expr_pat
                                      (fun
                                         v1 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v1)%expr,
                                         (-
                                          (#(ident.snd)%expr @ $v1)%expr_pat)%expr)%expr_pat)
                                   else
                                    UnderLets.Base
                                      (#(ident.Z_add_with_get_carry_concrete
                                           s)%expr @ x @ x0 @ x1)%expr_pat
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                      x @ x0 @ x1)%expr_pat
                               end)
                        | (s2 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s2 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete s)%expr @
                               x @ x0 @ x1)%expr_pat
                        end (Compile.reflect x2)
                    | None =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                           x0 @ x1)%expr_pat
                    end
                | @expr.App _ _ _ s2 _ #(idc0)%expr_pat x4 =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s0 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v0 : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t3 : base.type => expr (type.base t3)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   match
                                     s2 as t3
                                     return
                                       (Compile.value' false t3 ->
                                        UnderLets.UnderLets base.type ident
                                          var
                                          (expr
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)))
                                   with
                                   | type.base t3 =>
                                       fun v1 : expr (type.base t3) =>
                                       base.try_make_transport_cps
                                         (fun t4 : base.type =>
                                          expr (type.base t4)) t3 base.type.Z
                                         (UnderLets.UnderLets base.type ident
                                            var
                                            (expr
                                               (type.base
                                                  (base.type.Z * base.type.Z)%etype)))
                                         (fun
                                            a0 : option
                                                   (expr (type.base t3) ->
                                                    expr
                                                      (type.base base.type.Z))
                                          =>
                                          match a0 with
                                          | Some x'0 =>
                                              UnderLets.UnderLet
                                                (#(ident.Z_sub_with_get_borrow_concrete
                                                     s)%expr @ x' v0 @ x0 @
                                                 x'0 v1)%expr_pat
                                                (fun
                                                   v2 : var
                                                          (type.base
                                                             (base.type.Z *
                                                              base.type.Z)%etype)
                                                 =>
                                                 UnderLets.Base
                                                   (#(ident.fst)%expr @
                                                    ($v2)%expr,
                                                   (-
                                                    (#(ident.snd)%expr @ $v2)%expr_pat)%expr)%expr_pat)
                                          | None =>
                                              UnderLets.Base
                                                (#(ident.Z_add_with_get_carry_concrete
                                                     s)%expr @ x @ x0 @ x1)%expr_pat
                                          end)
                                   | (s3 -> d2)%ptype =>
                                       fun
                                         _ : Compile.value' false s3 ->
                                             Compile.value' true d2 =>
                                       UnderLets.Base
                                         (#(ident.Z_add_with_get_carry_concrete
                                              s)%expr @ x @ x0 @ x1)%expr_pat
                                   end (Compile.reflect x4)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                      x @ x0 @ x1)%expr_pat
                               end)
                        | (s3 -> d2)%ptype =>
                            fun
                              _ : Compile.value' false s3 ->
                                  Compile.value' true d2 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete s)%expr @
                               x @ x0 @ x1)%expr_pat
                        end (Compile.reflect x2)
                    | None =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                           x0 @ x1)%expr_pat
                    end
                | @expr.App _ _ _ s2 _ ($_)%expr _ | @expr.App _ _ _ s2 _
                  (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s2 _
                  (_ @ _)%expr_pat _ | @expr.App _ _ _ s2 _
                  (@expr.LetIn _ _ _ _ _ _ _) _ =>
                    UnderLets.Base
                      (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @
                       x1)%expr_pat
                | _ =>
                    UnderLets.Base
                      (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @
                       x1)%expr_pat
                end
            | @expr.App _ _ _ s1 _ (@expr.Abs _ _ _ _ _ _) _ =>
                match x1 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t1 v =>
                          match
                            t1 as t2 return (base.base_interp t2 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v0 : Z => Some v0
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        match
                          s0 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type => expr (type.base t1)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   if args0 <=? 0
                                   then
                                    UnderLets.UnderLet
                                      (#(ident.Z_sub_with_get_borrow_concrete
                                           s)%expr @ x' v @ x0 @
                                       ##((- args0)%Z)%expr)%expr_pat
                                      (fun
                                         v0 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v0)%expr,
                                         (-
                                          (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                   else
                                    UnderLets.Base
                                      (#(ident.Z_add_with_get_carry_concrete
                                           s)%expr @ x @ x0 @ x1)%expr_pat
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                      x @ x0 @ x1)%expr_pat
                               end)
                        | (s3 -> d2)%ptype =>
                            fun
                              _ : Compile.value' false s3 ->
                                  Compile.value' true d2 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete s)%expr @
                               x @ x0 @ x1)%expr_pat
                        end (Compile.reflect x2)
                    | None =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                           x0 @ x1)%expr_pat
                    end
                | @expr.App _ _ _ s3 _ #(idc0)%expr_pat x4 =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s0 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type => expr (type.base t1)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   match
                                     s3 as t3
                                     return
                                       (Compile.value' false t3 ->
                                        UnderLets.UnderLets base.type ident
                                          var
                                          (expr
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)))
                                   with
                                   | type.base t3 =>
                                       fun v0 : expr (type.base t3) =>
                                       base.try_make_transport_cps
                                         (fun t1 : base.type =>
                                          expr (type.base t1)) t3 base.type.Z
                                         (UnderLets.UnderLets base.type ident
                                            var
                                            (expr
                                               (type.base
                                                  (base.type.Z * base.type.Z)%etype)))
                                         (fun
                                            a0 : option
                                                   (expr (type.base t3) ->
                                                    expr
                                                      (type.base base.type.Z))
                                          =>
                                          match a0 with
                                          | Some x'0 =>
                                              UnderLets.UnderLet
                                                (#(ident.Z_sub_with_get_borrow_concrete
                                                     s)%expr @ x' v @ x0 @
                                                 x'0 v0)%expr_pat
                                                (fun
                                                   v1 : var
                                                          (type.base
                                                             (base.type.Z *
                                                              base.type.Z)%etype)
                                                 =>
                                                 UnderLets.Base
                                                   (#(ident.fst)%expr @
                                                    ($v1)%expr,
                                                   (-
                                                    (#(ident.snd)%expr @ $v1)%expr_pat)%expr)%expr_pat)
                                          | None =>
                                              UnderLets.Base
                                                (#(ident.Z_add_with_get_carry_concrete
                                                     s)%expr @ x @ x0 @ x1)%expr_pat
                                          end)
                                   | (s4 -> d3)%ptype =>
                                       fun
                                         _ : Compile.value' false s4 ->
                                             Compile.value' true d3 =>
                                       UnderLets.Base
                                         (#(ident.Z_add_with_get_carry_concrete
                                              s)%expr @ x @ x0 @ x1)%expr_pat
                                   end (Compile.reflect x4)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                      x @ x0 @ x1)%expr_pat
                               end)
                        | (s4 -> d3)%ptype =>
                            fun
                              _ : Compile.value' false s4 ->
                                  Compile.value' true d3 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete s)%expr @
                               x @ x0 @ x1)%expr_pat
                        end (Compile.reflect x2)
                    | None =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                           x0 @ x1)%expr_pat
                    end
                | @expr.App _ _ _ s3 _ ($_)%expr _ | @expr.App _ _ _ s3 _
                  (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s3 _
                  (_ @ _)%expr_pat _ | @expr.App _ _ _ s3 _
                  (@expr.LetIn _ _ _ _ _ _ _) _ =>
                    UnderLets.Base
                      (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @
                       x1)%expr_pat
                | _ =>
                    UnderLets.Base
                      (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @
                       x1)%expr_pat
                end
            | @expr.App _ _ _ s1 _ (_ @ _)%expr_pat _ =>
                match x1 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t1 v =>
                          match
                            t1 as t2 return (base.base_interp t2 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v0 : Z => Some v0
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        match
                          s0 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type => expr (type.base t1)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   if args0 <=? 0
                                   then
                                    UnderLets.UnderLet
                                      (#(ident.Z_sub_with_get_borrow_concrete
                                           s)%expr @ x' v @ x0 @
                                       ##((- args0)%Z)%expr)%expr_pat
                                      (fun
                                         v0 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v0)%expr,
                                         (-
                                          (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                   else
                                    UnderLets.Base
                                      (#(ident.Z_add_with_get_carry_concrete
                                           s)%expr @ x @ x0 @ x1)%expr_pat
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                      x @ x0 @ x1)%expr_pat
                               end)
                        | (s3 -> d2)%ptype =>
                            fun
                              _ : Compile.value' false s3 ->
                                  Compile.value' true d2 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete s)%expr @
                               x @ x0 @ x1)%expr_pat
                        end (Compile.reflect x2)
                    | None =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                           x0 @ x1)%expr_pat
                    end
                | @expr.App _ _ _ s3 _ #(idc0)%expr_pat x5 =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s0 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type => expr (type.base t1)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   match
                                     s3 as t3
                                     return
                                       (Compile.value' false t3 ->
                                        UnderLets.UnderLets base.type ident
                                          var
                                          (expr
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)))
                                   with
                                   | type.base t3 =>
                                       fun v0 : expr (type.base t3) =>
                                       base.try_make_transport_cps
                                         (fun t1 : base.type =>
                                          expr (type.base t1)) t3 base.type.Z
                                         (UnderLets.UnderLets base.type ident
                                            var
                                            (expr
                                               (type.base
                                                  (base.type.Z * base.type.Z)%etype)))
                                         (fun
                                            a0 : option
                                                   (expr (type.base t3) ->
                                                    expr
                                                      (type.base base.type.Z))
                                          =>
                                          match a0 with
                                          | Some x'0 =>
                                              UnderLets.UnderLet
                                                (#(ident.Z_sub_with_get_borrow_concrete
                                                     s)%expr @ x' v @ x0 @
                                                 x'0 v0)%expr_pat
                                                (fun
                                                   v1 : var
                                                          (type.base
                                                             (base.type.Z *
                                                              base.type.Z)%etype)
                                                 =>
                                                 UnderLets.Base
                                                   (#(ident.fst)%expr @
                                                    ($v1)%expr,
                                                   (-
                                                    (#(ident.snd)%expr @ $v1)%expr_pat)%expr)%expr_pat)
                                          | None =>
                                              UnderLets.Base
                                                (#(ident.Z_add_with_get_carry_concrete
                                                     s)%expr @ x @ x0 @ x1)%expr_pat
                                          end)
                                   | (s4 -> d3)%ptype =>
                                       fun
                                         _ : Compile.value' false s4 ->
                                             Compile.value' true d3 =>
                                       UnderLets.Base
                                         (#(ident.Z_add_with_get_carry_concrete
                                              s)%expr @ x @ x0 @ x1)%expr_pat
                                   end (Compile.reflect x5)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                      x @ x0 @ x1)%expr_pat
                               end)
                        | (s4 -> d3)%ptype =>
                            fun
                              _ : Compile.value' false s4 ->
                                  Compile.value' true d3 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete s)%expr @
                               x @ x0 @ x1)%expr_pat
                        end (Compile.reflect x2)
                    | None =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                           x0 @ x1)%expr_pat
                    end
                | @expr.App _ _ _ s3 _ ($_)%expr _ | @expr.App _ _ _ s3 _
                  (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s3 _
                  (_ @ _)%expr_pat _ | @expr.App _ _ _ s3 _
                  (@expr.LetIn _ _ _ _ _ _ _) _ =>
                    UnderLets.Base
                      (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @
                       x1)%expr_pat
                | _ =>
                    UnderLets.Base
                      (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @
                       x1)%expr_pat
                end
            | @expr.App _ _ _ s1 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
                match x1 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t1 v =>
                          match
                            t1 as t2 return (base.base_interp t2 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v0 : Z => Some v0
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        match
                          s0 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type => expr (type.base t1)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   if args0 <=? 0
                                   then
                                    UnderLets.UnderLet
                                      (#(ident.Z_sub_with_get_borrow_concrete
                                           s)%expr @ x' v @ x0 @
                                       ##((- args0)%Z)%expr)%expr_pat
                                      (fun
                                         v0 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v0)%expr,
                                         (-
                                          (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                   else
                                    UnderLets.Base
                                      (#(ident.Z_add_with_get_carry_concrete
                                           s)%expr @ x @ x0 @ x1)%expr_pat
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                      x @ x0 @ x1)%expr_pat
                               end)
                        | (s2 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s2 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete s)%expr @
                               x @ x0 @ x1)%expr_pat
                        end (Compile.reflect x2)
                    | None =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                           x0 @ x1)%expr_pat
                    end
                | @expr.App _ _ _ s2 _ #(idc0)%expr_pat x5 =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s0 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type => expr (type.base t1)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   match
                                     s2 as t3
                                     return
                                       (Compile.value' false t3 ->
                                        UnderLets.UnderLets base.type ident
                                          var
                                          (expr
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)))
                                   with
                                   | type.base t3 =>
                                       fun v0 : expr (type.base t3) =>
                                       base.try_make_transport_cps
                                         (fun t1 : base.type =>
                                          expr (type.base t1)) t3 base.type.Z
                                         (UnderLets.UnderLets base.type ident
                                            var
                                            (expr
                                               (type.base
                                                  (base.type.Z * base.type.Z)%etype)))
                                         (fun
                                            a0 : option
                                                   (expr (type.base t3) ->
                                                    expr
                                                      (type.base base.type.Z))
                                          =>
                                          match a0 with
                                          | Some x'0 =>
                                              UnderLets.UnderLet
                                                (#(ident.Z_sub_with_get_borrow_concrete
                                                     s)%expr @ x' v @ x0 @
                                                 x'0 v0)%expr_pat
                                                (fun
                                                   v1 : var
                                                          (type.base
                                                             (base.type.Z *
                                                              base.type.Z)%etype)
                                                 =>
                                                 UnderLets.Base
                                                   (#(ident.fst)%expr @
                                                    ($v1)%expr,
                                                   (-
                                                    (#(ident.snd)%expr @ $v1)%expr_pat)%expr)%expr_pat)
                                          | None =>
                                              UnderLets.Base
                                                (#(ident.Z_add_with_get_carry_concrete
                                                     s)%expr @ x @ x0 @ x1)%expr_pat
                                          end)
                                   | (s3 -> d2)%ptype =>
                                       fun
                                         _ : Compile.value' false s3 ->
                                             Compile.value' true d2 =>
                                       UnderLets.Base
                                         (#(ident.Z_add_with_get_carry_concrete
                                              s)%expr @ x @ x0 @ x1)%expr_pat
                                   end (Compile.reflect x5)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                      x @ x0 @ x1)%expr_pat
                               end)
                        | (s3 -> d2)%ptype =>
                            fun
                              _ : Compile.value' false s3 ->
                                  Compile.value' true d2 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete s)%expr @
                               x @ x0 @ x1)%expr_pat
                        end (Compile.reflect x2)
                    | None =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                           x0 @ x1)%expr_pat
                    end
                | @expr.App _ _ _ s2 _ ($_)%expr _ | @expr.App _ _ _ s2 _
                  (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s2 _
                  (_ @ _)%expr_pat _ | @expr.App _ _ _ s2 _
                  (@expr.LetIn _ _ _ _ _ _ _) _ =>
                    UnderLets.Base
                      (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @
                       x1)%expr_pat
                | _ =>
                    UnderLets.Base
                      (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @
                       x1)%expr_pat
                end
            | @expr.LetIn _ _ _ _ _ _ _ =>
                match x1 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t1 v =>
                          match
                            t1 as t2 return (base.base_interp t2 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v0 : Z => Some v0
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        match
                          s0 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type => expr (type.base t1)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   if args0 <=? 0
                                   then
                                    UnderLets.UnderLet
                                      (#(ident.Z_sub_with_get_borrow_concrete
                                           s)%expr @ x' v @ x0 @
                                       ##((- args0)%Z)%expr)%expr_pat
                                      (fun
                                         v0 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v0)%expr,
                                         (-
                                          (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                   else
                                    UnderLets.Base
                                      (#(ident.Z_add_with_get_carry_concrete
                                           s)%expr @ x @ x0 @ x1)%expr_pat
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                      x @ x0 @ x1)%expr_pat
                               end)
                        | (s1 -> d0)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d0 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete s)%expr @
                               x @ x0 @ x1)%expr_pat
                        end (Compile.reflect x2)
                    | None =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                           x0 @ x1)%expr_pat
                    end
                | @expr.App _ _ _ s1 _ #(idc0)%expr_pat x4 =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s0 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type => expr (type.base t1)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   match
                                     s1 as t3
                                     return
                                       (Compile.value' false t3 ->
                                        UnderLets.UnderLets base.type ident
                                          var
                                          (expr
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)))
                                   with
                                   | type.base t3 =>
                                       fun v0 : expr (type.base t3) =>
                                       base.try_make_transport_cps
                                         (fun t1 : base.type =>
                                          expr (type.base t1)) t3 base.type.Z
                                         (UnderLets.UnderLets base.type ident
                                            var
                                            (expr
                                               (type.base
                                                  (base.type.Z * base.type.Z)%etype)))
                                         (fun
                                            a0 : option
                                                   (expr (type.base t3) ->
                                                    expr
                                                      (type.base base.type.Z))
                                          =>
                                          match a0 with
                                          | Some x'0 =>
                                              UnderLets.UnderLet
                                                (#(ident.Z_sub_with_get_borrow_concrete
                                                     s)%expr @ x' v @ x0 @
                                                 x'0 v0)%expr_pat
                                                (fun
                                                   v1 : var
                                                          (type.base
                                                             (base.type.Z *
                                                              base.type.Z)%etype)
                                                 =>
                                                 UnderLets.Base
                                                   (#(ident.fst)%expr @
                                                    ($v1)%expr,
                                                   (-
                                                    (#(ident.snd)%expr @ $v1)%expr_pat)%expr)%expr_pat)
                                          | None =>
                                              UnderLets.Base
                                                (#(ident.Z_add_with_get_carry_concrete
                                                     s)%expr @ x @ x0 @ x1)%expr_pat
                                          end)
                                   | (s2 -> d1)%ptype =>
                                       fun
                                         _ : Compile.value' false s2 ->
                                             Compile.value' true d1 =>
                                       UnderLets.Base
                                         (#(ident.Z_add_with_get_carry_concrete
                                              s)%expr @ x @ x0 @ x1)%expr_pat
                                   end (Compile.reflect x4)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                      x @ x0 @ x1)%expr_pat
                               end)
                        | (s2 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s2 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete s)%expr @
                               x @ x0 @ x1)%expr_pat
                        end (Compile.reflect x2)
                    | None =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                           x0 @ x1)%expr_pat
                    end
                | @expr.App _ _ _ s1 _ ($_)%expr _ | @expr.App _ _ _ s1 _
                  (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s1 _
                  (_ @ _)%expr_pat _ | @expr.App _ _ _ s1 _
                  (@expr.LetIn _ _ _ _ _ _ _) _ =>
                    UnderLets.Base
                      (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @
                       x1)%expr_pat
                | _ =>
                    UnderLets.Base
                      (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @
                       x1)%expr_pat
                end
            end
        | None =>
            UnderLets.Base
              (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @ x1)%expr_pat
        end
    | @expr.App _ _ _ s0 _ ($_)%expr _ | @expr.App _ _ _ s0 _
      (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0 _ (_ @ _)%expr_pat _ |
      @expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
        UnderLets.Base
          (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @ x1)%expr_pat
    | _ =>
        UnderLets.Base
          (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @ x1)%expr_pat
    end
| ident.Z_sub_get_borrow =>
    fun x x0 x1 : expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 =>
                    match x1 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args1 =>
                            UnderLets.Base
                              (let
                               '(a, b) :=
                                Definitions.Z.sub_get_borrow_full args args0
                                  args1 in (##(a)%expr, ##(b)%expr)%expr_pat)
                        | None =>
                            UnderLets.Base
                              (#(ident.Z_sub_get_borrow_concrete args)%expr @
                               x0 @ x1)%expr_pat
                        end
                    | _ =>
                        UnderLets.Base
                          (#(ident.Z_sub_get_borrow_concrete args)%expr @ x0 @
                           x1)%expr_pat
                    end
                | None =>
                    UnderLets.Base
                      (#(ident.Z_sub_get_borrow_concrete args)%expr @ x0 @ x1)%expr_pat
                end
            | _ =>
                UnderLets.Base
                  (#(ident.Z_sub_get_borrow_concrete args)%expr @ x0 @ x1)%expr_pat
            end
        | None =>
            UnderLets.Base
              (#(ident.Z_sub_get_borrow)%expr @ x @ x0 @ x1)%expr_pat
        end
    | _ =>
        UnderLets.Base
          (#(ident.Z_sub_get_borrow)%expr @ x @ x0 @ x1)%expr_pat
    end
| ident.Z_sub_get_borrow_concrete s =>
    fun x x0 : expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 =>
                    UnderLets.Base
                      (let
                       '(a, b) :=
                        Definitions.Z.sub_get_borrow_full s args args0 in
                        (##(a)%expr, ##(b)%expr)%expr_pat)
                | None =>
                    UnderLets.Base
                      (#(ident.Z_sub_get_borrow_concrete s)%expr @ x @ x0)%expr_pat
                end
            | _ =>
                UnderLets.Base
                  (#(ident.Z_sub_get_borrow_concrete s)%expr @ x @ x0)%expr_pat
            end
        | None =>
            UnderLets.Base
              (#(ident.Z_sub_get_borrow_concrete s)%expr @ x @ x0)%expr_pat
        end
    | _ =>
        UnderLets.Base
          (#(ident.Z_sub_get_borrow_concrete s)%expr @ x @ x0)%expr_pat
    end
| ident.Z_sub_with_get_borrow =>
    fun x x0 x1 x2 : expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 =>
                    match x1 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args1 =>
                            match x2 with
                            | #(idc2)%expr_pat =>
                                match
                                  match idc2 with
                                  | @ident.Literal t3 v =>
                                      match
                                        t3 as t4
                                        return
                                          (base.base_interp t4 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args2 =>
                                    UnderLets.Base
                                      (let
                                       '(a, b) :=
                                        Definitions.Z.sub_with_get_borrow_full
                                          args args0 args1 args2 in
                                        (##(a)%expr, ##(b)%expr)%expr_pat)
                                | None =>
                                    UnderLets.Base
                                      (#(ident.Z_sub_with_get_borrow_concrete
                                           args)%expr @ x0 @ x1 @ x2)%expr_pat
                                end
                            | _ =>
                                UnderLets.Base
                                  (#(ident.Z_sub_with_get_borrow_concrete
                                       args)%expr @ x0 @ x1 @ x2)%expr_pat
                            end
                        | None =>
                            UnderLets.Base
                              (#(ident.Z_sub_with_get_borrow_concrete args)%expr @
                               x0 @ x1 @ x2)%expr_pat
                        end
                    | _ =>
                        UnderLets.Base
                          (#(ident.Z_sub_with_get_borrow_concrete args)%expr @
                           x0 @ x1 @ x2)%expr_pat
                    end
                | None =>
                    UnderLets.Base
                      (#(ident.Z_sub_with_get_borrow_concrete args)%expr @ x0 @
                       x1 @ x2)%expr_pat
                end
            | _ =>
                UnderLets.Base
                  (#(ident.Z_sub_with_get_borrow_concrete args)%expr @ x0 @
                   x1 @ x2)%expr_pat
            end
        | None =>
            UnderLets.Base
              (#(ident.Z_sub_with_get_borrow)%expr @ x @ x0 @ x1 @ x2)%expr_pat
        end
    | _ =>
        UnderLets.Base
          (#(ident.Z_sub_with_get_borrow)%expr @ x @ x0 @ x1 @ x2)%expr_pat
    end
| ident.Z_sub_with_get_borrow_concrete s =>
    fun x x0 x1 : expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 =>
                    match x1 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args1 =>
                            UnderLets.Base
                              (let
                               '(a, b) :=
                                Definitions.Z.sub_with_get_borrow_full s args
                                  args0 args1 in
                                (##(a)%expr, ##(b)%expr)%expr_pat)
                        | None =>
                            UnderLets.Base
                              (#(ident.Z_sub_with_get_borrow_concrete s)%expr @
                               x @ x0 @ x1)%expr_pat
                        end
                    | _ =>
                        UnderLets.Base
                          (#(ident.Z_sub_with_get_borrow_concrete s)%expr @ x @
                           x0 @ x1)%expr_pat
                    end
                | None =>
                    UnderLets.Base
                      (#(ident.Z_sub_with_get_borrow_concrete s)%expr @ x @
                       x0 @ x1)%expr_pat
                end
            | _ =>
                UnderLets.Base
                  (#(ident.Z_sub_with_get_borrow_concrete s)%expr @ x @ x0 @
                   x1)%expr_pat
            end
        | None =>
            UnderLets.Base
              (#(ident.Z_sub_with_get_borrow_concrete s)%expr @ x @ x0 @ x1)%expr_pat
        end
    | _ =>
        UnderLets.Base
          (#(ident.Z_sub_with_get_borrow_concrete s)%expr @ x @ x0 @ x1)%expr_pat
    end
| ident.Z_zselect =>
    fun x x0 x1 : expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 =>
                    match x1 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args1 =>
                            UnderLets.Base
                              ##(Definitions.Z.zselect args args0 args1)%expr
                        | None =>
                            UnderLets.Base
                              (#(ident.Z_zselect)%expr @ x @ x0 @ x1)%expr_pat
                        end
                    | _ =>
                        UnderLets.Base
                          (#(ident.Z_zselect)%expr @ x @ x0 @ x1)%expr_pat
                    end
                | None =>
                    UnderLets.Base
                      (#(ident.Z_zselect)%expr @ x @ x0 @ x1)%expr_pat
                end
            | _ =>
                UnderLets.Base
                  (#(ident.Z_zselect)%expr @ x @ x0 @ x1)%expr_pat
            end
        | None =>
            UnderLets.Base (#(ident.Z_zselect)%expr @ x @ x0 @ x1)%expr_pat
        end
    | _ => UnderLets.Base (#(ident.Z_zselect)%expr @ x @ x0 @ x1)%expr_pat
    end
| ident.Z_add_modulo =>
    fun x x0 x1 : expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 =>
                    match x1 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args1 =>
                            UnderLets.Base
                              ##(Definitions.Z.add_modulo args args0 args1)%expr
                        | None =>
                            UnderLets.Base
                              (#(ident.Z_add_modulo)%expr @ x @ x0 @ x1)%expr_pat
                        end
                    | _ =>
                        UnderLets.Base
                          (#(ident.Z_add_modulo)%expr @ x @ x0 @ x1)%expr_pat
                    end
                | None =>
                    UnderLets.Base
                      (#(ident.Z_add_modulo)%expr @ x @ x0 @ x1)%expr_pat
                end
            | _ =>
                UnderLets.Base
                  (#(ident.Z_add_modulo)%expr @ x @ x0 @ x1)%expr_pat
            end
        | None =>
            UnderLets.Base
              (#(ident.Z_add_modulo)%expr @ x @ x0 @ x1)%expr_pat
        end
    | _ => UnderLets.Base (#(ident.Z_add_modulo)%expr @ x @ x0 @ x1)%expr_pat
    end
| ident.Z_rshi =>
    fun x x0 x1 x2 : expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 =>
                    match x1 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args1 =>
                            match x2 with
                            | #(idc2)%expr_pat =>
                                match
                                  match idc2 with
                                  | @ident.Literal t3 v =>
                                      match
                                        t3 as t4
                                        return
                                          (base.base_interp t4 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args2 =>
                                    UnderLets.Base
                                      ##(Definitions.Z.rshi args args0 args1
                                           args2)%expr
                                | None =>
                                    UnderLets.Base
                                      (#(ident.Z_rshi)%expr @ x @ x0 @ x1 @
                                       x2)%expr_pat
                                end
                            | _ =>
                                UnderLets.Base
                                  (#(ident.Z_rshi)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                            end
                        | None =>
                            match x2 with
                            | #(idc2)%expr_pat =>
                                match
                                  match idc2 with
                                  | @ident.Literal t3 v =>
                                      match
                                        t3 as t4
                                        return
                                          (base.base_interp t4 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    UnderLets.Base
                                      (#(ident.Z_rshi_concrete args args1)%expr @
                                       x0 @ x1)%expr_pat
                                | None =>
                                    UnderLets.Base
                                      (#(ident.Z_rshi)%expr @ x @ x0 @ x1 @
                                       x2)%expr_pat
                                end
                            | _ =>
                                UnderLets.Base
                                  (#(ident.Z_rshi)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                            end
                        end
                    | ($_)%expr =>
                        match x2 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t3 v0 =>
                                  match
                                    t3 as t4
                                    return (base.base_interp t4 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v1 : Z => Some v1
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v0
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                UnderLets.Base
                                  (#(ident.Z_rshi_concrete args args1)%expr @
                                   x0 @ x1)%expr_pat
                            | None =>
                                UnderLets.Base
                                  (#(ident.Z_rshi)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                            end
                        | _ =>
                            UnderLets.Base
                              (#(ident.Z_rshi)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                        end
                    | _ =>
                        match x2 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t2 v =>
                                  match
                                    t2 as t3
                                    return (base.base_interp t3 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v0 : Z => Some v0
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                UnderLets.Base
                                  (#(ident.Z_rshi_concrete args args1)%expr @
                                   x0 @ x1)%expr_pat
                            | None =>
                                UnderLets.Base
                                  (#(ident.Z_rshi)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                            end
                        | _ =>
                            UnderLets.Base
                              (#(ident.Z_rshi)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                        end
                    end
                | None =>
                    match x2 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args0 =>
                            UnderLets.Base
                              (#(ident.Z_rshi_concrete args args0)%expr @ x0 @
                               x1)%expr_pat
                        | None =>
                            UnderLets.Base
                              (#(ident.Z_rshi)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                        end
                    | _ =>
                        UnderLets.Base
                          (#(ident.Z_rshi)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                    end
                end
            | ($_)%expr =>
                match x2 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t2 v0 =>
                          match
                            t2 as t3 return (base.base_interp t3 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v1 : Z => Some v1
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v0
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        UnderLets.Base
                          (#(ident.Z_rshi_concrete args args0)%expr @ x0 @ x1)%expr_pat
                    | None =>
                        UnderLets.Base
                          (#(ident.Z_rshi)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                    end
                | _ =>
                    UnderLets.Base
                      (#(ident.Z_rshi)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                end
            | _ =>
                match x2 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t1 v =>
                          match
                            t1 as t2 return (base.base_interp t2 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v0 : Z => Some v0
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        UnderLets.Base
                          (#(ident.Z_rshi_concrete args args0)%expr @ x0 @ x1)%expr_pat
                    | None =>
                        UnderLets.Base
                          (#(ident.Z_rshi)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                    end
                | _ =>
                    UnderLets.Base
                      (#(ident.Z_rshi)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                end
            end
        | None =>
            UnderLets.Base (#(ident.Z_rshi)%expr @ x @ x0 @ x1 @ x2)%expr_pat
        end
    | _ => UnderLets.Base (#(ident.Z_rshi)%expr @ x @ x0 @ x1 @ x2)%expr_pat
    end
| ident.Z_rshi_concrete s offset =>
    fun x x0 : expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 =>
                    UnderLets.Base
                      ##(Definitions.Z.rshi s args args0 offset)%expr
                | None =>
                    UnderLets.Base
                      (#(ident.Z_rshi_concrete s offset)%expr @ x @ x0)%expr_pat
                end
            | _ =>
                UnderLets.Base
                  (#(ident.Z_rshi_concrete s offset)%expr @ x @ x0)%expr_pat
            end
        | None =>
            UnderLets.Base
              (#(ident.Z_rshi_concrete s offset)%expr @ x @ x0)%expr_pat
        end
    | _ =>
        UnderLets.Base
          (#(ident.Z_rshi_concrete s offset)%expr @ x @ x0)%expr_pat
    end
| ident.Z_cc_m =>
    fun x x0 : expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 =>
                    UnderLets.Base ##(Definitions.Z.cc_m args args0)%expr
                | None =>
                    UnderLets.Base
                      (#(ident.Z_cc_m_concrete args)%expr @ x0)%expr_pat
                end
            | _ =>
                UnderLets.Base
                  (#(ident.Z_cc_m_concrete args)%expr @ x0)%expr_pat
            end
        | None => UnderLets.Base (#(ident.Z_cc_m)%expr @ x @ x0)%expr_pat
        end
    | _ => UnderLets.Base (#(ident.Z_cc_m)%expr @ x @ x0)%expr_pat
    end
| ident.Z_cc_m_concrete s =>
    fun x : expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args => UnderLets.Base ##(Definitions.Z.cc_m s args)%expr
        | None =>
            UnderLets.Base (#(ident.Z_cc_m_concrete s)%expr @ x)%expr_pat
        end
    | _ => UnderLets.Base (#(ident.Z_cc_m_concrete s)%expr @ x)%expr_pat
    end
| ident.Z_neg_snd =>
    fun x : expr (type.base (base.type.Z * base.type.Z)%etype) =>
    match x with
    | ($_)%expr =>
        UnderLets.UnderLet x
          (fun v0 : var (type.base (base.type.Z * base.type.Z)%etype) =>
           UnderLets.Base
             (#(ident.fst)%expr @ ($v0)%expr,
             (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
    | @expr.App _ _ _ s _ ($_)%expr _ =>
        UnderLets.UnderLet x
          (fun v0 : var (type.base (base.type.Z * base.type.Z)%etype) =>
           UnderLets.Base
             (#(ident.fst)%expr @ ($v0)%expr,
             (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
    | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ #(idc)%expr_pat x1) x0 =>
        match
          match idc with
          | @ident.pair A B => Some (A, B)
          | _ => None
          end
        with
        | Some _ =>
            match x1 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 =>
                    match x0 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args1 =>
                            UnderLets.Base
                              (##(args0)%expr, ##((- args1)%Z)%expr)%expr_pat
                        | None =>
                            match
                              s0 as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (expr
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)))
                            with
                            | type.base t2 =>
                                fun v : expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t3 : base.type => expr (type.base t3))
                                  t2 base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (expr
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)))
                                  (fun
                                     a : option
                                           (expr (type.base t2) ->
                                            expr (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       match
                                         s as t3
                                         return
                                           (Compile.value' false t3 ->
                                            UnderLets.UnderLets base.type
                                              ident var
                                              (expr
                                                 (type.base
                                                    (base.type.Z *
                                                     base.type.Z)%etype)))
                                       with
                                       | type.base t3 =>
                                           fun v0 : expr (type.base t3) =>
                                           base.try_make_transport_cps
                                             (fun t4 : base.type =>
                                              expr (type.base t4)) t3
                                             base.type.Z
                                             (UnderLets.UnderLets base.type
                                                ident var
                                                (expr
                                                   (type.base
                                                      (base.type.Z *
                                                       base.type.Z)%etype)))
                                             (fun
                                                a0 : option
                                                       (expr (type.base t3) ->
                                                        expr
                                                          (type.base
                                                             base.type.Z)) =>
                                              match a0 with
                                              | Some x'0 =>
                                                  UnderLets.Base
                                                    (x' v, (- x'0 v0)%expr)%expr_pat
                                              | None =>
                                                  UnderLets.Base
                                                    (#(ident.Z_neg_snd)%expr @
                                                     x)%expr_pat
                                              end)
                                       | (s1 -> d1)%ptype =>
                                           fun
                                             _ : Compile.value' false s1 ->
                                                 Compile.value' true d1 =>
                                           UnderLets.Base
                                             (#(ident.Z_neg_snd)%expr @ x)%expr_pat
                                       end (Compile.reflect x0)
                                   | None =>
                                       UnderLets.Base
                                         (#(ident.Z_neg_snd)%expr @ x)%expr_pat
                                   end)
                            | (s1 -> d1)%ptype =>
                                fun
                                  _ : Compile.value' false s1 ->
                                      Compile.value' true d1 =>
                                UnderLets.Base
                                  (#(ident.Z_neg_snd)%expr @ x)%expr_pat
                            end (Compile.reflect x1)
                        end
                    | ($_)%expr =>
                        match
                          s0 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v0 : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t3 : base.type => expr (type.base t3)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   match
                                     s as t3
                                     return
                                       (Compile.value' false t3 ->
                                        UnderLets.UnderLets base.type ident
                                          var
                                          (expr
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)))
                                   with
                                   | type.base t3 =>
                                       fun v1 : expr (type.base t3) =>
                                       base.try_make_transport_cps
                                         (fun t4 : base.type =>
                                          expr (type.base t4)) t3 base.type.Z
                                         (UnderLets.UnderLets base.type ident
                                            var
                                            (expr
                                               (type.base
                                                  (base.type.Z * base.type.Z)%etype)))
                                         (fun
                                            a0 : option
                                                   (expr (type.base t3) ->
                                                    expr
                                                      (type.base base.type.Z))
                                          =>
                                          match a0 with
                                          | Some x'0 =>
                                              UnderLets.Base
                                                (x' v0, (- x'0 v1)%expr)%expr_pat
                                          | None =>
                                              UnderLets.Base
                                                (#(ident.Z_neg_snd)%expr @ x)%expr_pat
                                          end)
                                   | (s1 -> d1)%ptype =>
                                       fun
                                         _ : Compile.value' false s1 ->
                                             Compile.value' true d1 =>
                                       UnderLets.Base
                                         (#(ident.Z_neg_snd)%expr @ x)%expr_pat
                                   end (Compile.reflect x0)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_neg_snd)%expr @ x)%expr_pat
                               end)
                        | (s1 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base
                              (#(ident.Z_neg_snd)%expr @ x)%expr_pat
                        end (Compile.reflect x1)
                    | @expr.LetIn _ _ _ _ _ _ _ =>
                        match
                          s0 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type => expr (type.base t1)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   match
                                     s as t3
                                     return
                                       (Compile.value' false t3 ->
                                        UnderLets.UnderLets base.type ident
                                          var
                                          (expr
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)))
                                   with
                                   | type.base t3 =>
                                       fun v0 : expr (type.base t3) =>
                                       base.try_make_transport_cps
                                         (fun t1 : base.type =>
                                          expr (type.base t1)) t3 base.type.Z
                                         (UnderLets.UnderLets base.type ident
                                            var
                                            (expr
                                               (type.base
                                                  (base.type.Z * base.type.Z)%etype)))
                                         (fun
                                            a0 : option
                                                   (expr (type.base t3) ->
                                                    expr
                                                      (type.base base.type.Z))
                                          =>
                                          match a0 with
                                          | Some x'0 =>
                                              UnderLets.Base
                                                (x' v, (- x'0 v0)%expr)%expr_pat
                                          | None =>
                                              UnderLets.Base
                                                (#(ident.Z_neg_snd)%expr @ x)%expr_pat
                                          end)
                                   | (s1 -> d1)%ptype =>
                                       fun
                                         _ : Compile.value' false s1 ->
                                             Compile.value' true d1 =>
                                       UnderLets.Base
                                         (#(ident.Z_neg_snd)%expr @ x)%expr_pat
                                   end (Compile.reflect x0)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_neg_snd)%expr @ x)%expr_pat
                               end)
                        | (s1 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base
                              (#(ident.Z_neg_snd)%expr @ x)%expr_pat
                        end (Compile.reflect x1)
                    | _ =>
                        match
                          s0 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type => expr (type.base t1)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   match
                                     s as t3
                                     return
                                       (Compile.value' false t3 ->
                                        UnderLets.UnderLets base.type ident
                                          var
                                          (expr
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)))
                                   with
                                   | type.base t3 =>
                                       fun v0 : expr (type.base t3) =>
                                       base.try_make_transport_cps
                                         (fun t1 : base.type =>
                                          expr (type.base t1)) t3 base.type.Z
                                         (UnderLets.UnderLets base.type ident
                                            var
                                            (expr
                                               (type.base
                                                  (base.type.Z * base.type.Z)%etype)))
                                         (fun
                                            a0 : option
                                                   (expr (type.base t3) ->
                                                    expr
                                                      (type.base base.type.Z))
                                          =>
                                          match a0 with
                                          | Some x'0 =>
                                              UnderLets.Base
                                                (x' v, (- x'0 v0)%expr)%expr_pat
                                          | None =>
                                              UnderLets.Base
                                                (#(ident.Z_neg_snd)%expr @ x)%expr_pat
                                          end)
                                   | (s2 -> d2)%ptype =>
                                       fun
                                         _ : Compile.value' false s2 ->
                                             Compile.value' true d2 =>
                                       UnderLets.Base
                                         (#(ident.Z_neg_snd)%expr @ x)%expr_pat
                                   end (Compile.reflect x0)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_neg_snd)%expr @ x)%expr_pat
                               end)
                        | (s2 -> d2)%ptype =>
                            fun
                              _ : Compile.value' false s2 ->
                                  Compile.value' true d2 =>
                            UnderLets.Base
                              (#(ident.Z_neg_snd)%expr @ x)%expr_pat
                        end (Compile.reflect x1)
                    end
                | None =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => expr (type.base t1)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               match
                                 s as t3
                                 return
                                   (Compile.value' false t3 ->
                                    UnderLets.UnderLets base.type ident var
                                      (expr
                                         (type.base
                                            (base.type.Z * base.type.Z)%etype)))
                               with
                               | type.base t3 =>
                                   fun v0 : expr (type.base t3) =>
                                   base.try_make_transport_cps
                                     (fun t1 : base.type =>
                                      expr (type.base t1)) t3 base.type.Z
                                     (UnderLets.UnderLets base.type ident var
                                        (expr
                                           (type.base
                                              (base.type.Z * base.type.Z)%etype)))
                                     (fun
                                        a0 : option
                                               (expr (type.base t3) ->
                                                expr (type.base base.type.Z))
                                      =>
                                      match a0 with
                                      | Some x'0 =>
                                          UnderLets.Base
                                            (x' v, (- x'0 v0)%expr)%expr_pat
                                      | None =>
                                          UnderLets.Base
                                            (#(ident.Z_neg_snd)%expr @ x)%expr_pat
                                      end)
                               | (s1 -> d1)%ptype =>
                                   fun
                                     _ : Compile.value' false s1 ->
                                         Compile.value' true d1 =>
                                   UnderLets.Base
                                     (#(ident.Z_neg_snd)%expr @ x)%expr_pat
                               end (Compile.reflect x0)
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_neg_snd)%expr @ x)%expr_pat
                           end)
                    | (s1 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d1 =>
                        UnderLets.Base (#(ident.Z_neg_snd)%expr @ x)%expr_pat
                    end (Compile.reflect x1)
                end
            | ($_)%expr =>
                match
                  s0 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base (base.type.Z * base.type.Z)%etype)))
                with
                | type.base t2 =>
                    fun v0 : expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t1 : base.type => expr (type.base t1)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base (base.type.Z * base.type.Z)%etype)))
                      (fun
                         a : option
                               (expr (type.base t2) ->
                                expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' =>
                           match
                             s as t3
                             return
                               (Compile.value' false t3 ->
                                UnderLets.UnderLets base.type ident var
                                  (expr
                                     (type.base
                                        (base.type.Z * base.type.Z)%etype)))
                           with
                           | type.base t3 =>
                               fun v1 : expr (type.base t3) =>
                               base.try_make_transport_cps
                                 (fun t1 : base.type => expr (type.base t1))
                                 t3 base.type.Z
                                 (UnderLets.UnderLets base.type ident var
                                    (expr
                                       (type.base
                                          (base.type.Z * base.type.Z)%etype)))
                                 (fun
                                    a0 : option
                                           (expr (type.base t3) ->
                                            expr (type.base base.type.Z)) =>
                                  match a0 with
                                  | Some x'0 =>
                                      UnderLets.Base
                                        (x' v0, (- x'0 v1)%expr)%expr_pat
                                  | None =>
                                      UnderLets.Base
                                        (#(ident.Z_neg_snd)%expr @ x)%expr_pat
                                  end)
                           | (s1 -> d1)%ptype =>
                               fun
                                 _ : Compile.value' false s1 ->
                                     Compile.value' true d1 =>
                               UnderLets.Base
                                 (#(ident.Z_neg_snd)%expr @ x)%expr_pat
                           end (Compile.reflect x0)
                       | None =>
                           UnderLets.Base
                             (#(ident.Z_neg_snd)%expr @ x)%expr_pat
                       end)
                | (s1 -> d1)%ptype =>
                    fun _ : Compile.value' false s1 -> Compile.value' true d1
                    => UnderLets.Base (#(ident.Z_neg_snd)%expr @ x)%expr_pat
                end (Compile.reflect x1)
            | @expr.LetIn _ _ _ _ _ _ _ =>
                match
                  s0 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base (base.type.Z * base.type.Z)%etype)))
                with
                | type.base t2 =>
                    fun v : expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => expr (type.base t0)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base (base.type.Z * base.type.Z)%etype)))
                      (fun
                         a : option
                               (expr (type.base t2) ->
                                expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' =>
                           match
                             s as t3
                             return
                               (Compile.value' false t3 ->
                                UnderLets.UnderLets base.type ident var
                                  (expr
                                     (type.base
                                        (base.type.Z * base.type.Z)%etype)))
                           with
                           | type.base t3 =>
                               fun v0 : expr (type.base t3) =>
                               base.try_make_transport_cps
                                 (fun t0 : base.type => expr (type.base t0))
                                 t3 base.type.Z
                                 (UnderLets.UnderLets base.type ident var
                                    (expr
                                       (type.base
                                          (base.type.Z * base.type.Z)%etype)))
                                 (fun
                                    a0 : option
                                           (expr (type.base t3) ->
                                            expr (type.base base.type.Z)) =>
                                  match a0 with
                                  | Some x'0 =>
                                      UnderLets.Base
                                        (x' v, (- x'0 v0)%expr)%expr_pat
                                  | None =>
                                      UnderLets.Base
                                        (#(ident.Z_neg_snd)%expr @ x)%expr_pat
                                  end)
                           | (s1 -> d1)%ptype =>
                               fun
                                 _ : Compile.value' false s1 ->
                                     Compile.value' true d1 =>
                               UnderLets.Base
                                 (#(ident.Z_neg_snd)%expr @ x)%expr_pat
                           end (Compile.reflect x0)
                       | None =>
                           UnderLets.Base
                             (#(ident.Z_neg_snd)%expr @ x)%expr_pat
                       end)
                | (s1 -> d1)%ptype =>
                    fun _ : Compile.value' false s1 -> Compile.value' true d1
                    => UnderLets.Base (#(ident.Z_neg_snd)%expr @ x)%expr_pat
                end (Compile.reflect x1)
            | _ =>
                match
                  s0 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base (base.type.Z * base.type.Z)%etype)))
                with
                | type.base t2 =>
                    fun v : expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => expr (type.base t0)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base (base.type.Z * base.type.Z)%etype)))
                      (fun
                         a : option
                               (expr (type.base t2) ->
                                expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' =>
                           match
                             s as t3
                             return
                               (Compile.value' false t3 ->
                                UnderLets.UnderLets base.type ident var
                                  (expr
                                     (type.base
                                        (base.type.Z * base.type.Z)%etype)))
                           with
                           | type.base t3 =>
                               fun v0 : expr (type.base t3) =>
                               base.try_make_transport_cps
                                 (fun t0 : base.type => expr (type.base t0))
                                 t3 base.type.Z
                                 (UnderLets.UnderLets base.type ident var
                                    (expr
                                       (type.base
                                          (base.type.Z * base.type.Z)%etype)))
                                 (fun
                                    a0 : option
                                           (expr (type.base t3) ->
                                            expr (type.base base.type.Z)) =>
                                  match a0 with
                                  | Some x'0 =>
                                      UnderLets.Base
                                        (x' v, (- x'0 v0)%expr)%expr_pat
                                  | None =>
                                      UnderLets.Base
                                        (#(ident.Z_neg_snd)%expr @ x)%expr_pat
                                  end)
                           | (s2 -> d2)%ptype =>
                               fun
                                 _ : Compile.value' false s2 ->
                                     Compile.value' true d2 =>
                               UnderLets.Base
                                 (#(ident.Z_neg_snd)%expr @ x)%expr_pat
                           end (Compile.reflect x0)
                       | None =>
                           UnderLets.Base
                             (#(ident.Z_neg_snd)%expr @ x)%expr_pat
                       end)
                | (s2 -> d2)%ptype =>
                    fun _ : Compile.value' false s2 -> Compile.value' true d2
                    => UnderLets.Base (#(ident.Z_neg_snd)%expr @ x)%expr_pat
                end (Compile.reflect x1)
            end
        | None =>
            UnderLets.UnderLet x
              (fun v : var (type.base (base.type.Z * base.type.Z)%etype) =>
               UnderLets.Base
                 (#(ident.fst)%expr @ ($v)%expr,
                 (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
        end
    | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ ($_)%expr _) _ =>
        UnderLets.UnderLet x
          (fun v0 : var (type.base (base.type.Z * base.type.Z)%etype) =>
           UnderLets.Base
             (#(ident.fst)%expr @ ($v0)%expr,
             (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
    | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _)
      _ | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ (_ @ _)%expr_pat _) _ |
      @expr.App _ _ _ s _
      (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _) _ =>
        UnderLets.UnderLet x
          (fun v : var (type.base (base.type.Z * base.type.Z)%etype) =>
           UnderLets.Base
             (#(ident.fst)%expr @ ($v)%expr,
             (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
    | @expr.App _ _ _ s _ #(_)%expr_pat _ | @expr.App _ _ _ s _
      (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _
      (@expr.LetIn _ _ _ _ _ _ _) _ =>
        UnderLets.UnderLet x
          (fun v : var (type.base (base.type.Z * base.type.Z)%etype) =>
           UnderLets.Base
             (#(ident.fst)%expr @ ($v)%expr,
             (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
    | _ =>
        UnderLets.UnderLet x
          (fun v : var (type.base (base.type.Z * base.type.Z)%etype) =>
           UnderLets.Base
             (#(ident.fst)%expr @ ($v)%expr,
             (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
    end
| ident.Z_cast range =>
    fun x : expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            UnderLets.Base
              ##(ident.cast ident.cast_outside_of_range range args)%expr
        | None => UnderLets.Base (#(ident.Z_cast range)%expr @ x)%expr_pat
        end
    | _ => UnderLets.Base (#(ident.Z_cast range)%expr @ x)%expr_pat
    end
| ident.Z_cast2 range =>
    fun x : expr (type.base (base.type.Z * base.type.Z)%etype) =>
    match x with
    | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ #(idc)%expr_pat x1) x0 =>
        match
          match idc with
          | @ident.pair A B => Some (A, B)
          | _ => None
          end
        with
        | Some _ =>
            match x1 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 =>
                    match x0 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args1 =>
                            UnderLets.Base
                              (let
                               '(a, b) :=
                                (let (r1, r2) := range in
                                 fun '(x2, x3) =>
                                 (ident.cast ident.cast_outside_of_range r1
                                    x2,
                                 ident.cast ident.cast_outside_of_range r2 x3))
                                  (args0, args1) in
                                (##(a)%expr, ##(b)%expr)%expr_pat)
                        | None =>
                            match
                              s0 as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (expr
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)))
                            with
                            | type.base t2 =>
                                fun v : expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t3 : base.type => expr (type.base t3))
                                  t2 base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (expr
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)))
                                  (fun
                                     a : option
                                           (expr (type.base t2) ->
                                            expr (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       match
                                         s as t3
                                         return
                                           (Compile.value' false t3 ->
                                            UnderLets.UnderLets base.type
                                              ident var
                                              (expr
                                                 (type.base
                                                    (base.type.Z *
                                                     base.type.Z)%etype)))
                                       with
                                       | type.base t3 =>
                                           fun v0 : expr (type.base t3) =>
                                           base.try_make_transport_cps
                                             (fun t4 : base.type =>
                                              expr (type.base t4)) t3
                                             base.type.Z
                                             (UnderLets.UnderLets base.type
                                                ident var
                                                (expr
                                                   (type.base
                                                      (base.type.Z *
                                                       base.type.Z)%etype)))
                                             (fun
                                                a0 : option
                                                       (expr (type.base t3) ->
                                                        expr
                                                          (type.base
                                                             base.type.Z)) =>
                                              match a0 with
                                              | Some x'0 =>
                                                  (fv <-- do_again
                                                            (base.type.Z *
                                                             base.type.Z)
                                                            (#(ident.Z_cast
                                                                 (fst range))%expr @
                                                             ($(x' v))%expr,
                                                            #(ident.Z_cast
                                                                (snd range))%expr @
                                                            ($(x'0 v0))%expr)%expr_pat;
                                                   UnderLets.Base
                                                     (id (id fv)))%under_lets
                                              | None =>
                                                  UnderLets.Base
                                                    (#(ident.Z_cast2 range)%expr @
                                                     x)%expr_pat
                                              end)
                                       | (s1 -> d1)%ptype =>
                                           fun
                                             _ : Compile.value' false s1 ->
                                                 Compile.value' true d1 =>
                                           UnderLets.Base
                                             (#(ident.Z_cast2 range)%expr @ x)%expr_pat
                                       end (Compile.reflect x0)
                                   | None =>
                                       UnderLets.Base
                                         (#(ident.Z_cast2 range)%expr @ x)%expr_pat
                                   end)
                            | (s1 -> d1)%ptype =>
                                fun
                                  _ : Compile.value' false s1 ->
                                      Compile.value' true d1 =>
                                UnderLets.Base
                                  (#(ident.Z_cast2 range)%expr @ x)%expr_pat
                            end (Compile.reflect x1)
                        end
                    | ($_)%expr =>
                        match
                          s0 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v0 : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t3 : base.type => expr (type.base t3)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   match
                                     s as t3
                                     return
                                       (Compile.value' false t3 ->
                                        UnderLets.UnderLets base.type ident
                                          var
                                          (expr
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)))
                                   with
                                   | type.base t3 =>
                                       fun v1 : expr (type.base t3) =>
                                       base.try_make_transport_cps
                                         (fun t4 : base.type =>
                                          expr (type.base t4)) t3 base.type.Z
                                         (UnderLets.UnderLets base.type ident
                                            var
                                            (expr
                                               (type.base
                                                  (base.type.Z * base.type.Z)%etype)))
                                         (fun
                                            a0 : option
                                                   (expr (type.base t3) ->
                                                    expr
                                                      (type.base base.type.Z))
                                          =>
                                          match a0 with
                                          | Some x'0 =>
                                              (fv <-- do_again
                                                        (base.type.Z *
                                                         base.type.Z)
                                                        (#(ident.Z_cast
                                                             (fst range))%expr @
                                                         ($(x' v0))%expr,
                                                        #(ident.Z_cast
                                                            (snd range))%expr @
                                                        ($(x'0 v1))%expr)%expr_pat;
                                               UnderLets.Base (id (id fv)))%under_lets
                                          | None =>
                                              UnderLets.Base
                                                (#(ident.Z_cast2 range)%expr @
                                                 x)%expr_pat
                                          end)
                                   | (s1 -> d1)%ptype =>
                                       fun
                                         _ : Compile.value' false s1 ->
                                             Compile.value' true d1 =>
                                       UnderLets.Base
                                         (#(ident.Z_cast2 range)%expr @ x)%expr_pat
                                   end (Compile.reflect x0)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_cast2 range)%expr @ x)%expr_pat
                               end)
                        | (s1 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base
                              (#(ident.Z_cast2 range)%expr @ x)%expr_pat
                        end (Compile.reflect x1)
                    | @expr.LetIn _ _ _ _ _ _ _ =>
                        match
                          s0 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type => expr (type.base t1)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   match
                                     s as t3
                                     return
                                       (Compile.value' false t3 ->
                                        UnderLets.UnderLets base.type ident
                                          var
                                          (expr
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)))
                                   with
                                   | type.base t3 =>
                                       fun v0 : expr (type.base t3) =>
                                       base.try_make_transport_cps
                                         (fun t1 : base.type =>
                                          expr (type.base t1)) t3 base.type.Z
                                         (UnderLets.UnderLets base.type ident
                                            var
                                            (expr
                                               (type.base
                                                  (base.type.Z * base.type.Z)%etype)))
                                         (fun
                                            a0 : option
                                                   (expr (type.base t3) ->
                                                    expr
                                                      (type.base base.type.Z))
                                          =>
                                          match a0 with
                                          | Some x'0 =>
                                              (fv <-- do_again
                                                        (base.type.Z *
                                                         base.type.Z)
                                                        (#(ident.Z_cast
                                                             (fst range))%expr @
                                                         ($(x' v))%expr,
                                                        #(ident.Z_cast
                                                            (snd range))%expr @
                                                        ($(x'0 v0))%expr)%expr_pat;
                                               UnderLets.Base (id (id fv)))%under_lets
                                          | None =>
                                              UnderLets.Base
                                                (#(ident.Z_cast2 range)%expr @
                                                 x)%expr_pat
                                          end)
                                   | (s1 -> d1)%ptype =>
                                       fun
                                         _ : Compile.value' false s1 ->
                                             Compile.value' true d1 =>
                                       UnderLets.Base
                                         (#(ident.Z_cast2 range)%expr @ x)%expr_pat
                                   end (Compile.reflect x0)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_cast2 range)%expr @ x)%expr_pat
                               end)
                        | (s1 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base
                              (#(ident.Z_cast2 range)%expr @ x)%expr_pat
                        end (Compile.reflect x1)
                    | _ =>
                        match
                          s0 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type => expr (type.base t1)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   match
                                     s as t3
                                     return
                                       (Compile.value' false t3 ->
                                        UnderLets.UnderLets base.type ident
                                          var
                                          (expr
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)))
                                   with
                                   | type.base t3 =>
                                       fun v0 : expr (type.base t3) =>
                                       base.try_make_transport_cps
                                         (fun t1 : base.type =>
                                          expr (type.base t1)) t3 base.type.Z
                                         (UnderLets.UnderLets base.type ident
                                            var
                                            (expr
                                               (type.base
                                                  (base.type.Z * base.type.Z)%etype)))
                                         (fun
                                            a0 : option
                                                   (expr (type.base t3) ->
                                                    expr
                                                      (type.base base.type.Z))
                                          =>
                                          match a0 with
                                          | Some x'0 =>
                                              (fv <-- do_again
                                                        (base.type.Z *
                                                         base.type.Z)
                                                        (#(ident.Z_cast
                                                             (fst range))%expr @
                                                         ($(x' v))%expr,
                                                        #(ident.Z_cast
                                                            (snd range))%expr @
                                                        ($(x'0 v0))%expr)%expr_pat;
                                               UnderLets.Base (id (id fv)))%under_lets
                                          | None =>
                                              UnderLets.Base
                                                (#(ident.Z_cast2 range)%expr @
                                                 x)%expr_pat
                                          end)
                                   | (s2 -> d2)%ptype =>
                                       fun
                                         _ : Compile.value' false s2 ->
                                             Compile.value' true d2 =>
                                       UnderLets.Base
                                         (#(ident.Z_cast2 range)%expr @ x)%expr_pat
                                   end (Compile.reflect x0)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_cast2 range)%expr @ x)%expr_pat
                               end)
                        | (s2 -> d2)%ptype =>
                            fun
                              _ : Compile.value' false s2 ->
                                  Compile.value' true d2 =>
                            UnderLets.Base
                              (#(ident.Z_cast2 range)%expr @ x)%expr_pat
                        end (Compile.reflect x1)
                    end
                | None =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => expr (type.base t1)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               match
                                 s as t3
                                 return
                                   (Compile.value' false t3 ->
                                    UnderLets.UnderLets base.type ident var
                                      (expr
                                         (type.base
                                            (base.type.Z * base.type.Z)%etype)))
                               with
                               | type.base t3 =>
                                   fun v0 : expr (type.base t3) =>
                                   base.try_make_transport_cps
                                     (fun t1 : base.type =>
                                      expr (type.base t1)) t3 base.type.Z
                                     (UnderLets.UnderLets base.type ident var
                                        (expr
                                           (type.base
                                              (base.type.Z * base.type.Z)%etype)))
                                     (fun
                                        a0 : option
                                               (expr (type.base t3) ->
                                                expr (type.base base.type.Z))
                                      =>
                                      match a0 with
                                      | Some x'0 =>
                                          (fv <-- do_again
                                                    (base.type.Z *
                                                     base.type.Z)
                                                    (#(ident.Z_cast
                                                         (fst range))%expr @
                                                     ($(x' v))%expr,
                                                    #(ident.Z_cast
                                                        (snd range))%expr @
                                                    ($(x'0 v0))%expr)%expr_pat;
                                           UnderLets.Base (id (id fv)))%under_lets
                                      | None =>
                                          UnderLets.Base
                                            (#(ident.Z_cast2 range)%expr @ x)%expr_pat
                                      end)
                               | (s1 -> d1)%ptype =>
                                   fun
                                     _ : Compile.value' false s1 ->
                                         Compile.value' true d1 =>
                                   UnderLets.Base
                                     (#(ident.Z_cast2 range)%expr @ x)%expr_pat
                               end (Compile.reflect x0)
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_cast2 range)%expr @ x)%expr_pat
                           end)
                    | (s1 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d1 =>
                        UnderLets.Base
                          (#(ident.Z_cast2 range)%expr @ x)%expr_pat
                    end (Compile.reflect x1)
                end
            | ($_)%expr =>
                match
                  s0 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base (base.type.Z * base.type.Z)%etype)))
                with
                | type.base t2 =>
                    fun v0 : expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t1 : base.type => expr (type.base t1)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base (base.type.Z * base.type.Z)%etype)))
                      (fun
                         a : option
                               (expr (type.base t2) ->
                                expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' =>
                           match
                             s as t3
                             return
                               (Compile.value' false t3 ->
                                UnderLets.UnderLets base.type ident var
                                  (expr
                                     (type.base
                                        (base.type.Z * base.type.Z)%etype)))
                           with
                           | type.base t3 =>
                               fun v1 : expr (type.base t3) =>
                               base.try_make_transport_cps
                                 (fun t1 : base.type => expr (type.base t1))
                                 t3 base.type.Z
                                 (UnderLets.UnderLets base.type ident var
                                    (expr
                                       (type.base
                                          (base.type.Z * base.type.Z)%etype)))
                                 (fun
                                    a0 : option
                                           (expr (type.base t3) ->
                                            expr (type.base base.type.Z)) =>
                                  match a0 with
                                  | Some x'0 =>
                                      (fv <-- do_again
                                                (base.type.Z * base.type.Z)
                                                (#(ident.Z_cast (fst range))%expr @
                                                 ($(x' v0))%expr,
                                                #(ident.Z_cast (snd range))%expr @
                                                ($(x'0 v1))%expr)%expr_pat;
                                       UnderLets.Base (id (id fv)))%under_lets
                                  | None =>
                                      UnderLets.Base
                                        (#(ident.Z_cast2 range)%expr @ x)%expr_pat
                                  end)
                           | (s1 -> d1)%ptype =>
                               fun
                                 _ : Compile.value' false s1 ->
                                     Compile.value' true d1 =>
                               UnderLets.Base
                                 (#(ident.Z_cast2 range)%expr @ x)%expr_pat
                           end (Compile.reflect x0)
                       | None =>
                           UnderLets.Base
                             (#(ident.Z_cast2 range)%expr @ x)%expr_pat
                       end)
                | (s1 -> d1)%ptype =>
                    fun _ : Compile.value' false s1 -> Compile.value' true d1
                    =>
                    UnderLets.Base (#(ident.Z_cast2 range)%expr @ x)%expr_pat
                end (Compile.reflect x1)
            | @expr.LetIn _ _ _ _ _ _ _ =>
                match
                  s0 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base (base.type.Z * base.type.Z)%etype)))
                with
                | type.base t2 =>
                    fun v : expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => expr (type.base t0)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base (base.type.Z * base.type.Z)%etype)))
                      (fun
                         a : option
                               (expr (type.base t2) ->
                                expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' =>
                           match
                             s as t3
                             return
                               (Compile.value' false t3 ->
                                UnderLets.UnderLets base.type ident var
                                  (expr
                                     (type.base
                                        (base.type.Z * base.type.Z)%etype)))
                           with
                           | type.base t3 =>
                               fun v0 : expr (type.base t3) =>
                               base.try_make_transport_cps
                                 (fun t0 : base.type => expr (type.base t0))
                                 t3 base.type.Z
                                 (UnderLets.UnderLets base.type ident var
                                    (expr
                                       (type.base
                                          (base.type.Z * base.type.Z)%etype)))
                                 (fun
                                    a0 : option
                                           (expr (type.base t3) ->
                                            expr (type.base base.type.Z)) =>
                                  match a0 with
                                  | Some x'0 =>
                                      (fv <-- do_again
                                                (base.type.Z * base.type.Z)
                                                (#(ident.Z_cast (fst range))%expr @
                                                 ($(x' v))%expr,
                                                #(ident.Z_cast (snd range))%expr @
                                                ($(x'0 v0))%expr)%expr_pat;
                                       UnderLets.Base (id (id fv)))%under_lets
                                  | None =>
                                      UnderLets.Base
                                        (#(ident.Z_cast2 range)%expr @ x)%expr_pat
                                  end)
                           | (s1 -> d1)%ptype =>
                               fun
                                 _ : Compile.value' false s1 ->
                                     Compile.value' true d1 =>
                               UnderLets.Base
                                 (#(ident.Z_cast2 range)%expr @ x)%expr_pat
                           end (Compile.reflect x0)
                       | None =>
                           UnderLets.Base
                             (#(ident.Z_cast2 range)%expr @ x)%expr_pat
                       end)
                | (s1 -> d1)%ptype =>
                    fun _ : Compile.value' false s1 -> Compile.value' true d1
                    =>
                    UnderLets.Base (#(ident.Z_cast2 range)%expr @ x)%expr_pat
                end (Compile.reflect x1)
            | _ =>
                match
                  s0 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base (base.type.Z * base.type.Z)%etype)))
                with
                | type.base t2 =>
                    fun v : expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => expr (type.base t0)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base (base.type.Z * base.type.Z)%etype)))
                      (fun
                         a : option
                               (expr (type.base t2) ->
                                expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' =>
                           match
                             s as t3
                             return
                               (Compile.value' false t3 ->
                                UnderLets.UnderLets base.type ident var
                                  (expr
                                     (type.base
                                        (base.type.Z * base.type.Z)%etype)))
                           with
                           | type.base t3 =>
                               fun v0 : expr (type.base t3) =>
                               base.try_make_transport_cps
                                 (fun t0 : base.type => expr (type.base t0))
                                 t3 base.type.Z
                                 (UnderLets.UnderLets base.type ident var
                                    (expr
                                       (type.base
                                          (base.type.Z * base.type.Z)%etype)))
                                 (fun
                                    a0 : option
                                           (expr (type.base t3) ->
                                            expr (type.base base.type.Z)) =>
                                  match a0 with
                                  | Some x'0 =>
                                      (fv <-- do_again
                                                (base.type.Z * base.type.Z)
                                                (#(ident.Z_cast (fst range))%expr @
                                                 ($(x' v))%expr,
                                                #(ident.Z_cast (snd range))%expr @
                                                ($(x'0 v0))%expr)%expr_pat;
                                       UnderLets.Base (id (id fv)))%under_lets
                                  | None =>
                                      UnderLets.Base
                                        (#(ident.Z_cast2 range)%expr @ x)%expr_pat
                                  end)
                           | (s2 -> d2)%ptype =>
                               fun
                                 _ : Compile.value' false s2 ->
                                     Compile.value' true d2 =>
                               UnderLets.Base
                                 (#(ident.Z_cast2 range)%expr @ x)%expr_pat
                           end (Compile.reflect x0)
                       | None =>
                           UnderLets.Base
                             (#(ident.Z_cast2 range)%expr @ x)%expr_pat
                       end)
                | (s2 -> d2)%ptype =>
                    fun _ : Compile.value' false s2 -> Compile.value' true d2
                    =>
                    UnderLets.Base (#(ident.Z_cast2 range)%expr @ x)%expr_pat
                end (Compile.reflect x1)
            end
        | None => UnderLets.Base (#(ident.Z_cast2 range)%expr @ x)%expr_pat
        end
    | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ ($_)%expr _) _ | @expr.App _
      _ _ s _ (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _) _ | @expr.App
      _ _ _ s _ (@expr.App _ _ _ s0 _ (_ @ _)%expr_pat _) _ | @expr.App _ _ _
      s _ (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _) _ =>
        UnderLets.Base (#(ident.Z_cast2 range)%expr @ x)%expr_pat
    | @expr.App _ _ _ s _ #(_)%expr_pat _ | @expr.App _ _ _ s _ ($_)%expr _ |
      @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _
      (@expr.LetIn _ _ _ _ _ _ _) _ =>
        UnderLets.Base (#(ident.Z_cast2 range)%expr @ x)%expr_pat
    | _ => UnderLets.Base (#(ident.Z_cast2 range)%expr @ x)%expr_pat
    end
| ident.fancy_add log2wordmax imm =>
    fun x : expr (type.base (base.type.Z * base.type.Z)%etype) =>
    match x with
    | (#(idc) @ x1 @ x0)%expr_pat =>
        match
          match idc with
          | @ident.pair A B => Some (A, B)
          | _ => None
          end
        with
        | Some _ =>
            match x1 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 =>
                    match x0 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args1 =>
                            UnderLets.Base
                              (let
                               '(a, b) :=
                                ident.fancy.interp
                                  (invert_Some
                                     (ident.to_fancy
                                        (ident.fancy_add log2wordmax imm)))
                                  (args0, args1) in
                                (##(a)%expr, ##(b)%expr)%expr_pat)
                        | None =>
                            UnderLets.Base
                              (#(ident.fancy_add log2wordmax imm)%expr @ x)%expr_pat
                        end
                    | _ =>
                        UnderLets.Base
                          (#(ident.fancy_add log2wordmax imm)%expr @ x)%expr_pat
                    end
                | None =>
                    UnderLets.Base
                      (#(ident.fancy_add log2wordmax imm)%expr @ x)%expr_pat
                end
            | _ =>
                UnderLets.Base
                  (#(ident.fancy_add log2wordmax imm)%expr @ x)%expr_pat
            end
        | None =>
            UnderLets.Base
              (#(ident.fancy_add log2wordmax imm)%expr @ x)%expr_pat
        end
    | _ =>
        UnderLets.Base (#(ident.fancy_add log2wordmax imm)%expr @ x)%expr_pat
    end
| ident.fancy_addc log2wordmax imm =>
    fun x : expr (type.base (base.type.Z * base.type.Z * base.type.Z)%etype)
    =>
    match x with
    | (#(idc) @ x1 @ x0)%expr_pat =>
        match
          match idc with
          | @ident.pair A B => Some (A, B)
          | _ => None
          end
        with
        | Some _ =>
            match x1 with
            | (#(idc0) @ x3 @ x2)%expr_pat =>
                match
                  match idc0 with
                  | @ident.pair A B => Some (A, B)
                  | _ => None
                  end
                with
                | Some _ =>
                    match x3 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args1 =>
                            match x2 with
                            | #(idc2)%expr_pat =>
                                match
                                  match idc2 with
                                  | @ident.Literal t3 v =>
                                      match
                                        t3 as t4
                                        return
                                          (base.base_interp t4 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args2 =>
                                    match x0 with
                                    | #(idc3)%expr_pat =>
                                        match
                                          match idc3 with
                                          | @ident.Literal t4 v =>
                                              match
                                                t4 as t5
                                                return
                                                  (base.base_interp t5 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v0 : Z => Some v0
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v
                                          | _ => None
                                          end
                                        with
                                        | Some args3 =>
                                            UnderLets.Base
                                              (let
                                               '(a, b) :=
                                                ident.fancy.interp
                                                  (invert_Some
                                                     (ident.to_fancy
                                                        (ident.fancy_addc
                                                           log2wordmax imm)))
                                                  (args1, args2, args3) in
                                                (##(a)%expr, ##(b)%expr)%expr_pat)
                                        | None =>
                                            UnderLets.Base
                                              (#(ident.fancy_addc log2wordmax
                                                   imm)%expr @ x)%expr_pat
                                        end
                                    | _ =>
                                        UnderLets.Base
                                          (#(ident.fancy_addc log2wordmax imm)%expr @
                                           x)%expr_pat
                                    end
                                | None =>
                                    UnderLets.Base
                                      (#(ident.fancy_addc log2wordmax imm)%expr @
                                       x)%expr_pat
                                end
                            | _ =>
                                UnderLets.Base
                                  (#(ident.fancy_addc log2wordmax imm)%expr @
                                   x)%expr_pat
                            end
                        | None =>
                            UnderLets.Base
                              (#(ident.fancy_addc log2wordmax imm)%expr @ x)%expr_pat
                        end
                    | _ =>
                        UnderLets.Base
                          (#(ident.fancy_addc log2wordmax imm)%expr @ x)%expr_pat
                    end
                | None =>
                    UnderLets.Base
                      (#(ident.fancy_addc log2wordmax imm)%expr @ x)%expr_pat
                end
            | _ =>
                UnderLets.Base
                  (#(ident.fancy_addc log2wordmax imm)%expr @ x)%expr_pat
            end
        | None =>
            UnderLets.Base
              (#(ident.fancy_addc log2wordmax imm)%expr @ x)%expr_pat
        end
    | _ =>
        UnderLets.Base
          (#(ident.fancy_addc log2wordmax imm)%expr @ x)%expr_pat
    end
| ident.fancy_sub log2wordmax imm =>
    fun x : expr (type.base (base.type.Z * base.type.Z)%etype) =>
    match x with
    | (#(idc) @ x1 @ x0)%expr_pat =>
        match
          match idc with
          | @ident.pair A B => Some (A, B)
          | _ => None
          end
        with
        | Some _ =>
            match x1 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 =>
                    match x0 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args1 =>
                            UnderLets.Base
                              (let
                               '(a, b) :=
                                ident.fancy.interp
                                  (invert_Some
                                     (ident.to_fancy
                                        (ident.fancy_sub log2wordmax imm)))
                                  (args0, args1) in
                                (##(a)%expr, ##(b)%expr)%expr_pat)
                        | None =>
                            UnderLets.Base
                              (#(ident.fancy_sub log2wordmax imm)%expr @ x)%expr_pat
                        end
                    | _ =>
                        UnderLets.Base
                          (#(ident.fancy_sub log2wordmax imm)%expr @ x)%expr_pat
                    end
                | None =>
                    UnderLets.Base
                      (#(ident.fancy_sub log2wordmax imm)%expr @ x)%expr_pat
                end
            | _ =>
                UnderLets.Base
                  (#(ident.fancy_sub log2wordmax imm)%expr @ x)%expr_pat
            end
        | None =>
            UnderLets.Base
              (#(ident.fancy_sub log2wordmax imm)%expr @ x)%expr_pat
        end
    | _ =>
        UnderLets.Base (#(ident.fancy_sub log2wordmax imm)%expr @ x)%expr_pat
    end
| ident.fancy_subb log2wordmax imm =>
    fun x : expr (type.base (base.type.Z * base.type.Z * base.type.Z)%etype)
    =>
    match x with
    | (#(idc) @ x1 @ x0)%expr_pat =>
        match
          match idc with
          | @ident.pair A B => Some (A, B)
          | _ => None
          end
        with
        | Some _ =>
            match x1 with
            | (#(idc0) @ x3 @ x2)%expr_pat =>
                match
                  match idc0 with
                  | @ident.pair A B => Some (A, B)
                  | _ => None
                  end
                with
                | Some _ =>
                    match x3 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args1 =>
                            match x2 with
                            | #(idc2)%expr_pat =>
                                match
                                  match idc2 with
                                  | @ident.Literal t3 v =>
                                      match
                                        t3 as t4
                                        return
                                          (base.base_interp t4 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args2 =>
                                    match x0 with
                                    | #(idc3)%expr_pat =>
                                        match
                                          match idc3 with
                                          | @ident.Literal t4 v =>
                                              match
                                                t4 as t5
                                                return
                                                  (base.base_interp t5 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v0 : Z => Some v0
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v
                                          | _ => None
                                          end
                                        with
                                        | Some args3 =>
                                            UnderLets.Base
                                              (let
                                               '(a, b) :=
                                                ident.fancy.interp
                                                  (invert_Some
                                                     (ident.to_fancy
                                                        (ident.fancy_subb
                                                           log2wordmax imm)))
                                                  (args1, args2, args3) in
                                                (##(a)%expr, ##(b)%expr)%expr_pat)
                                        | None =>
                                            UnderLets.Base
                                              (#(ident.fancy_subb log2wordmax
                                                   imm)%expr @ x)%expr_pat
                                        end
                                    | _ =>
                                        UnderLets.Base
                                          (#(ident.fancy_subb log2wordmax imm)%expr @
                                           x)%expr_pat
                                    end
                                | None =>
                                    UnderLets.Base
                                      (#(ident.fancy_subb log2wordmax imm)%expr @
                                       x)%expr_pat
                                end
                            | _ =>
                                UnderLets.Base
                                  (#(ident.fancy_subb log2wordmax imm)%expr @
                                   x)%expr_pat
                            end
                        | None =>
                            UnderLets.Base
                              (#(ident.fancy_subb log2wordmax imm)%expr @ x)%expr_pat
                        end
                    | _ =>
                        UnderLets.Base
                          (#(ident.fancy_subb log2wordmax imm)%expr @ x)%expr_pat
                    end
                | None =>
                    UnderLets.Base
                      (#(ident.fancy_subb log2wordmax imm)%expr @ x)%expr_pat
                end
            | _ =>
                UnderLets.Base
                  (#(ident.fancy_subb log2wordmax imm)%expr @ x)%expr_pat
            end
        | None =>
            UnderLets.Base
              (#(ident.fancy_subb log2wordmax imm)%expr @ x)%expr_pat
        end
    | _ =>
        UnderLets.Base
          (#(ident.fancy_subb log2wordmax imm)%expr @ x)%expr_pat
    end
| ident.fancy_mulll log2wordmax =>
    fun x : expr (type.base (base.type.Z * base.type.Z)%etype) =>
    match x with
    | (#(idc) @ x1 @ x0)%expr_pat =>
        match
          match idc with
          | @ident.pair A B => Some (A, B)
          | _ => None
          end
        with
        | Some _ =>
            match x1 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 =>
                    match x0 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args1 =>
                            UnderLets.Base
                              ##(ident.fancy.interp
                                   (invert_Some
                                      (ident.to_fancy
                                         (ident.fancy_mulll log2wordmax)))
                                   (args0, args1)%core)%expr
                        | None =>
                            UnderLets.Base
                              (#(ident.fancy_mulll log2wordmax)%expr @ x)%expr_pat
                        end
                    | _ =>
                        UnderLets.Base
                          (#(ident.fancy_mulll log2wordmax)%expr @ x)%expr_pat
                    end
                | None =>
                    UnderLets.Base
                      (#(ident.fancy_mulll log2wordmax)%expr @ x)%expr_pat
                end
            | _ =>
                UnderLets.Base
                  (#(ident.fancy_mulll log2wordmax)%expr @ x)%expr_pat
            end
        | None =>
            UnderLets.Base
              (#(ident.fancy_mulll log2wordmax)%expr @ x)%expr_pat
        end
    | _ =>
        UnderLets.Base (#(ident.fancy_mulll log2wordmax)%expr @ x)%expr_pat
    end
| ident.fancy_mullh log2wordmax =>
    fun x : expr (type.base (base.type.Z * base.type.Z)%etype) =>
    match x with
    | (#(idc) @ x1 @ x0)%expr_pat =>
        match
          match idc with
          | @ident.pair A B => Some (A, B)
          | _ => None
          end
        with
        | Some _ =>
            match x1 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 =>
                    match x0 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args1 =>
                            UnderLets.Base
                              ##(ident.fancy.interp
                                   (invert_Some
                                      (ident.to_fancy
                                         (ident.fancy_mullh log2wordmax)))
                                   (args0, args1)%core)%expr
                        | None =>
                            UnderLets.Base
                              (#(ident.fancy_mullh log2wordmax)%expr @ x)%expr_pat
                        end
                    | _ =>
                        UnderLets.Base
                          (#(ident.fancy_mullh log2wordmax)%expr @ x)%expr_pat
                    end
                | None =>
                    UnderLets.Base
                      (#(ident.fancy_mullh log2wordmax)%expr @ x)%expr_pat
                end
            | _ =>
                UnderLets.Base
                  (#(ident.fancy_mullh log2wordmax)%expr @ x)%expr_pat
            end
        | None =>
            UnderLets.Base
              (#(ident.fancy_mullh log2wordmax)%expr @ x)%expr_pat
        end
    | _ =>
        UnderLets.Base (#(ident.fancy_mullh log2wordmax)%expr @ x)%expr_pat
    end
| ident.fancy_mulhl log2wordmax =>
    fun x : expr (type.base (base.type.Z * base.type.Z)%etype) =>
    match x with
    | (#(idc) @ x1 @ x0)%expr_pat =>
        match
          match idc with
          | @ident.pair A B => Some (A, B)
          | _ => None
          end
        with
        | Some _ =>
            match x1 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 =>
                    match x0 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args1 =>
                            UnderLets.Base
                              ##(ident.fancy.interp
                                   (invert_Some
                                      (ident.to_fancy
                                         (ident.fancy_mulhl log2wordmax)))
                                   (args0, args1)%core)%expr
                        | None =>
                            UnderLets.Base
                              (#(ident.fancy_mulhl log2wordmax)%expr @ x)%expr_pat
                        end
                    | _ =>
                        UnderLets.Base
                          (#(ident.fancy_mulhl log2wordmax)%expr @ x)%expr_pat
                    end
                | None =>
                    UnderLets.Base
                      (#(ident.fancy_mulhl log2wordmax)%expr @ x)%expr_pat
                end
            | _ =>
                UnderLets.Base
                  (#(ident.fancy_mulhl log2wordmax)%expr @ x)%expr_pat
            end
        | None =>
            UnderLets.Base
              (#(ident.fancy_mulhl log2wordmax)%expr @ x)%expr_pat
        end
    | _ =>
        UnderLets.Base (#(ident.fancy_mulhl log2wordmax)%expr @ x)%expr_pat
    end
| ident.fancy_mulhh log2wordmax =>
    fun x : expr (type.base (base.type.Z * base.type.Z)%etype) =>
    match x with
    | (#(idc) @ x1 @ x0)%expr_pat =>
        match
          match idc with
          | @ident.pair A B => Some (A, B)
          | _ => None
          end
        with
        | Some _ =>
            match x1 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 =>
                    match x0 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args1 =>
                            UnderLets.Base
                              ##(ident.fancy.interp
                                   (invert_Some
                                      (ident.to_fancy
                                         (ident.fancy_mulhh log2wordmax)))
                                   (args0, args1)%core)%expr
                        | None =>
                            UnderLets.Base
                              (#(ident.fancy_mulhh log2wordmax)%expr @ x)%expr_pat
                        end
                    | _ =>
                        UnderLets.Base
                          (#(ident.fancy_mulhh log2wordmax)%expr @ x)%expr_pat
                    end
                | None =>
                    UnderLets.Base
                      (#(ident.fancy_mulhh log2wordmax)%expr @ x)%expr_pat
                end
            | _ =>
                UnderLets.Base
                  (#(ident.fancy_mulhh log2wordmax)%expr @ x)%expr_pat
            end
        | None =>
            UnderLets.Base
              (#(ident.fancy_mulhh log2wordmax)%expr @ x)%expr_pat
        end
    | _ =>
        UnderLets.Base (#(ident.fancy_mulhh log2wordmax)%expr @ x)%expr_pat
    end
| ident.fancy_rshi log2wordmax x =>
    fun x0 : expr (type.base (base.type.Z * base.type.Z)%etype) =>
    match x0 with
    | (#(idc) @ x2 @ x1)%expr_pat =>
        match
          match idc with
          | @ident.pair A B => Some (A, B)
          | _ => None
          end
        with
        | Some _ =>
            match x2 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 =>
                    match x1 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args1 =>
                            UnderLets.Base
                              ##(ident.fancy.interp
                                   (invert_Some
                                      (ident.to_fancy
                                         (ident.fancy_rshi log2wordmax x)))
                                   (args0, args1)%core)%expr
                        | None =>
                            UnderLets.Base
                              (#(ident.fancy_rshi log2wordmax x)%expr @ x0)%expr_pat
                        end
                    | _ =>
                        UnderLets.Base
                          (#(ident.fancy_rshi log2wordmax x)%expr @ x0)%expr_pat
                    end
                | None =>
                    UnderLets.Base
                      (#(ident.fancy_rshi log2wordmax x)%expr @ x0)%expr_pat
                end
            | _ =>
                UnderLets.Base
                  (#(ident.fancy_rshi log2wordmax x)%expr @ x0)%expr_pat
            end
        | None =>
            UnderLets.Base
              (#(ident.fancy_rshi log2wordmax x)%expr @ x0)%expr_pat
        end
    | _ =>
        UnderLets.Base (#(ident.fancy_rshi log2wordmax x)%expr @ x0)%expr_pat
    end
| ident.fancy_selc =>
    fun x : expr (type.base (base.type.Z * base.type.Z * base.type.Z)%etype)
    =>
    match x with
    | (#(idc) @ x1 @ x0)%expr_pat =>
        match
          match idc with
          | @ident.pair A B => Some (A, B)
          | _ => None
          end
        with
        | Some _ =>
            match x1 with
            | (#(idc0) @ x3 @ x2)%expr_pat =>
                match
                  match idc0 with
                  | @ident.pair A B => Some (A, B)
                  | _ => None
                  end
                with
                | Some _ =>
                    match x3 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args1 =>
                            match x2 with
                            | #(idc2)%expr_pat =>
                                match
                                  match idc2 with
                                  | @ident.Literal t3 v =>
                                      match
                                        t3 as t4
                                        return
                                          (base.base_interp t4 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args2 =>
                                    match x0 with
                                    | #(idc3)%expr_pat =>
                                        match
                                          match idc3 with
                                          | @ident.Literal t4 v =>
                                              match
                                                t4 as t5
                                                return
                                                  (base.base_interp t5 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v0 : Z => Some v0
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v
                                          | _ => None
                                          end
                                        with
                                        | Some args3 =>
                                            UnderLets.Base
                                              ##(ident.fancy.interp
                                                   (invert_Some
                                                      (ident.to_fancy
                                                         ident.fancy_selc))
                                                   (args1, args2, args3)%core)%expr
                                        | None =>
                                            UnderLets.Base
                                              (#(ident.fancy_selc)%expr @ x)%expr_pat
                                        end
                                    | _ =>
                                        UnderLets.Base
                                          (#(ident.fancy_selc)%expr @ x)%expr_pat
                                    end
                                | None =>
                                    UnderLets.Base
                                      (#(ident.fancy_selc)%expr @ x)%expr_pat
                                end
                            | _ =>
                                UnderLets.Base
                                  (#(ident.fancy_selc)%expr @ x)%expr_pat
                            end
                        | None =>
                            UnderLets.Base
                              (#(ident.fancy_selc)%expr @ x)%expr_pat
                        end
                    | _ =>
                        UnderLets.Base
                          (#(ident.fancy_selc)%expr @ x)%expr_pat
                    end
                | None =>
                    UnderLets.Base (#(ident.fancy_selc)%expr @ x)%expr_pat
                end
            | _ => UnderLets.Base (#(ident.fancy_selc)%expr @ x)%expr_pat
            end
        | None => UnderLets.Base (#(ident.fancy_selc)%expr @ x)%expr_pat
        end
    | _ => UnderLets.Base (#(ident.fancy_selc)%expr @ x)%expr_pat
    end
| ident.fancy_selm log2wordmax =>
    fun x : expr (type.base (base.type.Z * base.type.Z * base.type.Z)%etype)
    =>
    match x with
    | (#(idc) @ x1 @ x0)%expr_pat =>
        match
          match idc with
          | @ident.pair A B => Some (A, B)
          | _ => None
          end
        with
        | Some _ =>
            match x1 with
            | (#(idc0) @ x3 @ x2)%expr_pat =>
                match
                  match idc0 with
                  | @ident.pair A B => Some (A, B)
                  | _ => None
                  end
                with
                | Some _ =>
                    match x3 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args1 =>
                            match x2 with
                            | #(idc2)%expr_pat =>
                                match
                                  match idc2 with
                                  | @ident.Literal t3 v =>
                                      match
                                        t3 as t4
                                        return
                                          (base.base_interp t4 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args2 =>
                                    match x0 with
                                    | #(idc3)%expr_pat =>
                                        match
                                          match idc3 with
                                          | @ident.Literal t4 v =>
                                              match
                                                t4 as t5
                                                return
                                                  (base.base_interp t5 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v0 : Z => Some v0
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v
                                          | _ => None
                                          end
                                        with
                                        | Some args3 =>
                                            UnderLets.Base
                                              ##(ident.fancy.interp
                                                   (invert_Some
                                                      (ident.to_fancy
                                                         (ident.fancy_selm
                                                            log2wordmax)))
                                                   (args1, args2, args3)%core)%expr
                                        | None =>
                                            UnderLets.Base
                                              (#(ident.fancy_selm log2wordmax)%expr @
                                               x)%expr_pat
                                        end
                                    | _ =>
                                        UnderLets.Base
                                          (#(ident.fancy_selm log2wordmax)%expr @
                                           x)%expr_pat
                                    end
                                | None =>
                                    UnderLets.Base
                                      (#(ident.fancy_selm log2wordmax)%expr @
                                       x)%expr_pat
                                end
                            | _ =>
                                UnderLets.Base
                                  (#(ident.fancy_selm log2wordmax)%expr @ x)%expr_pat
                            end
                        | None =>
                            UnderLets.Base
                              (#(ident.fancy_selm log2wordmax)%expr @ x)%expr_pat
                        end
                    | _ =>
                        UnderLets.Base
                          (#(ident.fancy_selm log2wordmax)%expr @ x)%expr_pat
                    end
                | None =>
                    UnderLets.Base
                      (#(ident.fancy_selm log2wordmax)%expr @ x)%expr_pat
                end
            | _ =>
                UnderLets.Base
                  (#(ident.fancy_selm log2wordmax)%expr @ x)%expr_pat
            end
        | None =>
            UnderLets.Base
              (#(ident.fancy_selm log2wordmax)%expr @ x)%expr_pat
        end
    | _ => UnderLets.Base (#(ident.fancy_selm log2wordmax)%expr @ x)%expr_pat
    end
| ident.fancy_sell =>
    fun x : expr (type.base (base.type.Z * base.type.Z * base.type.Z)%etype)
    =>
    match x with
    | (#(idc) @ x1 @ x0)%expr_pat =>
        match
          match idc with
          | @ident.pair A B => Some (A, B)
          | _ => None
          end
        with
        | Some _ =>
            match x1 with
            | (#(idc0) @ x3 @ x2)%expr_pat =>
                match
                  match idc0 with
                  | @ident.pair A B => Some (A, B)
                  | _ => None
                  end
                with
                | Some _ =>
                    match x3 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args1 =>
                            match x2 with
                            | #(idc2)%expr_pat =>
                                match
                                  match idc2 with
                                  | @ident.Literal t3 v =>
                                      match
                                        t3 as t4
                                        return
                                          (base.base_interp t4 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args2 =>
                                    match x0 with
                                    | #(idc3)%expr_pat =>
                                        match
                                          match idc3 with
                                          | @ident.Literal t4 v =>
                                              match
                                                t4 as t5
                                                return
                                                  (base.base_interp t5 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v0 : Z => Some v0
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v
                                          | _ => None
                                          end
                                        with
                                        | Some args3 =>
                                            UnderLets.Base
                                              ##(ident.fancy.interp
                                                   (invert_Some
                                                      (ident.to_fancy
                                                         ident.fancy_sell))
                                                   (args1, args2, args3)%core)%expr
                                        | None =>
                                            UnderLets.Base
                                              (#(ident.fancy_sell)%expr @ x)%expr_pat
                                        end
                                    | _ =>
                                        UnderLets.Base
                                          (#(ident.fancy_sell)%expr @ x)%expr_pat
                                    end
                                | None =>
                                    UnderLets.Base
                                      (#(ident.fancy_sell)%expr @ x)%expr_pat
                                end
                            | _ =>
                                UnderLets.Base
                                  (#(ident.fancy_sell)%expr @ x)%expr_pat
                            end
                        | None =>
                            UnderLets.Base
                              (#(ident.fancy_sell)%expr @ x)%expr_pat
                        end
                    | _ =>
                        UnderLets.Base
                          (#(ident.fancy_sell)%expr @ x)%expr_pat
                    end
                | None =>
                    UnderLets.Base (#(ident.fancy_sell)%expr @ x)%expr_pat
                end
            | _ => UnderLets.Base (#(ident.fancy_sell)%expr @ x)%expr_pat
            end
        | None => UnderLets.Base (#(ident.fancy_sell)%expr @ x)%expr_pat
        end
    | _ => UnderLets.Base (#(ident.fancy_sell)%expr @ x)%expr_pat
    end
| ident.fancy_addm =>
    fun x : expr (type.base (base.type.Z * base.type.Z * base.type.Z)%etype)
    =>
    match x with
    | (#(idc) @ x1 @ x0)%expr_pat =>
        match
          match idc with
          | @ident.pair A B => Some (A, B)
          | _ => None
          end
        with
        | Some _ =>
            match x1 with
            | (#(idc0) @ x3 @ x2)%expr_pat =>
                match
                  match idc0 with
                  | @ident.pair A B => Some (A, B)
                  | _ => None
                  end
                with
                | Some _ =>
                    match x3 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args1 =>
                            match x2 with
                            | #(idc2)%expr_pat =>
                                match
                                  match idc2 with
                                  | @ident.Literal t3 v =>
                                      match
                                        t3 as t4
                                        return
                                          (base.base_interp t4 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args2 =>
                                    match x0 with
                                    | #(idc3)%expr_pat =>
                                        match
                                          match idc3 with
                                          | @ident.Literal t4 v =>
                                              match
                                                t4 as t5
                                                return
                                                  (base.base_interp t5 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v0 : Z => Some v0
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v
                                          | _ => None
                                          end
                                        with
                                        | Some args3 =>
                                            UnderLets.Base
                                              ##(ident.fancy.interp
                                                   (invert_Some
                                                      (ident.to_fancy
                                                         ident.fancy_addm))
                                                   (args1, args2, args3)%core)%expr
                                        | None =>
                                            UnderLets.Base
                                              (#(ident.fancy_addm)%expr @ x)%expr_pat
                                        end
                                    | _ =>
                                        UnderLets.Base
                                          (#(ident.fancy_addm)%expr @ x)%expr_pat
                                    end
                                | None =>
                                    UnderLets.Base
                                      (#(ident.fancy_addm)%expr @ x)%expr_pat
                                end
                            | _ =>
                                UnderLets.Base
                                  (#(ident.fancy_addm)%expr @ x)%expr_pat
                            end
                        | None =>
                            UnderLets.Base
                              (#(ident.fancy_addm)%expr @ x)%expr_pat
                        end
                    | _ =>
                        UnderLets.Base
                          (#(ident.fancy_addm)%expr @ x)%expr_pat
                    end
                | None =>
                    UnderLets.Base (#(ident.fancy_addm)%expr @ x)%expr_pat
                end
            | _ => UnderLets.Base (#(ident.fancy_addm)%expr @ x)%expr_pat
            end
        | None => UnderLets.Base (#(ident.fancy_addm)%expr @ x)%expr_pat
        end
    | _ => UnderLets.Base (#(ident.fancy_addm)%expr @ x)%expr_pat
    end
end
     : Compile.value' true t
