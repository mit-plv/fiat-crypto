arith_rewrite_head = 
match idc in (ident t) return (value' true t) with
| @ident.Literal t v =>
    match
      t as t0
      return
        (base.base_interp t0 ->
         UnderLets.UnderLets base.type ident var
           (defaults.expr (type.base t0)))
    with
    | base.type.unit => fun v0 : unit => UnderLets.Base (##v0)%expr
    | base.type.Z => fun v0 : Z => UnderLets.Base (##v0)%expr
    | base.type.bool => fun v0 : bool => UnderLets.Base (##v0)%expr
    | base.type.nat => fun v0 : nat => UnderLets.Base (##v0)%expr
    end v
| ident.Nat_succ =>
    fun x : defaults.expr (type.base base.type.nat) =>
    UnderLets.Base (#(ident.Nat_succ)%expr @ x)%expr_pat
| ident.Nat_pred =>
    fun x : defaults.expr (type.base base.type.nat) =>
    UnderLets.Base (#(ident.Nat_pred)%expr @ x)%expr_pat
| ident.Nat_max =>
    fun x x0 : defaults.expr (type.base base.type.nat) =>
    UnderLets.Base (#(ident.Nat_max)%expr @ x @ x0)%expr_pat
| ident.Nat_mul =>
    fun x x0 : defaults.expr (type.base base.type.nat) =>
    UnderLets.Base (#(ident.Nat_mul)%expr @ x @ x0)%expr_pat
| ident.Nat_add =>
    fun x x0 : defaults.expr (type.base base.type.nat) =>
    UnderLets.Base (#(ident.Nat_add)%expr @ x @ x0)%expr_pat
| ident.Nat_sub =>
    fun x x0 : defaults.expr (type.base base.type.nat) =>
    UnderLets.Base (#(ident.Nat_sub)%expr @ x @ x0)%expr_pat
| @ident.nil t => UnderLets.Base []%expr_pat
| @ident.cons t =>
    fun (x : defaults.expr (type.base t))
      (x0 : defaults.expr (type.base (base.type.list t))) =>
    UnderLets.Base (x :: x0)%expr_pat
| @ident.pair A B =>
    fun (x : defaults.expr (type.base A)) (x0 : defaults.expr (type.base B))
    => UnderLets.Base (x, x0)%expr_pat
| @ident.fst A B =>
    fun x : defaults.expr (type.base (A * B)%etype) =>
    ((match x with
      | @expr.App _ _ _ s _
        (@expr.App _ _ _ s0 _ (@expr.Ident _ _ _ t idc) x1) x0 =>
          _ <- pattern.ident.invert_bind_args idc pattern.ident.pair;
          match
            s0 as t2
            return
              (value' false t2 ->
               option
                 (UnderLets.UnderLets base.type ident var
                    (defaults.expr (type.base A))))
          with
          | type.base t2 =>
              fun v : defaults.expr (type.base t2) =>
              match
                s as t3
                return
                  (value' false t3 ->
                   option
                     (UnderLets.UnderLets base.type ident var
                        (defaults.expr (type.base A))))
              with
              | type.base t3 =>
                  fun _ : defaults.expr (type.base t3) =>
                  Some
                    (base.try_make_transport_cps t2 A
                       (fun
                          a : option
                                (defaults.expr (type.base t2) ->
                                 defaults.expr (type.base A)) =>
                        match a with
                        | Some x' => UnderLets.Base (x' v)
                        | None =>
                            UnderLets.Base
                              (ERROR_BAD_REWRITE_RULE
                                 (#(pident.fst) @ (??, ??))
                                 (#(ident.fst)%expr @ x)%expr_pat)
                        end))
              | (s1 -> d1)%ptype =>
                  fun _ : value' false s1 -> value' true d1 => None
              end (reflect x0)
          | (s1 -> d1)%ptype =>
              fun _ : value' false s1 -> value' true d1 => None
          end (reflect x1)
      | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ ($_)%expr _) _ | @expr.App
        _ _ _ s _ (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _) _ |
        @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ (_ @ _)%expr_pat _) _ |
        @expr.App _ _ _ s _
        (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _) _ => None
      | @expr.App _ _ _ s _ #(_)%expr_pat _ | @expr.App _ _ _ s _ ($_)%expr
        _ | @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s
        _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
      | _ => None
      end;;
      None);;;
     UnderLets.Base (#(ident.fst)%expr @ x)%expr_pat)%option
| @ident.snd A B =>
    fun x : defaults.expr (type.base (A * B)%etype) =>
    ((match x with
      | @expr.App _ _ _ s _
        (@expr.App _ _ _ s0 _ (@expr.Ident _ _ _ t idc) x1) x0 =>
          _ <- pattern.ident.invert_bind_args idc pattern.ident.pair;
          match
            s0 as t2
            return
              (value' false t2 ->
               option
                 (UnderLets.UnderLets base.type ident var
                    (defaults.expr (type.base B))))
          with
          | type.base t2 =>
              fun _ : defaults.expr (type.base t2) =>
              match
                s as t3
                return
                  (value' false t3 ->
                   option
                     (UnderLets.UnderLets base.type ident var
                        (defaults.expr (type.base B))))
              with
              | type.base t3 =>
                  fun v0 : defaults.expr (type.base t3) =>
                  Some
                    (base.try_make_transport_cps t3 B
                       (fun
                          a : option
                                (defaults.expr (type.base t3) ->
                                 defaults.expr (type.base B)) =>
                        match a with
                        | Some x' => UnderLets.Base (x' v0)
                        | None =>
                            UnderLets.Base
                              (ERROR_BAD_REWRITE_RULE
                                 (#(pident.snd) @ (??, ??))
                                 (#(ident.snd)%expr @ x)%expr_pat)
                        end))
              | (s1 -> d1)%ptype =>
                  fun _ : value' false s1 -> value' true d1 => None
              end (reflect x0)
          | (s1 -> d1)%ptype =>
              fun _ : value' false s1 -> value' true d1 => None
          end (reflect x1)
      | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ ($_)%expr _) _ | @expr.App
        _ _ _ s _ (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _) _ |
        @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ (_ @ _)%expr_pat _) _ |
        @expr.App _ _ _ s _
        (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _) _ => None
      | @expr.App _ _ _ s _ #(_)%expr_pat _ | @expr.App _ _ _ s _ ($_)%expr
        _ | @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s
        _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
      | _ => None
      end;;
      None);;;
     UnderLets.Base (#(ident.snd)%expr @ x)%expr_pat)%option
| @ident.prod_rect A B T =>
    fun
      (x : defaults.expr (type.base A) ->
           defaults.expr (type.base B) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base T)))
      (x0 : defaults.expr (type.base (A * B)%etype)) =>
    UnderLets.Base
      (#(ident.prod_rect)%expr @
       (λ (x1 : var (type.base A))(x2 : var (type.base B)),
        UnderLets.to_expr (x ($x1) ($x2)))%expr @ x0)%expr_pat
| @ident.bool_rect T =>
    fun
      (x
       x0 : defaults.expr (type.base base.type.unit) ->
            UnderLets.UnderLets base.type ident var
              (defaults.expr (type.base T)))
      (x1 : defaults.expr (type.base base.type.bool)) =>
    UnderLets.Base
      (#(ident.bool_rect)%expr @
       (λ x2 : var (type.base base.type.unit),
        UnderLets.to_expr (x ($x2)))%expr @
       (λ x2 : var (type.base base.type.unit),
        UnderLets.to_expr (x0 ($x2)))%expr @ x1)%expr_pat
| @ident.nat_rect P =>
    fun
      (x : defaults.expr (type.base base.type.unit) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base P)))
      (x0 : defaults.expr (type.base base.type.nat) ->
            defaults.expr (type.base P) ->
            UnderLets.UnderLets base.type ident var
              (defaults.expr (type.base P)))
      (x1 : defaults.expr (type.base base.type.nat)) =>
    UnderLets.Base
      (#(ident.nat_rect)%expr @
       (λ x2 : var (type.base base.type.unit),
        UnderLets.to_expr (x ($x2)))%expr @
       (λ (x2 : var (type.base base.type.nat))(x3 : var (type.base P)),
        UnderLets.to_expr (x0 ($x2) ($x3)))%expr @ x1)%expr_pat
| @ident.nat_rect_arrow P Q =>
    fun
      (x : defaults.expr (type.base P) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base Q)))
      (x0 : defaults.expr (type.base base.type.nat) ->
            (defaults.expr (type.base P) ->
             UnderLets.UnderLets base.type ident var
               (defaults.expr (type.base Q))) ->
            defaults.expr (type.base P) ->
            UnderLets.UnderLets base.type ident var
              (defaults.expr (type.base Q)))
      (x1 : defaults.expr (type.base base.type.nat))
      (x2 : defaults.expr (type.base P)) =>
    UnderLets.Base
      (#(ident.nat_rect_arrow)%expr @
       (λ x3 : var (type.base P),
        UnderLets.to_expr (x ($x3)))%expr @
       (λ (x3 : var (type.base base.type.nat))(x4 : var
                                                      (type.base P ->
                                                       type.base Q)%ptype)
        (x5 : var (type.base P)),
        UnderLets.to_expr
          (x0 ($x3)
             (fun x6 : defaults.expr (type.base P) =>
              UnderLets.Base ($x4 @ x6)%expr_pat) ($x5)))%expr @ x1 @ x2)%expr_pat
| @ident.list_rect A P =>
    fun
      (x : defaults.expr (type.base base.type.unit) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base P)))
      (x0 : defaults.expr (type.base A) ->
            defaults.expr (type.base (base.type.list A)) ->
            defaults.expr (type.base P) ->
            UnderLets.UnderLets base.type ident var
              (defaults.expr (type.base P)))
      (x1 : defaults.expr (type.base (base.type.list A))) =>
    UnderLets.Base
      (#(ident.list_rect)%expr @
       (λ x2 : var (type.base base.type.unit),
        UnderLets.to_expr (x ($x2)))%expr @
       (λ (x2 : var (type.base A))(x3 : var (type.base (base.type.list A)))
        (x4 : var (type.base P)),
        UnderLets.to_expr (x0 ($x2) ($x3) ($x4)))%expr @ x1)%expr_pat
| @ident.list_case A P =>
    fun
      (x : defaults.expr (type.base base.type.unit) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base P)))
      (x0 : defaults.expr (type.base A) ->
            defaults.expr (type.base (base.type.list A)) ->
            UnderLets.UnderLets base.type ident var
              (defaults.expr (type.base P)))
      (x1 : defaults.expr (type.base (base.type.list A))) =>
    UnderLets.Base
      (#(ident.list_case)%expr @
       (λ x2 : var (type.base base.type.unit),
        UnderLets.to_expr (x ($x2)))%expr @
       (λ (x2 : var (type.base A))(x3 : var (type.base (base.type.list A))),
        UnderLets.to_expr (x0 ($x2) ($x3)))%expr @ x1)%expr_pat
| @ident.List_length T =>
    fun x : defaults.expr (type.base (base.type.list T)) =>
    UnderLets.Base (#(ident.List_length)%expr @ x)%expr_pat
| ident.List_seq =>
    fun x x0 : defaults.expr (type.base base.type.nat) =>
    UnderLets.Base (#(ident.List_seq)%expr @ x @ x0)%expr_pat
| @ident.List_firstn A =>
    fun (x : defaults.expr (type.base base.type.nat))
      (x0 : defaults.expr (type.base (base.type.list A))) =>
    UnderLets.Base (#(ident.List_firstn)%expr @ x @ x0)%expr_pat
| @ident.List_skipn A =>
    fun (x : defaults.expr (type.base base.type.nat))
      (x0 : defaults.expr (type.base (base.type.list A))) =>
    UnderLets.Base (#(ident.List_skipn)%expr @ x @ x0)%expr_pat
| @ident.List_repeat A =>
    fun (x : defaults.expr (type.base A))
      (x0 : defaults.expr (type.base base.type.nat)) =>
    UnderLets.Base (#(ident.List_repeat)%expr @ x @ x0)%expr_pat
| @ident.List_combine A B =>
    fun (x : defaults.expr (type.base (base.type.list A)))
      (x0 : defaults.expr (type.base (base.type.list B))) =>
    UnderLets.Base (#(ident.List_combine)%expr @ x @ x0)%expr_pat
| @ident.List_map A B =>
    fun
      (x : defaults.expr (type.base A) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base B)))
      (x0 : defaults.expr (type.base (base.type.list A))) =>
    UnderLets.Base
      (#(ident.List_map)%expr @
       (λ x1 : var (type.base A),
        UnderLets.to_expr (x ($x1)))%expr @ x0)%expr_pat
| @ident.List_app A =>
    fun x x0 : defaults.expr (type.base (base.type.list A)) =>
    UnderLets.Base (x ++ x0)%expr
| @ident.List_rev A =>
    fun x : defaults.expr (type.base (base.type.list A)) =>
    UnderLets.Base (#(ident.List_rev)%expr @ x)%expr_pat
| @ident.List_flat_map A B =>
    fun
      (x : defaults.expr (type.base A) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base (base.type.list B))))
      (x0 : defaults.expr (type.base (base.type.list A))) =>
    UnderLets.Base
      (#(ident.List_flat_map)%expr @
       (λ x1 : var (type.base A),
        UnderLets.to_expr (x ($x1)))%expr @ x0)%expr_pat
| @ident.List_partition A =>
    fun
      (x : defaults.expr (type.base A) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base base.type.bool)))
      (x0 : defaults.expr (type.base (base.type.list A))) =>
    UnderLets.Base
      (#(ident.List_partition)%expr @
       (λ x1 : var (type.base A),
        UnderLets.to_expr (x ($x1)))%expr @ x0)%expr_pat
| @ident.List_fold_right A B =>
    fun
      (x : defaults.expr (type.base B) ->
           defaults.expr (type.base A) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base A)))
      (x0 : defaults.expr (type.base A))
      (x1 : defaults.expr (type.base (base.type.list B))) =>
    UnderLets.Base
      (#(ident.List_fold_right)%expr @
       (λ (x2 : var (type.base B))(x3 : var (type.base A)),
        UnderLets.to_expr (x ($x2) ($x3)))%expr @ x0 @ x1)%expr_pat
| @ident.List_update_nth T =>
    fun (x : defaults.expr (type.base base.type.nat))
      (x0 : defaults.expr (type.base T) ->
            UnderLets.UnderLets base.type ident var
              (defaults.expr (type.base T)))
      (x1 : defaults.expr (type.base (base.type.list T))) =>
    UnderLets.Base
      (#(ident.List_update_nth)%expr @ x @
       (λ x2 : var (type.base T),
        UnderLets.to_expr (x0 ($x2)))%expr @ x1)%expr_pat
| @ident.List_nth_default T =>
    fun (x : defaults.expr (type.base T))
      (x0 : defaults.expr (type.base (base.type.list T)))
      (x1 : defaults.expr (type.base base.type.nat)) =>
    UnderLets.Base (#(ident.List_nth_default)%expr @ x @ x0 @ x1)%expr_pat
| ident.Z_add =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    (((match x with
       | @expr.Ident _ _ _ t idc =>
           args <- pattern.ident.invert_bind_args idc pattern.ident.LiteralZ;
           (if args =? 0 then Some (UnderLets.Base x0) else None)
       | _ => None
       end;;
       match x0 with
       | @expr.Ident _ _ _ t idc =>
           args <- pattern.ident.invert_bind_args idc pattern.ident.LiteralZ;
           (if args =? 0 then Some (UnderLets.Base x) else None);;
           match x with
           | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t0 idc0) x1 =>
               _ <- pattern.ident.invert_bind_args idc0 pattern.ident.Z_opp;
               match
                 s as t2
                 return
                   (value' false t2 ->
                    option
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr (type.base base.type.Z))))
               with
               | type.base t2 =>
                   fun v : defaults.expr (type.base t2) =>
                   base.try_make_transport_cps t2 base.type.Z
                     (fun
                        a : option
                              (defaults.expr (type.base t2) ->
                               defaults.expr (type.base base.type.Z)) =>
                      match a with
                      | Some x' =>
                          if args >? 0
                          then Some (UnderLets.Base (##args - x' v)%expr)
                          else None
                      | None => None
                      end)
               | (s0 -> d0)%ptype =>
                   fun _ : value' false s0 -> value' true d0 => None
               end (reflect x1);;
               match
                 s as t2
                 return
                   (value' false t2 ->
                    option
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr (type.base base.type.Z))))
               with
               | type.base t2 =>
                   fun v : defaults.expr (type.base t2) =>
                   base.try_make_transport_cps t2 base.type.Z
                     (fun
                        a : option
                              (defaults.expr (type.base t2) ->
                               defaults.expr (type.base base.type.Z)) =>
                      match a with
                      | Some x' =>
                          if args <? 0
                          then
                           Some
                             (UnderLets.Base (- (x' v + ##(- args)%Z))%expr)
                          else None
                      | None => None
                      end)
               | (s0 -> d0)%ptype =>
                   fun _ : value' false s0 -> value' true d0 => None
               end (reflect x1)
           | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
             (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat
             _ | @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
           | _ => None
           end
       | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t idc) x1 =>
           _ <- pattern.ident.invert_bind_args idc pattern.ident.Z_opp;
           match x with
           | @expr.Ident _ _ _ t0 idc0 =>
               args0 <- pattern.ident.invert_bind_args idc0
                          pattern.ident.LiteralZ;
               match
                 s as t2
                 return
                   (value' false t2 ->
                    option
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr (type.base base.type.Z))))
               with
               | type.base t2 =>
                   fun v : defaults.expr (type.base t2) =>
                   base.try_make_transport_cps t2 base.type.Z
                     (fun
                        a : option
                              (defaults.expr (type.base t2) ->
                               defaults.expr (type.base base.type.Z)) =>
                      match a with
                      | Some x' =>
                          if args0 >? 0
                          then Some (UnderLets.Base (##args0 - x' v)%expr)
                          else None
                      | None => None
                      end)
               | (s0 -> d0)%ptype =>
                   fun _ : value' false s0 -> value' true d0 => None
               end (reflect x1);;
               match
                 s as t2
                 return
                   (value' false t2 ->
                    option
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr (type.base base.type.Z))))
               with
               | type.base t2 =>
                   fun v : defaults.expr (type.base t2) =>
                   base.try_make_transport_cps t2 base.type.Z
                     (fun
                        a : option
                              (defaults.expr (type.base t2) ->
                               defaults.expr (type.base base.type.Z)) =>
                      match a with
                      | Some x' =>
                          if args0 <? 0
                          then
                           Some
                             (UnderLets.Base (- (##(- args0)%Z + x' v))%expr)
                          else None
                      | None => None
                      end)
               | (s0 -> d0)%ptype =>
                   fun _ : value' false s0 -> value' true d0 => None
               end (reflect x1)
           | @expr.App _ _ _ s0 _ (@expr.Ident _ _ _ t0 idc0) x2 =>
               _ <- pattern.ident.invert_bind_args idc0 pattern.ident.Z_opp;
               match
                 s0 as t2
                 return
                   (value' false t2 ->
                    option
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr (type.base base.type.Z))))
               with
               | type.base t2 =>
                   fun v : defaults.expr (type.base t2) =>
                   base.try_make_transport_cps t2 base.type.Z
                     (fun
                        a : option
                              (defaults.expr (type.base t2) ->
                               defaults.expr (type.base base.type.Z)) =>
                      match a with
                      | Some x' =>
                          match
                            s as t3
                            return
                              (value' false t3 ->
                               option
                                 (UnderLets.UnderLets base.type ident var
                                    (defaults.expr (type.base base.type.Z))))
                          with
                          | type.base t3 =>
                              fun v0 : defaults.expr (type.base t3) =>
                              base.try_make_transport_cps t3 base.type.Z
                                (fun
                                   a0 : option
                                          (defaults.expr (type.base t3) ->
                                           defaults.expr
                                             (type.base base.type.Z)) =>
                                 match a0 with
                                 | Some x'0 =>
                                     Some
                                       (UnderLets.Base
                                          (- (x' v + x'0 v0))%expr)
                                 | None => None
                                 end)
                          | (s1 -> d1)%ptype =>
                              fun _ : value' false s1 -> value' true d1 =>
                              None
                          end (reflect x1)
                      | None => None
                      end)
               | (s1 -> d1)%ptype =>
                   fun _ : value' false s1 -> value' true d1 => None
               end (reflect x2)
           | @expr.App _ _ _ s0 _ ($_)%expr _ | @expr.App _ _ _ s0 _
             (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0 _
             (_ @ _)%expr_pat _ | @expr.App _ _ _ s0 _
             (@expr.LetIn _ _ _ _ _ _ _) _ => None
           | _ => None
           end
       | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
         (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat _ |
         @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
       | _ => None
       end;;
       match x with
       | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t idc) x1 =>
           _ <- pattern.ident.invert_bind_args idc pattern.ident.Z_opp;
           match
             s as t2
             return
               (value' false t2 ->
                option
                  (UnderLets.UnderLets base.type ident var
                     (defaults.expr (type.base base.type.Z))))
           with
           | type.base t2 =>
               fun v : defaults.expr (type.base t2) =>
               base.try_make_transport_cps t2 base.type.Z
                 (fun
                    a : option
                          (defaults.expr (type.base t2) ->
                           defaults.expr (type.base base.type.Z)) =>
                  match a with
                  | Some x' => Some (UnderLets.Base (x0 - x' v)%expr)
                  | None => None
                  end)
           | (s0 -> d0)%ptype =>
               fun _ : value' false s0 -> value' true d0 => None
           end (reflect x1)
       | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
         (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat _ |
         @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
       | _ => None
       end;;
       match x0 with
       | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t idc) x1 =>
           _ <- pattern.ident.invert_bind_args idc pattern.ident.Z_opp;
           match
             s as t2
             return
               (value' false t2 ->
                option
                  (UnderLets.UnderLets base.type ident var
                     (defaults.expr (type.base base.type.Z))))
           with
           | type.base t2 =>
               fun v : defaults.expr (type.base t2) =>
               base.try_make_transport_cps t2 base.type.Z
                 (fun
                    a : option
                          (defaults.expr (type.base t2) ->
                           defaults.expr (type.base base.type.Z)) =>
                  match a with
                  | Some x' => Some (UnderLets.Base (x - x' v)%expr)
                  | None => None
                  end)
           | (s0 -> d0)%ptype =>
               fun _ : value' false s0 -> value' true d0 => None
           end (reflect x1)
       | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
         (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat _ |
         @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
       | _ => None
       end);;
      None);;;
     UnderLets.Base (x + x0)%expr)%option
| ident.Z_mul =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    (((match x with
       | @expr.Ident _ _ _ t idc =>
           args <- pattern.ident.invert_bind_args idc pattern.ident.LiteralZ;
           (if args =? 0 then Some (UnderLets.Base (##0)%expr) else None)
       | _ => None
       end;;
       match x0 with
       | @expr.Ident _ _ _ t idc =>
           args <- pattern.ident.invert_bind_args idc pattern.ident.LiteralZ;
           (if args =? 0 then Some (UnderLets.Base (##0)%expr) else None)
       | _ => None
       end;;
       match x with
       | @expr.Ident _ _ _ t idc =>
           args <- pattern.ident.invert_bind_args idc pattern.ident.LiteralZ;
           (if args =? 1 then Some (UnderLets.Base x0) else None)
       | _ => None
       end;;
       match x0 with
       | @expr.Ident _ _ _ t idc =>
           args <- pattern.ident.invert_bind_args idc pattern.ident.LiteralZ;
           (if args =? 1 then Some (UnderLets.Base x) else None);;
           match x with
           | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t0 idc0) x1 =>
               _ <- pattern.ident.invert_bind_args idc0 pattern.ident.Z_opp;
               match
                 s as t2
                 return
                   (value' false t2 ->
                    option
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr (type.base base.type.Z))))
               with
               | type.base t2 =>
                   fun v : defaults.expr (type.base t2) =>
                   base.try_make_transport_cps t2 base.type.Z
                     (fun
                        a : option
                              (defaults.expr (type.base t2) ->
                               defaults.expr (type.base base.type.Z)) =>
                      match a with
                      | Some x' =>
                          if args =? -1
                          then Some (UnderLets.Base (x' v))
                          else None
                      | None => None
                      end)
               | (s0 -> d0)%ptype =>
                   fun _ : value' false s0 -> value' true d0 => None
               end (reflect x1)
           | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
             (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat
             _ | @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
           | _ => None
           end
       | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t idc) x1 =>
           _ <- pattern.ident.invert_bind_args idc pattern.ident.Z_opp;
           match x with
           | @expr.Ident _ _ _ t0 idc0 =>
               args0 <- pattern.ident.invert_bind_args idc0
                          pattern.ident.LiteralZ;
               match
                 s as t2
                 return
                   (value' false t2 ->
                    option
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr (type.base base.type.Z))))
               with
               | type.base t2 =>
                   fun v : defaults.expr (type.base t2) =>
                   base.try_make_transport_cps t2 base.type.Z
                     (fun
                        a : option
                              (defaults.expr (type.base t2) ->
                               defaults.expr (type.base base.type.Z)) =>
                      match a with
                      | Some x' =>
                          if args0 =? -1
                          then Some (UnderLets.Base (x' v))
                          else None
                      | None => None
                      end)
               | (s0 -> d0)%ptype =>
                   fun _ : value' false s0 -> value' true d0 => None
               end (reflect x1)
           | _ => None
           end
       | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
         (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat _ |
         @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
       | _ => None
       end;;
       match x with
       | @expr.Ident _ _ _ t idc =>
           args <- pattern.ident.invert_bind_args idc pattern.ident.LiteralZ;
           (if args =? -1 then Some (UnderLets.Base (- x0)%expr) else None)
       | _ => None
       end;;
       match x0 with
       | @expr.Ident _ _ _ t idc =>
           args <- pattern.ident.invert_bind_args idc pattern.ident.LiteralZ;
           (if args =? -1 then Some (UnderLets.Base (- x)%expr) else None)
       | _ => None
       end;;
       match x with
       | @expr.Ident _ _ _ t idc =>
           args <- pattern.ident.invert_bind_args idc pattern.ident.LiteralZ;
           (if args <? 0
            then Some (UnderLets.Base (- (##(- args)%Z * x0))%expr)
            else None)
       | _ => None
       end;;
       match x0 with
       | @expr.Ident _ _ _ t idc =>
           args <- pattern.ident.invert_bind_args idc pattern.ident.LiteralZ;
           (if args <? 0
            then Some (UnderLets.Base (- (x * ##(- args)%Z))%expr)
            else None)
       | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t idc) x1 =>
           _ <- pattern.ident.invert_bind_args idc pattern.ident.Z_opp;
           match x with
           | @expr.App _ _ _ s0 _ (@expr.Ident _ _ _ t0 idc0) x2 =>
               _ <- pattern.ident.invert_bind_args idc0 pattern.ident.Z_opp;
               match
                 s0 as t2
                 return
                   (value' false t2 ->
                    option
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr (type.base base.type.Z))))
               with
               | type.base t2 =>
                   fun v : defaults.expr (type.base t2) =>
                   base.try_make_transport_cps t2 base.type.Z
                     (fun
                        a : option
                              (defaults.expr (type.base t2) ->
                               defaults.expr (type.base base.type.Z)) =>
                      match a with
                      | Some x' =>
                          match
                            s as t3
                            return
                              (value' false t3 ->
                               option
                                 (UnderLets.UnderLets base.type ident var
                                    (defaults.expr (type.base base.type.Z))))
                          with
                          | type.base t3 =>
                              fun v0 : defaults.expr (type.base t3) =>
                              base.try_make_transport_cps t3 base.type.Z
                                (fun
                                   a0 : option
                                          (defaults.expr (type.base t3) ->
                                           defaults.expr
                                             (type.base base.type.Z)) =>
                                 match a0 with
                                 | Some x'0 =>
                                     Some
                                       (UnderLets.Base (x' v * x'0 v0)%expr)
                                 | None => None
                                 end)
                          | (s1 -> d1)%ptype =>
                              fun _ : value' false s1 -> value' true d1 =>
                              None
                          end (reflect x1)
                      | None => None
                      end)
               | (s1 -> d1)%ptype =>
                   fun _ : value' false s1 -> value' true d1 => None
               end (reflect x2)
           | @expr.App _ _ _ s0 _ ($_)%expr _ | @expr.App _ _ _ s0 _
             (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0 _
             (_ @ _)%expr_pat _ | @expr.App _ _ _ s0 _
             (@expr.LetIn _ _ _ _ _ _ _) _ => None
           | _ => None
           end
       | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
         (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat _ |
         @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
       | _ => None
       end;;
       match x with
       | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t idc) x1 =>
           _ <- pattern.ident.invert_bind_args idc pattern.ident.Z_opp;
           match
             s as t2
             return
               (value' false t2 ->
                option
                  (UnderLets.UnderLets base.type ident var
                     (defaults.expr (type.base base.type.Z))))
           with
           | type.base t2 =>
               fun v : defaults.expr (type.base t2) =>
               base.try_make_transport_cps t2 base.type.Z
                 (fun
                    a : option
                          (defaults.expr (type.base t2) ->
                           defaults.expr (type.base base.type.Z)) =>
                  match a with
                  | Some x' => Some (UnderLets.Base (- (x' v * x0))%expr)
                  | None => None
                  end)
           | (s0 -> d0)%ptype =>
               fun _ : value' false s0 -> value' true d0 => None
           end (reflect x1)
       | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
         (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat _ |
         @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
       | _ => None
       end;;
       match x0 with
       | @expr.Ident _ _ _ t idc =>
           args <- pattern.ident.invert_bind_args idc pattern.ident.LiteralZ;
           (if (args =? 2 ^ Z.log2 args) && negb (args =? 2)
            then Some (UnderLets.Base (x << ##(Z.log2 args))%expr)
            else None)
       | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t idc) x1 =>
           _ <- pattern.ident.invert_bind_args idc pattern.ident.Z_opp;
           match
             s as t2
             return
               (value' false t2 ->
                option
                  (UnderLets.UnderLets base.type ident var
                     (defaults.expr (type.base base.type.Z))))
           with
           | type.base t2 =>
               fun v : defaults.expr (type.base t2) =>
               base.try_make_transport_cps t2 base.type.Z
                 (fun
                    a : option
                          (defaults.expr (type.base t2) ->
                           defaults.expr (type.base base.type.Z)) =>
                  match a with
                  | Some x' => Some (UnderLets.Base (- (x * x' v))%expr)
                  | None => None
                  end)
           | (s0 -> d0)%ptype =>
               fun _ : value' false s0 -> value' true d0 => None
           end (reflect x1)
       | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
         (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat _ |
         @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
       | _ => None
       end;;
       match x with
       | @expr.Ident _ _ _ t idc =>
           args <- pattern.ident.invert_bind_args idc pattern.ident.LiteralZ;
           (if (args =? 2 ^ Z.log2 args) && negb (args =? 2)
            then Some (UnderLets.Base (x0 << ##(Z.log2 args))%expr)
            else None)
       | _ => None
       end);;
      None);;;
     UnderLets.Base (x * x0)%expr)%option
| ident.Z_pow =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_pow)%expr @ x @ x0)%expr_pat
| ident.Z_sub =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    (((match x with
       | @expr.Ident _ _ _ t idc =>
           args <- pattern.ident.invert_bind_args idc pattern.ident.LiteralZ;
           match x0 with
           | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t0 idc0) x1 =>
               _ <- pattern.ident.invert_bind_args idc0 pattern.ident.Z_opp;
               match
                 s as t2
                 return
                   (value' false t2 ->
                    option
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr (type.base base.type.Z))))
               with
               | type.base t2 =>
                   fun v : defaults.expr (type.base t2) =>
                   base.try_make_transport_cps t2 base.type.Z
                     (fun
                        a : option
                              (defaults.expr (type.base t2) ->
                               defaults.expr (type.base base.type.Z)) =>
                      match a with
                      | Some x' =>
                          if args =? 0
                          then Some (UnderLets.Base (x' v))
                          else None
                      | None => None
                      end)
               | (s0 -> d0)%ptype =>
                   fun _ : value' false s0 -> value' true d0 => None
               end (reflect x1)
           | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
             (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat
             _ | @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
           | _ => None
           end;;
           (if args =? 0 then Some (UnderLets.Base (- x0)%expr) else None)
       | _ => None
       end;;
       match x0 with
       | @expr.Ident _ _ _ t idc =>
           args <- pattern.ident.invert_bind_args idc pattern.ident.LiteralZ;
           (if args =? 0 then Some (UnderLets.Base x) else None)
       | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t idc) x1 =>
           _ <- pattern.ident.invert_bind_args idc pattern.ident.Z_opp;
           match x with
           | @expr.Ident _ _ _ t0 idc0 =>
               args0 <- pattern.ident.invert_bind_args idc0
                          pattern.ident.LiteralZ;
               match
                 s as t2
                 return
                   (value' false t2 ->
                    option
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr (type.base base.type.Z))))
               with
               | type.base t2 =>
                   fun v : defaults.expr (type.base t2) =>
                   base.try_make_transport_cps t2 base.type.Z
                     (fun
                        a : option
                              (defaults.expr (type.base t2) ->
                               defaults.expr (type.base base.type.Z)) =>
                      match a with
                      | Some x' =>
                          if args0 >? 0
                          then Some (UnderLets.Base (##args0 + x' v)%expr)
                          else None
                      | None => None
                      end)
               | (s0 -> d0)%ptype =>
                   fun _ : value' false s0 -> value' true d0 => None
               end (reflect x1);;
               match
                 s as t2
                 return
                   (value' false t2 ->
                    option
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr (type.base base.type.Z))))
               with
               | type.base t2 =>
                   fun v : defaults.expr (type.base t2) =>
                   base.try_make_transport_cps t2 base.type.Z
                     (fun
                        a : option
                              (defaults.expr (type.base t2) ->
                               defaults.expr (type.base base.type.Z)) =>
                      match a with
                      | Some x' =>
                          if args0 <? 0
                          then
                           Some (UnderLets.Base (x' v - ##(- args0)%Z)%expr)
                          else None
                      | None => None
                      end)
               | (s0 -> d0)%ptype =>
                   fun _ : value' false s0 -> value' true d0 => None
               end (reflect x1)
           | _ => None
           end
       | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
         (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat _ |
         @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
       | _ => None
       end;;
       match x with
       | @expr.Ident _ _ _ t idc =>
           args <- pattern.ident.invert_bind_args idc pattern.ident.LiteralZ;
           (if args <? 0
            then Some (UnderLets.Base (- (##(- args)%Z + x0))%expr)
            else None)
       | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t idc) x1 =>
           _ <- pattern.ident.invert_bind_args idc pattern.ident.Z_opp;
           match x0 with
           | @expr.Ident _ _ _ t0 idc0 =>
               args0 <- pattern.ident.invert_bind_args idc0
                          pattern.ident.LiteralZ;
               match
                 s as t2
                 return
                   (value' false t2 ->
                    option
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr (type.base base.type.Z))))
               with
               | type.base t2 =>
                   fun v : defaults.expr (type.base t2) =>
                   base.try_make_transport_cps t2 base.type.Z
                     (fun
                        a : option
                              (defaults.expr (type.base t2) ->
                               defaults.expr (type.base base.type.Z)) =>
                      match a with
                      | Some x' =>
                          if args0 >? 0
                          then
                           Some
                             (UnderLets.Base (- (x' v + ##(- args0)%Z))%expr)
                          else None
                      | None => None
                      end)
               | (s0 -> d0)%ptype =>
                   fun _ : value' false s0 -> value' true d0 => None
               end (reflect x1);;
               match
                 s as t2
                 return
                   (value' false t2 ->
                    option
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr (type.base base.type.Z))))
               with
               | type.base t2 =>
                   fun v : defaults.expr (type.base t2) =>
                   base.try_make_transport_cps t2 base.type.Z
                     (fun
                        a : option
                              (defaults.expr (type.base t2) ->
                               defaults.expr (type.base base.type.Z)) =>
                      match a with
                      | Some x' =>
                          if args0 <? 0
                          then
                           Some (UnderLets.Base (##(- args0)%Z - x' v)%expr)
                          else None
                      | None => None
                      end)
               | (s0 -> d0)%ptype =>
                   fun _ : value' false s0 -> value' true d0 => None
               end (reflect x1)
           | _ => None
           end
       | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
         (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat _ |
         @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
       | _ => None
       end;;
       match x0 with
       | @expr.Ident _ _ _ t idc =>
           args <- pattern.ident.invert_bind_args idc pattern.ident.LiteralZ;
           (if args <? 0
            then Some (UnderLets.Base (x + ##(- args)%Z)%expr)
            else None)
       | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t idc) x1 =>
           _ <- pattern.ident.invert_bind_args idc pattern.ident.Z_opp;
           match x with
           | @expr.App _ _ _ s0 _ (@expr.Ident _ _ _ t0 idc0) x2 =>
               _ <- pattern.ident.invert_bind_args idc0 pattern.ident.Z_opp;
               match
                 s0 as t2
                 return
                   (value' false t2 ->
                    option
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr (type.base base.type.Z))))
               with
               | type.base t2 =>
                   fun v : defaults.expr (type.base t2) =>
                   base.try_make_transport_cps t2 base.type.Z
                     (fun
                        a : option
                              (defaults.expr (type.base t2) ->
                               defaults.expr (type.base base.type.Z)) =>
                      match a with
                      | Some x' =>
                          match
                            s as t3
                            return
                              (value' false t3 ->
                               option
                                 (UnderLets.UnderLets base.type ident var
                                    (defaults.expr (type.base base.type.Z))))
                          with
                          | type.base t3 =>
                              fun v0 : defaults.expr (type.base t3) =>
                              base.try_make_transport_cps t3 base.type.Z
                                (fun
                                   a0 : option
                                          (defaults.expr (type.base t3) ->
                                           defaults.expr
                                             (type.base base.type.Z)) =>
                                 match a0 with
                                 | Some x'0 =>
                                     Some
                                       (UnderLets.Base (x'0 v0 - x' v)%expr)
                                 | None => None
                                 end)
                          | (s1 -> d1)%ptype =>
                              fun _ : value' false s1 -> value' true d1 =>
                              None
                          end (reflect x1)
                      | None => None
                      end)
               | (s1 -> d1)%ptype =>
                   fun _ : value' false s1 -> value' true d1 => None
               end (reflect x2)
           | @expr.App _ _ _ s0 _ ($_)%expr _ | @expr.App _ _ _ s0 _
             (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0 _
             (_ @ _)%expr_pat _ | @expr.App _ _ _ s0 _
             (@expr.LetIn _ _ _ _ _ _ _) _ => None
           | _ => None
           end
       | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
         (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat _ |
         @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
       | _ => None
       end;;
       match x with
       | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t idc) x1 =>
           _ <- pattern.ident.invert_bind_args idc pattern.ident.Z_opp;
           match
             s as t2
             return
               (value' false t2 ->
                option
                  (UnderLets.UnderLets base.type ident var
                     (defaults.expr (type.base base.type.Z))))
           with
           | type.base t2 =>
               fun v : defaults.expr (type.base t2) =>
               base.try_make_transport_cps t2 base.type.Z
                 (fun
                    a : option
                          (defaults.expr (type.base t2) ->
                           defaults.expr (type.base base.type.Z)) =>
                  match a with
                  | Some x' => Some (UnderLets.Base (- (x' v + x0))%expr)
                  | None => None
                  end)
           | (s0 -> d0)%ptype =>
               fun _ : value' false s0 -> value' true d0 => None
           end (reflect x1)
       | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
         (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat _ |
         @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
       | _ => None
       end;;
       match x0 with
       | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t idc) x1 =>
           _ <- pattern.ident.invert_bind_args idc pattern.ident.Z_opp;
           match
             s as t2
             return
               (value' false t2 ->
                option
                  (UnderLets.UnderLets base.type ident var
                     (defaults.expr (type.base base.type.Z))))
           with
           | type.base t2 =>
               fun v : defaults.expr (type.base t2) =>
               base.try_make_transport_cps t2 base.type.Z
                 (fun
                    a : option
                          (defaults.expr (type.base t2) ->
                           defaults.expr (type.base base.type.Z)) =>
                  match a with
                  | Some x' => Some (UnderLets.Base (x + x' v)%expr)
                  | None => None
                  end)
           | (s0 -> d0)%ptype =>
               fun _ : value' false s0 -> value' true d0 => None
           end (reflect x1)
       | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
         (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat _ |
         @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
       | _ => None
       end);;
      None);;;
     UnderLets.Base (x - x0)%expr)%option
| ident.Z_opp =>
    fun x : defaults.expr (type.base base.type.Z) =>
    (((match x with
       | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t idc) x0 =>
           _ <- pattern.ident.invert_bind_args idc pattern.ident.Z_opp;
           match
             s as t2
             return
               (value' false t2 ->
                option
                  (UnderLets.UnderLets base.type ident var
                     (defaults.expr (type.base base.type.Z))))
           with
           | type.base t2 =>
               fun v : defaults.expr (type.base t2) =>
               base.try_make_transport_cps t2 base.type.Z
                 (fun
                    a : option
                          (defaults.expr (type.base t2) ->
                           defaults.expr (type.base base.type.Z)) =>
                  match a with
                  | Some x' => Some (UnderLets.Base (x' v))
                  | None => None
                  end)
           | (s0 -> d0)%ptype =>
               fun _ : value' false s0 -> value' true d0 => None
           end (reflect x0)
       | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
         (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat _ |
         @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
       | _ => None
       end;;
       (if negb (SubstVarLike.is_var_fst_snd_pair_opp x)
        then
         Some
           (UnderLets.UnderLet x
              (fun v : var (type.base base.type.Z) =>
               UnderLets.Base (- $v)%expr))
        else None));;
      None);;;
     UnderLets.Base (- x)%expr)%option
| ident.Z_div =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    ((match x0 with
      | @expr.Ident _ _ _ t idc =>
          args <- pattern.ident.invert_bind_args idc pattern.ident.LiteralZ;
          (if args =? 1 then Some (UnderLets.Base x) else None);;
          (if args =? 2 ^ Z.log2 args
           then Some (UnderLets.Base (x >> ##(Z.log2 args))%expr)
           else None)
      | _ => None
      end;;
      None);;;
     UnderLets.Base (x / x0)%expr)%option
| ident.Z_modulo =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    (match x0 with
     | @expr.Ident _ _ _ t idc =>
         args <- pattern.ident.invert_bind_args idc pattern.ident.LiteralZ;
         (if args =? 1 then Some (UnderLets.Base (##0)%expr) else None);;
         (if args =? 2 ^ Z.log2 args
          then Some (UnderLets.Base (x &' ##(args - 1)%Z)%expr)
          else None)
     | _ => None
     end;;;
     UnderLets.Base (x mod x0)%expr)%option
| ident.Z_log2 =>
    fun x : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_log2)%expr @ x)%expr_pat
| ident.Z_log2_up =>
    fun x : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_log2_up)%expr @ x)%expr_pat
| ident.Z_eqb =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_eqb)%expr @ x @ x0)%expr_pat
| ident.Z_leb =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_leb)%expr @ x @ x0)%expr_pat
| ident.Z_geb =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_geb)%expr @ x @ x0)%expr_pat
| ident.Z_of_nat =>
    fun x : defaults.expr (type.base base.type.nat) =>
    UnderLets.Base (#(ident.Z_of_nat)%expr @ x)%expr_pat
| ident.Z_to_nat =>
    fun x : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_to_nat)%expr @ x)%expr_pat
| ident.Z_shiftr =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (x >> x0)%expr
| ident.Z_shiftl =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (x << x0)%expr
| ident.Z_land =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    (((match x0 with
       | @expr.Ident _ _ _ t idc =>
           args <- pattern.ident.invert_bind_args idc pattern.ident.LiteralZ;
           (if args =? 0 then Some (UnderLets.Base (##0)%expr) else None)
       | _ => None
       end;;
       match x with
       | @expr.Ident _ _ _ t idc =>
           args <- pattern.ident.invert_bind_args idc pattern.ident.LiteralZ;
           (if args =? 0 then Some (UnderLets.Base (##0)%expr) else None)
       | _ => None
       end);;
      None);;;
     UnderLets.Base (x &' x0)%expr)%option
| ident.Z_lor =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (x || x0)%expr
| ident.Z_bneg =>
    fun x : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_bneg)%expr @ x)%expr_pat
| ident.Z_lnot_modulo =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_lnot_modulo)%expr @ x @ x0)%expr_pat
| ident.Z_mul_split =>
    fun x x0 x1 : defaults.expr (type.base base.type.Z) =>
    (((match x with
       | @expr.Ident _ _ _ t idc =>
           _ <- pattern.ident.invert_bind_args idc pattern.ident.LiteralZ;
           match x0 with
           | @expr.Ident _ _ _ t0 idc0 =>
               args0 <- pattern.ident.invert_bind_args idc0
                          pattern.ident.LiteralZ;
               (if args0 =? 0
                then Some (UnderLets.Base ((##0)%expr, (##0)%expr)%expr_pat)
                else None)
           | _ => None
           end;;
           match x1 with
           | @expr.Ident _ _ _ t0 idc0 =>
               args0 <- pattern.ident.invert_bind_args idc0
                          pattern.ident.LiteralZ;
               (if args0 =? 0
                then Some (UnderLets.Base ((##0)%expr, (##0)%expr)%expr_pat)
                else None)
           | _ => None
           end;;
           match x0 with
           | @expr.Ident _ _ _ t0 idc0 =>
               args0 <- pattern.ident.invert_bind_args idc0
                          pattern.ident.LiteralZ;
               (if args0 =? 1
                then Some (UnderLets.Base (x1, (##0)%expr)%expr_pat)
                else None)
           | _ => None
           end;;
           match x1 with
           | @expr.Ident _ _ _ t0 idc0 =>
               args0 <- pattern.ident.invert_bind_args idc0
                          pattern.ident.LiteralZ;
               (if args0 =? 1
                then Some (UnderLets.Base (x0, (##0)%expr)%expr_pat)
                else None)
           | _ => None
           end;;
           match x0 with
           | @expr.Ident _ _ _ t0 idc0 =>
               args0 <- pattern.ident.invert_bind_args idc0
                          pattern.ident.LiteralZ;
               (if args0 =? -1
                then Some (UnderLets.Base ((- x1)%expr, (##0)%expr)%expr_pat)
                else None)
           | _ => None
           end;;
           match x1 with
           | @expr.Ident _ _ _ t0 idc0 =>
               args0 <- pattern.ident.invert_bind_args idc0
                          pattern.ident.LiteralZ;
               (if args0 =? -1
                then Some (UnderLets.Base ((- x0)%expr, (##0)%expr)%expr_pat)
                else None)
           | _ => None
           end
       | _ => None
       end;;
       Some
         (UnderLets.UnderLet
            (#(ident.Z_mul_split)%expr @ x @ x0 @ x1)%expr_pat
            (fun v : var (type.base (base.type.Z * base.type.Z)%etype) =>
             UnderLets.Base
               (#(ident.fst)%expr @ ($v)%expr, #(ident.snd)%expr @ ($v)%expr)%expr_pat)));;
      None);;;
     UnderLets.Base (#(ident.Z_mul_split)%expr @ x @ x0 @ x1)%expr_pat)%option
| ident.Z_add_get_carry =>
    fun x x0 x1 : defaults.expr (type.base base.type.Z) =>
    (((match x0 with
       | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t idc) x2 =>
           _ <- pattern.ident.invert_bind_args idc pattern.ident.Z_opp;
           match
             s as t2
             return
               (value' false t2 ->
                option
                  (UnderLets.UnderLets base.type ident var
                     (defaults.expr
                        (type.base (base.type.Z * base.type.Z)%etype))))
           with
           | type.base t2 =>
               fun v : defaults.expr (type.base t2) =>
               base.try_make_transport_cps t2 base.type.Z
                 (fun
                    a : option
                          (defaults.expr (type.base t2) ->
                           defaults.expr (type.base base.type.Z)) =>
                  match a with
                  | Some x' =>
                      Some
                        (UnderLets.UnderLet
                           (#(ident.Z_sub_get_borrow)%expr @ x @ x1 @ x' v)%expr_pat
                           (fun
                              v0 : var
                                     (type.base
                                        (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v0)%expr,
                              (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat))
                  | None => None
                  end)
           | (s0 -> d0)%ptype =>
               fun _ : value' false s0 -> value' true d0 => None
           end (reflect x2)
       | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
         (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat _ |
         @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
       | _ => None
       end;;
       match x1 with
       | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t idc) x2 =>
           _ <- pattern.ident.invert_bind_args idc pattern.ident.Z_opp;
           match
             s as t2
             return
               (value' false t2 ->
                option
                  (UnderLets.UnderLets base.type ident var
                     (defaults.expr
                        (type.base (base.type.Z * base.type.Z)%etype))))
           with
           | type.base t2 =>
               fun v : defaults.expr (type.base t2) =>
               base.try_make_transport_cps t2 base.type.Z
                 (fun
                    a : option
                          (defaults.expr (type.base t2) ->
                           defaults.expr (type.base base.type.Z)) =>
                  match a with
                  | Some x' =>
                      Some
                        (UnderLets.UnderLet
                           (#(ident.Z_sub_get_borrow)%expr @ x @ x0 @ x' v)%expr_pat
                           (fun
                              v0 : var
                                     (type.base
                                        (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v0)%expr,
                              (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat))
                  | None => None
                  end)
           | (s0 -> d0)%ptype =>
               fun _ : value' false s0 -> value' true d0 => None
           end (reflect x2)
       | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
         (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat _ |
         @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
       | _ => None
       end;;
       match x0 with
       | @expr.Ident _ _ _ t idc =>
           args <- pattern.ident.invert_bind_args idc pattern.ident.LiteralZ;
           (if args <? 0
            then
             Some
               (UnderLets.UnderLet
                  (#(ident.Z_sub_get_borrow)%expr @ x @ x1 @
                   (##(- args)%Z)%expr)%expr_pat
                  (fun v : var (type.base (base.type.Z * base.type.Z)%etype)
                   =>
                   UnderLets.Base
                     (#(ident.fst)%expr @ ($v)%expr,
                     (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat))
            else None)
       | _ => None
       end;;
       match x1 with
       | @expr.Ident _ _ _ t idc =>
           args <- pattern.ident.invert_bind_args idc pattern.ident.LiteralZ;
           (if args <? 0
            then
             Some
               (UnderLets.UnderLet
                  (#(ident.Z_sub_get_borrow)%expr @ x @ x0 @
                   (##(- args)%Z)%expr)%expr_pat
                  (fun v : var (type.base (base.type.Z * base.type.Z)%etype)
                   =>
                   UnderLets.Base
                     (#(ident.fst)%expr @ ($v)%expr,
                     (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat))
            else None)
       | _ => None
       end;;
       match x0 with
       | @expr.Ident _ _ _ t idc =>
           args <- pattern.ident.invert_bind_args idc pattern.ident.LiteralZ;
           (if args =? 0
            then Some (UnderLets.Base (x1, (##0)%expr)%expr_pat)
            else None)
       | _ => None
       end;;
       match x1 with
       | @expr.Ident _ _ _ t idc =>
           args <- pattern.ident.invert_bind_args idc pattern.ident.LiteralZ;
           (if args =? 0
            then Some (UnderLets.Base (x0, (##0)%expr)%expr_pat)
            else None)
       | _ => None
       end;;
       Some
         (UnderLets.UnderLet
            (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
            (fun v : var (type.base (base.type.Z * base.type.Z)%etype) =>
             UnderLets.Base
               (#(ident.fst)%expr @ ($v)%expr, #(ident.snd)%expr @ ($v)%expr)%expr_pat)));;
      None);;;
     UnderLets.Base (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat)%option
| ident.Z_add_with_carry =>
    fun x x0 x1 : defaults.expr (type.base base.type.Z) =>
    (((match x with
       | @expr.Ident _ _ _ t idc =>
           args <- pattern.ident.invert_bind_args idc pattern.ident.LiteralZ;
           (if args =? 0 then Some (UnderLets.Base (x0 + x1)%expr) else None)
       | _ => None
       end;;
       Some
         (UnderLets.UnderLet
            (#(ident.Z_add_with_carry)%expr @ x @ x0 @ x1)%expr_pat
            (fun v : var (type.base base.type.Z) => UnderLets.Base ($v)%expr)));;
      None);;;
     UnderLets.Base (#(ident.Z_add_with_carry)%expr @ x @ x0 @ x1)%expr_pat)%option
| ident.Z_add_with_get_carry =>
    fun x x0 x1 x2 : defaults.expr (type.base base.type.Z) =>
    (((match x0 with
       | @expr.Ident _ _ _ t idc =>
           args <- pattern.ident.invert_bind_args idc pattern.ident.LiteralZ;
           match x1 with
           | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t0 idc0) x3 =>
               _ <- pattern.ident.invert_bind_args idc0 pattern.ident.Z_opp;
               match
                 s as t2
                 return
                   (value' false t2 ->
                    option
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr
                            (type.base (base.type.Z * base.type.Z)%etype))))
               with
               | type.base t2 =>
                   fun v : defaults.expr (type.base t2) =>
                   base.try_make_transport_cps t2 base.type.Z
                     (fun
                        a : option
                              (defaults.expr (type.base t2) ->
                               defaults.expr (type.base base.type.Z)) =>
                      match a with
                      | Some x' =>
                          if args =? 0
                          then
                           Some
                             (UnderLets.UnderLet
                                (#(ident.Z_sub_get_borrow)%expr @ x @ x2 @
                                 x' v)%expr_pat
                                (fun
                                   v0 : var
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v0)%expr,
                                   (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat))
                          else None
                      | None => None
                      end)
               | (s0 -> d0)%ptype =>
                   fun _ : value' false s0 -> value' true d0 => None
               end (reflect x3);;
               match
                 s as t2
                 return
                   (value' false t2 ->
                    option
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr
                            (type.base (base.type.Z * base.type.Z)%etype))))
               with
               | type.base t2 =>
                   fun v : defaults.expr (type.base t2) =>
                   base.try_make_transport_cps t2 base.type.Z
                     (fun
                        a : option
                              (defaults.expr (type.base t2) ->
                               defaults.expr (type.base base.type.Z)) =>
                      match a with
                      | Some x' =>
                          if args <? 0
                          then
                           Some
                             (UnderLets.UnderLet
                                (#(ident.Z_sub_with_get_borrow)%expr @ x @
                                 (##(- args)%Z)%expr @ x2 @ x' v)%expr_pat
                                (fun
                                   v0 : var
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v0)%expr,
                                   (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat))
                          else None
                      | None => None
                      end)
               | (s0 -> d0)%ptype =>
                   fun _ : value' false s0 -> value' true d0 => None
               end (reflect x3)
           | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
             (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat
             _ | @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
           | _ => None
           end;;
           match x2 with
           | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t0 idc0) x3 =>
               _ <- pattern.ident.invert_bind_args idc0 pattern.ident.Z_opp;
               match
                 s as t2
                 return
                   (value' false t2 ->
                    option
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr
                            (type.base (base.type.Z * base.type.Z)%etype))))
               with
               | type.base t2 =>
                   fun v : defaults.expr (type.base t2) =>
                   base.try_make_transport_cps t2 base.type.Z
                     (fun
                        a : option
                              (defaults.expr (type.base t2) ->
                               defaults.expr (type.base base.type.Z)) =>
                      match a with
                      | Some x' =>
                          if args =? 0
                          then
                           Some
                             (UnderLets.UnderLet
                                (#(ident.Z_sub_get_borrow)%expr @ x @ x1 @
                                 x' v)%expr_pat
                                (fun
                                   v0 : var
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v0)%expr,
                                   (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat))
                          else None
                      | None => None
                      end)
               | (s0 -> d0)%ptype =>
                   fun _ : value' false s0 -> value' true d0 => None
               end (reflect x3);;
               match
                 s as t2
                 return
                   (value' false t2 ->
                    option
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr
                            (type.base (base.type.Z * base.type.Z)%etype))))
               with
               | type.base t2 =>
                   fun v : defaults.expr (type.base t2) =>
                   base.try_make_transport_cps t2 base.type.Z
                     (fun
                        a : option
                              (defaults.expr (type.base t2) ->
                               defaults.expr (type.base base.type.Z)) =>
                      match a with
                      | Some x' =>
                          if args <? 0
                          then
                           Some
                             (UnderLets.UnderLet
                                (#(ident.Z_sub_with_get_borrow)%expr @ x @
                                 (##(- args)%Z)%expr @ x1 @ x' v)%expr_pat
                                (fun
                                   v0 : var
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v0)%expr,
                                   (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat))
                          else None
                      | None => None
                      end)
               | (s0 -> d0)%ptype =>
                   fun _ : value' false s0 -> value' true d0 => None
               end (reflect x3)
           | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
             (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat
             _ | @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
           | _ => None
           end;;
           match x1 with
           | @expr.Ident _ _ _ t0 idc0 =>
               args0 <- pattern.ident.invert_bind_args idc0
                          pattern.ident.LiteralZ;
               (if (args0 <=? 0) && (args <=? 0) && (args0 + args <? 0)
                then
                 Some
                   (UnderLets.UnderLet
                      (#(ident.Z_sub_with_get_borrow)%expr @ x @
                       (##(- args)%Z)%expr @ x2 @ (##(- args0)%Z)%expr)%expr_pat
                      (fun
                         v : var
                               (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v)%expr,
                         (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat))
                else None)
           | _ => None
           end;;
           match x2 with
           | @expr.Ident _ _ _ t0 idc0 =>
               args0 <- pattern.ident.invert_bind_args idc0
                          pattern.ident.LiteralZ;
               (if (args0 <=? 0) && (args <=? 0) && (args0 + args <? 0)
                then
                 Some
                   (UnderLets.UnderLet
                      (#(ident.Z_sub_with_get_borrow)%expr @ x @
                       (##(- args)%Z)%expr @ x1 @ (##(- args0)%Z)%expr)%expr_pat
                      (fun
                         v : var
                               (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v)%expr,
                         (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat))
                else None)
           | _ => None
           end;;
           match x with
           | @expr.Ident _ _ _ t0 idc0 =>
               _ <- pattern.ident.invert_bind_args idc0
                      pattern.ident.LiteralZ;
               match x1 with
               | @expr.Ident _ _ _ t1 idc1 =>
                   args1 <- pattern.ident.invert_bind_args idc1
                              pattern.ident.LiteralZ;
                   (if (args =? 0) && (args1 =? 0)
                    then Some (UnderLets.Base (x2, (##0)%expr)%expr_pat)
                    else None)
               | _ => None
               end;;
               match x2 with
               | @expr.Ident _ _ _ t1 idc1 =>
                   args1 <- pattern.ident.invert_bind_args idc1
                              pattern.ident.LiteralZ;
                   (if (args =? 0) && (args1 =? 0)
                    then Some (UnderLets.Base (x1, (##0)%expr)%expr_pat)
                    else None)
               | _ => None
               end
           | _ => None
           end;;
           (if args =? 0
            then
             Some
               (UnderLets.UnderLet
                  (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                  (fun v : var (type.base (base.type.Z * base.type.Z)%etype)
                   =>
                   UnderLets.Base
                     (#(ident.fst)%expr @ ($v)%expr,
                     #(ident.snd)%expr @ ($v)%expr)%expr_pat))
            else None)
       | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t idc) x3 =>
           _ <- pattern.ident.invert_bind_args idc pattern.ident.Z_opp;
           match x1 with
           | @expr.App _ _ _ s0 _ (@expr.Ident _ _ _ t0 idc0) x4 =>
               _ <- pattern.ident.invert_bind_args idc0 pattern.ident.Z_opp;
               match
                 s as t2
                 return
                   (value' false t2 ->
                    option
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr
                            (type.base (base.type.Z * base.type.Z)%etype))))
               with
               | type.base t2 =>
                   fun v : defaults.expr (type.base t2) =>
                   base.try_make_transport_cps t2 base.type.Z
                     (fun
                        a : option
                              (defaults.expr (type.base t2) ->
                               defaults.expr (type.base base.type.Z)) =>
                      match a with
                      | Some x' =>
                          match
                            s0 as t3
                            return
                              (value' false t3 ->
                               option
                                 (UnderLets.UnderLets base.type ident var
                                    (defaults.expr
                                       (type.base
                                          (base.type.Z * base.type.Z)%etype))))
                          with
                          | type.base t3 =>
                              fun v0 : defaults.expr (type.base t3) =>
                              base.try_make_transport_cps t3 base.type.Z
                                (fun
                                   a0 : option
                                          (defaults.expr (type.base t3) ->
                                           defaults.expr
                                             (type.base base.type.Z)) =>
                                 match a0 with
                                 | Some x'0 =>
                                     Some
                                       (UnderLets.UnderLet
                                          (#(ident.Z_sub_with_get_borrow)%expr @
                                           x @ x' v @ x2 @ x'0 v0)%expr_pat
                                          (fun
                                             v1 : var
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)
                                           =>
                                           UnderLets.Base
                                             (#(ident.fst)%expr @ ($v1)%expr,
                                             (-
                                              (#(ident.snd)%expr @ $v1)%expr_pat)%expr)%expr_pat))
                                 | None => None
                                 end)
                          | (s1 -> d1)%ptype =>
                              fun _ : value' false s1 -> value' true d1 =>
                              None
                          end (reflect x4)
                      | None => None
                      end)
               | (s1 -> d1)%ptype =>
                   fun _ : value' false s1 -> value' true d1 => None
               end (reflect x3)
           | @expr.App _ _ _ s0 _ ($_)%expr _ | @expr.App _ _ _ s0 _
             (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0 _
             (_ @ _)%expr_pat _ | @expr.App _ _ _ s0 _
             (@expr.LetIn _ _ _ _ _ _ _) _ => None
           | _ => None
           end;;
           match x2 with
           | @expr.App _ _ _ s0 _ (@expr.Ident _ _ _ t0 idc0) x4 =>
               _ <- pattern.ident.invert_bind_args idc0 pattern.ident.Z_opp;
               match
                 s as t2
                 return
                   (value' false t2 ->
                    option
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr
                            (type.base (base.type.Z * base.type.Z)%etype))))
               with
               | type.base t2 =>
                   fun v : defaults.expr (type.base t2) =>
                   base.try_make_transport_cps t2 base.type.Z
                     (fun
                        a : option
                              (defaults.expr (type.base t2) ->
                               defaults.expr (type.base base.type.Z)) =>
                      match a with
                      | Some x' =>
                          match
                            s0 as t3
                            return
                              (value' false t3 ->
                               option
                                 (UnderLets.UnderLets base.type ident var
                                    (defaults.expr
                                       (type.base
                                          (base.type.Z * base.type.Z)%etype))))
                          with
                          | type.base t3 =>
                              fun v0 : defaults.expr (type.base t3) =>
                              base.try_make_transport_cps t3 base.type.Z
                                (fun
                                   a0 : option
                                          (defaults.expr (type.base t3) ->
                                           defaults.expr
                                             (type.base base.type.Z)) =>
                                 match a0 with
                                 | Some x'0 =>
                                     Some
                                       (UnderLets.UnderLet
                                          (#(ident.Z_sub_with_get_borrow)%expr @
                                           x @ x' v @ x1 @ x'0 v0)%expr_pat
                                          (fun
                                             v1 : var
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)
                                           =>
                                           UnderLets.Base
                                             (#(ident.fst)%expr @ ($v1)%expr,
                                             (-
                                              (#(ident.snd)%expr @ $v1)%expr_pat)%expr)%expr_pat))
                                 | None => None
                                 end)
                          | (s1 -> d1)%ptype =>
                              fun _ : value' false s1 -> value' true d1 =>
                              None
                          end (reflect x4)
                      | None => None
                      end)
               | (s1 -> d1)%ptype =>
                   fun _ : value' false s1 -> value' true d1 => None
               end (reflect x3)
           | @expr.App _ _ _ s0 _ ($_)%expr _ | @expr.App _ _ _ s0 _
             (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0 _
             (_ @ _)%expr_pat _ | @expr.App _ _ _ s0 _
             (@expr.LetIn _ _ _ _ _ _ _) _ => None
           | _ => None
           end;;
           match x1 with
           | @expr.Ident _ _ _ t0 idc0 =>
               args0 <- pattern.ident.invert_bind_args idc0
                          pattern.ident.LiteralZ;
               match
                 s as t2
                 return
                   (value' false t2 ->
                    option
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr
                            (type.base (base.type.Z * base.type.Z)%etype))))
               with
               | type.base t2 =>
                   fun v : defaults.expr (type.base t2) =>
                   base.try_make_transport_cps t2 base.type.Z
                     (fun
                        a : option
                              (defaults.expr (type.base t2) ->
                               defaults.expr (type.base base.type.Z)) =>
                      match a with
                      | Some x' =>
                          if args0 <=? 0
                          then
                           Some
                             (UnderLets.UnderLet
                                (#(ident.Z_sub_with_get_borrow)%expr @ x @
                                 x' v @ x2 @ (##(- args0)%Z)%expr)%expr_pat
                                (fun
                                   v0 : var
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v0)%expr,
                                   (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat))
                          else None
                      | None => None
                      end)
               | (s0 -> d0)%ptype =>
                   fun _ : value' false s0 -> value' true d0 => None
               end (reflect x3)
           | _ => None
           end;;
           match x2 with
           | @expr.Ident _ _ _ t0 idc0 =>
               args0 <- pattern.ident.invert_bind_args idc0
                          pattern.ident.LiteralZ;
               match
                 s as t2
                 return
                   (value' false t2 ->
                    option
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr
                            (type.base (base.type.Z * base.type.Z)%etype))))
               with
               | type.base t2 =>
                   fun v : defaults.expr (type.base t2) =>
                   base.try_make_transport_cps t2 base.type.Z
                     (fun
                        a : option
                              (defaults.expr (type.base t2) ->
                               defaults.expr (type.base base.type.Z)) =>
                      match a with
                      | Some x' =>
                          if args0 <=? 0
                          then
                           Some
                             (UnderLets.UnderLet
                                (#(ident.Z_sub_with_get_borrow)%expr @ x @
                                 x' v @ x1 @ (##(- args0)%Z)%expr)%expr_pat
                                (fun
                                   v0 : var
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v0)%expr,
                                   (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat))
                          else None
                      | None => None
                      end)
               | (s0 -> d0)%ptype =>
                   fun _ : value' false s0 -> value' true d0 => None
               end (reflect x3)
           | _ => None
           end
       | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
         (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat _ |
         @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
       | _ => None
       end;;
       match x1 with
       | @expr.Ident _ _ _ t idc =>
           args <- pattern.ident.invert_bind_args idc pattern.ident.LiteralZ;
           match x2 with
           | @expr.Ident _ _ _ t0 idc0 =>
               args0 <- pattern.ident.invert_bind_args idc0
                          pattern.ident.LiteralZ;
               (if (args =? 0) && (args0 =? 0)
                then
                 Some
                   (UnderLets.UnderLet
                      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                       (##args)%expr @ (##args0)%expr)%expr_pat
                      (fun
                         v : var
                               (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v)%expr, (##0)%expr)%expr_pat))
                else None)
           | _ => None
           end
       | _ => None
       end;;
       Some
         (UnderLets.UnderLet
            (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
            (fun v : var (type.base (base.type.Z * base.type.Z)%etype) =>
             UnderLets.Base
               (#(ident.fst)%expr @ ($v)%expr, #(ident.snd)%expr @ ($v)%expr)%expr_pat)));;
      None);;;
     UnderLets.Base
       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat)%option
| ident.Z_sub_get_borrow =>
    fun x x0 x1 : defaults.expr (type.base base.type.Z) =>
    UnderLets.UnderLet
      (#(ident.Z_sub_get_borrow)%expr @ x @ x0 @ x1)%expr_pat
      (fun v : var (type.base (base.type.Z * base.type.Z)%etype) =>
       UnderLets.Base
         (#(ident.fst)%expr @ ($v)%expr, #(ident.snd)%expr @ ($v)%expr)%expr_pat)
| ident.Z_sub_with_get_borrow =>
    fun x x0 x1 x2 : defaults.expr (type.base base.type.Z) =>
    UnderLets.UnderLet
      (#(ident.Z_sub_with_get_borrow)%expr @ x @ x0 @ x1 @ x2)%expr_pat
      (fun v : var (type.base (base.type.Z * base.type.Z)%etype) =>
       UnderLets.Base
         (#(ident.fst)%expr @ ($v)%expr, #(ident.snd)%expr @ ($v)%expr)%expr_pat)
| ident.Z_zselect =>
    fun x x0 x1 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_zselect)%expr @ x @ x0 @ x1)%expr_pat
| ident.Z_add_modulo =>
    fun x x0 x1 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_add_modulo)%expr @ x @ x0 @ x1)%expr_pat
| ident.Z_rshi =>
    fun x x0 x1 x2 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_rshi)%expr @ x @ x0 @ x1 @ x2)%expr_pat
| ident.Z_cc_m =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_cc_m)%expr @ x @ x0)%expr_pat
| ident.Z_cast range =>
    fun x : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_cast range)%expr @ x)%expr_pat
| ident.Z_cast2 range =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    (match x with
     | @expr.App _ _ _ s _
       (@expr.App _ _ _ s0 _ (@expr.Ident _ _ _ t idc) x1) x0 =>
         _ <- pattern.ident.invert_bind_args idc pattern.ident.pair;
         match
           s0 as t2
           return
             (value' false t2 ->
              option
                (UnderLets.UnderLets base.type ident var
                   (defaults.expr
                      (type.base (base.type.Z * base.type.Z)%etype))))
         with
         | type.base t2 =>
             fun v : defaults.expr (type.base t2) =>
             base.try_make_transport_cps t2 base.type.Z
               (fun
                  a : option
                        (defaults.expr (type.base t2) ->
                         defaults.expr (type.base base.type.Z)) =>
                match a with
                | Some x' =>
                    match
                      s as t3
                      return
                        (value' false t3 ->
                         option
                           (UnderLets.UnderLets base.type ident var
                              (defaults.expr
                                 (type.base (base.type.Z * base.type.Z)%etype))))
                    with
                    | type.base t3 =>
                        fun v0 : defaults.expr (type.base t3) =>
                        base.try_make_transport_cps t3 base.type.Z
                          (fun
                             a0 : option
                                    (defaults.expr (type.base t3) ->
                                     defaults.expr (type.base base.type.Z))
                           =>
                           match a0 with
                           | Some x'0 =>
                               Some
                                 (fv <-- do_again (base.type.Z * base.type.Z)
                                           (#(ident.Z_cast (fst range))%expr @
                                            ($(x' v))%expr,
                                           #(ident.Z_cast (snd range))%expr @
                                           ($(x'0 v0))%expr)%expr_pat;
                                  UnderLets.Base (id (id fv)))%under_lets
                           | None => None
                           end)
                    | (s1 -> d1)%ptype =>
                        fun _ : value' false s1 -> value' true d1 => None
                    end (reflect x0)
                | None => None
                end)
         | (s1 -> d1)%ptype =>
             fun _ : value' false s1 -> value' true d1 => None
         end (reflect x1)
     | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ ($_)%expr _) _ | @expr.App _
       _ _ s _ (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _) _ | @expr.App
       _ _ _ s _ (@expr.App _ _ _ s0 _ (_ @ _)%expr_pat _) _ | @expr.App _ _
       _ s _ (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _) _ => None
     | @expr.App _ _ _ s _ #(_)%expr_pat _ | @expr.App _ _ _ s _ ($_)%expr
       _ | @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s
       _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
     | _ => None
     end;;;
     UnderLets.Base (#(ident.Z_cast2 range)%expr @ x)%expr_pat)%option
| ident.fancy_add log2wordmax imm =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_add log2wordmax imm)%expr @ x)%expr_pat
| ident.fancy_addc log2wordmax imm =>
    fun
      x : defaults.expr
            (type.base (base.type.Z * base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_addc log2wordmax imm)%expr @ x)%expr_pat
| ident.fancy_sub log2wordmax imm =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_sub log2wordmax imm)%expr @ x)%expr_pat
| ident.fancy_subb log2wordmax imm =>
    fun
      x : defaults.expr
            (type.base (base.type.Z * base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_subb log2wordmax imm)%expr @ x)%expr_pat
| ident.fancy_mulll log2wordmax =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_mulll log2wordmax)%expr @ x)%expr_pat
| ident.fancy_mullh log2wordmax =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_mullh log2wordmax)%expr @ x)%expr_pat
| ident.fancy_mulhl log2wordmax =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_mulhl log2wordmax)%expr @ x)%expr_pat
| ident.fancy_mulhh log2wordmax =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_mulhh log2wordmax)%expr @ x)%expr_pat
| ident.fancy_rshi log2wordmax x =>
    fun x0 : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_rshi log2wordmax x)%expr @ x0)%expr_pat
| ident.fancy_selc =>
    fun
      x : defaults.expr
            (type.base (base.type.Z * base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_selc)%expr @ x)%expr_pat
| ident.fancy_selm log2wordmax =>
    fun
      x : defaults.expr
            (type.base (base.type.Z * base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_selm log2wordmax)%expr @ x)%expr_pat
| ident.fancy_sell =>
    fun
      x : defaults.expr
            (type.base (base.type.Z * base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_sell)%expr @ x)%expr_pat
| ident.fancy_addm =>
    fun
      x : defaults.expr
            (type.base (base.type.Z * base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_addm)%expr @ x)%expr_pat
end
     : value' true t
