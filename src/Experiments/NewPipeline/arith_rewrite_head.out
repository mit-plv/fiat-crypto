arith_rewrite_head = 
match idc in (ident t) return (Compile.value' true t) with
| @ident.Literal t v =>
    match
      t as t0
      return
        (base.base_interp t0 ->
         UnderLets.UnderLets base.type ident var
           (defaults.expr (type.base t0)))
    with
    | base.type.unit => fun v0 : unit => UnderLets.Base ##(v0)%expr
    | base.type.Z => fun v0 : Z => UnderLets.Base ##(v0)%expr
    | base.type.bool => fun v0 : bool => UnderLets.Base ##(v0)%expr
    | base.type.nat => fun v0 : nat => UnderLets.Base ##(v0)%expr
    end v
| ident.Nat_succ =>
    fun x : defaults.expr (type.base base.type.nat) =>
    UnderLets.Base (#(ident.Nat_succ)%expr @ x)%expr_pat
| ident.Nat_pred =>
    fun x : defaults.expr (type.base base.type.nat) =>
    UnderLets.Base (#(ident.Nat_pred)%expr @ x)%expr_pat
| ident.Nat_max =>
    fun x x0 : defaults.expr (type.base base.type.nat) =>
    UnderLets.Base (#(ident.Nat_max)%expr @ x @ x0)%expr_pat
| ident.Nat_mul =>
    fun x x0 : defaults.expr (type.base base.type.nat) =>
    UnderLets.Base (#(ident.Nat_mul)%expr @ x @ x0)%expr_pat
| ident.Nat_add =>
    fun x x0 : defaults.expr (type.base base.type.nat) =>
    UnderLets.Base (#(ident.Nat_add)%expr @ x @ x0)%expr_pat
| ident.Nat_sub =>
    fun x x0 : defaults.expr (type.base base.type.nat) =>
    UnderLets.Base (#(ident.Nat_sub)%expr @ x @ x0)%expr_pat
| @ident.nil t => UnderLets.Base []%expr_pat
| @ident.cons t =>
    fun (x : defaults.expr (type.base t))
      (x0 : defaults.expr (type.base (base.type.list t))) =>
    UnderLets.Base (x :: x0)%expr_pat
| @ident.pair A B =>
    fun (x : defaults.expr (type.base A)) (x0 : defaults.expr (type.base B))
    => UnderLets.Base (x, x0)%expr_pat
| @ident.fst A B =>
    fun x : defaults.expr (type.base (A * B)%etype) =>
    match x with
    | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ #(idc)%expr_pat x1) x0 =>
        match
          match idc with
          | @ident.pair A0 B0 => Some (A0, B0)
          | _ => None
          end
        with
        | Some _ =>
            match
              s0 as t2
              return
                (Compile.value' false t2 ->
                 UnderLets.UnderLets base.type ident var
                   (defaults.expr (type.base A)))
            with
            | type.base t2 =>
                fun v : defaults.expr (type.base t2) =>
                match
                  s as t3
                  return
                    (Compile.value' false t3 ->
                     UnderLets.UnderLets base.type ident var
                       (defaults.expr (type.base A)))
                with
                | type.base t3 =>
                    fun _ : defaults.expr (type.base t3) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => defaults.expr (type.base t0)) t2
                      A
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr (type.base A)))
                      (fun
                         a : option
                               (defaults.expr (type.base t2) ->
                                defaults.expr (type.base A)) =>
                       match a with
                       | Some x' => UnderLets.Base (x' v)
                       | None =>
                           UnderLets.Base (#(ident.fst)%expr @ x)%expr_pat
                       end)
                | (s1 -> d1)%ptype =>
                    fun _ : Compile.value' false s1 -> Compile.value' true d1
                    => UnderLets.Base (#(ident.fst)%expr @ x)%expr_pat
                end (Compile.reflect x0)
            | (s1 -> d1)%ptype =>
                fun _ : Compile.value' false s1 -> Compile.value' true d1 =>
                UnderLets.Base (#(ident.fst)%expr @ x)%expr_pat
            end (Compile.reflect x1)
        | None => UnderLets.Base (#(ident.fst)%expr @ x)%expr_pat
        end
    | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ ($_)%expr _) _ | @expr.App _
      _ _ s _ (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _) _ | @expr.App
      _ _ _ s _ (@expr.App _ _ _ s0 _ (_ @ _)%expr_pat _) _ | @expr.App _ _ _
      s _ (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _) _ =>
        UnderLets.Base (#(ident.fst)%expr @ x)%expr_pat
    | @expr.App _ _ _ s _ #(_)%expr_pat _ | @expr.App _ _ _ s _ ($_)%expr _ |
      @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _
      (@expr.LetIn _ _ _ _ _ _ _) _ =>
        UnderLets.Base (#(ident.fst)%expr @ x)%expr_pat
    | _ => UnderLets.Base (#(ident.fst)%expr @ x)%expr_pat
    end
| @ident.snd A B =>
    fun x : defaults.expr (type.base (A * B)%etype) =>
    match x with
    | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ #(idc)%expr_pat x1) x0 =>
        match
          match idc with
          | @ident.pair A0 B0 => Some (A0, B0)
          | _ => None
          end
        with
        | Some _ =>
            match
              s0 as t2
              return
                (Compile.value' false t2 ->
                 UnderLets.UnderLets base.type ident var
                   (defaults.expr (type.base B)))
            with
            | type.base t2 =>
                fun _ : defaults.expr (type.base t2) =>
                match
                  s as t3
                  return
                    (Compile.value' false t3 ->
                     UnderLets.UnderLets base.type ident var
                       (defaults.expr (type.base B)))
                with
                | type.base t3 =>
                    fun v0 : defaults.expr (type.base t3) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => defaults.expr (type.base t0)) t3
                      B
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr (type.base B)))
                      (fun
                         a : option
                               (defaults.expr (type.base t3) ->
                                defaults.expr (type.base B)) =>
                       match a with
                       | Some x' => UnderLets.Base (x' v0)
                       | None =>
                           UnderLets.Base (#(ident.snd)%expr @ x)%expr_pat
                       end)
                | (s1 -> d1)%ptype =>
                    fun _ : Compile.value' false s1 -> Compile.value' true d1
                    => UnderLets.Base (#(ident.snd)%expr @ x)%expr_pat
                end (Compile.reflect x0)
            | (s1 -> d1)%ptype =>
                fun _ : Compile.value' false s1 -> Compile.value' true d1 =>
                UnderLets.Base (#(ident.snd)%expr @ x)%expr_pat
            end (Compile.reflect x1)
        | None => UnderLets.Base (#(ident.snd)%expr @ x)%expr_pat
        end
    | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ ($_)%expr _) _ | @expr.App _
      _ _ s _ (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _) _ | @expr.App
      _ _ _ s _ (@expr.App _ _ _ s0 _ (_ @ _)%expr_pat _) _ | @expr.App _ _ _
      s _ (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _) _ =>
        UnderLets.Base (#(ident.snd)%expr @ x)%expr_pat
    | @expr.App _ _ _ s _ #(_)%expr_pat _ | @expr.App _ _ _ s _ ($_)%expr _ |
      @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _
      (@expr.LetIn _ _ _ _ _ _ _) _ =>
        UnderLets.Base (#(ident.snd)%expr @ x)%expr_pat
    | _ => UnderLets.Base (#(ident.snd)%expr @ x)%expr_pat
    end
| @ident.prod_rect A B T =>
    fun
      (x : defaults.expr (type.base A) ->
           defaults.expr (type.base B) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base T)))
      (x0 : defaults.expr (type.base (A * B)%etype)) =>
    UnderLets.Base
      (#(ident.prod_rect)%expr @
       (λ (x1 : var (type.base A))(x2 : var (type.base B)),
        UnderLets.to_expr (x ($x1) ($x2)))%expr @ x0)%expr_pat
| @ident.bool_rect T =>
    fun
      (x
       x0 : defaults.expr (type.base base.type.unit) ->
            UnderLets.UnderLets base.type ident var
              (defaults.expr (type.base T)))
      (x1 : defaults.expr (type.base base.type.bool)) =>
    UnderLets.Base
      (#(ident.bool_rect)%expr @
       (λ x2 : var (type.base base.type.unit),
        UnderLets.to_expr (x ($x2)))%expr @
       (λ x2 : var (type.base base.type.unit),
        UnderLets.to_expr (x0 ($x2)))%expr @ x1)%expr_pat
| @ident.nat_rect P =>
    fun
      (x : defaults.expr (type.base base.type.unit) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base P)))
      (x0 : defaults.expr (type.base base.type.nat) ->
            defaults.expr (type.base P) ->
            UnderLets.UnderLets base.type ident var
              (defaults.expr (type.base P)))
      (x1 : defaults.expr (type.base base.type.nat)) =>
    UnderLets.Base
      (#(ident.nat_rect)%expr @
       (λ x2 : var (type.base base.type.unit),
        UnderLets.to_expr (x ($x2)))%expr @
       (λ (x2 : var (type.base base.type.nat))(x3 : var (type.base P)),
        UnderLets.to_expr (x0 ($x2) ($x3)))%expr @ x1)%expr_pat
| @ident.nat_rect_arrow P Q =>
    fun
      (x : defaults.expr (type.base P) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base Q)))
      (x0 : defaults.expr (type.base base.type.nat) ->
            (defaults.expr (type.base P) ->
             UnderLets.UnderLets base.type ident var
               (defaults.expr (type.base Q))) ->
            defaults.expr (type.base P) ->
            UnderLets.UnderLets base.type ident var
              (defaults.expr (type.base Q)))
      (x1 : defaults.expr (type.base base.type.nat))
      (x2 : defaults.expr (type.base P)) =>
    UnderLets.Base
      (#(ident.nat_rect_arrow)%expr @
       (λ x3 : var (type.base P),
        UnderLets.to_expr (x ($x3)))%expr @
       (λ (x3 : var (type.base base.type.nat))(x4 : var
                                                      (type.base P ->
                                                       type.base Q)%ptype)
        (x5 : var (type.base P)),
        UnderLets.to_expr
          (x0 ($x3)
             (fun x6 : defaults.expr (type.base P) =>
              UnderLets.Base ($x4 @ x6)%expr_pat) ($x5)))%expr @ x1 @ x2)%expr_pat
| @ident.list_rect A P =>
    fun
      (x : defaults.expr (type.base base.type.unit) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base P)))
      (x0 : defaults.expr (type.base A) ->
            defaults.expr (type.base (base.type.list A)) ->
            defaults.expr (type.base P) ->
            UnderLets.UnderLets base.type ident var
              (defaults.expr (type.base P)))
      (x1 : defaults.expr (type.base (base.type.list A))) =>
    UnderLets.Base
      (#(ident.list_rect)%expr @
       (λ x2 : var (type.base base.type.unit),
        UnderLets.to_expr (x ($x2)))%expr @
       (λ (x2 : var (type.base A))(x3 : var (type.base (base.type.list A)))
        (x4 : var (type.base P)),
        UnderLets.to_expr (x0 ($x2) ($x3) ($x4)))%expr @ x1)%expr_pat
| @ident.list_case A P =>
    fun
      (x : defaults.expr (type.base base.type.unit) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base P)))
      (x0 : defaults.expr (type.base A) ->
            defaults.expr (type.base (base.type.list A)) ->
            UnderLets.UnderLets base.type ident var
              (defaults.expr (type.base P)))
      (x1 : defaults.expr (type.base (base.type.list A))) =>
    UnderLets.Base
      (#(ident.list_case)%expr @
       (λ x2 : var (type.base base.type.unit),
        UnderLets.to_expr (x ($x2)))%expr @
       (λ (x2 : var (type.base A))(x3 : var (type.base (base.type.list A))),
        UnderLets.to_expr (x0 ($x2) ($x3)))%expr @ x1)%expr_pat
| @ident.List_length T =>
    fun x : defaults.expr (type.base (base.type.list T)) =>
    UnderLets.Base (#(ident.List_length)%expr @ x)%expr_pat
| ident.List_seq =>
    fun x x0 : defaults.expr (type.base base.type.nat) =>
    UnderLets.Base (#(ident.List_seq)%expr @ x @ x0)%expr_pat
| @ident.List_firstn A =>
    fun (x : defaults.expr (type.base base.type.nat))
      (x0 : defaults.expr (type.base (base.type.list A))) =>
    UnderLets.Base (#(ident.List_firstn)%expr @ x @ x0)%expr_pat
| @ident.List_skipn A =>
    fun (x : defaults.expr (type.base base.type.nat))
      (x0 : defaults.expr (type.base (base.type.list A))) =>
    UnderLets.Base (#(ident.List_skipn)%expr @ x @ x0)%expr_pat
| @ident.List_repeat A =>
    fun (x : defaults.expr (type.base A))
      (x0 : defaults.expr (type.base base.type.nat)) =>
    UnderLets.Base (#(ident.List_repeat)%expr @ x @ x0)%expr_pat
| @ident.List_combine A B =>
    fun (x : defaults.expr (type.base (base.type.list A)))
      (x0 : defaults.expr (type.base (base.type.list B))) =>
    UnderLets.Base (#(ident.List_combine)%expr @ x @ x0)%expr_pat
| @ident.List_map A B =>
    fun
      (x : defaults.expr (type.base A) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base B)))
      (x0 : defaults.expr (type.base (base.type.list A))) =>
    UnderLets.Base
      (#(ident.List_map)%expr @
       (λ x1 : var (type.base A),
        UnderLets.to_expr (x ($x1)))%expr @ x0)%expr_pat
| @ident.List_app A =>
    fun x x0 : defaults.expr (type.base (base.type.list A)) =>
    UnderLets.Base (x ++ x0)%expr
| @ident.List_rev A =>
    fun x : defaults.expr (type.base (base.type.list A)) =>
    UnderLets.Base (#(ident.List_rev)%expr @ x)%expr_pat
| @ident.List_flat_map A B =>
    fun
      (x : defaults.expr (type.base A) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base (base.type.list B))))
      (x0 : defaults.expr (type.base (base.type.list A))) =>
    UnderLets.Base
      (#(ident.List_flat_map)%expr @
       (λ x1 : var (type.base A),
        UnderLets.to_expr (x ($x1)))%expr @ x0)%expr_pat
| @ident.List_partition A =>
    fun
      (x : defaults.expr (type.base A) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base base.type.bool)))
      (x0 : defaults.expr (type.base (base.type.list A))) =>
    UnderLets.Base
      (#(ident.List_partition)%expr @
       (λ x1 : var (type.base A),
        UnderLets.to_expr (x ($x1)))%expr @ x0)%expr_pat
| @ident.List_fold_right A B =>
    fun
      (x : defaults.expr (type.base B) ->
           defaults.expr (type.base A) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base A)))
      (x0 : defaults.expr (type.base A))
      (x1 : defaults.expr (type.base (base.type.list B))) =>
    UnderLets.Base
      (#(ident.List_fold_right)%expr @
       (λ (x2 : var (type.base B))(x3 : var (type.base A)),
        UnderLets.to_expr (x ($x2) ($x3)))%expr @ x0 @ x1)%expr_pat
| @ident.List_update_nth T =>
    fun (x : defaults.expr (type.base base.type.nat))
      (x0 : defaults.expr (type.base T) ->
            UnderLets.UnderLets base.type ident var
              (defaults.expr (type.base T)))
      (x1 : defaults.expr (type.base (base.type.list T))) =>
    UnderLets.Base
      (#(ident.List_update_nth)%expr @ x @
       (λ x2 : var (type.base T),
        UnderLets.to_expr (x0 ($x2)))%expr @ x1)%expr_pat
| @ident.List_nth_default T =>
    fun (x : defaults.expr (type.base T))
      (x0 : defaults.expr (type.base (base.type.list T)))
      (x1 : defaults.expr (type.base base.type.nat)) =>
    UnderLets.Base (#(ident.List_nth_default)%expr @ x @ x0 @ x1)%expr_pat
| ident.Z_add =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            if args =? 0
            then UnderLets.Base x0
            else
             match x0 with
             | #(idc0)%expr_pat =>
                 match
                   match idc0 with
                   | @ident.Literal t1 v =>
                       match
                         t1 as t2 return (base.base_interp t2 -> option Z)
                       with
                       | base.type.unit => fun _ : unit => None
                       | base.type.Z => fun v0 : Z => Some v0
                       | base.type.bool => fun _ : bool => None
                       | base.type.nat => fun _ : nat => None
                       end v
                   | _ => None
                   end
                 with
                 | Some args0 =>
                     if args0 =? 0
                     then UnderLets.Base x
                     else UnderLets.Base (x + x0)%expr
                 | None => UnderLets.Base (x + x0)%expr
                 end
             | @expr.App _ _ _ s _ #(idc0)%expr_pat x1 =>
                 match
                   match idc0 with
                   | ident.Z_opp => Some tt
                   | _ => None
                   end
                 with
                 | Some _ =>
                     match
                       s as t2
                       return
                         (Compile.value' false t2 ->
                          UnderLets.UnderLets base.type ident var
                            (defaults.expr (type.base base.type.Z)))
                     with
                     | type.base t2 =>
                         fun v : defaults.expr (type.base t2) =>
                         base.try_make_transport_cps
                           (fun t1 : base.type =>
                            defaults.expr (type.base t1)) t2 base.type.Z
                           (UnderLets.UnderLets base.type ident var
                              (defaults.expr (type.base base.type.Z)))
                           (fun
                              a : option
                                    (defaults.expr (type.base t2) ->
                                     defaults.expr (type.base base.type.Z))
                            =>
                            match a with
                            | Some x' =>
                                if args >? 0
                                then UnderLets.Base (##(args) - x' v)%expr
                                else
                                 match
                                   s as t3
                                   return
                                     (Compile.value' false t3 ->
                                      UnderLets.UnderLets base.type ident var
                                        (defaults.expr
                                           (type.base base.type.Z)))
                                 with
                                 | type.base t3 =>
                                     fun v0 : defaults.expr (type.base t3) =>
                                     base.try_make_transport_cps
                                       (fun t1 : base.type =>
                                        defaults.expr (type.base t1)) t3
                                       base.type.Z
                                       (UnderLets.UnderLets base.type ident
                                          var
                                          (defaults.expr
                                             (type.base base.type.Z)))
                                       (fun
                                          a0 : option
                                                 (defaults.expr
                                                    (type.base t3) ->
                                                  defaults.expr
                                                    (type.base base.type.Z))
                                        =>
                                        match a0 with
                                        | Some x'0 =>
                                            if args <? 0
                                            then
                                             UnderLets.Base
                                               (- (##((- args)%Z) + x'0 v0))%expr
                                            else
                                             match
                                               s as t4
                                               return
                                                 (Compile.value' false t4 ->
                                                  UnderLets.UnderLets
                                                    base.type ident var
                                                    (defaults.expr
                                                       (type.base base.type.Z)))
                                             with
                                             | type.base t4 =>
                                                 fun
                                                   v1 : defaults.expr
                                                          (type.base t4) =>
                                                 base.try_make_transport_cps
                                                   (fun t1 : base.type =>
                                                    defaults.expr
                                                      (type.base t1)) t4
                                                   base.type.Z
                                                   (UnderLets.UnderLets
                                                      base.type ident var
                                                      (defaults.expr
                                                         (type.base
                                                            base.type.Z)))
                                                   (fun
                                                      a1 : option
                                                             (defaults.expr
                                                                (type.base t4) ->
                                                              defaults.expr
                                                                (type.base
                                                                   base.type.Z))
                                                    =>
                                                    match a1 with
                                                    | Some x'1 =>
                                                        UnderLets.Base
                                                          (x - x'1 v1)%expr
                                                    | None =>
                                                        UnderLets.Base
                                                          (x + x0)%expr
                                                    end)
                                             | (s0 -> d0)%ptype =>
                                                 fun
                                                   _ : Compile.value' false
                                                         s0 ->
                                                       Compile.value' true d0
                                                 =>
                                                 UnderLets.Base (x + x0)%expr
                                             end (Compile.reflect x1)
                                        | None =>
                                            UnderLets.Base (x + x0)%expr
                                        end)
                                 | (s0 -> d0)%ptype =>
                                     fun
                                       _ : Compile.value' false s0 ->
                                           Compile.value' true d0 =>
                                     UnderLets.Base (x + x0)%expr
                                 end (Compile.reflect x1)
                            | None => UnderLets.Base (x + x0)%expr
                            end)
                     | (s0 -> d0)%ptype =>
                         fun
                           _ : Compile.value' false s0 ->
                               Compile.value' true d0 =>
                         UnderLets.Base (x + x0)%expr
                     end (Compile.reflect x1)
                 | None => UnderLets.Base (x + x0)%expr
                 end
             | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
               (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _
               (_ @ _)%expr_pat _ | @expr.App _ _ _ s _
               (@expr.LetIn _ _ _ _ _ _ _) _ => UnderLets.Base (x + x0)%expr
             | _ => UnderLets.Base (x + x0)%expr
             end
        | None =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args =>
                    if args =? 0
                    then UnderLets.Base x
                    else UnderLets.Base (x + x0)%expr
                | None => UnderLets.Base (x + x0)%expr
                end
            | @expr.App _ _ _ s _ #(idc0)%expr_pat x1 =>
                match
                  match idc0 with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (defaults.expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : defaults.expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => defaults.expr (type.base t1))
                          t2 base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (defaults.expr (type.base t2) ->
                                    defaults.expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (x - x' v)%expr
                           | None => UnderLets.Base (x + x0)%expr
                           end)
                    | (s0 -> d0)%ptype =>
                        fun
                          _ : Compile.value' false s0 ->
                              Compile.value' true d0 =>
                        UnderLets.Base (x + x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x + x0)%expr
                end
            | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
              (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _
              (_ @ _)%expr_pat _ | @expr.App _ _ _ s _
              (@expr.LetIn _ _ _ _ _ _ _) _ => UnderLets.Base (x + x0)%expr
            | _ => UnderLets.Base (x + x0)%expr
            end
        end
    | ($_)%expr =>
        match x0 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t1 v0 =>
                  match
                    t1 as t2 return (base.base_interp t2 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v1 : Z => Some v1
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v0
              | _ => None
              end
            with
            | Some args =>
                if args =? 0
                then UnderLets.Base x
                else UnderLets.Base (x + x0)%expr
            | None => UnderLets.Base (x + x0)%expr
            end
        | @expr.App _ _ _ s _ #(idc)%expr_pat x1 =>
            match
              match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end
            with
            | Some _ =>
                match
                  s as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (defaults.expr (type.base base.type.Z)))
                with
                | type.base t2 =>
                    fun v0 : defaults.expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t1 : base.type => defaults.expr (type.base t1)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr (type.base base.type.Z)))
                      (fun
                         a : option
                               (defaults.expr (type.base t2) ->
                                defaults.expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' => UnderLets.Base (x - x' v0)%expr
                       | None => UnderLets.Base (x + x0)%expr
                       end)
                | (s0 -> d0)%ptype =>
                    fun _ : Compile.value' false s0 -> Compile.value' true d0
                    => UnderLets.Base (x + x0)%expr
                end (Compile.reflect x1)
            | None => UnderLets.Base (x + x0)%expr
            end
        | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat
          _ | @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            UnderLets.Base (x + x0)%expr
        | _ => UnderLets.Base (x + x0)%expr
        end
    | @expr.Abs _ _ _ _ _ _ =>
        match x0 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t0 v =>
                  match
                    t0 as t1 return (base.base_interp t1 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v0 : Z => Some v0
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v
              | _ => None
              end
            with
            | Some args =>
                if args =? 0
                then UnderLets.Base x
                else UnderLets.Base (x + x0)%expr
            | None => UnderLets.Base (x + x0)%expr
            end
        | @expr.App _ _ _ s0 _ #(idc)%expr_pat x1 =>
            match
              match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end
            with
            | Some _ =>
                match
                  s0 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (defaults.expr (type.base base.type.Z)))
                with
                | type.base t2 =>
                    fun v : defaults.expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => defaults.expr (type.base t0)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr (type.base base.type.Z)))
                      (fun
                         a : option
                               (defaults.expr (type.base t2) ->
                                defaults.expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' => UnderLets.Base (x - x' v)%expr
                       | None => UnderLets.Base (x + x0)%expr
                       end)
                | (s1 -> d1)%ptype =>
                    fun _ : Compile.value' false s1 -> Compile.value' true d1
                    => UnderLets.Base (x + x0)%expr
                end (Compile.reflect x1)
            | None => UnderLets.Base (x + x0)%expr
            end
        | @expr.App _ _ _ s0 _ ($_)%expr _ | @expr.App _ _ _ s0 _
          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0 _ (_ @ _)%expr_pat
          _ | @expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            UnderLets.Base (x + x0)%expr
        | _ => UnderLets.Base (x + x0)%expr
        end
    | @expr.App _ _ _ s _ f x1 =>
        match x0 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t0 v =>
                  match
                    t0 as t1 return (base.base_interp t1 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v0 : Z => Some v0
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v
              | _ => None
              end
            with
            | Some args =>
                if args =? 0
                then UnderLets.Base x
                else
                 match f with
                 | #(idc0)%expr_pat =>
                     match
                       match idc0 with
                       | ident.Z_opp => Some tt
                       | _ => None
                       end
                     with
                     | Some _ =>
                         match
                           s as t2
                           return
                             (Compile.value' false t2 ->
                              UnderLets.UnderLets base.type ident var
                                (defaults.expr (type.base base.type.Z)))
                         with
                         | type.base t2 =>
                             fun v : defaults.expr (type.base t2) =>
                             base.try_make_transport_cps
                               (fun t1 : base.type =>
                                defaults.expr (type.base t1)) t2 base.type.Z
                               (UnderLets.UnderLets base.type ident var
                                  (defaults.expr (type.base base.type.Z)))
                               (fun
                                  a : option
                                        (defaults.expr (type.base t2) ->
                                         defaults.expr
                                           (type.base base.type.Z)) =>
                                match a with
                                | Some x' =>
                                    if args >? 0
                                    then
                                     UnderLets.Base (##(args) - x' v)%expr
                                    else
                                     match
                                       s as t3
                                       return
                                         (Compile.value' false t3 ->
                                          UnderLets.UnderLets base.type ident
                                            var
                                            (defaults.expr
                                               (type.base base.type.Z)))
                                     with
                                     | type.base t3 =>
                                         fun
                                           v0 : defaults.expr (type.base t3)
                                         =>
                                         base.try_make_transport_cps
                                           (fun t1 : base.type =>
                                            defaults.expr (type.base t1)) t3
                                           base.type.Z
                                           (UnderLets.UnderLets base.type
                                              ident var
                                              (defaults.expr
                                                 (type.base base.type.Z)))
                                           (fun
                                              a0 : option
                                                     (defaults.expr
                                                        (type.base t3) ->
                                                      defaults.expr
                                                        (type.base
                                                           base.type.Z)) =>
                                            match a0 with
                                            | Some x'0 =>
                                                if args <? 0
                                                then
                                                 UnderLets.Base
                                                   (-
                                                    (x'0 v0 + ##((- args)%Z)))%expr
                                                else
                                                 match
                                                   s as t4
                                                   return
                                                     (Compile.value' false t4 ->
                                                      UnderLets.UnderLets
                                                        base.type ident var
                                                        (defaults.expr
                                                           (type.base
                                                              base.type.Z)))
                                                 with
                                                 | type.base t4 =>
                                                     fun
                                                       v1 : defaults.expr
                                                              (type.base t4)
                                                     =>
                                                     base.try_make_transport_cps
                                                       (fun t1 : base.type =>
                                                        defaults.expr
                                                          (type.base t1)) t4
                                                       base.type.Z
                                                       (UnderLets.UnderLets
                                                          base.type ident var
                                                          (defaults.expr
                                                             (type.base
                                                                base.type.Z)))
                                                       (fun
                                                          a1 : option
                                                                 (defaults.expr
                                                                    (type.base
                                                                    t4) ->
                                                                  defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                        =>
                                                        match a1 with
                                                        | Some x'1 =>
                                                            UnderLets.Base
                                                              (x0 - x'1 v1)%expr
                                                        | None =>
                                                            UnderLets.Base
                                                              (x + x0)%expr
                                                        end)
                                                 | (s0 -> d0)%ptype =>
                                                     fun
                                                       _ : Compile.value'
                                                             false s0 ->
                                                           Compile.value'
                                                             true d0 =>
                                                     UnderLets.Base
                                                       (x + x0)%expr
                                                 end (Compile.reflect x1)
                                            | None =>
                                                UnderLets.Base (x + x0)%expr
                                            end)
                                     | (s0 -> d0)%ptype =>
                                         fun
                                           _ : Compile.value' false s0 ->
                                               Compile.value' true d0 =>
                                         UnderLets.Base (x + x0)%expr
                                     end (Compile.reflect x1)
                                | None => UnderLets.Base (x + x0)%expr
                                end)
                         | (s0 -> d0)%ptype =>
                             fun
                               _ : Compile.value' false s0 ->
                                   Compile.value' true d0 =>
                             UnderLets.Base (x + x0)%expr
                         end (Compile.reflect x1)
                     | None => UnderLets.Base (x + x0)%expr
                     end
                 | _ => UnderLets.Base (x + x0)%expr
                 end
            | None =>
                match f with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (defaults.expr (type.base base.type.Z)))
                        with
                        | type.base t2 =>
                            fun v : defaults.expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type =>
                               defaults.expr (type.base t1)) t2 base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (defaults.expr (type.base base.type.Z)))
                              (fun
                                 a : option
                                       (defaults.expr (type.base t2) ->
                                        defaults.expr (type.base base.type.Z))
                               =>
                               match a with
                               | Some x' => UnderLets.Base (x0 - x' v)%expr
                               | None => UnderLets.Base (x + x0)%expr
                               end)
                        | (s0 -> d0)%ptype =>
                            fun
                              _ : Compile.value' false s0 ->
                                  Compile.value' true d0 =>
                            UnderLets.Base (x + x0)%expr
                        end (Compile.reflect x1)
                    | None => UnderLets.Base (x + x0)%expr
                    end
                | _ => UnderLets.Base (x + x0)%expr
                end
            end
        | ($_)%expr =>
            match f with
            | #(idc)%expr_pat =>
                match
                  match idc with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (defaults.expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v0 : defaults.expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => defaults.expr (type.base t1))
                          t2 base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (defaults.expr (type.base t2) ->
                                    defaults.expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (x0 - x' v0)%expr
                           | None => UnderLets.Base (x + x0)%expr
                           end)
                    | (s0 -> d0)%ptype =>
                        fun
                          _ : Compile.value' false s0 ->
                              Compile.value' true d0 =>
                        UnderLets.Base (x + x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x + x0)%expr
                end
            | _ => UnderLets.Base (x + x0)%expr
            end
        | @expr.Abs _ _ _ _ _ _ =>
            match f with
            | #(idc)%expr_pat =>
                match
                  match idc with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (defaults.expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : defaults.expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => defaults.expr (type.base t0))
                          t2 base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (defaults.expr (type.base t2) ->
                                    defaults.expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (x0 - x' v)%expr
                           | None => UnderLets.Base (x + x0)%expr
                           end)
                    | (s1 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d1 =>
                        UnderLets.Base (x + x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x + x0)%expr
                end
            | _ => UnderLets.Base (x + x0)%expr
            end
        | @expr.App _ _ _ s0 _ #(idc)%expr_pat x2 =>
            match
              match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end
            with
            | Some _ =>
                match f with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (defaults.expr (type.base base.type.Z)))
                        with
                        | type.base t2 =>
                            fun v : defaults.expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type =>
                               defaults.expr (type.base t1)) t2 base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (defaults.expr (type.base base.type.Z)))
                              (fun
                                 a : option
                                       (defaults.expr (type.base t2) ->
                                        defaults.expr (type.base base.type.Z))
                               =>
                               match a with
                               | Some x' =>
                                   match
                                     s0 as t3
                                     return
                                       (Compile.value' false t3 ->
                                        UnderLets.UnderLets base.type ident
                                          var
                                          (defaults.expr
                                             (type.base base.type.Z)))
                                   with
                                   | type.base t3 =>
                                       fun v0 : defaults.expr (type.base t3)
                                       =>
                                       base.try_make_transport_cps
                                         (fun t1 : base.type =>
                                          defaults.expr (type.base t1)) t3
                                         base.type.Z
                                         (UnderLets.UnderLets base.type ident
                                            var
                                            (defaults.expr
                                               (type.base base.type.Z)))
                                         (fun
                                            a0 : option
                                                   (defaults.expr
                                                      (type.base t3) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                          =>
                                          match a0 with
                                          | Some x'0 =>
                                              UnderLets.Base
                                                (- (x' v + x'0 v0))%expr
                                          | None =>
                                              UnderLets.Base (x + x0)%expr
                                          end)
                                   | (s1 -> d1)%ptype =>
                                       fun
                                         _ : Compile.value' false s1 ->
                                             Compile.value' true d1 =>
                                       UnderLets.Base (x + x0)%expr
                                   end (Compile.reflect x2)
                               | None => UnderLets.Base (x + x0)%expr
                               end)
                        | (s1 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base (x + x0)%expr
                        end (Compile.reflect x1)
                    | None =>
                        match
                          s0 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (defaults.expr (type.base base.type.Z)))
                        with
                        | type.base t2 =>
                            fun v : defaults.expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type =>
                               defaults.expr (type.base t1)) t2 base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (defaults.expr (type.base base.type.Z)))
                              (fun
                                 a : option
                                       (defaults.expr (type.base t2) ->
                                        defaults.expr (type.base base.type.Z))
                               =>
                               match a with
                               | Some x' => UnderLets.Base (x - x' v)%expr
                               | None => UnderLets.Base (x + x0)%expr
                               end)
                        | (s1 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base (x + x0)%expr
                        end (Compile.reflect x2)
                    end
                | ($_)%expr =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (defaults.expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v0 : defaults.expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => defaults.expr (type.base t1))
                          t2 base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (defaults.expr (type.base t2) ->
                                    defaults.expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (x - x' v0)%expr
                           | None => UnderLets.Base (x + x0)%expr
                           end)
                    | (s1 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d1 =>
                        UnderLets.Base (x + x0)%expr
                    end (Compile.reflect x2)
                | @expr.LetIn _ _ _ _ _ _ _ =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (defaults.expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : defaults.expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => defaults.expr (type.base t0))
                          t2 base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (defaults.expr (type.base t2) ->
                                    defaults.expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (x - x' v)%expr
                           | None => UnderLets.Base (x + x0)%expr
                           end)
                    | (s1 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d1 =>
                        UnderLets.Base (x + x0)%expr
                    end (Compile.reflect x2)
                | _ =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (defaults.expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : defaults.expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => defaults.expr (type.base t0))
                          t2 base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (defaults.expr (type.base t2) ->
                                    defaults.expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (x - x' v)%expr
                           | None => UnderLets.Base (x + x0)%expr
                           end)
                    | (s2 -> d2)%ptype =>
                        fun
                          _ : Compile.value' false s2 ->
                              Compile.value' true d2 =>
                        UnderLets.Base (x + x0)%expr
                    end (Compile.reflect x2)
                end
            | None =>
                match f with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (defaults.expr (type.base base.type.Z)))
                        with
                        | type.base t2 =>
                            fun v : defaults.expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type =>
                               defaults.expr (type.base t1)) t2 base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (defaults.expr (type.base base.type.Z)))
                              (fun
                                 a : option
                                       (defaults.expr (type.base t2) ->
                                        defaults.expr (type.base base.type.Z))
                               =>
                               match a with
                               | Some x' => UnderLets.Base (x0 - x' v)%expr
                               | None => UnderLets.Base (x + x0)%expr
                               end)
                        | (s1 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base (x + x0)%expr
                        end (Compile.reflect x1)
                    | None => UnderLets.Base (x + x0)%expr
                    end
                | _ => UnderLets.Base (x + x0)%expr
                end
            end
        | @expr.App _ _ _ s0 _ ($_)%expr _ =>
            match f with
            | #(idc)%expr_pat =>
                match
                  match idc with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (defaults.expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v0 : defaults.expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => defaults.expr (type.base t1))
                          t2 base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (defaults.expr (type.base t2) ->
                                    defaults.expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (x0 - x' v0)%expr
                           | None => UnderLets.Base (x + x0)%expr
                           end)
                    | (s1 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d1 =>
                        UnderLets.Base (x + x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x + x0)%expr
                end
            | _ => UnderLets.Base (x + x0)%expr
            end
        | @expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0
          _ (_ @ _)%expr_pat _ =>
            match f with
            | #(idc)%expr_pat =>
                match
                  match idc with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (defaults.expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : defaults.expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => defaults.expr (type.base t0))
                          t2 base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (defaults.expr (type.base t2) ->
                                    defaults.expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (x0 - x' v)%expr
                           | None => UnderLets.Base (x + x0)%expr
                           end)
                    | (s2 -> d2)%ptype =>
                        fun
                          _ : Compile.value' false s2 ->
                              Compile.value' true d2 =>
                        UnderLets.Base (x + x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x + x0)%expr
                end
            | _ => UnderLets.Base (x + x0)%expr
            end
        | @expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            match f with
            | #(idc)%expr_pat =>
                match
                  match idc with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (defaults.expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : defaults.expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => defaults.expr (type.base t0))
                          t2 base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (defaults.expr (type.base t2) ->
                                    defaults.expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (x0 - x' v)%expr
                           | None => UnderLets.Base (x + x0)%expr
                           end)
                    | (s1 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d1 =>
                        UnderLets.Base (x + x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x + x0)%expr
                end
            | _ => UnderLets.Base (x + x0)%expr
            end
        | @expr.LetIn _ _ _ _ _ _ _ =>
            match f with
            | #(idc)%expr_pat =>
                match
                  match idc with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (defaults.expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : defaults.expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => defaults.expr (type.base t0))
                          t2 base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (defaults.expr (type.base t2) ->
                                    defaults.expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (x0 - x' v)%expr
                           | None => UnderLets.Base (x + x0)%expr
                           end)
                    | (s0 -> d0)%ptype =>
                        fun
                          _ : Compile.value' false s0 ->
                              Compile.value' true d0 =>
                        UnderLets.Base (x + x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x + x0)%expr
                end
            | _ => UnderLets.Base (x + x0)%expr
            end
        end
    | @expr.LetIn _ _ _ _ _ _ _ =>
        match x0 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t0 v =>
                  match
                    t0 as t1 return (base.base_interp t1 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v0 : Z => Some v0
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v
              | _ => None
              end
            with
            | Some args =>
                if args =? 0
                then UnderLets.Base x
                else UnderLets.Base (x + x0)%expr
            | None => UnderLets.Base (x + x0)%expr
            end
        | @expr.App _ _ _ s _ #(idc)%expr_pat x2 =>
            match
              match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end
            with
            | Some _ =>
                match
                  s as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (defaults.expr (type.base base.type.Z)))
                with
                | type.base t2 =>
                    fun v : defaults.expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => defaults.expr (type.base t0)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr (type.base base.type.Z)))
                      (fun
                         a : option
                               (defaults.expr (type.base t2) ->
                                defaults.expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' => UnderLets.Base (x - x' v)%expr
                       | None => UnderLets.Base (x + x0)%expr
                       end)
                | (s0 -> d0)%ptype =>
                    fun _ : Compile.value' false s0 -> Compile.value' true d0
                    => UnderLets.Base (x + x0)%expr
                end (Compile.reflect x2)
            | None => UnderLets.Base (x + x0)%expr
            end
        | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat
          _ | @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            UnderLets.Base (x + x0)%expr
        | _ => UnderLets.Base (x + x0)%expr
        end
    end
| ident.Z_mul =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            if args =? 0
            then UnderLets.Base ##(0)%expr
            else
             match x0 with
             | #(idc0)%expr_pat =>
                 match
                   match idc0 with
                   | @ident.Literal t1 v =>
                       match
                         t1 as t2 return (base.base_interp t2 -> option Z)
                       with
                       | base.type.unit => fun _ : unit => None
                       | base.type.Z => fun v0 : Z => Some v0
                       | base.type.bool => fun _ : bool => None
                       | base.type.nat => fun _ : nat => None
                       end v
                   | _ => None
                   end
                 with
                 | Some args0 =>
                     if args0 =? 0
                     then UnderLets.Base ##(0)%expr
                     else
                      if args =? 1
                      then UnderLets.Base x0
                      else
                       if args0 =? 1
                       then UnderLets.Base x
                       else
                        if args =? -1
                        then UnderLets.Base (- x0)%expr
                        else
                         if args0 =? -1
                         then UnderLets.Base (- x)%expr
                         else
                          if args <? 0
                          then UnderLets.Base (- (##((- args)%Z) * x0))%expr
                          else
                           if args0 <? 0
                           then UnderLets.Base (- (x * ##((- args0)%Z)))%expr
                           else
                            if
                             (args0 =? 2 ^ Z.log2 args0) && negb (args0 =? 2)
                            then UnderLets.Base (x << ##(Z.log2 args0))%expr
                            else
                             if (args =? 2 ^ Z.log2 args) && negb (args =? 2)
                             then UnderLets.Base (x0 << ##(Z.log2 args))%expr
                             else UnderLets.Base (x * x0)%expr
                 | None =>
                     if args =? 1
                     then UnderLets.Base x0
                     else
                      if args =? -1
                      then UnderLets.Base (- x0)%expr
                      else
                       if args <? 0
                       then UnderLets.Base (- (##((- args)%Z) * x0))%expr
                       else
                        if (args =? 2 ^ Z.log2 args) && negb (args =? 2)
                        then UnderLets.Base (x0 << ##(Z.log2 args))%expr
                        else UnderLets.Base (x * x0)%expr
                 end
             | @expr.App _ _ _ s _ f x1 =>
                 if args =? 1
                 then UnderLets.Base x0
                 else
                  match f with
                  | #(idc0)%expr_pat =>
                      match
                        match idc0 with
                        | ident.Z_opp => Some tt
                        | _ => None
                        end
                      with
                      | Some _ =>
                          match
                            s as t2
                            return
                              (Compile.value' false t2 ->
                               UnderLets.UnderLets base.type ident var
                                 (defaults.expr (type.base base.type.Z)))
                          with
                          | type.base t2 =>
                              fun v : defaults.expr (type.base t2) =>
                              base.try_make_transport_cps
                                (fun t1 : base.type =>
                                 defaults.expr (type.base t1)) t2 base.type.Z
                                (UnderLets.UnderLets base.type ident var
                                   (defaults.expr (type.base base.type.Z)))
                                (fun
                                   a : option
                                         (defaults.expr (type.base t2) ->
                                          defaults.expr
                                            (type.base base.type.Z)) =>
                                 match a with
                                 | Some x' =>
                                     if args =? -1
                                     then UnderLets.Base (x' v)
                                     else
                                      if args =? -1
                                      then UnderLets.Base (- x0)%expr
                                      else
                                       if args <? 0
                                       then
                                        UnderLets.Base
                                          (- (##((- args)%Z) * x0))%expr
                                       else
                                        match
                                          s as t3
                                          return
                                            (Compile.value' false t3 ->
                                             UnderLets.UnderLets base.type
                                               ident var
                                               (defaults.expr
                                                  (type.base base.type.Z)))
                                        with
                                        | type.base t3 =>
                                            fun
                                              v0 : defaults.expr
                                                     (type.base t3) =>
                                            base.try_make_transport_cps
                                              (fun t1 : base.type =>
                                               defaults.expr (type.base t1))
                                              t3 base.type.Z
                                              (UnderLets.UnderLets base.type
                                                 ident var
                                                 (defaults.expr
                                                    (type.base base.type.Z)))
                                              (fun
                                                 a0 : option
                                                        (defaults.expr
                                                           (type.base t3) ->
                                                         defaults.expr
                                                           (type.base
                                                              base.type.Z))
                                               =>
                                               match a0 with
                                               | Some x'0 =>
                                                   UnderLets.Base
                                                     (- (x * x'0 v0))%expr
                                               | None =>
                                                   UnderLets.Base
                                                     (x * x0)%expr
                                               end)
                                        | (s0 -> d0)%ptype =>
                                            fun
                                              _ : Compile.value' false s0 ->
                                                  Compile.value' true d0 =>
                                            UnderLets.Base (x * x0)%expr
                                        end (Compile.reflect x1)
                                 | None => UnderLets.Base (x * x0)%expr
                                 end)
                          | (s0 -> d0)%ptype =>
                              fun
                                _ : Compile.value' false s0 ->
                                    Compile.value' true d0 =>
                              UnderLets.Base (x * x0)%expr
                          end (Compile.reflect x1)
                      | None =>
                          if args =? -1
                          then UnderLets.Base (- x0)%expr
                          else
                           if args <? 0
                           then UnderLets.Base (- (##((- args)%Z) * x0))%expr
                           else
                            if (args =? 2 ^ Z.log2 args) && negb (args =? 2)
                            then UnderLets.Base (x0 << ##(Z.log2 args))%expr
                            else UnderLets.Base (x * x0)%expr
                      end
                  | _ =>
                      if args =? -1
                      then UnderLets.Base (- x0)%expr
                      else
                       if args <? 0
                       then UnderLets.Base (- (##((- args)%Z) * x0))%expr
                       else
                        if (args =? 2 ^ Z.log2 args) && negb (args =? 2)
                        then UnderLets.Base (x0 << ##(Z.log2 args))%expr
                        else UnderLets.Base (x * x0)%expr
                  end
             | _ =>
                 if args =? 1
                 then UnderLets.Base x0
                 else
                  if args =? -1
                  then UnderLets.Base (- x0)%expr
                  else
                   if args <? 0
                   then UnderLets.Base (- (##((- args)%Z) * x0))%expr
                   else
                    if (args =? 2 ^ Z.log2 args) && negb (args =? 2)
                    then UnderLets.Base (x0 << ##(Z.log2 args))%expr
                    else UnderLets.Base (x * x0)%expr
             end
        | None =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args =>
                    if args =? 0
                    then UnderLets.Base ##(0)%expr
                    else
                     if args =? 1
                     then UnderLets.Base x
                     else
                      if args =? -1
                      then UnderLets.Base (- x)%expr
                      else
                       if args <? 0
                       then UnderLets.Base (- (x * ##((- args)%Z)))%expr
                       else
                        if (args =? 2 ^ Z.log2 args) && negb (args =? 2)
                        then UnderLets.Base (x << ##(Z.log2 args))%expr
                        else UnderLets.Base (x * x0)%expr
                | None => UnderLets.Base (x * x0)%expr
                end
            | @expr.App _ _ _ s _ #(idc0)%expr_pat x1 =>
                match
                  match idc0 with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (defaults.expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : defaults.expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => defaults.expr (type.base t1))
                          t2 base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (defaults.expr (type.base t2) ->
                                    defaults.expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (- (x * x' v))%expr
                           | None => UnderLets.Base (x * x0)%expr
                           end)
                    | (s0 -> d0)%ptype =>
                        fun
                          _ : Compile.value' false s0 ->
                              Compile.value' true d0 =>
                        UnderLets.Base (x * x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x * x0)%expr
                end
            | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
              (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _
              (_ @ _)%expr_pat _ | @expr.App _ _ _ s _
              (@expr.LetIn _ _ _ _ _ _ _) _ => UnderLets.Base (x * x0)%expr
            | _ => UnderLets.Base (x * x0)%expr
            end
        end
    | ($_)%expr =>
        match x0 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t1 v0 =>
                  match
                    t1 as t2 return (base.base_interp t2 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v1 : Z => Some v1
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v0
              | _ => None
              end
            with
            | Some args =>
                if args =? 0
                then UnderLets.Base ##(0)%expr
                else
                 if args =? 1
                 then UnderLets.Base x
                 else
                  if args =? -1
                  then UnderLets.Base (- x)%expr
                  else
                   if args <? 0
                   then UnderLets.Base (- (x * ##((- args)%Z)))%expr
                   else
                    if (args =? 2 ^ Z.log2 args) && negb (args =? 2)
                    then UnderLets.Base (x << ##(Z.log2 args))%expr
                    else UnderLets.Base (x * x0)%expr
            | None => UnderLets.Base (x * x0)%expr
            end
        | @expr.App _ _ _ s _ #(idc)%expr_pat x1 =>
            match
              match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end
            with
            | Some _ =>
                match
                  s as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (defaults.expr (type.base base.type.Z)))
                with
                | type.base t2 =>
                    fun v0 : defaults.expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t1 : base.type => defaults.expr (type.base t1)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr (type.base base.type.Z)))
                      (fun
                         a : option
                               (defaults.expr (type.base t2) ->
                                defaults.expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' => UnderLets.Base (- (x * x' v0))%expr
                       | None => UnderLets.Base (x * x0)%expr
                       end)
                | (s0 -> d0)%ptype =>
                    fun _ : Compile.value' false s0 -> Compile.value' true d0
                    => UnderLets.Base (x * x0)%expr
                end (Compile.reflect x1)
            | None => UnderLets.Base (x * x0)%expr
            end
        | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat
          _ | @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            UnderLets.Base (x * x0)%expr
        | _ => UnderLets.Base (x * x0)%expr
        end
    | @expr.Abs _ _ _ _ _ _ =>
        match x0 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t0 v =>
                  match
                    t0 as t1 return (base.base_interp t1 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v0 : Z => Some v0
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v
              | _ => None
              end
            with
            | Some args =>
                if args =? 0
                then UnderLets.Base ##(0)%expr
                else
                 if args =? 1
                 then UnderLets.Base x
                 else
                  if args =? -1
                  then UnderLets.Base (- x)%expr
                  else
                   if args <? 0
                   then UnderLets.Base (- (x * ##((- args)%Z)))%expr
                   else
                    if (args =? 2 ^ Z.log2 args) && negb (args =? 2)
                    then UnderLets.Base (x << ##(Z.log2 args))%expr
                    else UnderLets.Base (x * x0)%expr
            | None => UnderLets.Base (x * x0)%expr
            end
        | @expr.App _ _ _ s0 _ #(idc)%expr_pat x1 =>
            match
              match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end
            with
            | Some _ =>
                match
                  s0 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (defaults.expr (type.base base.type.Z)))
                with
                | type.base t2 =>
                    fun v : defaults.expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => defaults.expr (type.base t0)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr (type.base base.type.Z)))
                      (fun
                         a : option
                               (defaults.expr (type.base t2) ->
                                defaults.expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' => UnderLets.Base (- (x * x' v))%expr
                       | None => UnderLets.Base (x * x0)%expr
                       end)
                | (s1 -> d1)%ptype =>
                    fun _ : Compile.value' false s1 -> Compile.value' true d1
                    => UnderLets.Base (x * x0)%expr
                end (Compile.reflect x1)
            | None => UnderLets.Base (x * x0)%expr
            end
        | @expr.App _ _ _ s0 _ ($_)%expr _ | @expr.App _ _ _ s0 _
          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0 _ (_ @ _)%expr_pat
          _ | @expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            UnderLets.Base (x * x0)%expr
        | _ => UnderLets.Base (x * x0)%expr
        end
    | @expr.App _ _ _ s _ f x1 =>
        match x0 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t0 v =>
                  match
                    t0 as t1 return (base.base_interp t1 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v0 : Z => Some v0
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v
              | _ => None
              end
            with
            | Some args =>
                if args =? 0
                then UnderLets.Base ##(0)%expr
                else
                 if args =? 1
                 then UnderLets.Base x
                 else
                  match f with
                  | #(idc0)%expr_pat =>
                      match
                        match idc0 with
                        | ident.Z_opp => Some tt
                        | _ => None
                        end
                      with
                      | Some _ =>
                          match
                            s as t2
                            return
                              (Compile.value' false t2 ->
                               UnderLets.UnderLets base.type ident var
                                 (defaults.expr (type.base base.type.Z)))
                          with
                          | type.base t2 =>
                              fun v : defaults.expr (type.base t2) =>
                              base.try_make_transport_cps
                                (fun t1 : base.type =>
                                 defaults.expr (type.base t1)) t2 base.type.Z
                                (UnderLets.UnderLets base.type ident var
                                   (defaults.expr (type.base base.type.Z)))
                                (fun
                                   a : option
                                         (defaults.expr (type.base t2) ->
                                          defaults.expr
                                            (type.base base.type.Z)) =>
                                 match a with
                                 | Some x' =>
                                     if args =? -1
                                     then UnderLets.Base (x' v)
                                     else
                                      if args =? -1
                                      then UnderLets.Base (- x)%expr
                                      else
                                       if args <? 0
                                       then
                                        UnderLets.Base
                                          (- (x * ##((- args)%Z)))%expr
                                       else
                                        match
                                          s as t3
                                          return
                                            (Compile.value' false t3 ->
                                             UnderLets.UnderLets base.type
                                               ident var
                                               (defaults.expr
                                                  (type.base base.type.Z)))
                                        with
                                        | type.base t3 =>
                                            fun
                                              v0 : defaults.expr
                                                     (type.base t3) =>
                                            base.try_make_transport_cps
                                              (fun t1 : base.type =>
                                               defaults.expr (type.base t1))
                                              t3 base.type.Z
                                              (UnderLets.UnderLets base.type
                                                 ident var
                                                 (defaults.expr
                                                    (type.base base.type.Z)))
                                              (fun
                                                 a0 : option
                                                        (defaults.expr
                                                           (type.base t3) ->
                                                         defaults.expr
                                                           (type.base
                                                              base.type.Z))
                                               =>
                                               match a0 with
                                               | Some x'0 =>
                                                   UnderLets.Base
                                                     (- (x'0 v0 * x0))%expr
                                               | None =>
                                                   UnderLets.Base
                                                     (x * x0)%expr
                                               end)
                                        | (s0 -> d0)%ptype =>
                                            fun
                                              _ : Compile.value' false s0 ->
                                                  Compile.value' true d0 =>
                                            UnderLets.Base (x * x0)%expr
                                        end (Compile.reflect x1)
                                 | None => UnderLets.Base (x * x0)%expr
                                 end)
                          | (s0 -> d0)%ptype =>
                              fun
                                _ : Compile.value' false s0 ->
                                    Compile.value' true d0 =>
                              UnderLets.Base (x * x0)%expr
                          end (Compile.reflect x1)
                      | None =>
                          if args =? -1
                          then UnderLets.Base (- x)%expr
                          else
                           if args <? 0
                           then UnderLets.Base (- (x * ##((- args)%Z)))%expr
                           else
                            if (args =? 2 ^ Z.log2 args) && negb (args =? 2)
                            then UnderLets.Base (x << ##(Z.log2 args))%expr
                            else UnderLets.Base (x * x0)%expr
                      end
                  | _ =>
                      if args =? -1
                      then UnderLets.Base (- x)%expr
                      else
                       if args <? 0
                       then UnderLets.Base (- (x * ##((- args)%Z)))%expr
                       else
                        if (args =? 2 ^ Z.log2 args) && negb (args =? 2)
                        then UnderLets.Base (x << ##(Z.log2 args))%expr
                        else UnderLets.Base (x * x0)%expr
                  end
            | None =>
                match f with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (defaults.expr (type.base base.type.Z)))
                        with
                        | type.base t2 =>
                            fun v : defaults.expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type =>
                               defaults.expr (type.base t1)) t2 base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (defaults.expr (type.base base.type.Z)))
                              (fun
                                 a : option
                                       (defaults.expr (type.base t2) ->
                                        defaults.expr (type.base base.type.Z))
                               =>
                               match a with
                               | Some x' =>
                                   UnderLets.Base (- (x' v * x0))%expr
                               | None => UnderLets.Base (x * x0)%expr
                               end)
                        | (s0 -> d0)%ptype =>
                            fun
                              _ : Compile.value' false s0 ->
                                  Compile.value' true d0 =>
                            UnderLets.Base (x * x0)%expr
                        end (Compile.reflect x1)
                    | None => UnderLets.Base (x * x0)%expr
                    end
                | _ => UnderLets.Base (x * x0)%expr
                end
            end
        | ($_)%expr =>
            match f with
            | #(idc)%expr_pat =>
                match
                  match idc with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (defaults.expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v0 : defaults.expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => defaults.expr (type.base t1))
                          t2 base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (defaults.expr (type.base t2) ->
                                    defaults.expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (- (x' v0 * x0))%expr
                           | None => UnderLets.Base (x * x0)%expr
                           end)
                    | (s0 -> d0)%ptype =>
                        fun
                          _ : Compile.value' false s0 ->
                              Compile.value' true d0 =>
                        UnderLets.Base (x * x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x * x0)%expr
                end
            | _ => UnderLets.Base (x * x0)%expr
            end
        | @expr.Abs _ _ _ _ _ _ =>
            match f with
            | #(idc)%expr_pat =>
                match
                  match idc with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (defaults.expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : defaults.expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => defaults.expr (type.base t0))
                          t2 base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (defaults.expr (type.base t2) ->
                                    defaults.expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (- (x' v * x0))%expr
                           | None => UnderLets.Base (x * x0)%expr
                           end)
                    | (s1 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d1 =>
                        UnderLets.Base (x * x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x * x0)%expr
                end
            | _ => UnderLets.Base (x * x0)%expr
            end
        | @expr.App _ _ _ s0 _ #(idc)%expr_pat x2 =>
            match
              match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end
            with
            | Some _ =>
                match f with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (defaults.expr (type.base base.type.Z)))
                        with
                        | type.base t2 =>
                            fun v : defaults.expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type =>
                               defaults.expr (type.base t1)) t2 base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (defaults.expr (type.base base.type.Z)))
                              (fun
                                 a : option
                                       (defaults.expr (type.base t2) ->
                                        defaults.expr (type.base base.type.Z))
                               =>
                               match a with
                               | Some x' =>
                                   match
                                     s0 as t3
                                     return
                                       (Compile.value' false t3 ->
                                        UnderLets.UnderLets base.type ident
                                          var
                                          (defaults.expr
                                             (type.base base.type.Z)))
                                   with
                                   | type.base t3 =>
                                       fun v0 : defaults.expr (type.base t3)
                                       =>
                                       base.try_make_transport_cps
                                         (fun t1 : base.type =>
                                          defaults.expr (type.base t1)) t3
                                         base.type.Z
                                         (UnderLets.UnderLets base.type ident
                                            var
                                            (defaults.expr
                                               (type.base base.type.Z)))
                                         (fun
                                            a0 : option
                                                   (defaults.expr
                                                      (type.base t3) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                          =>
                                          match a0 with
                                          | Some x'0 =>
                                              UnderLets.Base
                                                (x' v * x'0 v0)%expr
                                          | None =>
                                              UnderLets.Base (x * x0)%expr
                                          end)
                                   | (s1 -> d1)%ptype =>
                                       fun
                                         _ : Compile.value' false s1 ->
                                             Compile.value' true d1 =>
                                       UnderLets.Base (x * x0)%expr
                                   end (Compile.reflect x2)
                               | None => UnderLets.Base (x * x0)%expr
                               end)
                        | (s1 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base (x * x0)%expr
                        end (Compile.reflect x1)
                    | None =>
                        match
                          s0 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (defaults.expr (type.base base.type.Z)))
                        with
                        | type.base t2 =>
                            fun v : defaults.expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type =>
                               defaults.expr (type.base t1)) t2 base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (defaults.expr (type.base base.type.Z)))
                              (fun
                                 a : option
                                       (defaults.expr (type.base t2) ->
                                        defaults.expr (type.base base.type.Z))
                               =>
                               match a with
                               | Some x' =>
                                   UnderLets.Base (- (x * x' v))%expr
                               | None => UnderLets.Base (x * x0)%expr
                               end)
                        | (s1 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base (x * x0)%expr
                        end (Compile.reflect x2)
                    end
                | ($_)%expr =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (defaults.expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v0 : defaults.expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => defaults.expr (type.base t1))
                          t2 base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (defaults.expr (type.base t2) ->
                                    defaults.expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (- (x * x' v0))%expr
                           | None => UnderLets.Base (x * x0)%expr
                           end)
                    | (s1 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d1 =>
                        UnderLets.Base (x * x0)%expr
                    end (Compile.reflect x2)
                | @expr.LetIn _ _ _ _ _ _ _ =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (defaults.expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : defaults.expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => defaults.expr (type.base t0))
                          t2 base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (defaults.expr (type.base t2) ->
                                    defaults.expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (- (x * x' v))%expr
                           | None => UnderLets.Base (x * x0)%expr
                           end)
                    | (s1 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d1 =>
                        UnderLets.Base (x * x0)%expr
                    end (Compile.reflect x2)
                | _ =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (defaults.expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : defaults.expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => defaults.expr (type.base t0))
                          t2 base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (defaults.expr (type.base t2) ->
                                    defaults.expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (- (x * x' v))%expr
                           | None => UnderLets.Base (x * x0)%expr
                           end)
                    | (s2 -> d2)%ptype =>
                        fun
                          _ : Compile.value' false s2 ->
                              Compile.value' true d2 =>
                        UnderLets.Base (x * x0)%expr
                    end (Compile.reflect x2)
                end
            | None =>
                match f with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (defaults.expr (type.base base.type.Z)))
                        with
                        | type.base t2 =>
                            fun v : defaults.expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type =>
                               defaults.expr (type.base t1)) t2 base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (defaults.expr (type.base base.type.Z)))
                              (fun
                                 a : option
                                       (defaults.expr (type.base t2) ->
                                        defaults.expr (type.base base.type.Z))
                               =>
                               match a with
                               | Some x' =>
                                   UnderLets.Base (- (x' v * x0))%expr
                               | None => UnderLets.Base (x * x0)%expr
                               end)
                        | (s1 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base (x * x0)%expr
                        end (Compile.reflect x1)
                    | None => UnderLets.Base (x * x0)%expr
                    end
                | _ => UnderLets.Base (x * x0)%expr
                end
            end
        | @expr.App _ _ _ s0 _ ($_)%expr _ =>
            match f with
            | #(idc)%expr_pat =>
                match
                  match idc with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (defaults.expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v0 : defaults.expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => defaults.expr (type.base t1))
                          t2 base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (defaults.expr (type.base t2) ->
                                    defaults.expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (- (x' v0 * x0))%expr
                           | None => UnderLets.Base (x * x0)%expr
                           end)
                    | (s1 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d1 =>
                        UnderLets.Base (x * x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x * x0)%expr
                end
            | _ => UnderLets.Base (x * x0)%expr
            end
        | @expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0
          _ (_ @ _)%expr_pat _ =>
            match f with
            | #(idc)%expr_pat =>
                match
                  match idc with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (defaults.expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : defaults.expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => defaults.expr (type.base t0))
                          t2 base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (defaults.expr (type.base t2) ->
                                    defaults.expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (- (x' v * x0))%expr
                           | None => UnderLets.Base (x * x0)%expr
                           end)
                    | (s2 -> d2)%ptype =>
                        fun
                          _ : Compile.value' false s2 ->
                              Compile.value' true d2 =>
                        UnderLets.Base (x * x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x * x0)%expr
                end
            | _ => UnderLets.Base (x * x0)%expr
            end
        | @expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            match f with
            | #(idc)%expr_pat =>
                match
                  match idc with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (defaults.expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : defaults.expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => defaults.expr (type.base t0))
                          t2 base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (defaults.expr (type.base t2) ->
                                    defaults.expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (- (x' v * x0))%expr
                           | None => UnderLets.Base (x * x0)%expr
                           end)
                    | (s1 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d1 =>
                        UnderLets.Base (x * x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x * x0)%expr
                end
            | _ => UnderLets.Base (x * x0)%expr
            end
        | @expr.LetIn _ _ _ _ _ _ _ =>
            match f with
            | #(idc)%expr_pat =>
                match
                  match idc with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (defaults.expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : defaults.expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => defaults.expr (type.base t0))
                          t2 base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (defaults.expr (type.base t2) ->
                                    defaults.expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (- (x' v * x0))%expr
                           | None => UnderLets.Base (x * x0)%expr
                           end)
                    | (s0 -> d0)%ptype =>
                        fun
                          _ : Compile.value' false s0 ->
                              Compile.value' true d0 =>
                        UnderLets.Base (x * x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x * x0)%expr
                end
            | _ => UnderLets.Base (x * x0)%expr
            end
        end
    | @expr.LetIn _ _ _ _ _ _ _ =>
        match x0 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t0 v =>
                  match
                    t0 as t1 return (base.base_interp t1 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v0 : Z => Some v0
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v
              | _ => None
              end
            with
            | Some args =>
                if args =? 0
                then UnderLets.Base ##(0)%expr
                else
                 if args =? 1
                 then UnderLets.Base x
                 else
                  if args =? -1
                  then UnderLets.Base (- x)%expr
                  else
                   if args <? 0
                   then UnderLets.Base (- (x * ##((- args)%Z)))%expr
                   else
                    if (args =? 2 ^ Z.log2 args) && negb (args =? 2)
                    then UnderLets.Base (x << ##(Z.log2 args))%expr
                    else UnderLets.Base (x * x0)%expr
            | None => UnderLets.Base (x * x0)%expr
            end
        | @expr.App _ _ _ s _ #(idc)%expr_pat x2 =>
            match
              match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end
            with
            | Some _ =>
                match
                  s as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (defaults.expr (type.base base.type.Z)))
                with
                | type.base t2 =>
                    fun v : defaults.expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => defaults.expr (type.base t0)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr (type.base base.type.Z)))
                      (fun
                         a : option
                               (defaults.expr (type.base t2) ->
                                defaults.expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' => UnderLets.Base (- (x * x' v))%expr
                       | None => UnderLets.Base (x * x0)%expr
                       end)
                | (s0 -> d0)%ptype =>
                    fun _ : Compile.value' false s0 -> Compile.value' true d0
                    => UnderLets.Base (x * x0)%expr
                end (Compile.reflect x2)
            | None => UnderLets.Base (x * x0)%expr
            end
        | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat
          _ | @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            UnderLets.Base (x * x0)%expr
        | _ => UnderLets.Base (x * x0)%expr
        end
    end
| ident.Z_pow =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_pow)%expr @ x @ x0)%expr_pat
| ident.Z_sub =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 =>
                    if args =? 0
                    then UnderLets.Base (- x0)%expr
                    else
                     if args0 =? 0
                     then UnderLets.Base x
                     else
                      if args <? 0
                      then UnderLets.Base (- (##((- args)%Z) + x0))%expr
                      else
                       if args0 <? 0
                       then UnderLets.Base (x + ##((- args0)%Z))%expr
                       else UnderLets.Base (x - x0)%expr
                | None =>
                    if args =? 0
                    then UnderLets.Base (- x0)%expr
                    else
                     if args <? 0
                     then UnderLets.Base (- (##((- args)%Z) + x0))%expr
                     else UnderLets.Base (x - x0)%expr
                end
            | @expr.App _ _ _ s _ #(idc0)%expr_pat x1 =>
                match
                  match idc0 with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (defaults.expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : defaults.expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => defaults.expr (type.base t1))
                          t2 base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (defaults.expr (type.base t2) ->
                                    defaults.expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               if args =? 0
                               then UnderLets.Base (x' v)
                               else
                                if args =? 0
                                then UnderLets.Base (- x0)%expr
                                else
                                 match
                                   s as t3
                                   return
                                     (Compile.value' false t3 ->
                                      UnderLets.UnderLets base.type ident var
                                        (defaults.expr
                                           (type.base base.type.Z)))
                                 with
                                 | type.base t3 =>
                                     fun v0 : defaults.expr (type.base t3) =>
                                     base.try_make_transport_cps
                                       (fun t1 : base.type =>
                                        defaults.expr (type.base t1)) t3
                                       base.type.Z
                                       (UnderLets.UnderLets base.type ident
                                          var
                                          (defaults.expr
                                             (type.base base.type.Z)))
                                       (fun
                                          a0 : option
                                                 (defaults.expr
                                                    (type.base t3) ->
                                                  defaults.expr
                                                    (type.base base.type.Z))
                                        =>
                                        match a0 with
                                        | Some x'0 =>
                                            if args >? 0
                                            then
                                             UnderLets.Base
                                               (##(args) + x'0 v0)%expr
                                            else
                                             match
                                               s as t4
                                               return
                                                 (Compile.value' false t4 ->
                                                  UnderLets.UnderLets
                                                    base.type ident var
                                                    (defaults.expr
                                                       (type.base base.type.Z)))
                                             with
                                             | type.base t4 =>
                                                 fun
                                                   v1 : defaults.expr
                                                          (type.base t4) =>
                                                 base.try_make_transport_cps
                                                   (fun t1 : base.type =>
                                                    defaults.expr
                                                      (type.base t1)) t4
                                                   base.type.Z
                                                   (UnderLets.UnderLets
                                                      base.type ident var
                                                      (defaults.expr
                                                         (type.base
                                                            base.type.Z)))
                                                   (fun
                                                      a1 : option
                                                             (defaults.expr
                                                                (type.base t4) ->
                                                              defaults.expr
                                                                (type.base
                                                                   base.type.Z))
                                                    =>
                                                    match a1 with
                                                    | Some x'1 =>
                                                        if args <? 0
                                                        then
                                                         UnderLets.Base
                                                           (x'1 v1 -
                                                            ##((- args)%Z))%expr
                                                        else
                                                         if args <? 0
                                                         then
                                                          UnderLets.Base
                                                            (-
                                                             (##((- args)%Z) +
                                                              x0))%expr
                                                         else
                                                          match
                                                            s as t5
                                                            return
                                                              (Compile.value'
                                                                 false t5 ->
                                                               UnderLets.UnderLets
                                                                 base.type
                                                                 ident var
                                                                 (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                          with
                                                          | type.base t5 =>
                                                              fun
                                                                v2 : 
                                                                 defaults.expr
                                                                   (type.base
                                                                    t5) =>
                                                              base.try_make_transport_cps
                                                                (fun
                                                                   t1 : base.type
                                                                 =>
                                                                 defaults.expr
                                                                   (type.base
                                                                    t1)) t5
                                                                base.type.Z
                                                                (UnderLets.UnderLets
                                                                   base.type
                                                                   ident var
                                                                   (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                (fun
                                                                   a2 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t5) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                 =>
                                                                 match
                                                                   a2
                                                                 with
                                                                 | Some
                                                                   x'2 =>
                                                                    UnderLets.Base
                                                                    (x +
                                                                    x'2 v2)%expr
                                                                 | None =>
                                                                    UnderLets.Base
                                                                    (x - x0)%expr
                                                                 end)
                                                          | (s0 -> d0)%ptype =>
                                                              fun
                                                                _ : Compile.value'
                                                                    false s0 ->
                                                                    Compile.value'
                                                                    true d0
                                                              =>
                                                              UnderLets.Base
                                                                (x - x0)%expr
                                                          end
                                                            (Compile.reflect
                                                               x1)
                                                    | None =>
                                                        UnderLets.Base
                                                          (x - x0)%expr
                                                    end)
                                             | (s0 -> d0)%ptype =>
                                                 fun
                                                   _ : Compile.value' false
                                                         s0 ->
                                                       Compile.value' true d0
                                                 =>
                                                 UnderLets.Base (x - x0)%expr
                                             end (Compile.reflect x1)
                                        | None =>
                                            UnderLets.Base (x - x0)%expr
                                        end)
                                 | (s0 -> d0)%ptype =>
                                     fun
                                       _ : Compile.value' false s0 ->
                                           Compile.value' true d0 =>
                                     UnderLets.Base (x - x0)%expr
                                 end (Compile.reflect x1)
                           | None => UnderLets.Base (x - x0)%expr
                           end)
                    | (s0 -> d0)%ptype =>
                        fun
                          _ : Compile.value' false s0 ->
                              Compile.value' true d0 =>
                        UnderLets.Base (x - x0)%expr
                    end (Compile.reflect x1)
                | None =>
                    if args =? 0
                    then UnderLets.Base (- x0)%expr
                    else
                     if args <? 0
                     then UnderLets.Base (- (##((- args)%Z) + x0))%expr
                     else UnderLets.Base (x - x0)%expr
                end
            | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
              (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _
              (_ @ _)%expr_pat _ | @expr.App _ _ _ s _
              (@expr.LetIn _ _ _ _ _ _ _) _ =>
                if args =? 0
                then UnderLets.Base (- x0)%expr
                else
                 if args <? 0
                 then UnderLets.Base (- (##((- args)%Z) + x0))%expr
                 else UnderLets.Base (x - x0)%expr
            | _ =>
                if args =? 0
                then UnderLets.Base (- x0)%expr
                else
                 if args <? 0
                 then UnderLets.Base (- (##((- args)%Z) + x0))%expr
                 else UnderLets.Base (x - x0)%expr
            end
        | None =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args =>
                    if args =? 0
                    then UnderLets.Base x
                    else
                     if args <? 0
                     then UnderLets.Base (x + ##((- args)%Z))%expr
                     else UnderLets.Base (x - x0)%expr
                | None => UnderLets.Base (x - x0)%expr
                end
            | @expr.App _ _ _ s _ #(idc0)%expr_pat x1 =>
                match
                  match idc0 with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (defaults.expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : defaults.expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => defaults.expr (type.base t1))
                          t2 base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (defaults.expr (type.base t2) ->
                                    defaults.expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (x + x' v)%expr
                           | None => UnderLets.Base (x - x0)%expr
                           end)
                    | (s0 -> d0)%ptype =>
                        fun
                          _ : Compile.value' false s0 ->
                              Compile.value' true d0 =>
                        UnderLets.Base (x - x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x - x0)%expr
                end
            | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
              (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _
              (_ @ _)%expr_pat _ | @expr.App _ _ _ s _
              (@expr.LetIn _ _ _ _ _ _ _) _ => UnderLets.Base (x - x0)%expr
            | _ => UnderLets.Base (x - x0)%expr
            end
        end
    | ($_)%expr =>
        match x0 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t1 v0 =>
                  match
                    t1 as t2 return (base.base_interp t2 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v1 : Z => Some v1
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v0
              | _ => None
              end
            with
            | Some args =>
                if args =? 0
                then UnderLets.Base x
                else
                 if args <? 0
                 then UnderLets.Base (x + ##((- args)%Z))%expr
                 else UnderLets.Base (x - x0)%expr
            | None => UnderLets.Base (x - x0)%expr
            end
        | @expr.App _ _ _ s _ #(idc)%expr_pat x1 =>
            match
              match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end
            with
            | Some _ =>
                match
                  s as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (defaults.expr (type.base base.type.Z)))
                with
                | type.base t2 =>
                    fun v0 : defaults.expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t1 : base.type => defaults.expr (type.base t1)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr (type.base base.type.Z)))
                      (fun
                         a : option
                               (defaults.expr (type.base t2) ->
                                defaults.expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' => UnderLets.Base (x + x' v0)%expr
                       | None => UnderLets.Base (x - x0)%expr
                       end)
                | (s0 -> d0)%ptype =>
                    fun _ : Compile.value' false s0 -> Compile.value' true d0
                    => UnderLets.Base (x - x0)%expr
                end (Compile.reflect x1)
            | None => UnderLets.Base (x - x0)%expr
            end
        | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat
          _ | @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            UnderLets.Base (x - x0)%expr
        | _ => UnderLets.Base (x - x0)%expr
        end
    | @expr.Abs _ _ _ _ _ _ =>
        match x0 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t0 v =>
                  match
                    t0 as t1 return (base.base_interp t1 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v0 : Z => Some v0
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v
              | _ => None
              end
            with
            | Some args =>
                if args =? 0
                then UnderLets.Base x
                else
                 if args <? 0
                 then UnderLets.Base (x + ##((- args)%Z))%expr
                 else UnderLets.Base (x - x0)%expr
            | None => UnderLets.Base (x - x0)%expr
            end
        | @expr.App _ _ _ s0 _ #(idc)%expr_pat x1 =>
            match
              match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end
            with
            | Some _ =>
                match
                  s0 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (defaults.expr (type.base base.type.Z)))
                with
                | type.base t2 =>
                    fun v : defaults.expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => defaults.expr (type.base t0)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr (type.base base.type.Z)))
                      (fun
                         a : option
                               (defaults.expr (type.base t2) ->
                                defaults.expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' => UnderLets.Base (x + x' v)%expr
                       | None => UnderLets.Base (x - x0)%expr
                       end)
                | (s1 -> d1)%ptype =>
                    fun _ : Compile.value' false s1 -> Compile.value' true d1
                    => UnderLets.Base (x - x0)%expr
                end (Compile.reflect x1)
            | None => UnderLets.Base (x - x0)%expr
            end
        | @expr.App _ _ _ s0 _ ($_)%expr _ | @expr.App _ _ _ s0 _
          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0 _ (_ @ _)%expr_pat
          _ | @expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            UnderLets.Base (x - x0)%expr
        | _ => UnderLets.Base (x - x0)%expr
        end
    | @expr.App _ _ _ s _ f x1 =>
        match x0 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t0 v =>
                  match
                    t0 as t1 return (base.base_interp t1 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v0 : Z => Some v0
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v
              | _ => None
              end
            with
            | Some args =>
                if args =? 0
                then UnderLets.Base x
                else
                 match f with
                 | #(idc0)%expr_pat =>
                     match
                       match idc0 with
                       | ident.Z_opp => Some tt
                       | _ => None
                       end
                     with
                     | Some _ =>
                         match
                           s as t2
                           return
                             (Compile.value' false t2 ->
                              UnderLets.UnderLets base.type ident var
                                (defaults.expr (type.base base.type.Z)))
                         with
                         | type.base t2 =>
                             fun v : defaults.expr (type.base t2) =>
                             base.try_make_transport_cps
                               (fun t1 : base.type =>
                                defaults.expr (type.base t1)) t2 base.type.Z
                               (UnderLets.UnderLets base.type ident var
                                  (defaults.expr (type.base base.type.Z)))
                               (fun
                                  a : option
                                        (defaults.expr (type.base t2) ->
                                         defaults.expr
                                           (type.base base.type.Z)) =>
                                match a with
                                | Some x' =>
                                    if args >? 0
                                    then
                                     UnderLets.Base
                                       (- (x' v + ##((- args)%Z)))%expr
                                    else
                                     match
                                       s as t3
                                       return
                                         (Compile.value' false t3 ->
                                          UnderLets.UnderLets base.type ident
                                            var
                                            (defaults.expr
                                               (type.base base.type.Z)))
                                     with
                                     | type.base t3 =>
                                         fun
                                           v0 : defaults.expr (type.base t3)
                                         =>
                                         base.try_make_transport_cps
                                           (fun t1 : base.type =>
                                            defaults.expr (type.base t1)) t3
                                           base.type.Z
                                           (UnderLets.UnderLets base.type
                                              ident var
                                              (defaults.expr
                                                 (type.base base.type.Z)))
                                           (fun
                                              a0 : option
                                                     (defaults.expr
                                                        (type.base t3) ->
                                                      defaults.expr
                                                        (type.base
                                                           base.type.Z)) =>
                                            match a0 with
                                            | Some x'0 =>
                                                if args <? 0
                                                then
                                                 UnderLets.Base
                                                   (##((- args)%Z) - x'0 v0)%expr
                                                else
                                                 if args <? 0
                                                 then
                                                  UnderLets.Base
                                                    (x + ##((- args)%Z))%expr
                                                 else
                                                  match
                                                    s as t4
                                                    return
                                                      (Compile.value' false
                                                         t4 ->
                                                       UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               base.type.Z)))
                                                  with
                                                  | type.base t4 =>
                                                      fun
                                                        v1 : defaults.expr
                                                               (type.base t4)
                                                      =>
                                                      base.try_make_transport_cps
                                                        (fun t1 : base.type
                                                         =>
                                                         defaults.expr
                                                           (type.base t1)) t4
                                                        base.type.Z
                                                        (UnderLets.UnderLets
                                                           base.type ident
                                                           var
                                                           (defaults.expr
                                                              (type.base
                                                                 base.type.Z)))
                                                        (fun
                                                           a1 : option
                                                                  (defaults.expr
                                                                    (type.base
                                                                    t4) ->
                                                                   defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                         =>
                                                         match a1 with
                                                         | Some x'1 =>
                                                             UnderLets.Base
                                                               (-
                                                                (x'1 v1 + x0))%expr
                                                         | None =>
                                                             UnderLets.Base
                                                               (x - x0)%expr
                                                         end)
                                                  | (s0 -> d0)%ptype =>
                                                      fun
                                                        _ : Compile.value'
                                                              false s0 ->
                                                            Compile.value'
                                                              true d0 =>
                                                      UnderLets.Base
                                                        (x - x0)%expr
                                                  end (Compile.reflect x1)
                                            | None =>
                                                UnderLets.Base (x - x0)%expr
                                            end)
                                     | (s0 -> d0)%ptype =>
                                         fun
                                           _ : Compile.value' false s0 ->
                                               Compile.value' true d0 =>
                                         UnderLets.Base (x - x0)%expr
                                     end (Compile.reflect x1)
                                | None => UnderLets.Base (x - x0)%expr
                                end)
                         | (s0 -> d0)%ptype =>
                             fun
                               _ : Compile.value' false s0 ->
                                   Compile.value' true d0 =>
                             UnderLets.Base (x - x0)%expr
                         end (Compile.reflect x1)
                     | None =>
                         if args <? 0
                         then UnderLets.Base (x + ##((- args)%Z))%expr
                         else UnderLets.Base (x - x0)%expr
                     end
                 | _ =>
                     if args <? 0
                     then UnderLets.Base (x + ##((- args)%Z))%expr
                     else UnderLets.Base (x - x0)%expr
                 end
            | None =>
                match f with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (defaults.expr (type.base base.type.Z)))
                        with
                        | type.base t2 =>
                            fun v : defaults.expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type =>
                               defaults.expr (type.base t1)) t2 base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (defaults.expr (type.base base.type.Z)))
                              (fun
                                 a : option
                                       (defaults.expr (type.base t2) ->
                                        defaults.expr (type.base base.type.Z))
                               =>
                               match a with
                               | Some x' =>
                                   UnderLets.Base (- (x' v + x0))%expr
                               | None => UnderLets.Base (x - x0)%expr
                               end)
                        | (s0 -> d0)%ptype =>
                            fun
                              _ : Compile.value' false s0 ->
                                  Compile.value' true d0 =>
                            UnderLets.Base (x - x0)%expr
                        end (Compile.reflect x1)
                    | None => UnderLets.Base (x - x0)%expr
                    end
                | _ => UnderLets.Base (x - x0)%expr
                end
            end
        | ($_)%expr =>
            match f with
            | #(idc)%expr_pat =>
                match
                  match idc with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (defaults.expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v0 : defaults.expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => defaults.expr (type.base t1))
                          t2 base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (defaults.expr (type.base t2) ->
                                    defaults.expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (- (x' v0 + x0))%expr
                           | None => UnderLets.Base (x - x0)%expr
                           end)
                    | (s0 -> d0)%ptype =>
                        fun
                          _ : Compile.value' false s0 ->
                              Compile.value' true d0 =>
                        UnderLets.Base (x - x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x - x0)%expr
                end
            | _ => UnderLets.Base (x - x0)%expr
            end
        | @expr.Abs _ _ _ _ _ _ =>
            match f with
            | #(idc)%expr_pat =>
                match
                  match idc with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (defaults.expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : defaults.expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => defaults.expr (type.base t0))
                          t2 base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (defaults.expr (type.base t2) ->
                                    defaults.expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (- (x' v + x0))%expr
                           | None => UnderLets.Base (x - x0)%expr
                           end)
                    | (s1 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d1 =>
                        UnderLets.Base (x - x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x - x0)%expr
                end
            | _ => UnderLets.Base (x - x0)%expr
            end
        | @expr.App _ _ _ s0 _ #(idc)%expr_pat x2 =>
            match
              match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end
            with
            | Some _ =>
                match f with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (defaults.expr (type.base base.type.Z)))
                        with
                        | type.base t2 =>
                            fun v : defaults.expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type =>
                               defaults.expr (type.base t1)) t2 base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (defaults.expr (type.base base.type.Z)))
                              (fun
                                 a : option
                                       (defaults.expr (type.base t2) ->
                                        defaults.expr (type.base base.type.Z))
                               =>
                               match a with
                               | Some x' =>
                                   match
                                     s0 as t3
                                     return
                                       (Compile.value' false t3 ->
                                        UnderLets.UnderLets base.type ident
                                          var
                                          (defaults.expr
                                             (type.base base.type.Z)))
                                   with
                                   | type.base t3 =>
                                       fun v0 : defaults.expr (type.base t3)
                                       =>
                                       base.try_make_transport_cps
                                         (fun t1 : base.type =>
                                          defaults.expr (type.base t1)) t3
                                         base.type.Z
                                         (UnderLets.UnderLets base.type ident
                                            var
                                            (defaults.expr
                                               (type.base base.type.Z)))
                                         (fun
                                            a0 : option
                                                   (defaults.expr
                                                      (type.base t3) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                          =>
                                          match a0 with
                                          | Some x'0 =>
                                              UnderLets.Base
                                                (x'0 v0 - x' v)%expr
                                          | None =>
                                              UnderLets.Base (x - x0)%expr
                                          end)
                                   | (s1 -> d1)%ptype =>
                                       fun
                                         _ : Compile.value' false s1 ->
                                             Compile.value' true d1 =>
                                       UnderLets.Base (x - x0)%expr
                                   end (Compile.reflect x2)
                               | None => UnderLets.Base (x - x0)%expr
                               end)
                        | (s1 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base (x - x0)%expr
                        end (Compile.reflect x1)
                    | None =>
                        match
                          s0 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (defaults.expr (type.base base.type.Z)))
                        with
                        | type.base t2 =>
                            fun v : defaults.expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type =>
                               defaults.expr (type.base t1)) t2 base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (defaults.expr (type.base base.type.Z)))
                              (fun
                                 a : option
                                       (defaults.expr (type.base t2) ->
                                        defaults.expr (type.base base.type.Z))
                               =>
                               match a with
                               | Some x' => UnderLets.Base (x + x' v)%expr
                               | None => UnderLets.Base (x - x0)%expr
                               end)
                        | (s1 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base (x - x0)%expr
                        end (Compile.reflect x2)
                    end
                | ($_)%expr =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (defaults.expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v0 : defaults.expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => defaults.expr (type.base t1))
                          t2 base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (defaults.expr (type.base t2) ->
                                    defaults.expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (x + x' v0)%expr
                           | None => UnderLets.Base (x - x0)%expr
                           end)
                    | (s1 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d1 =>
                        UnderLets.Base (x - x0)%expr
                    end (Compile.reflect x2)
                | @expr.LetIn _ _ _ _ _ _ _ =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (defaults.expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : defaults.expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => defaults.expr (type.base t0))
                          t2 base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (defaults.expr (type.base t2) ->
                                    defaults.expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (x + x' v)%expr
                           | None => UnderLets.Base (x - x0)%expr
                           end)
                    | (s1 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d1 =>
                        UnderLets.Base (x - x0)%expr
                    end (Compile.reflect x2)
                | _ =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (defaults.expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : defaults.expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => defaults.expr (type.base t0))
                          t2 base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (defaults.expr (type.base t2) ->
                                    defaults.expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (x + x' v)%expr
                           | None => UnderLets.Base (x - x0)%expr
                           end)
                    | (s2 -> d2)%ptype =>
                        fun
                          _ : Compile.value' false s2 ->
                              Compile.value' true d2 =>
                        UnderLets.Base (x - x0)%expr
                    end (Compile.reflect x2)
                end
            | None =>
                match f with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (defaults.expr (type.base base.type.Z)))
                        with
                        | type.base t2 =>
                            fun v : defaults.expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type =>
                               defaults.expr (type.base t1)) t2 base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (defaults.expr (type.base base.type.Z)))
                              (fun
                                 a : option
                                       (defaults.expr (type.base t2) ->
                                        defaults.expr (type.base base.type.Z))
                               =>
                               match a with
                               | Some x' =>
                                   UnderLets.Base (- (x' v + x0))%expr
                               | None => UnderLets.Base (x - x0)%expr
                               end)
                        | (s1 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base (x - x0)%expr
                        end (Compile.reflect x1)
                    | None => UnderLets.Base (x - x0)%expr
                    end
                | _ => UnderLets.Base (x - x0)%expr
                end
            end
        | @expr.App _ _ _ s0 _ ($_)%expr _ =>
            match f with
            | #(idc)%expr_pat =>
                match
                  match idc with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (defaults.expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v0 : defaults.expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => defaults.expr (type.base t1))
                          t2 base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (defaults.expr (type.base t2) ->
                                    defaults.expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (- (x' v0 + x0))%expr
                           | None => UnderLets.Base (x - x0)%expr
                           end)
                    | (s1 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d1 =>
                        UnderLets.Base (x - x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x - x0)%expr
                end
            | _ => UnderLets.Base (x - x0)%expr
            end
        | @expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0
          _ (_ @ _)%expr_pat _ =>
            match f with
            | #(idc)%expr_pat =>
                match
                  match idc with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (defaults.expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : defaults.expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => defaults.expr (type.base t0))
                          t2 base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (defaults.expr (type.base t2) ->
                                    defaults.expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (- (x' v + x0))%expr
                           | None => UnderLets.Base (x - x0)%expr
                           end)
                    | (s2 -> d2)%ptype =>
                        fun
                          _ : Compile.value' false s2 ->
                              Compile.value' true d2 =>
                        UnderLets.Base (x - x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x - x0)%expr
                end
            | _ => UnderLets.Base (x - x0)%expr
            end
        | @expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            match f with
            | #(idc)%expr_pat =>
                match
                  match idc with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (defaults.expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : defaults.expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => defaults.expr (type.base t0))
                          t2 base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (defaults.expr (type.base t2) ->
                                    defaults.expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (- (x' v + x0))%expr
                           | None => UnderLets.Base (x - x0)%expr
                           end)
                    | (s1 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d1 =>
                        UnderLets.Base (x - x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x - x0)%expr
                end
            | _ => UnderLets.Base (x - x0)%expr
            end
        | @expr.LetIn _ _ _ _ _ _ _ =>
            match f with
            | #(idc)%expr_pat =>
                match
                  match idc with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (defaults.expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : defaults.expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => defaults.expr (type.base t0))
                          t2 base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (defaults.expr (type.base t2) ->
                                    defaults.expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' => UnderLets.Base (- (x' v + x0))%expr
                           | None => UnderLets.Base (x - x0)%expr
                           end)
                    | (s0 -> d0)%ptype =>
                        fun
                          _ : Compile.value' false s0 ->
                              Compile.value' true d0 =>
                        UnderLets.Base (x - x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x - x0)%expr
                end
            | _ => UnderLets.Base (x - x0)%expr
            end
        end
    | @expr.LetIn _ _ _ _ _ _ _ =>
        match x0 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t0 v =>
                  match
                    t0 as t1 return (base.base_interp t1 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v0 : Z => Some v0
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v
              | _ => None
              end
            with
            | Some args =>
                if args =? 0
                then UnderLets.Base x
                else
                 if args <? 0
                 then UnderLets.Base (x + ##((- args)%Z))%expr
                 else UnderLets.Base (x - x0)%expr
            | None => UnderLets.Base (x - x0)%expr
            end
        | @expr.App _ _ _ s _ #(idc)%expr_pat x2 =>
            match
              match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end
            with
            | Some _ =>
                match
                  s as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (defaults.expr (type.base base.type.Z)))
                with
                | type.base t2 =>
                    fun v : defaults.expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => defaults.expr (type.base t0)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr (type.base base.type.Z)))
                      (fun
                         a : option
                               (defaults.expr (type.base t2) ->
                                defaults.expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' => UnderLets.Base (x + x' v)%expr
                       | None => UnderLets.Base (x - x0)%expr
                       end)
                | (s0 -> d0)%ptype =>
                    fun _ : Compile.value' false s0 -> Compile.value' true d0
                    => UnderLets.Base (x - x0)%expr
                end (Compile.reflect x2)
            | None => UnderLets.Base (x - x0)%expr
            end
        | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat
          _ | @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            UnderLets.Base (x - x0)%expr
        | _ => UnderLets.Base (x - x0)%expr
        end
    end
| ident.Z_opp =>
    fun x : defaults.expr (type.base base.type.Z) =>
    match x with
    | ($_)%expr =>
        if negb (SubstVarLike.is_var_fst_snd_pair_opp x)
        then
         UnderLets.UnderLet x
           (fun v0 : var (type.base base.type.Z) =>
            UnderLets.Base (- $v0)%expr)
        else UnderLets.Base (- x)%expr
    | @expr.App _ _ _ s _ #(idc)%expr_pat x0 =>
        match match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end with
        | Some _ =>
            match
              s as t2
              return
                (Compile.value' false t2 ->
                 UnderLets.UnderLets base.type ident var
                   (defaults.expr (type.base base.type.Z)))
            with
            | type.base t2 =>
                fun v : defaults.expr (type.base t2) =>
                base.try_make_transport_cps
                  (fun t0 : base.type => defaults.expr (type.base t0)) t2
                  base.type.Z
                  (UnderLets.UnderLets base.type ident var
                     (defaults.expr (type.base base.type.Z)))
                  (fun
                     a : option
                           (defaults.expr (type.base t2) ->
                            defaults.expr (type.base base.type.Z)) =>
                   match a with
                   | Some x' => UnderLets.Base (x' v)
                   | None => UnderLets.Base (- x)%expr
                   end)
            | (s0 -> d0)%ptype =>
                fun _ : Compile.value' false s0 -> Compile.value' true d0 =>
                UnderLets.Base (- x)%expr
            end (Compile.reflect x0)
        | None =>
            if negb (SubstVarLike.is_var_fst_snd_pair_opp x)
            then
             UnderLets.UnderLet x
               (fun v : var (type.base base.type.Z) =>
                UnderLets.Base (- $v)%expr)
            else UnderLets.Base (- x)%expr
        end
    | @expr.App _ _ _ s _ ($_)%expr _ =>
        if negb (SubstVarLike.is_var_fst_snd_pair_opp x)
        then
         UnderLets.UnderLet x
           (fun v0 : var (type.base base.type.Z) =>
            UnderLets.Base (- $v0)%expr)
        else UnderLets.Base (- x)%expr
    | @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _
      (_ @ _)%expr_pat _ | @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _)
      _ =>
        if negb (SubstVarLike.is_var_fst_snd_pair_opp x)
        then
         UnderLets.UnderLet x
           (fun v : var (type.base base.type.Z) => UnderLets.Base (- $v)%expr)
        else UnderLets.Base (- x)%expr
    | _ =>
        if negb (SubstVarLike.is_var_fst_snd_pair_opp x)
        then
         UnderLets.UnderLet x
           (fun v : var (type.base base.type.Z) => UnderLets.Base (- $v)%expr)
        else UnderLets.Base (- x)%expr
    end
| ident.Z_div =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    match x0 with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            if args =? 1
            then UnderLets.Base x
            else
             if args =? 2 ^ Z.log2 args
             then UnderLets.Base (x >> ##(Z.log2 args))%expr
             else UnderLets.Base (x / x0)%expr
        | None => UnderLets.Base (x / x0)%expr
        end
    | _ => UnderLets.Base (x / x0)%expr
    end
| ident.Z_modulo =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    match x0 with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            if args =? 1
            then UnderLets.Base ##(0)%expr
            else
             if args =? 2 ^ Z.log2 args
             then UnderLets.Base (x &' ##((args - 1)%Z))%expr
             else UnderLets.Base (x mod x0)%expr
        | None => UnderLets.Base (x mod x0)%expr
        end
    | _ => UnderLets.Base (x mod x0)%expr
    end
| ident.Z_log2 =>
    fun x : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_log2)%expr @ x)%expr_pat
| ident.Z_log2_up =>
    fun x : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_log2_up)%expr @ x)%expr_pat
| ident.Z_eqb =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_eqb)%expr @ x @ x0)%expr_pat
| ident.Z_leb =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_leb)%expr @ x @ x0)%expr_pat
| ident.Z_geb =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_geb)%expr @ x @ x0)%expr_pat
| ident.Z_of_nat =>
    fun x : defaults.expr (type.base base.type.nat) =>
    UnderLets.Base (#(ident.Z_of_nat)%expr @ x)%expr_pat
| ident.Z_to_nat =>
    fun x : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_to_nat)%expr @ x)%expr_pat
| ident.Z_shiftr =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (x >> x0)%expr
| ident.Z_shiftl =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (x << x0)%expr
| ident.Z_land =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    match x0 with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            if args =? 0
            then UnderLets.Base ##(0)%expr
            else
             match x with
             | #(idc0)%expr_pat =>
                 match
                   match idc0 with
                   | @ident.Literal t1 v =>
                       match
                         t1 as t2 return (base.base_interp t2 -> option Z)
                       with
                       | base.type.unit => fun _ : unit => None
                       | base.type.Z => fun v0 : Z => Some v0
                       | base.type.bool => fun _ : bool => None
                       | base.type.nat => fun _ : nat => None
                       end v
                   | _ => None
                   end
                 with
                 | Some args0 =>
                     if args0 =? 0
                     then UnderLets.Base ##(0)%expr
                     else UnderLets.Base (x &' x0)%expr
                 | None => UnderLets.Base (x &' x0)%expr
                 end
             | _ => UnderLets.Base (x &' x0)%expr
             end
        | None =>
            match x with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args =>
                    if args =? 0
                    then UnderLets.Base ##(0)%expr
                    else UnderLets.Base (x &' x0)%expr
                | None => UnderLets.Base (x &' x0)%expr
                end
            | _ => UnderLets.Base (x &' x0)%expr
            end
        end
    | ($_)%expr =>
        match x with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t1 v0 =>
                  match
                    t1 as t2 return (base.base_interp t2 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v1 : Z => Some v1
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v0
              | _ => None
              end
            with
            | Some args =>
                if args =? 0
                then UnderLets.Base ##(0)%expr
                else UnderLets.Base (x &' x0)%expr
            | None => UnderLets.Base (x &' x0)%expr
            end
        | _ => UnderLets.Base (x &' x0)%expr
        end
    | _ =>
        match x with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t0 v =>
                  match
                    t0 as t1 return (base.base_interp t1 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v0 : Z => Some v0
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v
              | _ => None
              end
            with
            | Some args =>
                if args =? 0
                then UnderLets.Base ##(0)%expr
                else UnderLets.Base (x &' x0)%expr
            | None => UnderLets.Base (x &' x0)%expr
            end
        | _ => UnderLets.Base (x &' x0)%expr
        end
    end
| ident.Z_lor =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (x || x0)%expr
| ident.Z_bneg =>
    fun x : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_bneg)%expr @ x)%expr_pat
| ident.Z_lnot_modulo =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_lnot_modulo)%expr @ x @ x0)%expr_pat
| ident.Z_mul_split =>
    fun x x0 x1 : defaults.expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some _ =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 =>
                    if args0 =? 0
                    then UnderLets.Base (##(0)%expr, ##(0)%expr)%expr_pat
                    else
                     match x1 with
                     | #(idc1)%expr_pat =>
                         match
                           match idc1 with
                           | @ident.Literal t2 v =>
                               match
                                 t2 as t3
                                 return (base.base_interp t3 -> option Z)
                               with
                               | base.type.unit => fun _ : unit => None
                               | base.type.Z => fun v0 : Z => Some v0
                               | base.type.bool => fun _ : bool => None
                               | base.type.nat => fun _ : nat => None
                               end v
                           | _ => None
                           end
                         with
                         | Some args1 =>
                             if args1 =? 0
                             then
                              UnderLets.Base
                                (##(0)%expr, ##(0)%expr)%expr_pat
                             else
                              if args0 =? 1
                              then UnderLets.Base (x1, ##(0)%expr)%expr_pat
                              else
                               if args1 =? 1
                               then UnderLets.Base (x0, ##(0)%expr)%expr_pat
                               else
                                if args0 =? -1
                                then
                                 UnderLets.Base
                                   ((- x1)%expr, ##(0)%expr)%expr_pat
                                else
                                 if args1 =? -1
                                 then
                                  UnderLets.Base
                                    ((- x0)%expr, ##(0)%expr)%expr_pat
                                 else
                                  UnderLets.UnderLet
                                    (#(ident.Z_mul_split)%expr @ x @ x0 @ x1)%expr_pat
                                    (fun
                                       v : var
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)
                                     =>
                                     UnderLets.Base
                                       (#(ident.fst)%expr @ ($v)%expr,
                                       #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                         | None =>
                             if args0 =? 1
                             then UnderLets.Base (x1, ##(0)%expr)%expr_pat
                             else
                              if args0 =? -1
                              then
                               UnderLets.Base
                                 ((- x1)%expr, ##(0)%expr)%expr_pat
                              else
                               UnderLets.UnderLet
                                 (#(ident.Z_mul_split)%expr @ x @ x0 @ x1)%expr_pat
                                 (fun
                                    v : var
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)
                                  =>
                                  UnderLets.Base
                                    (#(ident.fst)%expr @ ($v)%expr,
                                    #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                         end
                     | ($_)%expr =>
                         if args0 =? 1
                         then UnderLets.Base (x1, ##(0)%expr)%expr_pat
                         else
                          if args0 =? -1
                          then
                           UnderLets.Base ((- x1)%expr, ##(0)%expr)%expr_pat
                          else
                           UnderLets.UnderLet
                             (#(ident.Z_mul_split)%expr @ x @ x0 @ x1)%expr_pat
                             (fun
                                v0 : var
                                       (type.base
                                          (base.type.Z * base.type.Z)%etype)
                              =>
                              UnderLets.Base
                                (#(ident.fst)%expr @ ($v0)%expr,
                                #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                     | _ =>
                         if args0 =? 1
                         then UnderLets.Base (x1, ##(0)%expr)%expr_pat
                         else
                          if args0 =? -1
                          then
                           UnderLets.Base ((- x1)%expr, ##(0)%expr)%expr_pat
                          else
                           UnderLets.UnderLet
                             (#(ident.Z_mul_split)%expr @ x @ x0 @ x1)%expr_pat
                             (fun
                                v : var
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)
                              =>
                              UnderLets.Base
                                (#(ident.fst)%expr @ ($v)%expr,
                                #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                     end
                | None =>
                    match x1 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args0 =>
                            if args0 =? 0
                            then
                             UnderLets.Base (##(0)%expr, ##(0)%expr)%expr_pat
                            else
                             if args0 =? 1
                             then UnderLets.Base (x0, ##(0)%expr)%expr_pat
                             else
                              if args0 =? -1
                              then
                               UnderLets.Base
                                 ((- x0)%expr, ##(0)%expr)%expr_pat
                              else
                               UnderLets.UnderLet
                                 (#(ident.Z_mul_split)%expr @ x @ x0 @ x1)%expr_pat
                                 (fun
                                    v : var
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)
                                  =>
                                  UnderLets.Base
                                    (#(ident.fst)%expr @ ($v)%expr,
                                    #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                        | None =>
                            UnderLets.UnderLet
                              (#(ident.Z_mul_split)%expr @ x @ x0 @ x1)%expr_pat
                              (fun
                                 v : var
                                       (type.base
                                          (base.type.Z * base.type.Z)%etype)
                               =>
                               UnderLets.Base
                                 (#(ident.fst)%expr @ ($v)%expr,
                                 #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                        end
                    | ($_)%expr =>
                        UnderLets.UnderLet
                          (#(ident.Z_mul_split)%expr @ x @ x0 @ x1)%expr_pat
                          (fun
                             v0 : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                           UnderLets.Base
                             (#(ident.fst)%expr @ ($v0)%expr,
                             #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                    | _ =>
                        UnderLets.UnderLet
                          (#(ident.Z_mul_split)%expr @ x @ x0 @ x1)%expr_pat
                          (fun
                             v : var
                                   (type.base
                                      (base.type.Z * base.type.Z)%etype) =>
                           UnderLets.Base
                             (#(ident.fst)%expr @ ($v)%expr,
                             #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    end
                end
            | ($_)%expr =>
                match x1 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t2 v0 =>
                          match
                            t2 as t3 return (base.base_interp t3 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v1 : Z => Some v1
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v0
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        if args0 =? 0
                        then UnderLets.Base (##(0)%expr, ##(0)%expr)%expr_pat
                        else
                         if args0 =? 1
                         then UnderLets.Base (x0, ##(0)%expr)%expr_pat
                         else
                          if args0 =? -1
                          then
                           UnderLets.Base ((- x0)%expr, ##(0)%expr)%expr_pat
                          else
                           UnderLets.UnderLet
                             (#(ident.Z_mul_split)%expr @ x @ x0 @ x1)%expr_pat
                             (fun
                                v0 : var
                                       (type.base
                                          (base.type.Z * base.type.Z)%etype)
                              =>
                              UnderLets.Base
                                (#(ident.fst)%expr @ ($v0)%expr,
                                #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                    | None =>
                        UnderLets.UnderLet
                          (#(ident.Z_mul_split)%expr @ x @ x0 @ x1)%expr_pat
                          (fun
                             v0 : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                           UnderLets.Base
                             (#(ident.fst)%expr @ ($v0)%expr,
                             #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                    end
                | ($_)%expr =>
                    UnderLets.UnderLet
                      (#(ident.Z_mul_split)%expr @ x @ x0 @ x1)%expr_pat
                      (fun
                         v1 : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v1)%expr,
                         #(ident.snd)%expr @ ($v1)%expr)%expr_pat)
                | _ =>
                    UnderLets.UnderLet
                      (#(ident.Z_mul_split)%expr @ x @ x0 @ x1)%expr_pat
                      (fun
                         v0 : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v0)%expr,
                         #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                end
            | _ =>
                match x1 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t1 v =>
                          match
                            t1 as t2 return (base.base_interp t2 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v0 : Z => Some v0
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        if args0 =? 0
                        then UnderLets.Base (##(0)%expr, ##(0)%expr)%expr_pat
                        else
                         if args0 =? 1
                         then UnderLets.Base (x0, ##(0)%expr)%expr_pat
                         else
                          if args0 =? -1
                          then
                           UnderLets.Base ((- x0)%expr, ##(0)%expr)%expr_pat
                          else
                           UnderLets.UnderLet
                             (#(ident.Z_mul_split)%expr @ x @ x0 @ x1)%expr_pat
                             (fun
                                v : var
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)
                              =>
                              UnderLets.Base
                                (#(ident.fst)%expr @ ($v)%expr,
                                #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    | None =>
                        UnderLets.UnderLet
                          (#(ident.Z_mul_split)%expr @ x @ x0 @ x1)%expr_pat
                          (fun
                             v : var
                                   (type.base
                                      (base.type.Z * base.type.Z)%etype) =>
                           UnderLets.Base
                             (#(ident.fst)%expr @ ($v)%expr,
                             #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    end
                | ($_)%expr =>
                    UnderLets.UnderLet
                      (#(ident.Z_mul_split)%expr @ x @ x0 @ x1)%expr_pat
                      (fun
                         v0 : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v0)%expr,
                         #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                | _ =>
                    UnderLets.UnderLet
                      (#(ident.Z_mul_split)%expr @ x @ x0 @ x1)%expr_pat
                      (fun
                         v : var
                               (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v)%expr,
                         #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                end
            end
        | None =>
            UnderLets.UnderLet
              (#(ident.Z_mul_split)%expr @ x @ x0 @ x1)%expr_pat
              (fun v : var (type.base (base.type.Z * base.type.Z)%etype) =>
               UnderLets.Base
                 (#(ident.fst)%expr @ ($v)%expr,
                 #(ident.snd)%expr @ ($v)%expr)%expr_pat)
        end
    | ($_)%expr =>
        UnderLets.UnderLet (#(ident.Z_mul_split)%expr @ x @ x0 @ x1)%expr_pat
          (fun v0 : var (type.base (base.type.Z * base.type.Z)%etype) =>
           UnderLets.Base
             (#(ident.fst)%expr @ ($v0)%expr, #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
    | _ =>
        UnderLets.UnderLet (#(ident.Z_mul_split)%expr @ x @ x0 @ x1)%expr_pat
          (fun v : var (type.base (base.type.Z * base.type.Z)%etype) =>
           UnderLets.Base
             (#(ident.fst)%expr @ ($v)%expr, #(ident.snd)%expr @ ($v)%expr)%expr_pat)
    end
| ident.Z_add_get_carry =>
    fun x x0 x1 : defaults.expr (type.base base.type.Z) =>
    match x0 with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            match x1 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 =>
                    if args <? 0
                    then
                     UnderLets.UnderLet
                       (#(ident.Z_sub_get_borrow)%expr @ x @ x1 @
                        ##((- args)%Z)%expr)%expr_pat
                       (fun
                          v : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v)%expr,
                          (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
                    else
                     if args0 <? 0
                     then
                      UnderLets.UnderLet
                        (#(ident.Z_sub_get_borrow)%expr @ x @ x0 @
                         ##((- args0)%Z)%expr)%expr_pat
                        (fun
                           v : var
                                 (type.base (base.type.Z * base.type.Z)%etype)
                         =>
                         UnderLets.Base
                           (#(ident.fst)%expr @ ($v)%expr,
                           (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
                     else
                      if args =? 0
                      then UnderLets.Base (x1, ##(0)%expr)%expr_pat
                      else
                       if args0 =? 0
                       then UnderLets.Base (x0, ##(0)%expr)%expr_pat
                       else
                        UnderLets.UnderLet
                          (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                          (fun
                             v : var
                                   (type.base
                                      (base.type.Z * base.type.Z)%etype) =>
                           UnderLets.Base
                             (#(ident.fst)%expr @ ($v)%expr,
                             #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                | None =>
                    if args <? 0
                    then
                     UnderLets.UnderLet
                       (#(ident.Z_sub_get_borrow)%expr @ x @ x1 @
                        ##((- args)%Z)%expr)%expr_pat
                       (fun
                          v : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v)%expr,
                          (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
                    else
                     if args =? 0
                     then UnderLets.Base (x1, ##(0)%expr)%expr_pat
                     else
                      UnderLets.UnderLet
                        (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                        (fun
                           v : var
                                 (type.base (base.type.Z * base.type.Z)%etype)
                         =>
                         UnderLets.Base
                           (#(ident.fst)%expr @ ($v)%expr,
                           #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                end
            | ($_)%expr =>
                if args <? 0
                then
                 UnderLets.UnderLet
                   (#(ident.Z_sub_get_borrow)%expr @ x @ x1 @
                    ##((- args)%Z)%expr)%expr_pat
                   (fun
                      v0 : var (type.base (base.type.Z * base.type.Z)%etype)
                    =>
                    UnderLets.Base
                      (#(ident.fst)%expr @ ($v0)%expr,
                      (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                else
                 if args =? 0
                 then UnderLets.Base (x1, ##(0)%expr)%expr_pat
                 else
                  UnderLets.UnderLet
                    (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                    (fun
                       v0 : var (type.base (base.type.Z * base.type.Z)%etype)
                     =>
                     UnderLets.Base
                       (#(ident.fst)%expr @ ($v0)%expr,
                       #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
            | @expr.App _ _ _ s _ #(idc0)%expr_pat x2 =>
                match
                  match idc0 with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (defaults.expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v : defaults.expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => defaults.expr (type.base t1))
                          t2 base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (defaults.expr (type.base t2) ->
                                    defaults.expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               UnderLets.UnderLet
                                 (#(ident.Z_sub_get_borrow)%expr @ x @ x0 @
                                  x' v)%expr_pat
                                 (fun
                                    v0 : var
                                           (type.base
                                              (base.type.Z * base.type.Z)%etype)
                                  =>
                                  UnderLets.Base
                                    (#(ident.fst)%expr @ ($v0)%expr,
                                    (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                           end)
                    | (s0 -> d0)%ptype =>
                        fun
                          _ : Compile.value' false s0 ->
                              Compile.value' true d0 =>
                        UnderLets.Base
                          (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                    end (Compile.reflect x2)
                | None =>
                    if args <? 0
                    then
                     UnderLets.UnderLet
                       (#(ident.Z_sub_get_borrow)%expr @ x @ x1 @
                        ##((- args)%Z)%expr)%expr_pat
                       (fun
                          v : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v)%expr,
                          (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
                    else
                     if args =? 0
                     then UnderLets.Base (x1, ##(0)%expr)%expr_pat
                     else
                      UnderLets.UnderLet
                        (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                        (fun
                           v : var
                                 (type.base (base.type.Z * base.type.Z)%etype)
                         =>
                         UnderLets.Base
                           (#(ident.fst)%expr @ ($v)%expr,
                           #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                end
            | @expr.App _ _ _ s _ ($_)%expr _ =>
                if args <? 0
                then
                 UnderLets.UnderLet
                   (#(ident.Z_sub_get_borrow)%expr @ x @ x1 @
                    ##((- args)%Z)%expr)%expr_pat
                   (fun
                      v0 : var (type.base (base.type.Z * base.type.Z)%etype)
                    =>
                    UnderLets.Base
                      (#(ident.fst)%expr @ ($v0)%expr,
                      (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                else
                 if args =? 0
                 then UnderLets.Base (x1, ##(0)%expr)%expr_pat
                 else
                  UnderLets.UnderLet
                    (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                    (fun
                       v0 : var (type.base (base.type.Z * base.type.Z)%etype)
                     =>
                     UnderLets.Base
                       (#(ident.fst)%expr @ ($v0)%expr,
                       #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
            | @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _
              s _ (_ @ _)%expr_pat _ | @expr.App _ _ _ s _
              (@expr.LetIn _ _ _ _ _ _ _) _ =>
                if args <? 0
                then
                 UnderLets.UnderLet
                   (#(ident.Z_sub_get_borrow)%expr @ x @ x1 @
                    ##((- args)%Z)%expr)%expr_pat
                   (fun v : var (type.base (base.type.Z * base.type.Z)%etype)
                    =>
                    UnderLets.Base
                      (#(ident.fst)%expr @ ($v)%expr,
                      (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
                else
                 if args =? 0
                 then UnderLets.Base (x1, ##(0)%expr)%expr_pat
                 else
                  UnderLets.UnderLet
                    (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                    (fun
                       v : var (type.base (base.type.Z * base.type.Z)%etype)
                     =>
                     UnderLets.Base
                       (#(ident.fst)%expr @ ($v)%expr,
                       #(ident.snd)%expr @ ($v)%expr)%expr_pat)
            | _ =>
                if args <? 0
                then
                 UnderLets.UnderLet
                   (#(ident.Z_sub_get_borrow)%expr @ x @ x1 @
                    ##((- args)%Z)%expr)%expr_pat
                   (fun v : var (type.base (base.type.Z * base.type.Z)%etype)
                    =>
                    UnderLets.Base
                      (#(ident.fst)%expr @ ($v)%expr,
                      (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
                else
                 if args =? 0
                 then UnderLets.Base (x1, ##(0)%expr)%expr_pat
                 else
                  UnderLets.UnderLet
                    (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                    (fun
                       v : var (type.base (base.type.Z * base.type.Z)%etype)
                     =>
                     UnderLets.Base
                       (#(ident.fst)%expr @ ($v)%expr,
                       #(ident.snd)%expr @ ($v)%expr)%expr_pat)
            end
        | None =>
            match x1 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args =>
                    if args <? 0
                    then
                     UnderLets.UnderLet
                       (#(ident.Z_sub_get_borrow)%expr @ x @ x0 @
                        ##((- args)%Z)%expr)%expr_pat
                       (fun
                          v : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v)%expr,
                          (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
                    else
                     if args =? 0
                     then UnderLets.Base (x0, ##(0)%expr)%expr_pat
                     else
                      UnderLets.UnderLet
                        (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                        (fun
                           v : var
                                 (type.base (base.type.Z * base.type.Z)%etype)
                         =>
                         UnderLets.Base
                           (#(ident.fst)%expr @ ($v)%expr,
                           #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                | None =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                      (fun
                         v : var
                               (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v)%expr,
                         #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                end
            | ($_)%expr =>
                UnderLets.UnderLet
                  (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                  (fun v0 : var (type.base (base.type.Z * base.type.Z)%etype)
                   =>
                   UnderLets.Base
                     (#(ident.fst)%expr @ ($v0)%expr,
                     #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
            | @expr.App _ _ _ s _ #(idc0)%expr_pat x2 =>
                match
                  match idc0 with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (defaults.expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v : defaults.expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => defaults.expr (type.base t1))
                          t2 base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (defaults.expr (type.base t2) ->
                                    defaults.expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               UnderLets.UnderLet
                                 (#(ident.Z_sub_get_borrow)%expr @ x @ x0 @
                                  x' v)%expr_pat
                                 (fun
                                    v0 : var
                                           (type.base
                                              (base.type.Z * base.type.Z)%etype)
                                  =>
                                  UnderLets.Base
                                    (#(ident.fst)%expr @ ($v0)%expr,
                                    (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                           end)
                    | (s0 -> d0)%ptype =>
                        fun
                          _ : Compile.value' false s0 ->
                              Compile.value' true d0 =>
                        UnderLets.Base
                          (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                    end (Compile.reflect x2)
                | None =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                      (fun
                         v : var
                               (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v)%expr,
                         #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                end
            | @expr.App _ _ _ s _ ($_)%expr _ =>
                UnderLets.UnderLet
                  (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                  (fun v0 : var (type.base (base.type.Z * base.type.Z)%etype)
                   =>
                   UnderLets.Base
                     (#(ident.fst)%expr @ ($v0)%expr,
                     #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
            | @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _
              s _ (_ @ _)%expr_pat _ | @expr.App _ _ _ s _
              (@expr.LetIn _ _ _ _ _ _ _) _ =>
                UnderLets.UnderLet
                  (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                  (fun v : var (type.base (base.type.Z * base.type.Z)%etype)
                   =>
                   UnderLets.Base
                     (#(ident.fst)%expr @ ($v)%expr,
                     #(ident.snd)%expr @ ($v)%expr)%expr_pat)
            | _ =>
                UnderLets.UnderLet
                  (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                  (fun v : var (type.base (base.type.Z * base.type.Z)%etype)
                   =>
                   UnderLets.Base
                     (#(ident.fst)%expr @ ($v)%expr,
                     #(ident.snd)%expr @ ($v)%expr)%expr_pat)
            end
        end
    | ($_)%expr =>
        match x1 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t1 v0 =>
                  match
                    t1 as t2 return (base.base_interp t2 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v1 : Z => Some v1
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v0
              | _ => None
              end
            with
            | Some args =>
                if args <? 0
                then
                 UnderLets.UnderLet
                   (#(ident.Z_sub_get_borrow)%expr @ x @ x0 @
                    ##((- args)%Z)%expr)%expr_pat
                   (fun
                      v0 : var (type.base (base.type.Z * base.type.Z)%etype)
                    =>
                    UnderLets.Base
                      (#(ident.fst)%expr @ ($v0)%expr,
                      (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                else
                 if args =? 0
                 then UnderLets.Base (x0, ##(0)%expr)%expr_pat
                 else
                  UnderLets.UnderLet
                    (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                    (fun
                       v0 : var (type.base (base.type.Z * base.type.Z)%etype)
                     =>
                     UnderLets.Base
                       (#(ident.fst)%expr @ ($v0)%expr,
                       #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
            | None =>
                UnderLets.UnderLet
                  (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                  (fun v0 : var (type.base (base.type.Z * base.type.Z)%etype)
                   =>
                   UnderLets.Base
                     (#(ident.fst)%expr @ ($v0)%expr,
                     #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
            end
        | ($_)%expr =>
            UnderLets.UnderLet
              (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
              (fun v1 : var (type.base (base.type.Z * base.type.Z)%etype) =>
               UnderLets.Base
                 (#(ident.fst)%expr @ ($v1)%expr,
                 #(ident.snd)%expr @ ($v1)%expr)%expr_pat)
        | @expr.App _ _ _ s _ #(idc)%expr_pat x2 =>
            match
              match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end
            with
            | Some _ =>
                match
                  s as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (defaults.expr
                          (type.base (base.type.Z * base.type.Z)%etype)))
                with
                | type.base t2 =>
                    fun v0 : defaults.expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t1 : base.type => defaults.expr (type.base t1)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr
                            (type.base (base.type.Z * base.type.Z)%etype)))
                      (fun
                         a : option
                               (defaults.expr (type.base t2) ->
                                defaults.expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' =>
                           UnderLets.UnderLet
                             (#(ident.Z_sub_get_borrow)%expr @ x @ x0 @ x' v0)%expr_pat
                             (fun
                                v1 : var
                                       (type.base
                                          (base.type.Z * base.type.Z)%etype)
                              =>
                              UnderLets.Base
                                (#(ident.fst)%expr @ ($v1)%expr,
                                (- (#(ident.snd)%expr @ $v1)%expr_pat)%expr)%expr_pat)
                       | None =>
                           UnderLets.Base
                             (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                       end)
                | (s0 -> d0)%ptype =>
                    fun _ : Compile.value' false s0 -> Compile.value' true d0
                    =>
                    UnderLets.Base
                      (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                end (Compile.reflect x2)
            | None =>
                UnderLets.UnderLet
                  (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                  (fun v0 : var (type.base (base.type.Z * base.type.Z)%etype)
                   =>
                   UnderLets.Base
                     (#(ident.fst)%expr @ ($v0)%expr,
                     #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
            end
        | @expr.App _ _ _ s _ ($_)%expr _ =>
            UnderLets.UnderLet
              (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
              (fun v1 : var (type.base (base.type.Z * base.type.Z)%etype) =>
               UnderLets.Base
                 (#(ident.fst)%expr @ ($v1)%expr,
                 #(ident.snd)%expr @ ($v1)%expr)%expr_pat)
        | @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _
          (_ @ _)%expr_pat _ | @expr.App _ _ _ s _
          (@expr.LetIn _ _ _ _ _ _ _) _ =>
            UnderLets.UnderLet
              (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
              (fun v0 : var (type.base (base.type.Z * base.type.Z)%etype) =>
               UnderLets.Base
                 (#(ident.fst)%expr @ ($v0)%expr,
                 #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
        | _ =>
            UnderLets.UnderLet
              (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
              (fun v0 : var (type.base (base.type.Z * base.type.Z)%etype) =>
               UnderLets.Base
                 (#(ident.fst)%expr @ ($v0)%expr,
                 #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
        end
    | @expr.Abs _ _ _ _ _ _ =>
        match x1 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t0 v =>
                  match
                    t0 as t1 return (base.base_interp t1 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v0 : Z => Some v0
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v
              | _ => None
              end
            with
            | Some args =>
                if args <? 0
                then
                 UnderLets.UnderLet
                   (#(ident.Z_sub_get_borrow)%expr @ x @ x0 @
                    ##((- args)%Z)%expr)%expr_pat
                   (fun v : var (type.base (base.type.Z * base.type.Z)%etype)
                    =>
                    UnderLets.Base
                      (#(ident.fst)%expr @ ($v)%expr,
                      (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
                else
                 if args =? 0
                 then UnderLets.Base (x0, ##(0)%expr)%expr_pat
                 else
                  UnderLets.UnderLet
                    (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                    (fun
                       v : var (type.base (base.type.Z * base.type.Z)%etype)
                     =>
                     UnderLets.Base
                       (#(ident.fst)%expr @ ($v)%expr,
                       #(ident.snd)%expr @ ($v)%expr)%expr_pat)
            | None =>
                UnderLets.UnderLet
                  (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                  (fun v : var (type.base (base.type.Z * base.type.Z)%etype)
                   =>
                   UnderLets.Base
                     (#(ident.fst)%expr @ ($v)%expr,
                     #(ident.snd)%expr @ ($v)%expr)%expr_pat)
            end
        | ($_)%expr =>
            UnderLets.UnderLet
              (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
              (fun v0 : var (type.base (base.type.Z * base.type.Z)%etype) =>
               UnderLets.Base
                 (#(ident.fst)%expr @ ($v0)%expr,
                 #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
        | @expr.App _ _ _ s0 _ #(idc)%expr_pat x2 =>
            match
              match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end
            with
            | Some _ =>
                match
                  s0 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (defaults.expr
                          (type.base (base.type.Z * base.type.Z)%etype)))
                with
                | type.base t2 =>
                    fun v : defaults.expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => defaults.expr (type.base t0)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr
                            (type.base (base.type.Z * base.type.Z)%etype)))
                      (fun
                         a : option
                               (defaults.expr (type.base t2) ->
                                defaults.expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' =>
                           UnderLets.UnderLet
                             (#(ident.Z_sub_get_borrow)%expr @ x @ x0 @ x' v)%expr_pat
                             (fun
                                v0 : var
                                       (type.base
                                          (base.type.Z * base.type.Z)%etype)
                              =>
                              UnderLets.Base
                                (#(ident.fst)%expr @ ($v0)%expr,
                                (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                       | None =>
                           UnderLets.Base
                             (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                       end)
                | (s1 -> d1)%ptype =>
                    fun _ : Compile.value' false s1 -> Compile.value' true d1
                    =>
                    UnderLets.Base
                      (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                end (Compile.reflect x2)
            | None =>
                UnderLets.UnderLet
                  (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                  (fun v : var (type.base (base.type.Z * base.type.Z)%etype)
                   =>
                   UnderLets.Base
                     (#(ident.fst)%expr @ ($v)%expr,
                     #(ident.snd)%expr @ ($v)%expr)%expr_pat)
            end
        | @expr.App _ _ _ s0 _ ($_)%expr _ =>
            UnderLets.UnderLet
              (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
              (fun v0 : var (type.base (base.type.Z * base.type.Z)%etype) =>
               UnderLets.Base
                 (#(ident.fst)%expr @ ($v0)%expr,
                 #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
        | @expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0
          _ (_ @ _)%expr_pat _ | @expr.App _ _ _ s0 _
          (@expr.LetIn _ _ _ _ _ _ _) _ =>
            UnderLets.UnderLet
              (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
              (fun v : var (type.base (base.type.Z * base.type.Z)%etype) =>
               UnderLets.Base
                 (#(ident.fst)%expr @ ($v)%expr,
                 #(ident.snd)%expr @ ($v)%expr)%expr_pat)
        | _ =>
            UnderLets.UnderLet
              (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
              (fun v : var (type.base (base.type.Z * base.type.Z)%etype) =>
               UnderLets.Base
                 (#(ident.fst)%expr @ ($v)%expr,
                 #(ident.snd)%expr @ ($v)%expr)%expr_pat)
        end
    | @expr.App _ _ _ s _ #(idc)%expr_pat x2 =>
        match match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end with
        | Some _ =>
            match
              s as t2
              return
                (Compile.value' false t2 ->
                 UnderLets.UnderLets base.type ident var
                   (defaults.expr
                      (type.base (base.type.Z * base.type.Z)%etype)))
            with
            | type.base t2 =>
                fun v : defaults.expr (type.base t2) =>
                base.try_make_transport_cps
                  (fun t0 : base.type => defaults.expr (type.base t0)) t2
                  base.type.Z
                  (UnderLets.UnderLets base.type ident var
                     (defaults.expr
                        (type.base (base.type.Z * base.type.Z)%etype)))
                  (fun
                     a : option
                           (defaults.expr (type.base t2) ->
                            defaults.expr (type.base base.type.Z)) =>
                   match a with
                   | Some x' =>
                       UnderLets.UnderLet
                         (#(ident.Z_sub_get_borrow)%expr @ x @ x1 @ x' v)%expr_pat
                         (fun
                            v0 : var
                                   (type.base
                                      (base.type.Z * base.type.Z)%etype) =>
                          UnderLets.Base
                            (#(ident.fst)%expr @ ($v0)%expr,
                            (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                   | None =>
                       UnderLets.Base
                         (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                   end)
            | (s0 -> d0)%ptype =>
                fun _ : Compile.value' false s0 -> Compile.value' true d0 =>
                UnderLets.Base
                  (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
            end (Compile.reflect x2)
        | None =>
            match x1 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args =>
                    if args <? 0
                    then
                     UnderLets.UnderLet
                       (#(ident.Z_sub_get_borrow)%expr @ x @ x0 @
                        ##((- args)%Z)%expr)%expr_pat
                       (fun
                          v : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v)%expr,
                          (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
                    else
                     if args =? 0
                     then UnderLets.Base (x0, ##(0)%expr)%expr_pat
                     else
                      UnderLets.UnderLet
                        (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                        (fun
                           v : var
                                 (type.base (base.type.Z * base.type.Z)%etype)
                         =>
                         UnderLets.Base
                           (#(ident.fst)%expr @ ($v)%expr,
                           #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                | None =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                      (fun
                         v : var
                               (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v)%expr,
                         #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                end
            | ($_)%expr =>
                UnderLets.UnderLet
                  (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                  (fun v0 : var (type.base (base.type.Z * base.type.Z)%etype)
                   =>
                   UnderLets.Base
                     (#(ident.fst)%expr @ ($v0)%expr,
                     #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
            | @expr.App _ _ _ s0 _ #(idc0)%expr_pat x3 =>
                match
                  match idc0 with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (defaults.expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v : defaults.expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => defaults.expr (type.base t1))
                          t2 base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (defaults.expr (type.base t2) ->
                                    defaults.expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               UnderLets.UnderLet
                                 (#(ident.Z_sub_get_borrow)%expr @ x @ x0 @
                                  x' v)%expr_pat
                                 (fun
                                    v0 : var
                                           (type.base
                                              (base.type.Z * base.type.Z)%etype)
                                  =>
                                  UnderLets.Base
                                    (#(ident.fst)%expr @ ($v0)%expr,
                                    (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                           end)
                    | (s1 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d1 =>
                        UnderLets.Base
                          (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                    end (Compile.reflect x3)
                | None =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                      (fun
                         v : var
                               (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v)%expr,
                         #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                end
            | @expr.App _ _ _ s0 _ ($_)%expr _ =>
                UnderLets.UnderLet
                  (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                  (fun v0 : var (type.base (base.type.Z * base.type.Z)%etype)
                   =>
                   UnderLets.Base
                     (#(ident.fst)%expr @ ($v0)%expr,
                     #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
            | @expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _
              _ s0 _ (_ @ _)%expr_pat _ | @expr.App _ _ _ s0 _
              (@expr.LetIn _ _ _ _ _ _ _) _ =>
                UnderLets.UnderLet
                  (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                  (fun v : var (type.base (base.type.Z * base.type.Z)%etype)
                   =>
                   UnderLets.Base
                     (#(ident.fst)%expr @ ($v)%expr,
                     #(ident.snd)%expr @ ($v)%expr)%expr_pat)
            | _ =>
                UnderLets.UnderLet
                  (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                  (fun v : var (type.base (base.type.Z * base.type.Z)%etype)
                   =>
                   UnderLets.Base
                     (#(ident.fst)%expr @ ($v)%expr,
                     #(ident.snd)%expr @ ($v)%expr)%expr_pat)
            end
        end
    | @expr.App _ _ _ s _ ($_)%expr _ =>
        match x1 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t1 v0 =>
                  match
                    t1 as t2 return (base.base_interp t2 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v1 : Z => Some v1
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v0
              | _ => None
              end
            with
            | Some args =>
                if args <? 0
                then
                 UnderLets.UnderLet
                   (#(ident.Z_sub_get_borrow)%expr @ x @ x0 @
                    ##((- args)%Z)%expr)%expr_pat
                   (fun
                      v0 : var (type.base (base.type.Z * base.type.Z)%etype)
                    =>
                    UnderLets.Base
                      (#(ident.fst)%expr @ ($v0)%expr,
                      (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                else
                 if args =? 0
                 then UnderLets.Base (x0, ##(0)%expr)%expr_pat
                 else
                  UnderLets.UnderLet
                    (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                    (fun
                       v0 : var (type.base (base.type.Z * base.type.Z)%etype)
                     =>
                     UnderLets.Base
                       (#(ident.fst)%expr @ ($v0)%expr,
                       #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
            | None =>
                UnderLets.UnderLet
                  (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                  (fun v0 : var (type.base (base.type.Z * base.type.Z)%etype)
                   =>
                   UnderLets.Base
                     (#(ident.fst)%expr @ ($v0)%expr,
                     #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
            end
        | ($_)%expr =>
            UnderLets.UnderLet
              (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
              (fun v1 : var (type.base (base.type.Z * base.type.Z)%etype) =>
               UnderLets.Base
                 (#(ident.fst)%expr @ ($v1)%expr,
                 #(ident.snd)%expr @ ($v1)%expr)%expr_pat)
        | @expr.App _ _ _ s0 _ #(idc)%expr_pat x3 =>
            match
              match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end
            with
            | Some _ =>
                match
                  s0 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (defaults.expr
                          (type.base (base.type.Z * base.type.Z)%etype)))
                with
                | type.base t2 =>
                    fun v0 : defaults.expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t1 : base.type => defaults.expr (type.base t1)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr
                            (type.base (base.type.Z * base.type.Z)%etype)))
                      (fun
                         a : option
                               (defaults.expr (type.base t2) ->
                                defaults.expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' =>
                           UnderLets.UnderLet
                             (#(ident.Z_sub_get_borrow)%expr @ x @ x0 @ x' v0)%expr_pat
                             (fun
                                v1 : var
                                       (type.base
                                          (base.type.Z * base.type.Z)%etype)
                              =>
                              UnderLets.Base
                                (#(ident.fst)%expr @ ($v1)%expr,
                                (- (#(ident.snd)%expr @ $v1)%expr_pat)%expr)%expr_pat)
                       | None =>
                           UnderLets.Base
                             (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                       end)
                | (s1 -> d1)%ptype =>
                    fun _ : Compile.value' false s1 -> Compile.value' true d1
                    =>
                    UnderLets.Base
                      (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                end (Compile.reflect x3)
            | None =>
                UnderLets.UnderLet
                  (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                  (fun v0 : var (type.base (base.type.Z * base.type.Z)%etype)
                   =>
                   UnderLets.Base
                     (#(ident.fst)%expr @ ($v0)%expr,
                     #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
            end
        | @expr.App _ _ _ s0 _ ($_)%expr _ =>
            UnderLets.UnderLet
              (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
              (fun v1 : var (type.base (base.type.Z * base.type.Z)%etype) =>
               UnderLets.Base
                 (#(ident.fst)%expr @ ($v1)%expr,
                 #(ident.snd)%expr @ ($v1)%expr)%expr_pat)
        | @expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0
          _ (_ @ _)%expr_pat _ | @expr.App _ _ _ s0 _
          (@expr.LetIn _ _ _ _ _ _ _) _ =>
            UnderLets.UnderLet
              (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
              (fun v0 : var (type.base (base.type.Z * base.type.Z)%etype) =>
               UnderLets.Base
                 (#(ident.fst)%expr @ ($v0)%expr,
                 #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
        | _ =>
            UnderLets.UnderLet
              (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
              (fun v0 : var (type.base (base.type.Z * base.type.Z)%etype) =>
               UnderLets.Base
                 (#(ident.fst)%expr @ ($v0)%expr,
                 #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
        end
    | @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ =>
        match x1 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t0 v =>
                  match
                    t0 as t1 return (base.base_interp t1 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v0 : Z => Some v0
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v
              | _ => None
              end
            with
            | Some args =>
                if args <? 0
                then
                 UnderLets.UnderLet
                   (#(ident.Z_sub_get_borrow)%expr @ x @ x0 @
                    ##((- args)%Z)%expr)%expr_pat
                   (fun v : var (type.base (base.type.Z * base.type.Z)%etype)
                    =>
                    UnderLets.Base
                      (#(ident.fst)%expr @ ($v)%expr,
                      (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
                else
                 if args =? 0
                 then UnderLets.Base (x0, ##(0)%expr)%expr_pat
                 else
                  UnderLets.UnderLet
                    (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                    (fun
                       v : var (type.base (base.type.Z * base.type.Z)%etype)
                     =>
                     UnderLets.Base
                       (#(ident.fst)%expr @ ($v)%expr,
                       #(ident.snd)%expr @ ($v)%expr)%expr_pat)
            | None =>
                UnderLets.UnderLet
                  (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                  (fun v : var (type.base (base.type.Z * base.type.Z)%etype)
                   =>
                   UnderLets.Base
                     (#(ident.fst)%expr @ ($v)%expr,
                     #(ident.snd)%expr @ ($v)%expr)%expr_pat)
            end
        | ($_)%expr =>
            UnderLets.UnderLet
              (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
              (fun v0 : var (type.base (base.type.Z * base.type.Z)%etype) =>
               UnderLets.Base
                 (#(ident.fst)%expr @ ($v0)%expr,
                 #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
        | @expr.App _ _ _ s1 _ #(idc)%expr_pat x3 =>
            match
              match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end
            with
            | Some _ =>
                match
                  s1 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (defaults.expr
                          (type.base (base.type.Z * base.type.Z)%etype)))
                with
                | type.base t2 =>
                    fun v : defaults.expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => defaults.expr (type.base t0)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr
                            (type.base (base.type.Z * base.type.Z)%etype)))
                      (fun
                         a : option
                               (defaults.expr (type.base t2) ->
                                defaults.expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' =>
                           UnderLets.UnderLet
                             (#(ident.Z_sub_get_borrow)%expr @ x @ x0 @ x' v)%expr_pat
                             (fun
                                v0 : var
                                       (type.base
                                          (base.type.Z * base.type.Z)%etype)
                              =>
                              UnderLets.Base
                                (#(ident.fst)%expr @ ($v0)%expr,
                                (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                       | None =>
                           UnderLets.Base
                             (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                       end)
                | (s2 -> d2)%ptype =>
                    fun _ : Compile.value' false s2 -> Compile.value' true d2
                    =>
                    UnderLets.Base
                      (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                end (Compile.reflect x3)
            | None =>
                UnderLets.UnderLet
                  (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                  (fun v : var (type.base (base.type.Z * base.type.Z)%etype)
                   =>
                   UnderLets.Base
                     (#(ident.fst)%expr @ ($v)%expr,
                     #(ident.snd)%expr @ ($v)%expr)%expr_pat)
            end
        | @expr.App _ _ _ s1 _ ($_)%expr _ =>
            UnderLets.UnderLet
              (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
              (fun v0 : var (type.base (base.type.Z * base.type.Z)%etype) =>
               UnderLets.Base
                 (#(ident.fst)%expr @ ($v0)%expr,
                 #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
        | @expr.App _ _ _ s1 _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s1
          _ (_ @ _)%expr_pat _ | @expr.App _ _ _ s1 _
          (@expr.LetIn _ _ _ _ _ _ _) _ =>
            UnderLets.UnderLet
              (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
              (fun v : var (type.base (base.type.Z * base.type.Z)%etype) =>
               UnderLets.Base
                 (#(ident.fst)%expr @ ($v)%expr,
                 #(ident.snd)%expr @ ($v)%expr)%expr_pat)
        | _ =>
            UnderLets.UnderLet
              (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
              (fun v : var (type.base (base.type.Z * base.type.Z)%etype) =>
               UnderLets.Base
                 (#(ident.fst)%expr @ ($v)%expr,
                 #(ident.snd)%expr @ ($v)%expr)%expr_pat)
        end
    | @expr.App _ _ _ s _ (_ @ _)%expr_pat _ =>
        match x1 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t0 v =>
                  match
                    t0 as t1 return (base.base_interp t1 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v0 : Z => Some v0
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v
              | _ => None
              end
            with
            | Some args =>
                if args <? 0
                then
                 UnderLets.UnderLet
                   (#(ident.Z_sub_get_borrow)%expr @ x @ x0 @
                    ##((- args)%Z)%expr)%expr_pat
                   (fun v : var (type.base (base.type.Z * base.type.Z)%etype)
                    =>
                    UnderLets.Base
                      (#(ident.fst)%expr @ ($v)%expr,
                      (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
                else
                 if args =? 0
                 then UnderLets.Base (x0, ##(0)%expr)%expr_pat
                 else
                  UnderLets.UnderLet
                    (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                    (fun
                       v : var (type.base (base.type.Z * base.type.Z)%etype)
                     =>
                     UnderLets.Base
                       (#(ident.fst)%expr @ ($v)%expr,
                       #(ident.snd)%expr @ ($v)%expr)%expr_pat)
            | None =>
                UnderLets.UnderLet
                  (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                  (fun v : var (type.base (base.type.Z * base.type.Z)%etype)
                   =>
                   UnderLets.Base
                     (#(ident.fst)%expr @ ($v)%expr,
                     #(ident.snd)%expr @ ($v)%expr)%expr_pat)
            end
        | ($_)%expr =>
            UnderLets.UnderLet
              (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
              (fun v0 : var (type.base (base.type.Z * base.type.Z)%etype) =>
               UnderLets.Base
                 (#(ident.fst)%expr @ ($v0)%expr,
                 #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
        | @expr.App _ _ _ s1 _ #(idc)%expr_pat x4 =>
            match
              match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end
            with
            | Some _ =>
                match
                  s1 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (defaults.expr
                          (type.base (base.type.Z * base.type.Z)%etype)))
                with
                | type.base t2 =>
                    fun v : defaults.expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => defaults.expr (type.base t0)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr
                            (type.base (base.type.Z * base.type.Z)%etype)))
                      (fun
                         a : option
                               (defaults.expr (type.base t2) ->
                                defaults.expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' =>
                           UnderLets.UnderLet
                             (#(ident.Z_sub_get_borrow)%expr @ x @ x0 @ x' v)%expr_pat
                             (fun
                                v0 : var
                                       (type.base
                                          (base.type.Z * base.type.Z)%etype)
                              =>
                              UnderLets.Base
                                (#(ident.fst)%expr @ ($v0)%expr,
                                (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                       | None =>
                           UnderLets.Base
                             (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                       end)
                | (s2 -> d2)%ptype =>
                    fun _ : Compile.value' false s2 -> Compile.value' true d2
                    =>
                    UnderLets.Base
                      (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                end (Compile.reflect x4)
            | None =>
                UnderLets.UnderLet
                  (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                  (fun v : var (type.base (base.type.Z * base.type.Z)%etype)
                   =>
                   UnderLets.Base
                     (#(ident.fst)%expr @ ($v)%expr,
                     #(ident.snd)%expr @ ($v)%expr)%expr_pat)
            end
        | @expr.App _ _ _ s1 _ ($_)%expr _ =>
            UnderLets.UnderLet
              (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
              (fun v0 : var (type.base (base.type.Z * base.type.Z)%etype) =>
               UnderLets.Base
                 (#(ident.fst)%expr @ ($v0)%expr,
                 #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
        | @expr.App _ _ _ s1 _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s1
          _ (_ @ _)%expr_pat _ | @expr.App _ _ _ s1 _
          (@expr.LetIn _ _ _ _ _ _ _) _ =>
            UnderLets.UnderLet
              (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
              (fun v : var (type.base (base.type.Z * base.type.Z)%etype) =>
               UnderLets.Base
                 (#(ident.fst)%expr @ ($v)%expr,
                 #(ident.snd)%expr @ ($v)%expr)%expr_pat)
        | _ =>
            UnderLets.UnderLet
              (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
              (fun v : var (type.base (base.type.Z * base.type.Z)%etype) =>
               UnderLets.Base
                 (#(ident.fst)%expr @ ($v)%expr,
                 #(ident.snd)%expr @ ($v)%expr)%expr_pat)
        end
    | @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
        match x1 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t0 v =>
                  match
                    t0 as t1 return (base.base_interp t1 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v0 : Z => Some v0
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v
              | _ => None
              end
            with
            | Some args =>
                if args <? 0
                then
                 UnderLets.UnderLet
                   (#(ident.Z_sub_get_borrow)%expr @ x @ x0 @
                    ##((- args)%Z)%expr)%expr_pat
                   (fun v : var (type.base (base.type.Z * base.type.Z)%etype)
                    =>
                    UnderLets.Base
                      (#(ident.fst)%expr @ ($v)%expr,
                      (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
                else
                 if args =? 0
                 then UnderLets.Base (x0, ##(0)%expr)%expr_pat
                 else
                  UnderLets.UnderLet
                    (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                    (fun
                       v : var (type.base (base.type.Z * base.type.Z)%etype)
                     =>
                     UnderLets.Base
                       (#(ident.fst)%expr @ ($v)%expr,
                       #(ident.snd)%expr @ ($v)%expr)%expr_pat)
            | None =>
                UnderLets.UnderLet
                  (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                  (fun v : var (type.base (base.type.Z * base.type.Z)%etype)
                   =>
                   UnderLets.Base
                     (#(ident.fst)%expr @ ($v)%expr,
                     #(ident.snd)%expr @ ($v)%expr)%expr_pat)
            end
        | ($_)%expr =>
            UnderLets.UnderLet
              (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
              (fun v0 : var (type.base (base.type.Z * base.type.Z)%etype) =>
               UnderLets.Base
                 (#(ident.fst)%expr @ ($v0)%expr,
                 #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
        | @expr.App _ _ _ s0 _ #(idc)%expr_pat x4 =>
            match
              match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end
            with
            | Some _ =>
                match
                  s0 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (defaults.expr
                          (type.base (base.type.Z * base.type.Z)%etype)))
                with
                | type.base t2 =>
                    fun v : defaults.expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => defaults.expr (type.base t0)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr
                            (type.base (base.type.Z * base.type.Z)%etype)))
                      (fun
                         a : option
                               (defaults.expr (type.base t2) ->
                                defaults.expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' =>
                           UnderLets.UnderLet
                             (#(ident.Z_sub_get_borrow)%expr @ x @ x0 @ x' v)%expr_pat
                             (fun
                                v0 : var
                                       (type.base
                                          (base.type.Z * base.type.Z)%etype)
                              =>
                              UnderLets.Base
                                (#(ident.fst)%expr @ ($v0)%expr,
                                (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                       | None =>
                           UnderLets.Base
                             (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                       end)
                | (s1 -> d1)%ptype =>
                    fun _ : Compile.value' false s1 -> Compile.value' true d1
                    =>
                    UnderLets.Base
                      (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                end (Compile.reflect x4)
            | None =>
                UnderLets.UnderLet
                  (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                  (fun v : var (type.base (base.type.Z * base.type.Z)%etype)
                   =>
                   UnderLets.Base
                     (#(ident.fst)%expr @ ($v)%expr,
                     #(ident.snd)%expr @ ($v)%expr)%expr_pat)
            end
        | @expr.App _ _ _ s0 _ ($_)%expr _ =>
            UnderLets.UnderLet
              (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
              (fun v0 : var (type.base (base.type.Z * base.type.Z)%etype) =>
               UnderLets.Base
                 (#(ident.fst)%expr @ ($v0)%expr,
                 #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
        | @expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0
          _ (_ @ _)%expr_pat _ | @expr.App _ _ _ s0 _
          (@expr.LetIn _ _ _ _ _ _ _) _ =>
            UnderLets.UnderLet
              (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
              (fun v : var (type.base (base.type.Z * base.type.Z)%etype) =>
               UnderLets.Base
                 (#(ident.fst)%expr @ ($v)%expr,
                 #(ident.snd)%expr @ ($v)%expr)%expr_pat)
        | _ =>
            UnderLets.UnderLet
              (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
              (fun v : var (type.base (base.type.Z * base.type.Z)%etype) =>
               UnderLets.Base
                 (#(ident.fst)%expr @ ($v)%expr,
                 #(ident.snd)%expr @ ($v)%expr)%expr_pat)
        end
    | @expr.LetIn _ _ _ _ _ _ _ =>
        match x1 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t0 v =>
                  match
                    t0 as t1 return (base.base_interp t1 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v0 : Z => Some v0
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v
              | _ => None
              end
            with
            | Some args =>
                if args <? 0
                then
                 UnderLets.UnderLet
                   (#(ident.Z_sub_get_borrow)%expr @ x @ x0 @
                    ##((- args)%Z)%expr)%expr_pat
                   (fun v : var (type.base (base.type.Z * base.type.Z)%etype)
                    =>
                    UnderLets.Base
                      (#(ident.fst)%expr @ ($v)%expr,
                      (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
                else
                 if args =? 0
                 then UnderLets.Base (x0, ##(0)%expr)%expr_pat
                 else
                  UnderLets.UnderLet
                    (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                    (fun
                       v : var (type.base (base.type.Z * base.type.Z)%etype)
                     =>
                     UnderLets.Base
                       (#(ident.fst)%expr @ ($v)%expr,
                       #(ident.snd)%expr @ ($v)%expr)%expr_pat)
            | None =>
                UnderLets.UnderLet
                  (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                  (fun v : var (type.base (base.type.Z * base.type.Z)%etype)
                   =>
                   UnderLets.Base
                     (#(ident.fst)%expr @ ($v)%expr,
                     #(ident.snd)%expr @ ($v)%expr)%expr_pat)
            end
        | ($_)%expr =>
            UnderLets.UnderLet
              (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
              (fun v0 : var (type.base (base.type.Z * base.type.Z)%etype) =>
               UnderLets.Base
                 (#(ident.fst)%expr @ ($v0)%expr,
                 #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
        | @expr.App _ _ _ s _ #(idc)%expr_pat x3 =>
            match
              match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end
            with
            | Some _ =>
                match
                  s as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (defaults.expr
                          (type.base (base.type.Z * base.type.Z)%etype)))
                with
                | type.base t2 =>
                    fun v : defaults.expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => defaults.expr (type.base t0)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr
                            (type.base (base.type.Z * base.type.Z)%etype)))
                      (fun
                         a : option
                               (defaults.expr (type.base t2) ->
                                defaults.expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' =>
                           UnderLets.UnderLet
                             (#(ident.Z_sub_get_borrow)%expr @ x @ x0 @ x' v)%expr_pat
                             (fun
                                v0 : var
                                       (type.base
                                          (base.type.Z * base.type.Z)%etype)
                              =>
                              UnderLets.Base
                                (#(ident.fst)%expr @ ($v0)%expr,
                                (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                       | None =>
                           UnderLets.Base
                             (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                       end)
                | (s0 -> d0)%ptype =>
                    fun _ : Compile.value' false s0 -> Compile.value' true d0
                    =>
                    UnderLets.Base
                      (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                end (Compile.reflect x3)
            | None =>
                UnderLets.UnderLet
                  (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                  (fun v : var (type.base (base.type.Z * base.type.Z)%etype)
                   =>
                   UnderLets.Base
                     (#(ident.fst)%expr @ ($v)%expr,
                     #(ident.snd)%expr @ ($v)%expr)%expr_pat)
            end
        | @expr.App _ _ _ s _ ($_)%expr _ =>
            UnderLets.UnderLet
              (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
              (fun v0 : var (type.base (base.type.Z * base.type.Z)%etype) =>
               UnderLets.Base
                 (#(ident.fst)%expr @ ($v0)%expr,
                 #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
        | @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _
          (_ @ _)%expr_pat _ | @expr.App _ _ _ s _
          (@expr.LetIn _ _ _ _ _ _ _) _ =>
            UnderLets.UnderLet
              (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
              (fun v : var (type.base (base.type.Z * base.type.Z)%etype) =>
               UnderLets.Base
                 (#(ident.fst)%expr @ ($v)%expr,
                 #(ident.snd)%expr @ ($v)%expr)%expr_pat)
        | _ =>
            UnderLets.UnderLet
              (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
              (fun v : var (type.base (base.type.Z * base.type.Z)%etype) =>
               UnderLets.Base
                 (#(ident.fst)%expr @ ($v)%expr,
                 #(ident.snd)%expr @ ($v)%expr)%expr_pat)
        end
    end
| ident.Z_add_with_carry =>
    fun x x0 x1 : defaults.expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            if args =? 0
            then UnderLets.Base (x0 + x1)%expr
            else
             UnderLets.UnderLet
               (#(ident.Z_add_with_carry)%expr @ x @ x0 @ x1)%expr_pat
               (fun v : var (type.base base.type.Z) =>
                UnderLets.Base ($v)%expr)
        | None =>
            UnderLets.UnderLet
              (#(ident.Z_add_with_carry)%expr @ x @ x0 @ x1)%expr_pat
              (fun v : var (type.base base.type.Z) =>
               UnderLets.Base ($v)%expr)
        end
    | ($_)%expr =>
        UnderLets.UnderLet
          (#(ident.Z_add_with_carry)%expr @ x @ x0 @ x1)%expr_pat
          (fun v0 : var (type.base base.type.Z) => UnderLets.Base ($v0)%expr)
    | _ =>
        UnderLets.UnderLet
          (#(ident.Z_add_with_carry)%expr @ x @ x0 @ x1)%expr_pat
          (fun v : var (type.base base.type.Z) => UnderLets.Base ($v)%expr)
    end
| ident.Z_add_with_get_carry =>
    fun x x0 x1 x2 : defaults.expr (type.base base.type.Z) =>
    match x0 with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            match x1 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 =>
                    match x2 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args1 =>
                            if
                             (args0 <=? 0) && (args <=? 0) &&
                             (args0 + args <? 0)
                            then
                             UnderLets.UnderLet
                               (#(ident.Z_sub_with_get_borrow)%expr @ x @
                                ##((- args)%Z)%expr @ x2 @
                                ##((- args0)%Z)%expr)%expr_pat
                               (fun
                                  v : var
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)
                                =>
                                UnderLets.Base
                                  (#(ident.fst)%expr @ ($v)%expr,
                                  (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
                            else
                             if
                              (args1 <=? 0) && (args <=? 0) &&
                              (args1 + args <? 0)
                             then
                              UnderLets.UnderLet
                                (#(ident.Z_sub_with_get_borrow)%expr @ x @
                                 ##((- args)%Z)%expr @ x1 @
                                 ##((- args1)%Z)%expr)%expr_pat
                                (fun
                                   v : var
                                         (type.base
                                            (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v)%expr,
                                   (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
                             else
                              match x with
                              | #(idc2)%expr_pat =>
                                  match
                                    match idc2 with
                                    | @ident.Literal t3 v =>
                                        match
                                          t3 as t4
                                          return
                                            (base.base_interp t4 -> option Z)
                                        with
                                        | base.type.unit =>
                                            fun _ : unit => None
                                        | base.type.Z =>
                                            fun v0 : Z => Some v0
                                        | base.type.bool =>
                                            fun _ : bool => None
                                        | base.type.nat =>
                                            fun _ : nat => None
                                        end v
                                    | _ => None
                                    end
                                  with
                                  | Some _ =>
                                      if (args =? 0) && (args0 =? 0)
                                      then
                                       UnderLets.Base
                                         (x2, ##(0)%expr)%expr_pat
                                      else
                                       if (args =? 0) && (args1 =? 0)
                                       then
                                        UnderLets.Base
                                          (x1, ##(0)%expr)%expr_pat
                                       else
                                        if args =? 0
                                        then
                                         UnderLets.UnderLet
                                           (#(ident.Z_add_get_carry)%expr @ x @
                                            x1 @ x2)%expr_pat
                                           (fun
                                              v : var
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)
                                            =>
                                            UnderLets.Base
                                              (#(ident.fst)%expr @ ($v)%expr,
                                              #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                                        else
                                         if (args0 =? 0) && (args1 =? 0)
                                         then
                                          UnderLets.UnderLet
                                            (#(ident.Z_add_with_get_carry)%expr @
                                             x @ x0 @ ##(args0)%expr @
                                             ##(args1)%expr)%expr_pat
                                            (fun
                                               v : var
                                                     (type.base
                                                        (base.type.Z *
                                                         base.type.Z)%etype)
                                             =>
                                             UnderLets.Base
                                               (#(ident.fst)%expr @ ($v)%expr,
                                               ##(0)%expr)%expr_pat)
                                         else
                                          UnderLets.UnderLet
                                            (#(ident.Z_add_with_get_carry)%expr @
                                             x @ x0 @ x1 @ x2)%expr_pat
                                            (fun
                                               v : var
                                                     (type.base
                                                        (base.type.Z *
                                                         base.type.Z)%etype)
                                             =>
                                             UnderLets.Base
                                               (#(ident.fst)%expr @ ($v)%expr,
                                               #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                                  | None =>
                                      if args =? 0
                                      then
                                       UnderLets.UnderLet
                                         (#(ident.Z_add_get_carry)%expr @ x @
                                          x1 @ x2)%expr_pat
                                         (fun
                                            v : var
                                                  (type.base
                                                     (base.type.Z *
                                                      base.type.Z)%etype) =>
                                          UnderLets.Base
                                            (#(ident.fst)%expr @ ($v)%expr,
                                            #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                                      else
                                       if (args0 =? 0) && (args1 =? 0)
                                       then
                                        UnderLets.UnderLet
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ ##(args0)%expr @
                                           ##(args1)%expr)%expr_pat
                                          (fun
                                             v : var
                                                   (type.base
                                                      (base.type.Z *
                                                       base.type.Z)%etype) =>
                                           UnderLets.Base
                                             (#(ident.fst)%expr @ ($v)%expr,
                                             ##(0)%expr)%expr_pat)
                                       else
                                        UnderLets.UnderLet
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ x1 @ x2)%expr_pat
                                          (fun
                                             v : var
                                                   (type.base
                                                      (base.type.Z *
                                                       base.type.Z)%etype) =>
                                           UnderLets.Base
                                             (#(ident.fst)%expr @ ($v)%expr,
                                             #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                                  end
                              | ($_)%expr =>
                                  if args =? 0
                                  then
                                   UnderLets.UnderLet
                                     (#(ident.Z_add_get_carry)%expr @ x @ x1 @
                                      x2)%expr_pat
                                     (fun
                                        v0 : var
                                               (type.base
                                                  (base.type.Z * base.type.Z)%etype)
                                      =>
                                      UnderLets.Base
                                        (#(ident.fst)%expr @ ($v0)%expr,
                                        #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                                  else
                                   if (args0 =? 0) && (args1 =? 0)
                                   then
                                    UnderLets.UnderLet
                                      (#(ident.Z_add_with_get_carry)%expr @ x @
                                       x0 @ ##(args0)%expr @ ##(args1)%expr)%expr_pat
                                      (fun
                                         v0 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v0)%expr,
                                         ##(0)%expr)%expr_pat)
                                   else
                                    UnderLets.UnderLet
                                      (#(ident.Z_add_with_get_carry)%expr @ x @
                                       x0 @ x1 @ x2)%expr_pat
                                      (fun
                                         v0 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v0)%expr,
                                         #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                              | _ =>
                                  if args =? 0
                                  then
                                   UnderLets.UnderLet
                                     (#(ident.Z_add_get_carry)%expr @ x @ x1 @
                                      x2)%expr_pat
                                     (fun
                                        v : var
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)
                                      =>
                                      UnderLets.Base
                                        (#(ident.fst)%expr @ ($v)%expr,
                                        #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                                  else
                                   if (args0 =? 0) && (args1 =? 0)
                                   then
                                    UnderLets.UnderLet
                                      (#(ident.Z_add_with_get_carry)%expr @ x @
                                       x0 @ ##(args0)%expr @ ##(args1)%expr)%expr_pat
                                      (fun
                                         v : var
                                               (type.base
                                                  (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v)%expr,
                                         ##(0)%expr)%expr_pat)
                                   else
                                    UnderLets.UnderLet
                                      (#(ident.Z_add_with_get_carry)%expr @ x @
                                       x0 @ x1 @ x2)%expr_pat
                                      (fun
                                         v : var
                                               (type.base
                                                  (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v)%expr,
                                         #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                              end
                        | None =>
                            if
                             (args0 <=? 0) && (args <=? 0) &&
                             (args0 + args <? 0)
                            then
                             UnderLets.UnderLet
                               (#(ident.Z_sub_with_get_borrow)%expr @ x @
                                ##((- args)%Z)%expr @ x2 @
                                ##((- args0)%Z)%expr)%expr_pat
                               (fun
                                  v : var
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)
                                =>
                                UnderLets.Base
                                  (#(ident.fst)%expr @ ($v)%expr,
                                  (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
                            else
                             match x with
                             | #(idc2)%expr_pat =>
                                 match
                                   match idc2 with
                                   | @ident.Literal t3 v =>
                                       match
                                         t3 as t4
                                         return
                                           (base.base_interp t4 -> option Z)
                                       with
                                       | base.type.unit =>
                                           fun _ : unit => None
                                       | base.type.Z => fun v0 : Z => Some v0
                                       | base.type.bool =>
                                           fun _ : bool => None
                                       | base.type.nat => fun _ : nat => None
                                       end v
                                   | _ => None
                                   end
                                 with
                                 | Some _ =>
                                     if (args =? 0) && (args0 =? 0)
                                     then
                                      UnderLets.Base
                                        (x2, ##(0)%expr)%expr_pat
                                     else
                                      if args =? 0
                                      then
                                       UnderLets.UnderLet
                                         (#(ident.Z_add_get_carry)%expr @ x @
                                          x1 @ x2)%expr_pat
                                         (fun
                                            v : var
                                                  (type.base
                                                     (base.type.Z *
                                                      base.type.Z)%etype) =>
                                          UnderLets.Base
                                            (#(ident.fst)%expr @ ($v)%expr,
                                            #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                                      else
                                       UnderLets.UnderLet
                                         (#(ident.Z_add_with_get_carry)%expr @
                                          x @ x0 @ x1 @ x2)%expr_pat
                                         (fun
                                            v : var
                                                  (type.base
                                                     (base.type.Z *
                                                      base.type.Z)%etype) =>
                                          UnderLets.Base
                                            (#(ident.fst)%expr @ ($v)%expr,
                                            #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                                 | None =>
                                     if args =? 0
                                     then
                                      UnderLets.UnderLet
                                        (#(ident.Z_add_get_carry)%expr @ x @
                                         x1 @ x2)%expr_pat
                                        (fun
                                           v : var
                                                 (type.base
                                                    (base.type.Z *
                                                     base.type.Z)%etype) =>
                                         UnderLets.Base
                                           (#(ident.fst)%expr @ ($v)%expr,
                                           #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                                     else
                                      UnderLets.UnderLet
                                        (#(ident.Z_add_with_get_carry)%expr @
                                         x @ x0 @ x1 @ x2)%expr_pat
                                        (fun
                                           v : var
                                                 (type.base
                                                    (base.type.Z *
                                                     base.type.Z)%etype) =>
                                         UnderLets.Base
                                           (#(ident.fst)%expr @ ($v)%expr,
                                           #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                                 end
                             | ($_)%expr =>
                                 if args =? 0
                                 then
                                  UnderLets.UnderLet
                                    (#(ident.Z_add_get_carry)%expr @ x @ x1 @
                                     x2)%expr_pat
                                    (fun
                                       v0 : var
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)
                                     =>
                                     UnderLets.Base
                                       (#(ident.fst)%expr @ ($v0)%expr,
                                       #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                                 else
                                  UnderLets.UnderLet
                                    (#(ident.Z_add_with_get_carry)%expr @ x @
                                     x0 @ x1 @ x2)%expr_pat
                                    (fun
                                       v0 : var
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)
                                     =>
                                     UnderLets.Base
                                       (#(ident.fst)%expr @ ($v0)%expr,
                                       #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                             | _ =>
                                 if args =? 0
                                 then
                                  UnderLets.UnderLet
                                    (#(ident.Z_add_get_carry)%expr @ x @ x1 @
                                     x2)%expr_pat
                                    (fun
                                       v : var
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)
                                     =>
                                     UnderLets.Base
                                       (#(ident.fst)%expr @ ($v)%expr,
                                       #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                                 else
                                  UnderLets.UnderLet
                                    (#(ident.Z_add_with_get_carry)%expr @ x @
                                     x0 @ x1 @ x2)%expr_pat
                                    (fun
                                       v : var
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)
                                     =>
                                     UnderLets.Base
                                       (#(ident.fst)%expr @ ($v)%expr,
                                       #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                             end
                        end
                    | ($_)%expr =>
                        if
                         (args0 <=? 0) && (args <=? 0) && (args0 + args <? 0)
                        then
                         UnderLets.UnderLet
                           (#(ident.Z_sub_with_get_borrow)%expr @ x @
                            ##((- args)%Z)%expr @ x2 @ ##((- args0)%Z)%expr)%expr_pat
                           (fun
                              v0 : var
                                     (type.base
                                        (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v0)%expr,
                              (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                        else
                         match x with
                         | #(idc1)%expr_pat =>
                             match
                               match idc1 with
                               | @ident.Literal t3 v0 =>
                                   match
                                     t3 as t4
                                     return (base.base_interp t4 -> option Z)
                                   with
                                   | base.type.unit => fun _ : unit => None
                                   | base.type.Z => fun v1 : Z => Some v1
                                   | base.type.bool => fun _ : bool => None
                                   | base.type.nat => fun _ : nat => None
                                   end v0
                               | _ => None
                               end
                             with
                             | Some _ =>
                                 if (args =? 0) && (args0 =? 0)
                                 then
                                  UnderLets.Base (x2, ##(0)%expr)%expr_pat
                                 else
                                  if args =? 0
                                  then
                                   UnderLets.UnderLet
                                     (#(ident.Z_add_get_carry)%expr @ x @ x1 @
                                      x2)%expr_pat
                                     (fun
                                        v0 : var
                                               (type.base
                                                  (base.type.Z * base.type.Z)%etype)
                                      =>
                                      UnderLets.Base
                                        (#(ident.fst)%expr @ ($v0)%expr,
                                        #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                                  else
                                   UnderLets.UnderLet
                                     (#(ident.Z_add_with_get_carry)%expr @ x @
                                      x0 @ x1 @ x2)%expr_pat
                                     (fun
                                        v0 : var
                                               (type.base
                                                  (base.type.Z * base.type.Z)%etype)
                                      =>
                                      UnderLets.Base
                                        (#(ident.fst)%expr @ ($v0)%expr,
                                        #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                             | None =>
                                 if args =? 0
                                 then
                                  UnderLets.UnderLet
                                    (#(ident.Z_add_get_carry)%expr @ x @ x1 @
                                     x2)%expr_pat
                                    (fun
                                       v0 : var
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)
                                     =>
                                     UnderLets.Base
                                       (#(ident.fst)%expr @ ($v0)%expr,
                                       #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                                 else
                                  UnderLets.UnderLet
                                    (#(ident.Z_add_with_get_carry)%expr @ x @
                                     x0 @ x1 @ x2)%expr_pat
                                    (fun
                                       v0 : var
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)
                                     =>
                                     UnderLets.Base
                                       (#(ident.fst)%expr @ ($v0)%expr,
                                       #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                             end
                         | ($_)%expr =>
                             if args =? 0
                             then
                              UnderLets.UnderLet
                                (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                                (fun
                                   v1 : var
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v1)%expr,
                                   #(ident.snd)%expr @ ($v1)%expr)%expr_pat)
                             else
                              UnderLets.UnderLet
                                (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                 x1 @ x2)%expr_pat
                                (fun
                                   v1 : var
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v1)%expr,
                                   #(ident.snd)%expr @ ($v1)%expr)%expr_pat)
                         | _ =>
                             if args =? 0
                             then
                              UnderLets.UnderLet
                                (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                                (fun
                                   v0 : var
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v0)%expr,
                                   #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                             else
                              UnderLets.UnderLet
                                (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                 x1 @ x2)%expr_pat
                                (fun
                                   v0 : var
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v0)%expr,
                                   #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                         end
                    | @expr.App _ _ _ s _ #(idc1)%expr_pat x3 =>
                        match
                          match idc1 with
                          | ident.Z_opp => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match
                              s as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (defaults.expr
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)))
                            with
                            | type.base t2 =>
                                fun v : defaults.expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t3 : base.type =>
                                   defaults.expr (type.base t3)) t2
                                  base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (defaults.expr
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)))
                                  (fun
                                     a : option
                                           (defaults.expr (type.base t2) ->
                                            defaults.expr
                                              (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       if args =? 0
                                       then
                                        UnderLets.UnderLet
                                          (#(ident.Z_sub_get_borrow)%expr @ x @
                                           x1 @ x' v)%expr_pat
                                          (fun
                                             v0 : var
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)
                                           =>
                                           UnderLets.Base
                                             (#(ident.fst)%expr @ ($v0)%expr,
                                             (-
                                              (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                       else
                                        match
                                          s as t3
                                          return
                                            (Compile.value' false t3 ->
                                             UnderLets.UnderLets base.type
                                               ident var
                                               (defaults.expr
                                                  (type.base
                                                     (base.type.Z *
                                                      base.type.Z)%etype)))
                                        with
                                        | type.base t3 =>
                                            fun
                                              v0 : defaults.expr
                                                     (type.base t3) =>
                                            base.try_make_transport_cps
                                              (fun t4 : base.type =>
                                               defaults.expr (type.base t4))
                                              t3 base.type.Z
                                              (UnderLets.UnderLets base.type
                                                 ident var
                                                 (defaults.expr
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)))
                                              (fun
                                                 a0 : option
                                                        (defaults.expr
                                                           (type.base t3) ->
                                                         defaults.expr
                                                           (type.base
                                                              base.type.Z))
                                               =>
                                               match a0 with
                                               | Some x'0 =>
                                                   if args <? 0
                                                   then
                                                    UnderLets.UnderLet
                                                      (#(ident.Z_sub_with_get_borrow)%expr @
                                                       x @
                                                       ##((- args)%Z)%expr @
                                                       x1 @ x'0 v0)%expr_pat
                                                      (fun
                                                         v1 : var
                                                                (type.base
                                                                   (base.type.Z *
                                                                    base.type.Z)%etype)
                                                       =>
                                                       UnderLets.Base
                                                         (#(ident.fst)%expr @
                                                          ($v1)%expr,
                                                         (-
                                                          (#(ident.snd)%expr @
                                                           $v1)%expr_pat)%expr)%expr_pat)
                                                   else
                                                    if
                                                     (args0 <=? 0) &&
                                                     (args <=? 0) &&
                                                     (args0 + args <? 0)
                                                    then
                                                     UnderLets.UnderLet
                                                       (#(ident.Z_sub_with_get_borrow)%expr @
                                                        x @
                                                        ##((- args)%Z)%expr @
                                                        x2 @
                                                        ##((- args0)%Z)%expr)%expr_pat
                                                       (fun
                                                          v1 : var
                                                                 (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                        =>
                                                        UnderLets.Base
                                                          (#(ident.fst)%expr @
                                                           ($v1)%expr,
                                                          (-
                                                           (#(ident.snd)%expr @
                                                            $v1)%expr_pat)%expr)%expr_pat)
                                                    else
                                                     match x with
                                                     | #(idc2)%expr_pat =>
                                                         match
                                                           match idc2 with
                                                           | @ident.Literal
                                                             t5 v1 =>
                                                               match
                                                                 t5 as t6
                                                                 return
                                                                   (base.base_interp
                                                                    t6 ->
                                                                    option Z)
                                                               with
                                                               | base.type.unit =>
                                                                   fun
                                                                    _ : unit
                                                                   => None
                                                               | base.type.Z =>
                                                                   fun v2 : Z
                                                                   => 
                                                                   Some v2
                                                               | base.type.bool =>
                                                                   fun
                                                                    _ : bool
                                                                   => None
                                                               | base.type.nat =>
                                                                   fun
                                                                    _ : nat
                                                                   => None
                                                               end v1
                                                           | _ => None
                                                           end
                                                         with
                                                         | Some _ =>
                                                             if
                                                              (args =? 0) &&
                                                              (args0 =? 0)
                                                             then
                                                              UnderLets.Base
                                                                (x2,
                                                                ##(0)%expr)%expr_pat
                                                             else
                                                              if args =? 0
                                                              then
                                                               UnderLets.UnderLet
                                                                 (#(ident.Z_add_get_carry)%expr @
                                                                  x @ x1 @ x2)%expr_pat
                                                                 (fun
                                                                    v1 : 
                                                                    var
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                                  =>
                                                                  UnderLets.Base
                                                                    (
                                                                    #
                                                                    (ident.fst)%expr @
                                                                    ($v1)%expr,
                                                                    #
                                                                    (ident.snd)%expr @
                                                                    ($v1)%expr)%expr_pat)
                                                              else
                                                               UnderLets.UnderLet
                                                                 (#(ident.Z_add_with_get_carry)%expr @
                                                                  x @ x0 @ x1 @
                                                                  x2)%expr_pat
                                                                 (fun
                                                                    v1 : 
                                                                    var
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                                  =>
                                                                  UnderLets.Base
                                                                    (
                                                                    #
                                                                    (ident.fst)%expr @
                                                                    ($v1)%expr,
                                                                    #
                                                                    (ident.snd)%expr @
                                                                    ($v1)%expr)%expr_pat)
                                                         | None =>
                                                             if args =? 0
                                                             then
                                                              UnderLets.UnderLet
                                                                (#(ident.Z_add_get_carry)%expr @
                                                                 x @ x1 @ x2)%expr_pat
                                                                (fun
                                                                   v1 : 
                                                                    var
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                                 =>
                                                                 UnderLets.Base
                                                                   (#
                                                                    (ident.fst)%expr @
                                                                    ($v1)%expr,
                                                                   #(ident.snd)%expr @
                                                                   ($v1)%expr)%expr_pat)
                                                             else
                                                              UnderLets.UnderLet
                                                                (#(ident.Z_add_with_get_carry)%expr @
                                                                 x @ x0 @ x1 @
                                                                 x2)%expr_pat
                                                                (fun
                                                                   v1 : 
                                                                    var
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                                 =>
                                                                 UnderLets.Base
                                                                   (#
                                                                    (ident.fst)%expr @
                                                                    ($v1)%expr,
                                                                   #(ident.snd)%expr @
                                                                   ($v1)%expr)%expr_pat)
                                                         end
                                                     | ($_)%expr =>
                                                         if args =? 0
                                                         then
                                                          UnderLets.UnderLet
                                                            (#(ident.Z_add_get_carry)%expr @
                                                             x @ x1 @ x2)%expr_pat
                                                            (fun
                                                               v2 : var
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                             =>
                                                             UnderLets.Base
                                                               (#(ident.fst)%expr @
                                                                ($v2)%expr,
                                                               #(ident.snd)%expr @
                                                               ($v2)%expr)%expr_pat)
                                                         else
                                                          UnderLets.UnderLet
                                                            (#(ident.Z_add_with_get_carry)%expr @
                                                             x @ x0 @ x1 @ x2)%expr_pat
                                                            (fun
                                                               v2 : var
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                             =>
                                                             UnderLets.Base
                                                               (#(ident.fst)%expr @
                                                                ($v2)%expr,
                                                               #(ident.snd)%expr @
                                                               ($v2)%expr)%expr_pat)
                                                     | _ =>
                                                         if args =? 0
                                                         then
                                                          UnderLets.UnderLet
                                                            (#(ident.Z_add_get_carry)%expr @
                                                             x @ x1 @ x2)%expr_pat
                                                            (fun
                                                               v1 : var
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                             =>
                                                             UnderLets.Base
                                                               (#(ident.fst)%expr @
                                                                ($v1)%expr,
                                                               #(ident.snd)%expr @
                                                               ($v1)%expr)%expr_pat)
                                                         else
                                                          UnderLets.UnderLet
                                                            (#(ident.Z_add_with_get_carry)%expr @
                                                             x @ x0 @ x1 @ x2)%expr_pat
                                                            (fun
                                                               v1 : var
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                             =>
                                                             UnderLets.Base
                                                               (#(ident.fst)%expr @
                                                                ($v1)%expr,
                                                               #(ident.snd)%expr @
                                                               ($v1)%expr)%expr_pat)
                                                     end
                                               | None =>
                                                   UnderLets.Base
                                                     (#(ident.Z_add_with_get_carry)%expr @
                                                      x @ x0 @ x1 @ x2)%expr_pat
                                               end)
                                        | (s0 -> d0)%ptype =>
                                            fun
                                              _ : Compile.value' false s0 ->
                                                  Compile.value' true d0 =>
                                            UnderLets.Base
                                              (#(ident.Z_add_with_get_carry)%expr @
                                               x @ x0 @ x1 @ x2)%expr_pat
                                        end (Compile.reflect x3)
                                   | None =>
                                       UnderLets.Base
                                         (#(ident.Z_add_with_get_carry)%expr @
                                          x @ x0 @ x1 @ x2)%expr_pat
                                   end)
                            | (s0 -> d0)%ptype =>
                                fun
                                  _ : Compile.value' false s0 ->
                                      Compile.value' true d0 =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry)%expr @ x @
                                   x0 @ x1 @ x2)%expr_pat
                            end (Compile.reflect x3)
                        | None =>
                            if
                             (args0 <=? 0) && (args <=? 0) &&
                             (args0 + args <? 0)
                            then
                             UnderLets.UnderLet
                               (#(ident.Z_sub_with_get_borrow)%expr @ x @
                                ##((- args)%Z)%expr @ x2 @
                                ##((- args0)%Z)%expr)%expr_pat
                               (fun
                                  v : var
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)
                                =>
                                UnderLets.Base
                                  (#(ident.fst)%expr @ ($v)%expr,
                                  (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
                            else
                             match x with
                             | #(idc2)%expr_pat =>
                                 match
                                   match idc2 with
                                   | @ident.Literal t3 v =>
                                       match
                                         t3 as t4
                                         return
                                           (base.base_interp t4 -> option Z)
                                       with
                                       | base.type.unit =>
                                           fun _ : unit => None
                                       | base.type.Z => fun v0 : Z => Some v0
                                       | base.type.bool =>
                                           fun _ : bool => None
                                       | base.type.nat => fun _ : nat => None
                                       end v
                                   | _ => None
                                   end
                                 with
                                 | Some _ =>
                                     if (args =? 0) && (args0 =? 0)
                                     then
                                      UnderLets.Base
                                        (x2, ##(0)%expr)%expr_pat
                                     else
                                      if args =? 0
                                      then
                                       UnderLets.UnderLet
                                         (#(ident.Z_add_get_carry)%expr @ x @
                                          x1 @ x2)%expr_pat
                                         (fun
                                            v : var
                                                  (type.base
                                                     (base.type.Z *
                                                      base.type.Z)%etype) =>
                                          UnderLets.Base
                                            (#(ident.fst)%expr @ ($v)%expr,
                                            #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                                      else
                                       UnderLets.UnderLet
                                         (#(ident.Z_add_with_get_carry)%expr @
                                          x @ x0 @ x1 @ x2)%expr_pat
                                         (fun
                                            v : var
                                                  (type.base
                                                     (base.type.Z *
                                                      base.type.Z)%etype) =>
                                          UnderLets.Base
                                            (#(ident.fst)%expr @ ($v)%expr,
                                            #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                                 | None =>
                                     if args =? 0
                                     then
                                      UnderLets.UnderLet
                                        (#(ident.Z_add_get_carry)%expr @ x @
                                         x1 @ x2)%expr_pat
                                        (fun
                                           v : var
                                                 (type.base
                                                    (base.type.Z *
                                                     base.type.Z)%etype) =>
                                         UnderLets.Base
                                           (#(ident.fst)%expr @ ($v)%expr,
                                           #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                                     else
                                      UnderLets.UnderLet
                                        (#(ident.Z_add_with_get_carry)%expr @
                                         x @ x0 @ x1 @ x2)%expr_pat
                                        (fun
                                           v : var
                                                 (type.base
                                                    (base.type.Z *
                                                     base.type.Z)%etype) =>
                                         UnderLets.Base
                                           (#(ident.fst)%expr @ ($v)%expr,
                                           #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                                 end
                             | ($_)%expr =>
                                 if args =? 0
                                 then
                                  UnderLets.UnderLet
                                    (#(ident.Z_add_get_carry)%expr @ x @ x1 @
                                     x2)%expr_pat
                                    (fun
                                       v0 : var
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)
                                     =>
                                     UnderLets.Base
                                       (#(ident.fst)%expr @ ($v0)%expr,
                                       #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                                 else
                                  UnderLets.UnderLet
                                    (#(ident.Z_add_with_get_carry)%expr @ x @
                                     x0 @ x1 @ x2)%expr_pat
                                    (fun
                                       v0 : var
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)
                                     =>
                                     UnderLets.Base
                                       (#(ident.fst)%expr @ ($v0)%expr,
                                       #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                             | _ =>
                                 if args =? 0
                                 then
                                  UnderLets.UnderLet
                                    (#(ident.Z_add_get_carry)%expr @ x @ x1 @
                                     x2)%expr_pat
                                    (fun
                                       v : var
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)
                                     =>
                                     UnderLets.Base
                                       (#(ident.fst)%expr @ ($v)%expr,
                                       #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                                 else
                                  UnderLets.UnderLet
                                    (#(ident.Z_add_with_get_carry)%expr @ x @
                                     x0 @ x1 @ x2)%expr_pat
                                    (fun
                                       v : var
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)
                                     =>
                                     UnderLets.Base
                                       (#(ident.fst)%expr @ ($v)%expr,
                                       #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                             end
                        end
                    | @expr.App _ _ _ s _ ($_)%expr _ =>
                        if
                         (args0 <=? 0) && (args <=? 0) && (args0 + args <? 0)
                        then
                         UnderLets.UnderLet
                           (#(ident.Z_sub_with_get_borrow)%expr @ x @
                            ##((- args)%Z)%expr @ x2 @ ##((- args0)%Z)%expr)%expr_pat
                           (fun
                              v0 : var
                                     (type.base
                                        (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v0)%expr,
                              (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                        else
                         match x with
                         | #(idc1)%expr_pat =>
                             match
                               match idc1 with
                               | @ident.Literal t3 v0 =>
                                   match
                                     t3 as t4
                                     return (base.base_interp t4 -> option Z)
                                   with
                                   | base.type.unit => fun _ : unit => None
                                   | base.type.Z => fun v1 : Z => Some v1
                                   | base.type.bool => fun _ : bool => None
                                   | base.type.nat => fun _ : nat => None
                                   end v0
                               | _ => None
                               end
                             with
                             | Some _ =>
                                 if (args =? 0) && (args0 =? 0)
                                 then
                                  UnderLets.Base (x2, ##(0)%expr)%expr_pat
                                 else
                                  if args =? 0
                                  then
                                   UnderLets.UnderLet
                                     (#(ident.Z_add_get_carry)%expr @ x @ x1 @
                                      x2)%expr_pat
                                     (fun
                                        v0 : var
                                               (type.base
                                                  (base.type.Z * base.type.Z)%etype)
                                      =>
                                      UnderLets.Base
                                        (#(ident.fst)%expr @ ($v0)%expr,
                                        #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                                  else
                                   UnderLets.UnderLet
                                     (#(ident.Z_add_with_get_carry)%expr @ x @
                                      x0 @ x1 @ x2)%expr_pat
                                     (fun
                                        v0 : var
                                               (type.base
                                                  (base.type.Z * base.type.Z)%etype)
                                      =>
                                      UnderLets.Base
                                        (#(ident.fst)%expr @ ($v0)%expr,
                                        #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                             | None =>
                                 if args =? 0
                                 then
                                  UnderLets.UnderLet
                                    (#(ident.Z_add_get_carry)%expr @ x @ x1 @
                                     x2)%expr_pat
                                    (fun
                                       v0 : var
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)
                                     =>
                                     UnderLets.Base
                                       (#(ident.fst)%expr @ ($v0)%expr,
                                       #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                                 else
                                  UnderLets.UnderLet
                                    (#(ident.Z_add_with_get_carry)%expr @ x @
                                     x0 @ x1 @ x2)%expr_pat
                                    (fun
                                       v0 : var
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)
                                     =>
                                     UnderLets.Base
                                       (#(ident.fst)%expr @ ($v0)%expr,
                                       #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                             end
                         | ($_)%expr =>
                             if args =? 0
                             then
                              UnderLets.UnderLet
                                (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                                (fun
                                   v1 : var
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v1)%expr,
                                   #(ident.snd)%expr @ ($v1)%expr)%expr_pat)
                             else
                              UnderLets.UnderLet
                                (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                 x1 @ x2)%expr_pat
                                (fun
                                   v1 : var
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v1)%expr,
                                   #(ident.snd)%expr @ ($v1)%expr)%expr_pat)
                         | _ =>
                             if args =? 0
                             then
                              UnderLets.UnderLet
                                (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                                (fun
                                   v0 : var
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v0)%expr,
                                   #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                             else
                              UnderLets.UnderLet
                                (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                 x1 @ x2)%expr_pat
                                (fun
                                   v0 : var
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v0)%expr,
                                   #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                         end
                    | @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ |
                      @expr.App _ _ _ s _ (_ @ _)%expr_pat _ | @expr.App _ _
                      _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
                        if
                         (args0 <=? 0) && (args <=? 0) && (args0 + args <? 0)
                        then
                         UnderLets.UnderLet
                           (#(ident.Z_sub_with_get_borrow)%expr @ x @
                            ##((- args)%Z)%expr @ x2 @ ##((- args0)%Z)%expr)%expr_pat
                           (fun
                              v : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v)%expr,
                              (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
                        else
                         match x with
                         | #(idc1)%expr_pat =>
                             match
                               match idc1 with
                               | @ident.Literal t2 v =>
                                   match
                                     t2 as t3
                                     return (base.base_interp t3 -> option Z)
                                   with
                                   | base.type.unit => fun _ : unit => None
                                   | base.type.Z => fun v0 : Z => Some v0
                                   | base.type.bool => fun _ : bool => None
                                   | base.type.nat => fun _ : nat => None
                                   end v
                               | _ => None
                               end
                             with
                             | Some _ =>
                                 if (args =? 0) && (args0 =? 0)
                                 then
                                  UnderLets.Base (x2, ##(0)%expr)%expr_pat
                                 else
                                  if args =? 0
                                  then
                                   UnderLets.UnderLet
                                     (#(ident.Z_add_get_carry)%expr @ x @ x1 @
                                      x2)%expr_pat
                                     (fun
                                        v : var
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)
                                      =>
                                      UnderLets.Base
                                        (#(ident.fst)%expr @ ($v)%expr,
                                        #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                                  else
                                   UnderLets.UnderLet
                                     (#(ident.Z_add_with_get_carry)%expr @ x @
                                      x0 @ x1 @ x2)%expr_pat
                                     (fun
                                        v : var
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)
                                      =>
                                      UnderLets.Base
                                        (#(ident.fst)%expr @ ($v)%expr,
                                        #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                             | None =>
                                 if args =? 0
                                 then
                                  UnderLets.UnderLet
                                    (#(ident.Z_add_get_carry)%expr @ x @ x1 @
                                     x2)%expr_pat
                                    (fun
                                       v : var
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)
                                     =>
                                     UnderLets.Base
                                       (#(ident.fst)%expr @ ($v)%expr,
                                       #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                                 else
                                  UnderLets.UnderLet
                                    (#(ident.Z_add_with_get_carry)%expr @ x @
                                     x0 @ x1 @ x2)%expr_pat
                                    (fun
                                       v : var
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)
                                     =>
                                     UnderLets.Base
                                       (#(ident.fst)%expr @ ($v)%expr,
                                       #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                             end
                         | ($_)%expr =>
                             if args =? 0
                             then
                              UnderLets.UnderLet
                                (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                                (fun
                                   v0 : var
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v0)%expr,
                                   #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                             else
                              UnderLets.UnderLet
                                (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                 x1 @ x2)%expr_pat
                                (fun
                                   v0 : var
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v0)%expr,
                                   #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                         | _ =>
                             if args =? 0
                             then
                              UnderLets.UnderLet
                                (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                                (fun
                                   v : var
                                         (type.base
                                            (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v)%expr,
                                   #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                             else
                              UnderLets.UnderLet
                                (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                 x1 @ x2)%expr_pat
                                (fun
                                   v : var
                                         (type.base
                                            (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v)%expr,
                                   #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                         end
                    | _ =>
                        if
                         (args0 <=? 0) && (args <=? 0) && (args0 + args <? 0)
                        then
                         UnderLets.UnderLet
                           (#(ident.Z_sub_with_get_borrow)%expr @ x @
                            ##((- args)%Z)%expr @ x2 @ ##((- args0)%Z)%expr)%expr_pat
                           (fun
                              v : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v)%expr,
                              (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
                        else
                         match x with
                         | #(idc1)%expr_pat =>
                             match
                               match idc1 with
                               | @ident.Literal t2 v =>
                                   match
                                     t2 as t3
                                     return (base.base_interp t3 -> option Z)
                                   with
                                   | base.type.unit => fun _ : unit => None
                                   | base.type.Z => fun v0 : Z => Some v0
                                   | base.type.bool => fun _ : bool => None
                                   | base.type.nat => fun _ : nat => None
                                   end v
                               | _ => None
                               end
                             with
                             | Some _ =>
                                 if (args =? 0) && (args0 =? 0)
                                 then
                                  UnderLets.Base (x2, ##(0)%expr)%expr_pat
                                 else
                                  if args =? 0
                                  then
                                   UnderLets.UnderLet
                                     (#(ident.Z_add_get_carry)%expr @ x @ x1 @
                                      x2)%expr_pat
                                     (fun
                                        v : var
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)
                                      =>
                                      UnderLets.Base
                                        (#(ident.fst)%expr @ ($v)%expr,
                                        #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                                  else
                                   UnderLets.UnderLet
                                     (#(ident.Z_add_with_get_carry)%expr @ x @
                                      x0 @ x1 @ x2)%expr_pat
                                     (fun
                                        v : var
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)
                                      =>
                                      UnderLets.Base
                                        (#(ident.fst)%expr @ ($v)%expr,
                                        #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                             | None =>
                                 if args =? 0
                                 then
                                  UnderLets.UnderLet
                                    (#(ident.Z_add_get_carry)%expr @ x @ x1 @
                                     x2)%expr_pat
                                    (fun
                                       v : var
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)
                                     =>
                                     UnderLets.Base
                                       (#(ident.fst)%expr @ ($v)%expr,
                                       #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                                 else
                                  UnderLets.UnderLet
                                    (#(ident.Z_add_with_get_carry)%expr @ x @
                                     x0 @ x1 @ x2)%expr_pat
                                    (fun
                                       v : var
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)
                                     =>
                                     UnderLets.Base
                                       (#(ident.fst)%expr @ ($v)%expr,
                                       #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                             end
                         | ($_)%expr =>
                             if args =? 0
                             then
                              UnderLets.UnderLet
                                (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                                (fun
                                   v0 : var
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v0)%expr,
                                   #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                             else
                              UnderLets.UnderLet
                                (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                 x1 @ x2)%expr_pat
                                (fun
                                   v0 : var
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v0)%expr,
                                   #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                         | _ =>
                             if args =? 0
                             then
                              UnderLets.UnderLet
                                (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                                (fun
                                   v : var
                                         (type.base
                                            (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v)%expr,
                                   #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                             else
                              UnderLets.UnderLet
                                (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                 x1 @ x2)%expr_pat
                                (fun
                                   v : var
                                         (type.base
                                            (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v)%expr,
                                   #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                         end
                    end
                | None =>
                    match x2 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args0 =>
                            if
                             (args0 <=? 0) && (args <=? 0) &&
                             (args0 + args <? 0)
                            then
                             UnderLets.UnderLet
                               (#(ident.Z_sub_with_get_borrow)%expr @ x @
                                ##((- args)%Z)%expr @ x1 @
                                ##((- args0)%Z)%expr)%expr_pat
                               (fun
                                  v : var
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)
                                =>
                                UnderLets.Base
                                  (#(ident.fst)%expr @ ($v)%expr,
                                  (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
                            else
                             match x with
                             | #(idc2)%expr_pat =>
                                 match
                                   match idc2 with
                                   | @ident.Literal t3 v =>
                                       match
                                         t3 as t4
                                         return
                                           (base.base_interp t4 -> option Z)
                                       with
                                       | base.type.unit =>
                                           fun _ : unit => None
                                       | base.type.Z => fun v0 : Z => Some v0
                                       | base.type.bool =>
                                           fun _ : bool => None
                                       | base.type.nat => fun _ : nat => None
                                       end v
                                   | _ => None
                                   end
                                 with
                                 | Some _ =>
                                     if (args =? 0) && (args0 =? 0)
                                     then
                                      UnderLets.Base
                                        (x1, ##(0)%expr)%expr_pat
                                     else
                                      if args =? 0
                                      then
                                       UnderLets.UnderLet
                                         (#(ident.Z_add_get_carry)%expr @ x @
                                          x1 @ x2)%expr_pat
                                         (fun
                                            v : var
                                                  (type.base
                                                     (base.type.Z *
                                                      base.type.Z)%etype) =>
                                          UnderLets.Base
                                            (#(ident.fst)%expr @ ($v)%expr,
                                            #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                                      else
                                       UnderLets.UnderLet
                                         (#(ident.Z_add_with_get_carry)%expr @
                                          x @ x0 @ x1 @ x2)%expr_pat
                                         (fun
                                            v : var
                                                  (type.base
                                                     (base.type.Z *
                                                      base.type.Z)%etype) =>
                                          UnderLets.Base
                                            (#(ident.fst)%expr @ ($v)%expr,
                                            #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                                 | None =>
                                     if args =? 0
                                     then
                                      UnderLets.UnderLet
                                        (#(ident.Z_add_get_carry)%expr @ x @
                                         x1 @ x2)%expr_pat
                                        (fun
                                           v : var
                                                 (type.base
                                                    (base.type.Z *
                                                     base.type.Z)%etype) =>
                                         UnderLets.Base
                                           (#(ident.fst)%expr @ ($v)%expr,
                                           #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                                     else
                                      UnderLets.UnderLet
                                        (#(ident.Z_add_with_get_carry)%expr @
                                         x @ x0 @ x1 @ x2)%expr_pat
                                        (fun
                                           v : var
                                                 (type.base
                                                    (base.type.Z *
                                                     base.type.Z)%etype) =>
                                         UnderLets.Base
                                           (#(ident.fst)%expr @ ($v)%expr,
                                           #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                                 end
                             | ($_)%expr =>
                                 if args =? 0
                                 then
                                  UnderLets.UnderLet
                                    (#(ident.Z_add_get_carry)%expr @ x @ x1 @
                                     x2)%expr_pat
                                    (fun
                                       v0 : var
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)
                                     =>
                                     UnderLets.Base
                                       (#(ident.fst)%expr @ ($v0)%expr,
                                       #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                                 else
                                  UnderLets.UnderLet
                                    (#(ident.Z_add_with_get_carry)%expr @ x @
                                     x0 @ x1 @ x2)%expr_pat
                                    (fun
                                       v0 : var
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)
                                     =>
                                     UnderLets.Base
                                       (#(ident.fst)%expr @ ($v0)%expr,
                                       #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                             | _ =>
                                 if args =? 0
                                 then
                                  UnderLets.UnderLet
                                    (#(ident.Z_add_get_carry)%expr @ x @ x1 @
                                     x2)%expr_pat
                                    (fun
                                       v : var
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)
                                     =>
                                     UnderLets.Base
                                       (#(ident.fst)%expr @ ($v)%expr,
                                       #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                                 else
                                  UnderLets.UnderLet
                                    (#(ident.Z_add_with_get_carry)%expr @ x @
                                     x0 @ x1 @ x2)%expr_pat
                                    (fun
                                       v : var
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)
                                     =>
                                     UnderLets.Base
                                       (#(ident.fst)%expr @ ($v)%expr,
                                       #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                             end
                        | None =>
                            if args =? 0
                            then
                             UnderLets.UnderLet
                               (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                               (fun
                                  v : var
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)
                                =>
                                UnderLets.Base
                                  (#(ident.fst)%expr @ ($v)%expr,
                                  #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                            else
                             UnderLets.UnderLet
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                               (fun
                                  v : var
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)
                                =>
                                UnderLets.Base
                                  (#(ident.fst)%expr @ ($v)%expr,
                                  #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                        end
                    | ($_)%expr =>
                        if args =? 0
                        then
                         UnderLets.UnderLet
                           (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                           (fun
                              v0 : var
                                     (type.base
                                        (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v0)%expr,
                              #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                        else
                         UnderLets.UnderLet
                           (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                            x2)%expr_pat
                           (fun
                              v0 : var
                                     (type.base
                                        (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v0)%expr,
                              #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                    | @expr.App _ _ _ s _ #(idc1)%expr_pat x3 =>
                        match
                          match idc1 with
                          | ident.Z_opp => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match
                              s as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (defaults.expr
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)))
                            with
                            | type.base t2 =>
                                fun v : defaults.expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t3 : base.type =>
                                   defaults.expr (type.base t3)) t2
                                  base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (defaults.expr
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)))
                                  (fun
                                     a : option
                                           (defaults.expr (type.base t2) ->
                                            defaults.expr
                                              (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       if args =? 0
                                       then
                                        UnderLets.UnderLet
                                          (#(ident.Z_sub_get_borrow)%expr @ x @
                                           x1 @ x' v)%expr_pat
                                          (fun
                                             v0 : var
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)
                                           =>
                                           UnderLets.Base
                                             (#(ident.fst)%expr @ ($v0)%expr,
                                             (-
                                              (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                       else
                                        match
                                          s as t3
                                          return
                                            (Compile.value' false t3 ->
                                             UnderLets.UnderLets base.type
                                               ident var
                                               (defaults.expr
                                                  (type.base
                                                     (base.type.Z *
                                                      base.type.Z)%etype)))
                                        with
                                        | type.base t3 =>
                                            fun
                                              v0 : defaults.expr
                                                     (type.base t3) =>
                                            base.try_make_transport_cps
                                              (fun t4 : base.type =>
                                               defaults.expr (type.base t4))
                                              t3 base.type.Z
                                              (UnderLets.UnderLets base.type
                                                 ident var
                                                 (defaults.expr
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)))
                                              (fun
                                                 a0 : option
                                                        (defaults.expr
                                                           (type.base t3) ->
                                                         defaults.expr
                                                           (type.base
                                                              base.type.Z))
                                               =>
                                               match a0 with
                                               | Some x'0 =>
                                                   if args <? 0
                                                   then
                                                    UnderLets.UnderLet
                                                      (#(ident.Z_sub_with_get_borrow)%expr @
                                                       x @
                                                       ##((- args)%Z)%expr @
                                                       x1 @ x'0 v0)%expr_pat
                                                      (fun
                                                         v1 : var
                                                                (type.base
                                                                   (base.type.Z *
                                                                    base.type.Z)%etype)
                                                       =>
                                                       UnderLets.Base
                                                         (#(ident.fst)%expr @
                                                          ($v1)%expr,
                                                         (-
                                                          (#(ident.snd)%expr @
                                                           $v1)%expr_pat)%expr)%expr_pat)
                                                   else
                                                    if args =? 0
                                                    then
                                                     UnderLets.UnderLet
                                                       (#(ident.Z_add_get_carry)%expr @
                                                        x @ x1 @ x2)%expr_pat
                                                       (fun
                                                          v1 : var
                                                                 (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                        =>
                                                        UnderLets.Base
                                                          (#(ident.fst)%expr @
                                                           ($v1)%expr,
                                                          #(ident.snd)%expr @
                                                          ($v1)%expr)%expr_pat)
                                                    else
                                                     UnderLets.UnderLet
                                                       (#(ident.Z_add_with_get_carry)%expr @
                                                        x @ x0 @ x1 @ x2)%expr_pat
                                                       (fun
                                                          v1 : var
                                                                 (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                        =>
                                                        UnderLets.Base
                                                          (#(ident.fst)%expr @
                                                           ($v1)%expr,
                                                          #(ident.snd)%expr @
                                                          ($v1)%expr)%expr_pat)
                                               | None =>
                                                   UnderLets.Base
                                                     (#(ident.Z_add_with_get_carry)%expr @
                                                      x @ x0 @ x1 @ x2)%expr_pat
                                               end)
                                        | (s0 -> d0)%ptype =>
                                            fun
                                              _ : Compile.value' false s0 ->
                                                  Compile.value' true d0 =>
                                            UnderLets.Base
                                              (#(ident.Z_add_with_get_carry)%expr @
                                               x @ x0 @ x1 @ x2)%expr_pat
                                        end (Compile.reflect x3)
                                   | None =>
                                       UnderLets.Base
                                         (#(ident.Z_add_with_get_carry)%expr @
                                          x @ x0 @ x1 @ x2)%expr_pat
                                   end)
                            | (s0 -> d0)%ptype =>
                                fun
                                  _ : Compile.value' false s0 ->
                                      Compile.value' true d0 =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry)%expr @ x @
                                   x0 @ x1 @ x2)%expr_pat
                            end (Compile.reflect x3)
                        | None =>
                            if args =? 0
                            then
                             UnderLets.UnderLet
                               (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                               (fun
                                  v : var
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)
                                =>
                                UnderLets.Base
                                  (#(ident.fst)%expr @ ($v)%expr,
                                  #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                            else
                             UnderLets.UnderLet
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                               (fun
                                  v : var
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)
                                =>
                                UnderLets.Base
                                  (#(ident.fst)%expr @ ($v)%expr,
                                  #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                        end
                    | @expr.App _ _ _ s _ ($_)%expr _ =>
                        if args =? 0
                        then
                         UnderLets.UnderLet
                           (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                           (fun
                              v0 : var
                                     (type.base
                                        (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v0)%expr,
                              #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                        else
                         UnderLets.UnderLet
                           (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                            x2)%expr_pat
                           (fun
                              v0 : var
                                     (type.base
                                        (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v0)%expr,
                              #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                    | @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ |
                      @expr.App _ _ _ s _ (_ @ _)%expr_pat _ | @expr.App _ _
                      _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
                        if args =? 0
                        then
                         UnderLets.UnderLet
                           (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                           (fun
                              v : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v)%expr,
                              #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                        else
                         UnderLets.UnderLet
                           (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                            x2)%expr_pat
                           (fun
                              v : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v)%expr,
                              #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    | _ =>
                        if args =? 0
                        then
                         UnderLets.UnderLet
                           (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                           (fun
                              v : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v)%expr,
                              #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                        else
                         UnderLets.UnderLet
                           (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                            x2)%expr_pat
                           (fun
                              v : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v)%expr,
                              #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    end
                end
            | ($_)%expr =>
                match x2 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t2 v0 =>
                          match
                            t2 as t3 return (base.base_interp t3 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v1 : Z => Some v1
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v0
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        if
                         (args0 <=? 0) && (args <=? 0) && (args0 + args <? 0)
                        then
                         UnderLets.UnderLet
                           (#(ident.Z_sub_with_get_borrow)%expr @ x @
                            ##((- args)%Z)%expr @ x1 @ ##((- args0)%Z)%expr)%expr_pat
                           (fun
                              v0 : var
                                     (type.base
                                        (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v0)%expr,
                              (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                        else
                         match x with
                         | #(idc1)%expr_pat =>
                             match
                               match idc1 with
                               | @ident.Literal t3 v0 =>
                                   match
                                     t3 as t4
                                     return (base.base_interp t4 -> option Z)
                                   with
                                   | base.type.unit => fun _ : unit => None
                                   | base.type.Z => fun v1 : Z => Some v1
                                   | base.type.bool => fun _ : bool => None
                                   | base.type.nat => fun _ : nat => None
                                   end v0
                               | _ => None
                               end
                             with
                             | Some _ =>
                                 if (args =? 0) && (args0 =? 0)
                                 then
                                  UnderLets.Base (x1, ##(0)%expr)%expr_pat
                                 else
                                  if args =? 0
                                  then
                                   UnderLets.UnderLet
                                     (#(ident.Z_add_get_carry)%expr @ x @ x1 @
                                      x2)%expr_pat
                                     (fun
                                        v0 : var
                                               (type.base
                                                  (base.type.Z * base.type.Z)%etype)
                                      =>
                                      UnderLets.Base
                                        (#(ident.fst)%expr @ ($v0)%expr,
                                        #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                                  else
                                   UnderLets.UnderLet
                                     (#(ident.Z_add_with_get_carry)%expr @ x @
                                      x0 @ x1 @ x2)%expr_pat
                                     (fun
                                        v0 : var
                                               (type.base
                                                  (base.type.Z * base.type.Z)%etype)
                                      =>
                                      UnderLets.Base
                                        (#(ident.fst)%expr @ ($v0)%expr,
                                        #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                             | None =>
                                 if args =? 0
                                 then
                                  UnderLets.UnderLet
                                    (#(ident.Z_add_get_carry)%expr @ x @ x1 @
                                     x2)%expr_pat
                                    (fun
                                       v0 : var
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)
                                     =>
                                     UnderLets.Base
                                       (#(ident.fst)%expr @ ($v0)%expr,
                                       #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                                 else
                                  UnderLets.UnderLet
                                    (#(ident.Z_add_with_get_carry)%expr @ x @
                                     x0 @ x1 @ x2)%expr_pat
                                    (fun
                                       v0 : var
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)
                                     =>
                                     UnderLets.Base
                                       (#(ident.fst)%expr @ ($v0)%expr,
                                       #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                             end
                         | ($_)%expr =>
                             if args =? 0
                             then
                              UnderLets.UnderLet
                                (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                                (fun
                                   v1 : var
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v1)%expr,
                                   #(ident.snd)%expr @ ($v1)%expr)%expr_pat)
                             else
                              UnderLets.UnderLet
                                (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                 x1 @ x2)%expr_pat
                                (fun
                                   v1 : var
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v1)%expr,
                                   #(ident.snd)%expr @ ($v1)%expr)%expr_pat)
                         | _ =>
                             if args =? 0
                             then
                              UnderLets.UnderLet
                                (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                                (fun
                                   v0 : var
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v0)%expr,
                                   #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                             else
                              UnderLets.UnderLet
                                (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                 x1 @ x2)%expr_pat
                                (fun
                                   v0 : var
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v0)%expr,
                                   #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                         end
                    | None =>
                        if args =? 0
                        then
                         UnderLets.UnderLet
                           (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                           (fun
                              v0 : var
                                     (type.base
                                        (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v0)%expr,
                              #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                        else
                         UnderLets.UnderLet
                           (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                            x2)%expr_pat
                           (fun
                              v0 : var
                                     (type.base
                                        (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v0)%expr,
                              #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                    end
                | ($_)%expr =>
                    if args =? 0
                    then
                     UnderLets.UnderLet
                       (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                       (fun
                          v1 : var
                                 (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v1)%expr,
                          #(ident.snd)%expr @ ($v1)%expr)%expr_pat)
                    else
                     UnderLets.UnderLet
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                       (fun
                          v1 : var
                                 (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v1)%expr,
                          #(ident.snd)%expr @ ($v1)%expr)%expr_pat)
                | @expr.App _ _ _ s _ #(idc0)%expr_pat x3 =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (defaults.expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v0 : defaults.expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t3 : base.type =>
                               defaults.expr (type.base t3)) t2 base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (defaults.expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (defaults.expr (type.base t2) ->
                                        defaults.expr (type.base base.type.Z))
                               =>
                               match a with
                               | Some x' =>
                                   if args =? 0
                                   then
                                    UnderLets.UnderLet
                                      (#(ident.Z_sub_get_borrow)%expr @ x @
                                       x1 @ x' v0)%expr_pat
                                      (fun
                                         v1 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v1)%expr,
                                         (-
                                          (#(ident.snd)%expr @ $v1)%expr_pat)%expr)%expr_pat)
                                   else
                                    match
                                      s as t3
                                      return
                                        (Compile.value' false t3 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t3 =>
                                        fun v1 : defaults.expr (type.base t3)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t4 : base.type =>
                                           defaults.expr (type.base t4)) t3
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a0 : option
                                                    (defaults.expr
                                                       (type.base t3) ->
                                                     defaults.expr
                                                       (type.base base.type.Z))
                                           =>
                                           match a0 with
                                           | Some x'0 =>
                                               if args <? 0
                                               then
                                                UnderLets.UnderLet
                                                  (#(ident.Z_sub_with_get_borrow)%expr @
                                                   x @ ##((- args)%Z)%expr @
                                                   x1 @ x'0 v1)%expr_pat
                                                  (fun
                                                     v2 : var
                                                            (type.base
                                                               (base.type.Z *
                                                                base.type.Z)%etype)
                                                   =>
                                                   UnderLets.Base
                                                     (#(ident.fst)%expr @
                                                      ($v2)%expr,
                                                     (-
                                                      (#(ident.snd)%expr @
                                                       $v2)%expr_pat)%expr)%expr_pat)
                                               else
                                                if args =? 0
                                                then
                                                 UnderLets.UnderLet
                                                   (#(ident.Z_add_get_carry)%expr @
                                                    x @ x1 @ x2)%expr_pat
                                                   (fun
                                                      v2 : var
                                                             (type.base
                                                                (base.type.Z *
                                                                 base.type.Z)%etype)
                                                    =>
                                                    UnderLets.Base
                                                      (#(ident.fst)%expr @
                                                       ($v2)%expr,
                                                      #(ident.snd)%expr @
                                                      ($v2)%expr)%expr_pat)
                                                else
                                                 UnderLets.UnderLet
                                                   (#(ident.Z_add_with_get_carry)%expr @
                                                    x @ x0 @ x1 @ x2)%expr_pat
                                                   (fun
                                                      v2 : var
                                                             (type.base
                                                                (base.type.Z *
                                                                 base.type.Z)%etype)
                                                    =>
                                                    UnderLets.Base
                                                      (#(ident.fst)%expr @
                                                       ($v2)%expr,
                                                      #(ident.snd)%expr @
                                                      ($v2)%expr)%expr_pat)
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_with_get_carry)%expr @
                                                  x @ x0 @ x1 @ x2)%expr_pat
                                           end)
                                    | (s0 -> d0)%ptype =>
                                        fun
                                          _ : Compile.value' false s0 ->
                                              Compile.value' true d0 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ x1 @ x2)%expr_pat
                                    end (Compile.reflect x3)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry)%expr @ x @
                                      x0 @ x1 @ x2)%expr_pat
                               end)
                        | (s0 -> d0)%ptype =>
                            fun
                              _ : Compile.value' false s0 ->
                                  Compile.value' true d0 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                               x1 @ x2)%expr_pat
                        end (Compile.reflect x3)
                    | None =>
                        if args =? 0
                        then
                         UnderLets.UnderLet
                           (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                           (fun
                              v0 : var
                                     (type.base
                                        (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v0)%expr,
                              #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                        else
                         UnderLets.UnderLet
                           (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                            x2)%expr_pat
                           (fun
                              v0 : var
                                     (type.base
                                        (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v0)%expr,
                              #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                    end
                | @expr.App _ _ _ s _ ($_)%expr _ =>
                    if args =? 0
                    then
                     UnderLets.UnderLet
                       (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                       (fun
                          v1 : var
                                 (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v1)%expr,
                          #(ident.snd)%expr @ ($v1)%expr)%expr_pat)
                    else
                     UnderLets.UnderLet
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                       (fun
                          v1 : var
                                 (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v1)%expr,
                          #(ident.snd)%expr @ ($v1)%expr)%expr_pat)
                | @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _
                  _ _ s _ (_ @ _)%expr_pat _ | @expr.App _ _ _ s _
                  (@expr.LetIn _ _ _ _ _ _ _) _ =>
                    if args =? 0
                    then
                     UnderLets.UnderLet
                       (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                       (fun
                          v0 : var
                                 (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v0)%expr,
                          #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                    else
                     UnderLets.UnderLet
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                       (fun
                          v0 : var
                                 (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v0)%expr,
                          #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                | _ =>
                    if args =? 0
                    then
                     UnderLets.UnderLet
                       (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                       (fun
                          v0 : var
                                 (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v0)%expr,
                          #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                    else
                     UnderLets.UnderLet
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                       (fun
                          v0 : var
                                 (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v0)%expr,
                          #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                end
            | @expr.Abs _ _ _ _ _ _ =>
                match x2 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t1 v =>
                          match
                            t1 as t2 return (base.base_interp t2 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v0 : Z => Some v0
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        if
                         (args0 <=? 0) && (args <=? 0) && (args0 + args <? 0)
                        then
                         UnderLets.UnderLet
                           (#(ident.Z_sub_with_get_borrow)%expr @ x @
                            ##((- args)%Z)%expr @ x1 @ ##((- args0)%Z)%expr)%expr_pat
                           (fun
                              v : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v)%expr,
                              (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
                        else
                         match x with
                         | #(idc1)%expr_pat =>
                             match
                               match idc1 with
                               | @ident.Literal t2 v =>
                                   match
                                     t2 as t3
                                     return (base.base_interp t3 -> option Z)
                                   with
                                   | base.type.unit => fun _ : unit => None
                                   | base.type.Z => fun v0 : Z => Some v0
                                   | base.type.bool => fun _ : bool => None
                                   | base.type.nat => fun _ : nat => None
                                   end v
                               | _ => None
                               end
                             with
                             | Some _ =>
                                 if (args =? 0) && (args0 =? 0)
                                 then
                                  UnderLets.Base (x1, ##(0)%expr)%expr_pat
                                 else
                                  if args =? 0
                                  then
                                   UnderLets.UnderLet
                                     (#(ident.Z_add_get_carry)%expr @ x @ x1 @
                                      x2)%expr_pat
                                     (fun
                                        v : var
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)
                                      =>
                                      UnderLets.Base
                                        (#(ident.fst)%expr @ ($v)%expr,
                                        #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                                  else
                                   UnderLets.UnderLet
                                     (#(ident.Z_add_with_get_carry)%expr @ x @
                                      x0 @ x1 @ x2)%expr_pat
                                     (fun
                                        v : var
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)
                                      =>
                                      UnderLets.Base
                                        (#(ident.fst)%expr @ ($v)%expr,
                                        #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                             | None =>
                                 if args =? 0
                                 then
                                  UnderLets.UnderLet
                                    (#(ident.Z_add_get_carry)%expr @ x @ x1 @
                                     x2)%expr_pat
                                    (fun
                                       v : var
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)
                                     =>
                                     UnderLets.Base
                                       (#(ident.fst)%expr @ ($v)%expr,
                                       #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                                 else
                                  UnderLets.UnderLet
                                    (#(ident.Z_add_with_get_carry)%expr @ x @
                                     x0 @ x1 @ x2)%expr_pat
                                    (fun
                                       v : var
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)
                                     =>
                                     UnderLets.Base
                                       (#(ident.fst)%expr @ ($v)%expr,
                                       #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                             end
                         | ($_)%expr =>
                             if args =? 0
                             then
                              UnderLets.UnderLet
                                (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                                (fun
                                   v0 : var
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v0)%expr,
                                   #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                             else
                              UnderLets.UnderLet
                                (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                 x1 @ x2)%expr_pat
                                (fun
                                   v0 : var
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v0)%expr,
                                   #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                         | _ =>
                             if args =? 0
                             then
                              UnderLets.UnderLet
                                (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                                (fun
                                   v : var
                                         (type.base
                                            (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v)%expr,
                                   #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                             else
                              UnderLets.UnderLet
                                (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                 x1 @ x2)%expr_pat
                                (fun
                                   v : var
                                         (type.base
                                            (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v)%expr,
                                   #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                         end
                    | None =>
                        if args =? 0
                        then
                         UnderLets.UnderLet
                           (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                           (fun
                              v : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v)%expr,
                              #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                        else
                         UnderLets.UnderLet
                           (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                            x2)%expr_pat
                           (fun
                              v : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v)%expr,
                              #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    end
                | ($_)%expr =>
                    if args =? 0
                    then
                     UnderLets.UnderLet
                       (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                       (fun
                          v0 : var
                                 (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v0)%expr,
                          #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                    else
                     UnderLets.UnderLet
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                       (fun
                          v0 : var
                                 (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v0)%expr,
                          #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                | @expr.App _ _ _ s0 _ #(idc0)%expr_pat x3 =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s0 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (defaults.expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : defaults.expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type =>
                               defaults.expr (type.base t1)) t2 base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (defaults.expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (defaults.expr (type.base t2) ->
                                        defaults.expr (type.base base.type.Z))
                               =>
                               match a with
                               | Some x' =>
                                   if args =? 0
                                   then
                                    UnderLets.UnderLet
                                      (#(ident.Z_sub_get_borrow)%expr @ x @
                                       x1 @ x' v)%expr_pat
                                      (fun
                                         v0 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v0)%expr,
                                         (-
                                          (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                   else
                                    match
                                      s0 as t3
                                      return
                                        (Compile.value' false t3 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t3 =>
                                        fun v0 : defaults.expr (type.base t3)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t1 : base.type =>
                                           defaults.expr (type.base t1)) t3
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a0 : option
                                                    (defaults.expr
                                                       (type.base t3) ->
                                                     defaults.expr
                                                       (type.base base.type.Z))
                                           =>
                                           match a0 with
                                           | Some x'0 =>
                                               if args <? 0
                                               then
                                                UnderLets.UnderLet
                                                  (#(ident.Z_sub_with_get_borrow)%expr @
                                                   x @ ##((- args)%Z)%expr @
                                                   x1 @ x'0 v0)%expr_pat
                                                  (fun
                                                     v1 : var
                                                            (type.base
                                                               (base.type.Z *
                                                                base.type.Z)%etype)
                                                   =>
                                                   UnderLets.Base
                                                     (#(ident.fst)%expr @
                                                      ($v1)%expr,
                                                     (-
                                                      (#(ident.snd)%expr @
                                                       $v1)%expr_pat)%expr)%expr_pat)
                                               else
                                                if args =? 0
                                                then
                                                 UnderLets.UnderLet
                                                   (#(ident.Z_add_get_carry)%expr @
                                                    x @ x1 @ x2)%expr_pat
                                                   (fun
                                                      v1 : var
                                                             (type.base
                                                                (base.type.Z *
                                                                 base.type.Z)%etype)
                                                    =>
                                                    UnderLets.Base
                                                      (#(ident.fst)%expr @
                                                       ($v1)%expr,
                                                      #(ident.snd)%expr @
                                                      ($v1)%expr)%expr_pat)
                                                else
                                                 UnderLets.UnderLet
                                                   (#(ident.Z_add_with_get_carry)%expr @
                                                    x @ x0 @ x1 @ x2)%expr_pat
                                                   (fun
                                                      v1 : var
                                                             (type.base
                                                                (base.type.Z *
                                                                 base.type.Z)%etype)
                                                    =>
                                                    UnderLets.Base
                                                      (#(ident.fst)%expr @
                                                       ($v1)%expr,
                                                      #(ident.snd)%expr @
                                                      ($v1)%expr)%expr_pat)
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_with_get_carry)%expr @
                                                  x @ x0 @ x1 @ x2)%expr_pat
                                           end)
                                    | (s1 -> d1)%ptype =>
                                        fun
                                          _ : Compile.value' false s1 ->
                                              Compile.value' true d1 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ x1 @ x2)%expr_pat
                                    end (Compile.reflect x3)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry)%expr @ x @
                                      x0 @ x1 @ x2)%expr_pat
                               end)
                        | (s1 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                               x1 @ x2)%expr_pat
                        end (Compile.reflect x3)
                    | None =>
                        if args =? 0
                        then
                         UnderLets.UnderLet
                           (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                           (fun
                              v : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v)%expr,
                              #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                        else
                         UnderLets.UnderLet
                           (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                            x2)%expr_pat
                           (fun
                              v : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v)%expr,
                              #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    end
                | @expr.App _ _ _ s0 _ ($_)%expr _ =>
                    if args =? 0
                    then
                     UnderLets.UnderLet
                       (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                       (fun
                          v0 : var
                                 (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v0)%expr,
                          #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                    else
                     UnderLets.UnderLet
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                       (fun
                          v0 : var
                                 (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v0)%expr,
                          #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                | @expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App
                  _ _ _ s0 _ (_ @ _)%expr_pat _ | @expr.App _ _ _ s0 _
                  (@expr.LetIn _ _ _ _ _ _ _) _ =>
                    if args =? 0
                    then
                     UnderLets.UnderLet
                       (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                       (fun
                          v : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v)%expr,
                          #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    else
                     UnderLets.UnderLet
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                       (fun
                          v : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v)%expr,
                          #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                | _ =>
                    if args =? 0
                    then
                     UnderLets.UnderLet
                       (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                       (fun
                          v : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v)%expr,
                          #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    else
                     UnderLets.UnderLet
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                       (fun
                          v : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v)%expr,
                          #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                end
            | @expr.App _ _ _ s _ #(idc0)%expr_pat x3 =>
                match
                  match idc0 with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (defaults.expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v : defaults.expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => defaults.expr (type.base t1))
                          t2 base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (defaults.expr (type.base t2) ->
                                    defaults.expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               if args =? 0
                               then
                                UnderLets.UnderLet
                                  (#(ident.Z_sub_get_borrow)%expr @ x @ x2 @
                                   x' v)%expr_pat
                                  (fun
                                     v0 : var
                                            (type.base
                                               (base.type.Z * base.type.Z)%etype)
                                   =>
                                   UnderLets.Base
                                     (#(ident.fst)%expr @ ($v0)%expr,
                                     (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                               else
                                match
                                  s as t3
                                  return
                                    (Compile.value' false t3 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)))
                                with
                                | type.base t3 =>
                                    fun v0 : defaults.expr (type.base t3) =>
                                    base.try_make_transport_cps
                                      (fun t1 : base.type =>
                                       defaults.expr (type.base t1)) t3
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base
                                               (base.type.Z * base.type.Z)%etype)))
                                      (fun
                                         a0 : option
                                                (defaults.expr (type.base t3) ->
                                                 defaults.expr
                                                   (type.base base.type.Z))
                                       =>
                                       match a0 with
                                       | Some x'0 =>
                                           if args <? 0
                                           then
                                            UnderLets.UnderLet
                                              (#(ident.Z_sub_with_get_borrow)%expr @
                                               x @ ##((- args)%Z)%expr @ x2 @
                                               x'0 v0)%expr_pat
                                              (fun
                                                 v1 : var
                                                        (type.base
                                                           (base.type.Z *
                                                            base.type.Z)%etype)
                                               =>
                                               UnderLets.Base
                                                 (#(ident.fst)%expr @
                                                  ($v1)%expr,
                                                 (-
                                                  (#(ident.snd)%expr @ $v1)%expr_pat)%expr)%expr_pat)
                                           else
                                            match x2 with
                                            | #(idc1)%expr_pat =>
                                                match
                                                  match idc1 with
                                                  | @ident.Literal t4 v1 =>
                                                      match
                                                        t4 as t5
                                                        return
                                                          (base.base_interp
                                                             t5 -> option Z)
                                                      with
                                                      | base.type.unit =>
                                                          fun _ : unit =>
                                                          None
                                                      | base.type.Z =>
                                                          fun v2 : Z =>
                                                          Some v2
                                                      | base.type.bool =>
                                                          fun _ : bool =>
                                                          None
                                                      | base.type.nat =>
                                                          fun _ : nat => None
                                                      end v1
                                                  | _ => None
                                                  end
                                                with
                                                | Some args1 =>
                                                    if
                                                     (args1 <=? 0) &&
                                                     (args <=? 0) &&
                                                     (args1 + args <? 0)
                                                    then
                                                     UnderLets.UnderLet
                                                       (#(ident.Z_sub_with_get_borrow)%expr @
                                                        x @
                                                        ##((- args)%Z)%expr @
                                                        x1 @
                                                        ##((- args1)%Z)%expr)%expr_pat
                                                       (fun
                                                          v1 : var
                                                                 (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                        =>
                                                        UnderLets.Base
                                                          (#(ident.fst)%expr @
                                                           ($v1)%expr,
                                                          (-
                                                           (#(ident.snd)%expr @
                                                            $v1)%expr_pat)%expr)%expr_pat)
                                                    else
                                                     match x with
                                                     | #(idc2)%expr_pat =>
                                                         match
                                                           match idc2 with
                                                           | @ident.Literal
                                                             t5 v1 =>
                                                               match
                                                                 t5 as t6
                                                                 return
                                                                   (base.base_interp
                                                                    t6 ->
                                                                    option Z)
                                                               with
                                                               | base.type.unit =>
                                                                   fun
                                                                    _ : unit
                                                                   => None
                                                               | base.type.Z =>
                                                                   fun v2 : Z
                                                                   => 
                                                                   Some v2
                                                               | base.type.bool =>
                                                                   fun
                                                                    _ : bool
                                                                   => None
                                                               | base.type.nat =>
                                                                   fun
                                                                    _ : nat
                                                                   => None
                                                               end v1
                                                           | _ => None
                                                           end
                                                         with
                                                         | Some _ =>
                                                             if
                                                              (args =? 0) &&
                                                              (args1 =? 0)
                                                             then
                                                              UnderLets.Base
                                                                (x1,
                                                                ##(0)%expr)%expr_pat
                                                             else
                                                              if args =? 0
                                                              then
                                                               UnderLets.UnderLet
                                                                 (#(ident.Z_add_get_carry)%expr @
                                                                  x @ x1 @ x2)%expr_pat
                                                                 (fun
                                                                    v1 : 
                                                                    var
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                                  =>
                                                                  UnderLets.Base
                                                                    (
                                                                    #
                                                                    (ident.fst)%expr @
                                                                    ($v1)%expr,
                                                                    #
                                                                    (ident.snd)%expr @
                                                                    ($v1)%expr)%expr_pat)
                                                              else
                                                               UnderLets.UnderLet
                                                                 (#(ident.Z_add_with_get_carry)%expr @
                                                                  x @ x0 @ x1 @
                                                                  x2)%expr_pat
                                                                 (fun
                                                                    v1 : 
                                                                    var
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                                  =>
                                                                  UnderLets.Base
                                                                    (
                                                                    #
                                                                    (ident.fst)%expr @
                                                                    ($v1)%expr,
                                                                    #
                                                                    (ident.snd)%expr @
                                                                    ($v1)%expr)%expr_pat)
                                                         | None =>
                                                             if args =? 0
                                                             then
                                                              UnderLets.UnderLet
                                                                (#(ident.Z_add_get_carry)%expr @
                                                                 x @ x1 @ x2)%expr_pat
                                                                (fun
                                                                   v1 : 
                                                                    var
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                                 =>
                                                                 UnderLets.Base
                                                                   (#
                                                                    (ident.fst)%expr @
                                                                    ($v1)%expr,
                                                                   #(ident.snd)%expr @
                                                                   ($v1)%expr)%expr_pat)
                                                             else
                                                              UnderLets.UnderLet
                                                                (#(ident.Z_add_with_get_carry)%expr @
                                                                 x @ x0 @ x1 @
                                                                 x2)%expr_pat
                                                                (fun
                                                                   v1 : 
                                                                    var
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                                 =>
                                                                 UnderLets.Base
                                                                   (#
                                                                    (ident.fst)%expr @
                                                                    ($v1)%expr,
                                                                   #(ident.snd)%expr @
                                                                   ($v1)%expr)%expr_pat)
                                                         end
                                                     | ($_)%expr =>
                                                         if args =? 0
                                                         then
                                                          UnderLets.UnderLet
                                                            (#(ident.Z_add_get_carry)%expr @
                                                             x @ x1 @ x2)%expr_pat
                                                            (fun
                                                               v2 : var
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                             =>
                                                             UnderLets.Base
                                                               (#(ident.fst)%expr @
                                                                ($v2)%expr,
                                                               #(ident.snd)%expr @
                                                               ($v2)%expr)%expr_pat)
                                                         else
                                                          UnderLets.UnderLet
                                                            (#(ident.Z_add_with_get_carry)%expr @
                                                             x @ x0 @ x1 @ x2)%expr_pat
                                                            (fun
                                                               v2 : var
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                             =>
                                                             UnderLets.Base
                                                               (#(ident.fst)%expr @
                                                                ($v2)%expr,
                                                               #(ident.snd)%expr @
                                                               ($v2)%expr)%expr_pat)
                                                     | _ =>
                                                         if args =? 0
                                                         then
                                                          UnderLets.UnderLet
                                                            (#(ident.Z_add_get_carry)%expr @
                                                             x @ x1 @ x2)%expr_pat
                                                            (fun
                                                               v1 : var
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                             =>
                                                             UnderLets.Base
                                                               (#(ident.fst)%expr @
                                                                ($v1)%expr,
                                                               #(ident.snd)%expr @
                                                               ($v1)%expr)%expr_pat)
                                                         else
                                                          UnderLets.UnderLet
                                                            (#(ident.Z_add_with_get_carry)%expr @
                                                             x @ x0 @ x1 @ x2)%expr_pat
                                                            (fun
                                                               v1 : var
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                             =>
                                                             UnderLets.Base
                                                               (#(ident.fst)%expr @
                                                                ($v1)%expr,
                                                               #(ident.snd)%expr @
                                                               ($v1)%expr)%expr_pat)
                                                     end
                                                | None =>
                                                    if args =? 0
                                                    then
                                                     UnderLets.UnderLet
                                                       (#(ident.Z_add_get_carry)%expr @
                                                        x @ x1 @ x2)%expr_pat
                                                       (fun
                                                          v1 : var
                                                                 (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                        =>
                                                        UnderLets.Base
                                                          (#(ident.fst)%expr @
                                                           ($v1)%expr,
                                                          #(ident.snd)%expr @
                                                          ($v1)%expr)%expr_pat)
                                                    else
                                                     UnderLets.UnderLet
                                                       (#(ident.Z_add_with_get_carry)%expr @
                                                        x @ x0 @ x1 @ x2)%expr_pat
                                                       (fun
                                                          v1 : var
                                                                 (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                        =>
                                                        UnderLets.Base
                                                          (#(ident.fst)%expr @
                                                           ($v1)%expr,
                                                          #(ident.snd)%expr @
                                                          ($v1)%expr)%expr_pat)
                                                end
                                            | ($_)%expr =>
                                                if args =? 0
                                                then
                                                 UnderLets.UnderLet
                                                   (#(ident.Z_add_get_carry)%expr @
                                                    x @ x1 @ x2)%expr_pat
                                                   (fun
                                                      v2 : var
                                                             (type.base
                                                                (base.type.Z *
                                                                 base.type.Z)%etype)
                                                    =>
                                                    UnderLets.Base
                                                      (#(ident.fst)%expr @
                                                       ($v2)%expr,
                                                      #(ident.snd)%expr @
                                                      ($v2)%expr)%expr_pat)
                                                else
                                                 UnderLets.UnderLet
                                                   (#(ident.Z_add_with_get_carry)%expr @
                                                    x @ x0 @ x1 @ x2)%expr_pat
                                                   (fun
                                                      v2 : var
                                                             (type.base
                                                                (base.type.Z *
                                                                 base.type.Z)%etype)
                                                    =>
                                                    UnderLets.Base
                                                      (#(ident.fst)%expr @
                                                       ($v2)%expr,
                                                      #(ident.snd)%expr @
                                                      ($v2)%expr)%expr_pat)
                                            | @expr.App _ _ _ s0 _
                                              #(idc1)%expr_pat x4 =>
                                                match
                                                  match idc1 with
                                                  | ident.Z_opp => Some tt
                                                  | _ => None
                                                  end
                                                with
                                                | Some _ =>
                                                    match
                                                      s0 as t4
                                                      return
                                                        (Compile.value' false
                                                           t4 ->
                                                         UnderLets.UnderLets
                                                           base.type ident
                                                           var
                                                           (defaults.expr
                                                              (type.base
                                                                 (base.type.Z *
                                                                  base.type.Z)%etype)))
                                                    with
                                                    | type.base t4 =>
                                                        fun
                                                          v1 : defaults.expr
                                                                 (type.base
                                                                    t4) =>
                                                        base.try_make_transport_cps
                                                          (fun t5 : base.type
                                                           =>
                                                           defaults.expr
                                                             (type.base t5))
                                                          t4 base.type.Z
                                                          (UnderLets.UnderLets
                                                             base.type ident
                                                             var
                                                             (defaults.expr
                                                                (type.base
                                                                   (base.type.Z *
                                                                    base.type.Z)%etype)))
                                                          (fun
                                                             a1 : option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t4) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                           =>
                                                           match a1 with
                                                           | Some x'1 =>
                                                               if args =? 0
                                                               then
                                                                UnderLets.UnderLet
                                                                  (#(ident.Z_sub_get_borrow)%expr @
                                                                   x @ x1 @
                                                                   x'1 v1)%expr_pat
                                                                  (fun
                                                                    v2 : 
                                                                    var
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                                   =>
                                                                   UnderLets.Base
                                                                    (
                                                                    #
                                                                    (ident.fst)%expr @
                                                                    ($v2)%expr,
                                                                    (-
                                                                    (#
                                                                    (ident.snd)%expr @
                                                                    $v2)%expr_pat)%expr)%expr_pat)
                                                               else
                                                                match
                                                                  s0 as t5
                                                                  return
                                                                    (Compile.value'
                                                                    false t5 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)))
                                                                with
                                                                | type.base
                                                                  t5 =>
                                                                    fun
                                                                    v2 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t5) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t6 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t6)) t5
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)))
                                                                    (fun
                                                                    a2 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t5) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a2
                                                                    with
                                                                    | Some
                                                                    x'2 =>
                                                                    if
                                                                    args <? 0
                                                                    then
                                                                    UnderLets.UnderLet
                                                                    (#
                                                                    (ident.Z_sub_with_get_borrow)%expr @
                                                                    x @
                                                                    ##
                                                                    ((- args)%Z)%expr @
                                                                    x1 @
                                                                    x'2 v2)%expr_pat
                                                                    (fun
                                                                    v3 : 
                                                                    var
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                                    =>
                                                                    UnderLets.Base
                                                                    (
                                                                    #
                                                                    (ident.fst)%expr @
                                                                    ($v3)%expr,
                                                                    (-
                                                                    (#
                                                                    (ident.snd)%expr @
                                                                    $v3)%expr_pat)%expr)%expr_pat)
                                                                    else
                                                                    if
                                                                    args =? 0
                                                                    then
                                                                    UnderLets.UnderLet
                                                                    (#
                                                                    (ident.Z_add_get_carry)%expr @
                                                                    x @ x1 @
                                                                    x2)%expr_pat
                                                                    (fun
                                                                    v3 : 
                                                                    var
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                                    =>
                                                                    UnderLets.Base
                                                                    (
                                                                    #
                                                                    (ident.fst)%expr @
                                                                    ($v3)%expr,
                                                                    #
                                                                    (ident.snd)%expr @
                                                                    ($v3)%expr)%expr_pat)
                                                                    else
                                                                    UnderLets.UnderLet
                                                                    (#
                                                                    (ident.Z_add_with_get_carry)%expr @
                                                                    x @ x0 @
                                                                    x1 @ x2)%expr_pat
                                                                    (fun
                                                                    v3 : 
                                                                    var
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                                    =>
                                                                    UnderLets.Base
                                                                    (
                                                                    #
                                                                    (ident.fst)%expr @
                                                                    ($v3)%expr,
                                                                    #
                                                                    (ident.snd)%expr @
                                                                    ($v3)%expr)%expr_pat)
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.Z_add_with_get_carry)%expr @
                                                                    x @ x0 @
                                                                    x1 @ x2)%expr_pat
                                                                    end)
                                                                | (s1 -> d1)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s1 ->
                                                                    Compile.value'
                                                                    true d1
                                                                    =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.Z_add_with_get_carry)%expr @
                                                                    x @ x0 @
                                                                    x1 @ x2)%expr_pat
                                                                end
                                                                  (Compile.reflect
                                                                    x4)
                                                           | None =>
                                                               UnderLets.Base
                                                                 (#(ident.Z_add_with_get_carry)%expr @
                                                                  x @ x0 @ x1 @
                                                                  x2)%expr_pat
                                                           end)
                                                    | (s1 -> d1)%ptype =>
                                                        fun
                                                          _ : Compile.value'
                                                                false s1 ->
                                                              Compile.value'
                                                                true d1 =>
                                                        UnderLets.Base
                                                          (#(ident.Z_add_with_get_carry)%expr @
                                                           x @ x0 @ x1 @ x2)%expr_pat
                                                    end (Compile.reflect x4)
                                                | None =>
                                                    if args =? 0
                                                    then
                                                     UnderLets.UnderLet
                                                       (#(ident.Z_add_get_carry)%expr @
                                                        x @ x1 @ x2)%expr_pat
                                                       (fun
                                                          v1 : var
                                                                 (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                        =>
                                                        UnderLets.Base
                                                          (#(ident.fst)%expr @
                                                           ($v1)%expr,
                                                          #(ident.snd)%expr @
                                                          ($v1)%expr)%expr_pat)
                                                    else
                                                     UnderLets.UnderLet
                                                       (#(ident.Z_add_with_get_carry)%expr @
                                                        x @ x0 @ x1 @ x2)%expr_pat
                                                       (fun
                                                          v1 : var
                                                                 (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                        =>
                                                        UnderLets.Base
                                                          (#(ident.fst)%expr @
                                                           ($v1)%expr,
                                                          #(ident.snd)%expr @
                                                          ($v1)%expr)%expr_pat)
                                                end
                                            | @expr.App _ _ _ s0 _ ($_)%expr
                                              _ =>
                                                if args =? 0
                                                then
                                                 UnderLets.UnderLet
                                                   (#(ident.Z_add_get_carry)%expr @
                                                    x @ x1 @ x2)%expr_pat
                                                   (fun
                                                      v2 : var
                                                             (type.base
                                                                (base.type.Z *
                                                                 base.type.Z)%etype)
                                                    =>
                                                    UnderLets.Base
                                                      (#(ident.fst)%expr @
                                                       ($v2)%expr,
                                                      #(ident.snd)%expr @
                                                      ($v2)%expr)%expr_pat)
                                                else
                                                 UnderLets.UnderLet
                                                   (#(ident.Z_add_with_get_carry)%expr @
                                                    x @ x0 @ x1 @ x2)%expr_pat
                                                   (fun
                                                      v2 : var
                                                             (type.base
                                                                (base.type.Z *
                                                                 base.type.Z)%etype)
                                                    =>
                                                    UnderLets.Base
                                                      (#(ident.fst)%expr @
                                                       ($v2)%expr,
                                                      #(ident.snd)%expr @
                                                      ($v2)%expr)%expr_pat)
                                            | @expr.App _ _ _ s0 _
                                              (@expr.Abs _ _ _ _ _ _) _ |
                                              @expr.App _ _ _ s0 _
                                              (_ @ _)%expr_pat _ | @expr.App
                                              _ _ _ s0 _
                                              (@expr.LetIn _ _ _ _ _ _ _)
                                              _ =>
                                                if args =? 0
                                                then
                                                 UnderLets.UnderLet
                                                   (#(ident.Z_add_get_carry)%expr @
                                                    x @ x1 @ x2)%expr_pat
                                                   (fun
                                                      v1 : var
                                                             (type.base
                                                                (base.type.Z *
                                                                 base.type.Z)%etype)
                                                    =>
                                                    UnderLets.Base
                                                      (#(ident.fst)%expr @
                                                       ($v1)%expr,
                                                      #(ident.snd)%expr @
                                                      ($v1)%expr)%expr_pat)
                                                else
                                                 UnderLets.UnderLet
                                                   (#(ident.Z_add_with_get_carry)%expr @
                                                    x @ x0 @ x1 @ x2)%expr_pat
                                                   (fun
                                                      v1 : var
                                                             (type.base
                                                                (base.type.Z *
                                                                 base.type.Z)%etype)
                                                    =>
                                                    UnderLets.Base
                                                      (#(ident.fst)%expr @
                                                       ($v1)%expr,
                                                      #(ident.snd)%expr @
                                                      ($v1)%expr)%expr_pat)
                                            | _ =>
                                                if args =? 0
                                                then
                                                 UnderLets.UnderLet
                                                   (#(ident.Z_add_get_carry)%expr @
                                                    x @ x1 @ x2)%expr_pat
                                                   (fun
                                                      v1 : var
                                                             (type.base
                                                                (base.type.Z *
                                                                 base.type.Z)%etype)
                                                    =>
                                                    UnderLets.Base
                                                      (#(ident.fst)%expr @
                                                       ($v1)%expr,
                                                      #(ident.snd)%expr @
                                                      ($v1)%expr)%expr_pat)
                                                else
                                                 UnderLets.UnderLet
                                                   (#(ident.Z_add_with_get_carry)%expr @
                                                    x @ x0 @ x1 @ x2)%expr_pat
                                                   (fun
                                                      v1 : var
                                                             (type.base
                                                                (base.type.Z *
                                                                 base.type.Z)%etype)
                                                    =>
                                                    UnderLets.Base
                                                      (#(ident.fst)%expr @
                                                       ($v1)%expr,
                                                      #(ident.snd)%expr @
                                                      ($v1)%expr)%expr_pat)
                                            end
                                       | None =>
                                           UnderLets.Base
                                             (#(ident.Z_add_with_get_carry)%expr @
                                              x @ x0 @ x1 @ x2)%expr_pat
                                       end)
                                | (s0 -> d0)%ptype =>
                                    fun
                                      _ : Compile.value' false s0 ->
                                          Compile.value' true d0 =>
                                    UnderLets.Base
                                      (#(ident.Z_add_with_get_carry)%expr @ x @
                                       x0 @ x1 @ x2)%expr_pat
                                end (Compile.reflect x3)
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                  x1 @ x2)%expr_pat
                           end)
                    | (s0 -> d0)%ptype =>
                        fun
                          _ : Compile.value' false s0 ->
                              Compile.value' true d0 =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                           x2)%expr_pat
                    end (Compile.reflect x3)
                | None =>
                    match x2 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args0 =>
                            if
                             (args0 <=? 0) && (args <=? 0) &&
                             (args0 + args <? 0)
                            then
                             UnderLets.UnderLet
                               (#(ident.Z_sub_with_get_borrow)%expr @ x @
                                ##((- args)%Z)%expr @ x1 @
                                ##((- args0)%Z)%expr)%expr_pat
                               (fun
                                  v : var
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)
                                =>
                                UnderLets.Base
                                  (#(ident.fst)%expr @ ($v)%expr,
                                  (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
                            else
                             match x with
                             | #(idc2)%expr_pat =>
                                 match
                                   match idc2 with
                                   | @ident.Literal t3 v =>
                                       match
                                         t3 as t4
                                         return
                                           (base.base_interp t4 -> option Z)
                                       with
                                       | base.type.unit =>
                                           fun _ : unit => None
                                       | base.type.Z => fun v0 : Z => Some v0
                                       | base.type.bool =>
                                           fun _ : bool => None
                                       | base.type.nat => fun _ : nat => None
                                       end v
                                   | _ => None
                                   end
                                 with
                                 | Some _ =>
                                     if (args =? 0) && (args0 =? 0)
                                     then
                                      UnderLets.Base
                                        (x1, ##(0)%expr)%expr_pat
                                     else
                                      if args =? 0
                                      then
                                       UnderLets.UnderLet
                                         (#(ident.Z_add_get_carry)%expr @ x @
                                          x1 @ x2)%expr_pat
                                         (fun
                                            v : var
                                                  (type.base
                                                     (base.type.Z *
                                                      base.type.Z)%etype) =>
                                          UnderLets.Base
                                            (#(ident.fst)%expr @ ($v)%expr,
                                            #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                                      else
                                       UnderLets.UnderLet
                                         (#(ident.Z_add_with_get_carry)%expr @
                                          x @ x0 @ x1 @ x2)%expr_pat
                                         (fun
                                            v : var
                                                  (type.base
                                                     (base.type.Z *
                                                      base.type.Z)%etype) =>
                                          UnderLets.Base
                                            (#(ident.fst)%expr @ ($v)%expr,
                                            #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                                 | None =>
                                     if args =? 0
                                     then
                                      UnderLets.UnderLet
                                        (#(ident.Z_add_get_carry)%expr @ x @
                                         x1 @ x2)%expr_pat
                                        (fun
                                           v : var
                                                 (type.base
                                                    (base.type.Z *
                                                     base.type.Z)%etype) =>
                                         UnderLets.Base
                                           (#(ident.fst)%expr @ ($v)%expr,
                                           #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                                     else
                                      UnderLets.UnderLet
                                        (#(ident.Z_add_with_get_carry)%expr @
                                         x @ x0 @ x1 @ x2)%expr_pat
                                        (fun
                                           v : var
                                                 (type.base
                                                    (base.type.Z *
                                                     base.type.Z)%etype) =>
                                         UnderLets.Base
                                           (#(ident.fst)%expr @ ($v)%expr,
                                           #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                                 end
                             | ($_)%expr =>
                                 if args =? 0
                                 then
                                  UnderLets.UnderLet
                                    (#(ident.Z_add_get_carry)%expr @ x @ x1 @
                                     x2)%expr_pat
                                    (fun
                                       v0 : var
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)
                                     =>
                                     UnderLets.Base
                                       (#(ident.fst)%expr @ ($v0)%expr,
                                       #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                                 else
                                  UnderLets.UnderLet
                                    (#(ident.Z_add_with_get_carry)%expr @ x @
                                     x0 @ x1 @ x2)%expr_pat
                                    (fun
                                       v0 : var
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)
                                     =>
                                     UnderLets.Base
                                       (#(ident.fst)%expr @ ($v0)%expr,
                                       #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                             | _ =>
                                 if args =? 0
                                 then
                                  UnderLets.UnderLet
                                    (#(ident.Z_add_get_carry)%expr @ x @ x1 @
                                     x2)%expr_pat
                                    (fun
                                       v : var
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)
                                     =>
                                     UnderLets.Base
                                       (#(ident.fst)%expr @ ($v)%expr,
                                       #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                                 else
                                  UnderLets.UnderLet
                                    (#(ident.Z_add_with_get_carry)%expr @ x @
                                     x0 @ x1 @ x2)%expr_pat
                                    (fun
                                       v : var
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)
                                     =>
                                     UnderLets.Base
                                       (#(ident.fst)%expr @ ($v)%expr,
                                       #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                             end
                        | None =>
                            if args =? 0
                            then
                             UnderLets.UnderLet
                               (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                               (fun
                                  v : var
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)
                                =>
                                UnderLets.Base
                                  (#(ident.fst)%expr @ ($v)%expr,
                                  #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                            else
                             UnderLets.UnderLet
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                               (fun
                                  v : var
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)
                                =>
                                UnderLets.Base
                                  (#(ident.fst)%expr @ ($v)%expr,
                                  #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                        end
                    | ($_)%expr =>
                        if args =? 0
                        then
                         UnderLets.UnderLet
                           (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                           (fun
                              v0 : var
                                     (type.base
                                        (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v0)%expr,
                              #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                        else
                         UnderLets.UnderLet
                           (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                            x2)%expr_pat
                           (fun
                              v0 : var
                                     (type.base
                                        (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v0)%expr,
                              #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                    | @expr.App _ _ _ s0 _ #(idc1)%expr_pat x4 =>
                        match
                          match idc1 with
                          | ident.Z_opp => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match
                              s0 as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (defaults.expr
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)))
                            with
                            | type.base t2 =>
                                fun v : defaults.expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t3 : base.type =>
                                   defaults.expr (type.base t3)) t2
                                  base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (defaults.expr
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)))
                                  (fun
                                     a : option
                                           (defaults.expr (type.base t2) ->
                                            defaults.expr
                                              (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       if args =? 0
                                       then
                                        UnderLets.UnderLet
                                          (#(ident.Z_sub_get_borrow)%expr @ x @
                                           x1 @ x' v)%expr_pat
                                          (fun
                                             v0 : var
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)
                                           =>
                                           UnderLets.Base
                                             (#(ident.fst)%expr @ ($v0)%expr,
                                             (-
                                              (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                       else
                                        match
                                          s0 as t3
                                          return
                                            (Compile.value' false t3 ->
                                             UnderLets.UnderLets base.type
                                               ident var
                                               (defaults.expr
                                                  (type.base
                                                     (base.type.Z *
                                                      base.type.Z)%etype)))
                                        with
                                        | type.base t3 =>
                                            fun
                                              v0 : defaults.expr
                                                     (type.base t3) =>
                                            base.try_make_transport_cps
                                              (fun t4 : base.type =>
                                               defaults.expr (type.base t4))
                                              t3 base.type.Z
                                              (UnderLets.UnderLets base.type
                                                 ident var
                                                 (defaults.expr
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)))
                                              (fun
                                                 a0 : option
                                                        (defaults.expr
                                                           (type.base t3) ->
                                                         defaults.expr
                                                           (type.base
                                                              base.type.Z))
                                               =>
                                               match a0 with
                                               | Some x'0 =>
                                                   if args <? 0
                                                   then
                                                    UnderLets.UnderLet
                                                      (#(ident.Z_sub_with_get_borrow)%expr @
                                                       x @
                                                       ##((- args)%Z)%expr @
                                                       x1 @ x'0 v0)%expr_pat
                                                      (fun
                                                         v1 : var
                                                                (type.base
                                                                   (base.type.Z *
                                                                    base.type.Z)%etype)
                                                       =>
                                                       UnderLets.Base
                                                         (#(ident.fst)%expr @
                                                          ($v1)%expr,
                                                         (-
                                                          (#(ident.snd)%expr @
                                                           $v1)%expr_pat)%expr)%expr_pat)
                                                   else
                                                    if args =? 0
                                                    then
                                                     UnderLets.UnderLet
                                                       (#(ident.Z_add_get_carry)%expr @
                                                        x @ x1 @ x2)%expr_pat
                                                       (fun
                                                          v1 : var
                                                                 (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                        =>
                                                        UnderLets.Base
                                                          (#(ident.fst)%expr @
                                                           ($v1)%expr,
                                                          #(ident.snd)%expr @
                                                          ($v1)%expr)%expr_pat)
                                                    else
                                                     UnderLets.UnderLet
                                                       (#(ident.Z_add_with_get_carry)%expr @
                                                        x @ x0 @ x1 @ x2)%expr_pat
                                                       (fun
                                                          v1 : var
                                                                 (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                        =>
                                                        UnderLets.Base
                                                          (#(ident.fst)%expr @
                                                           ($v1)%expr,
                                                          #(ident.snd)%expr @
                                                          ($v1)%expr)%expr_pat)
                                               | None =>
                                                   UnderLets.Base
                                                     (#(ident.Z_add_with_get_carry)%expr @
                                                      x @ x0 @ x1 @ x2)%expr_pat
                                               end)
                                        | (s1 -> d1)%ptype =>
                                            fun
                                              _ : Compile.value' false s1 ->
                                                  Compile.value' true d1 =>
                                            UnderLets.Base
                                              (#(ident.Z_add_with_get_carry)%expr @
                                               x @ x0 @ x1 @ x2)%expr_pat
                                        end (Compile.reflect x4)
                                   | None =>
                                       UnderLets.Base
                                         (#(ident.Z_add_with_get_carry)%expr @
                                          x @ x0 @ x1 @ x2)%expr_pat
                                   end)
                            | (s1 -> d1)%ptype =>
                                fun
                                  _ : Compile.value' false s1 ->
                                      Compile.value' true d1 =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry)%expr @ x @
                                   x0 @ x1 @ x2)%expr_pat
                            end (Compile.reflect x4)
                        | None =>
                            if args =? 0
                            then
                             UnderLets.UnderLet
                               (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                               (fun
                                  v : var
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)
                                =>
                                UnderLets.Base
                                  (#(ident.fst)%expr @ ($v)%expr,
                                  #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                            else
                             UnderLets.UnderLet
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                               (fun
                                  v : var
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)
                                =>
                                UnderLets.Base
                                  (#(ident.fst)%expr @ ($v)%expr,
                                  #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                        end
                    | @expr.App _ _ _ s0 _ ($_)%expr _ =>
                        if args =? 0
                        then
                         UnderLets.UnderLet
                           (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                           (fun
                              v0 : var
                                     (type.base
                                        (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v0)%expr,
                              #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                        else
                         UnderLets.UnderLet
                           (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                            x2)%expr_pat
                           (fun
                              v0 : var
                                     (type.base
                                        (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v0)%expr,
                              #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                    | @expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ |
                      @expr.App _ _ _ s0 _ (_ @ _)%expr_pat _ | @expr.App _ _
                      _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
                        if args =? 0
                        then
                         UnderLets.UnderLet
                           (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                           (fun
                              v : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v)%expr,
                              #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                        else
                         UnderLets.UnderLet
                           (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                            x2)%expr_pat
                           (fun
                              v : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v)%expr,
                              #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    | _ =>
                        if args =? 0
                        then
                         UnderLets.UnderLet
                           (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                           (fun
                              v : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v)%expr,
                              #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                        else
                         UnderLets.UnderLet
                           (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                            x2)%expr_pat
                           (fun
                              v : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v)%expr,
                              #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    end
                end
            | @expr.App _ _ _ s _ ($_)%expr _ =>
                match x2 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t2 v0 =>
                          match
                            t2 as t3 return (base.base_interp t3 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v1 : Z => Some v1
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v0
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        if
                         (args0 <=? 0) && (args <=? 0) && (args0 + args <? 0)
                        then
                         UnderLets.UnderLet
                           (#(ident.Z_sub_with_get_borrow)%expr @ x @
                            ##((- args)%Z)%expr @ x1 @ ##((- args0)%Z)%expr)%expr_pat
                           (fun
                              v0 : var
                                     (type.base
                                        (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v0)%expr,
                              (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                        else
                         match x with
                         | #(idc1)%expr_pat =>
                             match
                               match idc1 with
                               | @ident.Literal t3 v0 =>
                                   match
                                     t3 as t4
                                     return (base.base_interp t4 -> option Z)
                                   with
                                   | base.type.unit => fun _ : unit => None
                                   | base.type.Z => fun v1 : Z => Some v1
                                   | base.type.bool => fun _ : bool => None
                                   | base.type.nat => fun _ : nat => None
                                   end v0
                               | _ => None
                               end
                             with
                             | Some _ =>
                                 if (args =? 0) && (args0 =? 0)
                                 then
                                  UnderLets.Base (x1, ##(0)%expr)%expr_pat
                                 else
                                  if args =? 0
                                  then
                                   UnderLets.UnderLet
                                     (#(ident.Z_add_get_carry)%expr @ x @ x1 @
                                      x2)%expr_pat
                                     (fun
                                        v0 : var
                                               (type.base
                                                  (base.type.Z * base.type.Z)%etype)
                                      =>
                                      UnderLets.Base
                                        (#(ident.fst)%expr @ ($v0)%expr,
                                        #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                                  else
                                   UnderLets.UnderLet
                                     (#(ident.Z_add_with_get_carry)%expr @ x @
                                      x0 @ x1 @ x2)%expr_pat
                                     (fun
                                        v0 : var
                                               (type.base
                                                  (base.type.Z * base.type.Z)%etype)
                                      =>
                                      UnderLets.Base
                                        (#(ident.fst)%expr @ ($v0)%expr,
                                        #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                             | None =>
                                 if args =? 0
                                 then
                                  UnderLets.UnderLet
                                    (#(ident.Z_add_get_carry)%expr @ x @ x1 @
                                     x2)%expr_pat
                                    (fun
                                       v0 : var
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)
                                     =>
                                     UnderLets.Base
                                       (#(ident.fst)%expr @ ($v0)%expr,
                                       #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                                 else
                                  UnderLets.UnderLet
                                    (#(ident.Z_add_with_get_carry)%expr @ x @
                                     x0 @ x1 @ x2)%expr_pat
                                    (fun
                                       v0 : var
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)
                                     =>
                                     UnderLets.Base
                                       (#(ident.fst)%expr @ ($v0)%expr,
                                       #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                             end
                         | ($_)%expr =>
                             if args =? 0
                             then
                              UnderLets.UnderLet
                                (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                                (fun
                                   v1 : var
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v1)%expr,
                                   #(ident.snd)%expr @ ($v1)%expr)%expr_pat)
                             else
                              UnderLets.UnderLet
                                (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                 x1 @ x2)%expr_pat
                                (fun
                                   v1 : var
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v1)%expr,
                                   #(ident.snd)%expr @ ($v1)%expr)%expr_pat)
                         | _ =>
                             if args =? 0
                             then
                              UnderLets.UnderLet
                                (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                                (fun
                                   v0 : var
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v0)%expr,
                                   #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                             else
                              UnderLets.UnderLet
                                (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                 x1 @ x2)%expr_pat
                                (fun
                                   v0 : var
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v0)%expr,
                                   #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                         end
                    | None =>
                        if args =? 0
                        then
                         UnderLets.UnderLet
                           (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                           (fun
                              v0 : var
                                     (type.base
                                        (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v0)%expr,
                              #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                        else
                         UnderLets.UnderLet
                           (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                            x2)%expr_pat
                           (fun
                              v0 : var
                                     (type.base
                                        (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v0)%expr,
                              #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                    end
                | ($_)%expr =>
                    if args =? 0
                    then
                     UnderLets.UnderLet
                       (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                       (fun
                          v1 : var
                                 (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v1)%expr,
                          #(ident.snd)%expr @ ($v1)%expr)%expr_pat)
                    else
                     UnderLets.UnderLet
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                       (fun
                          v1 : var
                                 (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v1)%expr,
                          #(ident.snd)%expr @ ($v1)%expr)%expr_pat)
                | @expr.App _ _ _ s0 _ #(idc0)%expr_pat x4 =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s0 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (defaults.expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v0 : defaults.expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t3 : base.type =>
                               defaults.expr (type.base t3)) t2 base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (defaults.expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (defaults.expr (type.base t2) ->
                                        defaults.expr (type.base base.type.Z))
                               =>
                               match a with
                               | Some x' =>
                                   if args =? 0
                                   then
                                    UnderLets.UnderLet
                                      (#(ident.Z_sub_get_borrow)%expr @ x @
                                       x1 @ x' v0)%expr_pat
                                      (fun
                                         v1 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v1)%expr,
                                         (-
                                          (#(ident.snd)%expr @ $v1)%expr_pat)%expr)%expr_pat)
                                   else
                                    match
                                      s0 as t3
                                      return
                                        (Compile.value' false t3 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t3 =>
                                        fun v1 : defaults.expr (type.base t3)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t4 : base.type =>
                                           defaults.expr (type.base t4)) t3
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a0 : option
                                                    (defaults.expr
                                                       (type.base t3) ->
                                                     defaults.expr
                                                       (type.base base.type.Z))
                                           =>
                                           match a0 with
                                           | Some x'0 =>
                                               if args <? 0
                                               then
                                                UnderLets.UnderLet
                                                  (#(ident.Z_sub_with_get_borrow)%expr @
                                                   x @ ##((- args)%Z)%expr @
                                                   x1 @ x'0 v1)%expr_pat
                                                  (fun
                                                     v2 : var
                                                            (type.base
                                                               (base.type.Z *
                                                                base.type.Z)%etype)
                                                   =>
                                                   UnderLets.Base
                                                     (#(ident.fst)%expr @
                                                      ($v2)%expr,
                                                     (-
                                                      (#(ident.snd)%expr @
                                                       $v2)%expr_pat)%expr)%expr_pat)
                                               else
                                                if args =? 0
                                                then
                                                 UnderLets.UnderLet
                                                   (#(ident.Z_add_get_carry)%expr @
                                                    x @ x1 @ x2)%expr_pat
                                                   (fun
                                                      v2 : var
                                                             (type.base
                                                                (base.type.Z *
                                                                 base.type.Z)%etype)
                                                    =>
                                                    UnderLets.Base
                                                      (#(ident.fst)%expr @
                                                       ($v2)%expr,
                                                      #(ident.snd)%expr @
                                                      ($v2)%expr)%expr_pat)
                                                else
                                                 UnderLets.UnderLet
                                                   (#(ident.Z_add_with_get_carry)%expr @
                                                    x @ x0 @ x1 @ x2)%expr_pat
                                                   (fun
                                                      v2 : var
                                                             (type.base
                                                                (base.type.Z *
                                                                 base.type.Z)%etype)
                                                    =>
                                                    UnderLets.Base
                                                      (#(ident.fst)%expr @
                                                       ($v2)%expr,
                                                      #(ident.snd)%expr @
                                                      ($v2)%expr)%expr_pat)
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_with_get_carry)%expr @
                                                  x @ x0 @ x1 @ x2)%expr_pat
                                           end)
                                    | (s1 -> d1)%ptype =>
                                        fun
                                          _ : Compile.value' false s1 ->
                                              Compile.value' true d1 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ x1 @ x2)%expr_pat
                                    end (Compile.reflect x4)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry)%expr @ x @
                                      x0 @ x1 @ x2)%expr_pat
                               end)
                        | (s1 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                               x1 @ x2)%expr_pat
                        end (Compile.reflect x4)
                    | None =>
                        if args =? 0
                        then
                         UnderLets.UnderLet
                           (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                           (fun
                              v0 : var
                                     (type.base
                                        (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v0)%expr,
                              #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                        else
                         UnderLets.UnderLet
                           (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                            x2)%expr_pat
                           (fun
                              v0 : var
                                     (type.base
                                        (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v0)%expr,
                              #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                    end
                | @expr.App _ _ _ s0 _ ($_)%expr _ =>
                    if args =? 0
                    then
                     UnderLets.UnderLet
                       (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                       (fun
                          v1 : var
                                 (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v1)%expr,
                          #(ident.snd)%expr @ ($v1)%expr)%expr_pat)
                    else
                     UnderLets.UnderLet
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                       (fun
                          v1 : var
                                 (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v1)%expr,
                          #(ident.snd)%expr @ ($v1)%expr)%expr_pat)
                | @expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App
                  _ _ _ s0 _ (_ @ _)%expr_pat _ | @expr.App _ _ _ s0 _
                  (@expr.LetIn _ _ _ _ _ _ _) _ =>
                    if args =? 0
                    then
                     UnderLets.UnderLet
                       (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                       (fun
                          v0 : var
                                 (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v0)%expr,
                          #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                    else
                     UnderLets.UnderLet
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                       (fun
                          v0 : var
                                 (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v0)%expr,
                          #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                | _ =>
                    if args =? 0
                    then
                     UnderLets.UnderLet
                       (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                       (fun
                          v0 : var
                                 (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v0)%expr,
                          #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                    else
                     UnderLets.UnderLet
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                       (fun
                          v0 : var
                                 (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v0)%expr,
                          #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                end
            | @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ =>
                match x2 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t1 v =>
                          match
                            t1 as t2 return (base.base_interp t2 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v0 : Z => Some v0
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        if
                         (args0 <=? 0) && (args <=? 0) && (args0 + args <? 0)
                        then
                         UnderLets.UnderLet
                           (#(ident.Z_sub_with_get_borrow)%expr @ x @
                            ##((- args)%Z)%expr @ x1 @ ##((- args0)%Z)%expr)%expr_pat
                           (fun
                              v : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v)%expr,
                              (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
                        else
                         match x with
                         | #(idc1)%expr_pat =>
                             match
                               match idc1 with
                               | @ident.Literal t2 v =>
                                   match
                                     t2 as t3
                                     return (base.base_interp t3 -> option Z)
                                   with
                                   | base.type.unit => fun _ : unit => None
                                   | base.type.Z => fun v0 : Z => Some v0
                                   | base.type.bool => fun _ : bool => None
                                   | base.type.nat => fun _ : nat => None
                                   end v
                               | _ => None
                               end
                             with
                             | Some _ =>
                                 if (args =? 0) && (args0 =? 0)
                                 then
                                  UnderLets.Base (x1, ##(0)%expr)%expr_pat
                                 else
                                  if args =? 0
                                  then
                                   UnderLets.UnderLet
                                     (#(ident.Z_add_get_carry)%expr @ x @ x1 @
                                      x2)%expr_pat
                                     (fun
                                        v : var
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)
                                      =>
                                      UnderLets.Base
                                        (#(ident.fst)%expr @ ($v)%expr,
                                        #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                                  else
                                   UnderLets.UnderLet
                                     (#(ident.Z_add_with_get_carry)%expr @ x @
                                      x0 @ x1 @ x2)%expr_pat
                                     (fun
                                        v : var
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)
                                      =>
                                      UnderLets.Base
                                        (#(ident.fst)%expr @ ($v)%expr,
                                        #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                             | None =>
                                 if args =? 0
                                 then
                                  UnderLets.UnderLet
                                    (#(ident.Z_add_get_carry)%expr @ x @ x1 @
                                     x2)%expr_pat
                                    (fun
                                       v : var
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)
                                     =>
                                     UnderLets.Base
                                       (#(ident.fst)%expr @ ($v)%expr,
                                       #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                                 else
                                  UnderLets.UnderLet
                                    (#(ident.Z_add_with_get_carry)%expr @ x @
                                     x0 @ x1 @ x2)%expr_pat
                                    (fun
                                       v : var
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)
                                     =>
                                     UnderLets.Base
                                       (#(ident.fst)%expr @ ($v)%expr,
                                       #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                             end
                         | ($_)%expr =>
                             if args =? 0
                             then
                              UnderLets.UnderLet
                                (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                                (fun
                                   v0 : var
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v0)%expr,
                                   #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                             else
                              UnderLets.UnderLet
                                (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                 x1 @ x2)%expr_pat
                                (fun
                                   v0 : var
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v0)%expr,
                                   #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                         | _ =>
                             if args =? 0
                             then
                              UnderLets.UnderLet
                                (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                                (fun
                                   v : var
                                         (type.base
                                            (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v)%expr,
                                   #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                             else
                              UnderLets.UnderLet
                                (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                 x1 @ x2)%expr_pat
                                (fun
                                   v : var
                                         (type.base
                                            (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v)%expr,
                                   #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                         end
                    | None =>
                        if args =? 0
                        then
                         UnderLets.UnderLet
                           (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                           (fun
                              v : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v)%expr,
                              #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                        else
                         UnderLets.UnderLet
                           (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                            x2)%expr_pat
                           (fun
                              v : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v)%expr,
                              #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    end
                | ($_)%expr =>
                    if args =? 0
                    then
                     UnderLets.UnderLet
                       (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                       (fun
                          v0 : var
                                 (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v0)%expr,
                          #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                    else
                     UnderLets.UnderLet
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                       (fun
                          v0 : var
                                 (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v0)%expr,
                          #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                | @expr.App _ _ _ s1 _ #(idc0)%expr_pat x4 =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s1 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (defaults.expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : defaults.expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type =>
                               defaults.expr (type.base t1)) t2 base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (defaults.expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (defaults.expr (type.base t2) ->
                                        defaults.expr (type.base base.type.Z))
                               =>
                               match a with
                               | Some x' =>
                                   if args =? 0
                                   then
                                    UnderLets.UnderLet
                                      (#(ident.Z_sub_get_borrow)%expr @ x @
                                       x1 @ x' v)%expr_pat
                                      (fun
                                         v0 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v0)%expr,
                                         (-
                                          (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                   else
                                    match
                                      s1 as t3
                                      return
                                        (Compile.value' false t3 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t3 =>
                                        fun v0 : defaults.expr (type.base t3)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t1 : base.type =>
                                           defaults.expr (type.base t1)) t3
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a0 : option
                                                    (defaults.expr
                                                       (type.base t3) ->
                                                     defaults.expr
                                                       (type.base base.type.Z))
                                           =>
                                           match a0 with
                                           | Some x'0 =>
                                               if args <? 0
                                               then
                                                UnderLets.UnderLet
                                                  (#(ident.Z_sub_with_get_borrow)%expr @
                                                   x @ ##((- args)%Z)%expr @
                                                   x1 @ x'0 v0)%expr_pat
                                                  (fun
                                                     v1 : var
                                                            (type.base
                                                               (base.type.Z *
                                                                base.type.Z)%etype)
                                                   =>
                                                   UnderLets.Base
                                                     (#(ident.fst)%expr @
                                                      ($v1)%expr,
                                                     (-
                                                      (#(ident.snd)%expr @
                                                       $v1)%expr_pat)%expr)%expr_pat)
                                               else
                                                if args =? 0
                                                then
                                                 UnderLets.UnderLet
                                                   (#(ident.Z_add_get_carry)%expr @
                                                    x @ x1 @ x2)%expr_pat
                                                   (fun
                                                      v1 : var
                                                             (type.base
                                                                (base.type.Z *
                                                                 base.type.Z)%etype)
                                                    =>
                                                    UnderLets.Base
                                                      (#(ident.fst)%expr @
                                                       ($v1)%expr,
                                                      #(ident.snd)%expr @
                                                      ($v1)%expr)%expr_pat)
                                                else
                                                 UnderLets.UnderLet
                                                   (#(ident.Z_add_with_get_carry)%expr @
                                                    x @ x0 @ x1 @ x2)%expr_pat
                                                   (fun
                                                      v1 : var
                                                             (type.base
                                                                (base.type.Z *
                                                                 base.type.Z)%etype)
                                                    =>
                                                    UnderLets.Base
                                                      (#(ident.fst)%expr @
                                                       ($v1)%expr,
                                                      #(ident.snd)%expr @
                                                      ($v1)%expr)%expr_pat)
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_with_get_carry)%expr @
                                                  x @ x0 @ x1 @ x2)%expr_pat
                                           end)
                                    | (s2 -> d2)%ptype =>
                                        fun
                                          _ : Compile.value' false s2 ->
                                              Compile.value' true d2 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ x1 @ x2)%expr_pat
                                    end (Compile.reflect x4)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry)%expr @ x @
                                      x0 @ x1 @ x2)%expr_pat
                               end)
                        | (s2 -> d2)%ptype =>
                            fun
                              _ : Compile.value' false s2 ->
                                  Compile.value' true d2 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                               x1 @ x2)%expr_pat
                        end (Compile.reflect x4)
                    | None =>
                        if args =? 0
                        then
                         UnderLets.UnderLet
                           (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                           (fun
                              v : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v)%expr,
                              #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                        else
                         UnderLets.UnderLet
                           (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                            x2)%expr_pat
                           (fun
                              v : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v)%expr,
                              #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    end
                | @expr.App _ _ _ s1 _ ($_)%expr _ =>
                    if args =? 0
                    then
                     UnderLets.UnderLet
                       (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                       (fun
                          v0 : var
                                 (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v0)%expr,
                          #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                    else
                     UnderLets.UnderLet
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                       (fun
                          v0 : var
                                 (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v0)%expr,
                          #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                | @expr.App _ _ _ s1 _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App
                  _ _ _ s1 _ (_ @ _)%expr_pat _ | @expr.App _ _ _ s1 _
                  (@expr.LetIn _ _ _ _ _ _ _) _ =>
                    if args =? 0
                    then
                     UnderLets.UnderLet
                       (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                       (fun
                          v : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v)%expr,
                          #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    else
                     UnderLets.UnderLet
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                       (fun
                          v : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v)%expr,
                          #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                | _ =>
                    if args =? 0
                    then
                     UnderLets.UnderLet
                       (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                       (fun
                          v : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v)%expr,
                          #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    else
                     UnderLets.UnderLet
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                       (fun
                          v : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v)%expr,
                          #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                end
            | @expr.App _ _ _ s _ (_ @ _)%expr_pat _ =>
                match x2 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t1 v =>
                          match
                            t1 as t2 return (base.base_interp t2 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v0 : Z => Some v0
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        if
                         (args0 <=? 0) && (args <=? 0) && (args0 + args <? 0)
                        then
                         UnderLets.UnderLet
                           (#(ident.Z_sub_with_get_borrow)%expr @ x @
                            ##((- args)%Z)%expr @ x1 @ ##((- args0)%Z)%expr)%expr_pat
                           (fun
                              v : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v)%expr,
                              (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
                        else
                         match x with
                         | #(idc1)%expr_pat =>
                             match
                               match idc1 with
                               | @ident.Literal t2 v =>
                                   match
                                     t2 as t3
                                     return (base.base_interp t3 -> option Z)
                                   with
                                   | base.type.unit => fun _ : unit => None
                                   | base.type.Z => fun v0 : Z => Some v0
                                   | base.type.bool => fun _ : bool => None
                                   | base.type.nat => fun _ : nat => None
                                   end v
                               | _ => None
                               end
                             with
                             | Some _ =>
                                 if (args =? 0) && (args0 =? 0)
                                 then
                                  UnderLets.Base (x1, ##(0)%expr)%expr_pat
                                 else
                                  if args =? 0
                                  then
                                   UnderLets.UnderLet
                                     (#(ident.Z_add_get_carry)%expr @ x @ x1 @
                                      x2)%expr_pat
                                     (fun
                                        v : var
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)
                                      =>
                                      UnderLets.Base
                                        (#(ident.fst)%expr @ ($v)%expr,
                                        #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                                  else
                                   UnderLets.UnderLet
                                     (#(ident.Z_add_with_get_carry)%expr @ x @
                                      x0 @ x1 @ x2)%expr_pat
                                     (fun
                                        v : var
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)
                                      =>
                                      UnderLets.Base
                                        (#(ident.fst)%expr @ ($v)%expr,
                                        #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                             | None =>
                                 if args =? 0
                                 then
                                  UnderLets.UnderLet
                                    (#(ident.Z_add_get_carry)%expr @ x @ x1 @
                                     x2)%expr_pat
                                    (fun
                                       v : var
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)
                                     =>
                                     UnderLets.Base
                                       (#(ident.fst)%expr @ ($v)%expr,
                                       #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                                 else
                                  UnderLets.UnderLet
                                    (#(ident.Z_add_with_get_carry)%expr @ x @
                                     x0 @ x1 @ x2)%expr_pat
                                    (fun
                                       v : var
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)
                                     =>
                                     UnderLets.Base
                                       (#(ident.fst)%expr @ ($v)%expr,
                                       #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                             end
                         | ($_)%expr =>
                             if args =? 0
                             then
                              UnderLets.UnderLet
                                (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                                (fun
                                   v0 : var
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v0)%expr,
                                   #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                             else
                              UnderLets.UnderLet
                                (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                 x1 @ x2)%expr_pat
                                (fun
                                   v0 : var
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v0)%expr,
                                   #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                         | _ =>
                             if args =? 0
                             then
                              UnderLets.UnderLet
                                (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                                (fun
                                   v : var
                                         (type.base
                                            (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v)%expr,
                                   #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                             else
                              UnderLets.UnderLet
                                (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                 x1 @ x2)%expr_pat
                                (fun
                                   v : var
                                         (type.base
                                            (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v)%expr,
                                   #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                         end
                    | None =>
                        if args =? 0
                        then
                         UnderLets.UnderLet
                           (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                           (fun
                              v : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v)%expr,
                              #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                        else
                         UnderLets.UnderLet
                           (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                            x2)%expr_pat
                           (fun
                              v : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v)%expr,
                              #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    end
                | ($_)%expr =>
                    if args =? 0
                    then
                     UnderLets.UnderLet
                       (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                       (fun
                          v0 : var
                                 (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v0)%expr,
                          #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                    else
                     UnderLets.UnderLet
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                       (fun
                          v0 : var
                                 (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v0)%expr,
                          #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                | @expr.App _ _ _ s1 _ #(idc0)%expr_pat x5 =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s1 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (defaults.expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : defaults.expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type =>
                               defaults.expr (type.base t1)) t2 base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (defaults.expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (defaults.expr (type.base t2) ->
                                        defaults.expr (type.base base.type.Z))
                               =>
                               match a with
                               | Some x' =>
                                   if args =? 0
                                   then
                                    UnderLets.UnderLet
                                      (#(ident.Z_sub_get_borrow)%expr @ x @
                                       x1 @ x' v)%expr_pat
                                      (fun
                                         v0 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v0)%expr,
                                         (-
                                          (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                   else
                                    match
                                      s1 as t3
                                      return
                                        (Compile.value' false t3 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t3 =>
                                        fun v0 : defaults.expr (type.base t3)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t1 : base.type =>
                                           defaults.expr (type.base t1)) t3
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a0 : option
                                                    (defaults.expr
                                                       (type.base t3) ->
                                                     defaults.expr
                                                       (type.base base.type.Z))
                                           =>
                                           match a0 with
                                           | Some x'0 =>
                                               if args <? 0
                                               then
                                                UnderLets.UnderLet
                                                  (#(ident.Z_sub_with_get_borrow)%expr @
                                                   x @ ##((- args)%Z)%expr @
                                                   x1 @ x'0 v0)%expr_pat
                                                  (fun
                                                     v1 : var
                                                            (type.base
                                                               (base.type.Z *
                                                                base.type.Z)%etype)
                                                   =>
                                                   UnderLets.Base
                                                     (#(ident.fst)%expr @
                                                      ($v1)%expr,
                                                     (-
                                                      (#(ident.snd)%expr @
                                                       $v1)%expr_pat)%expr)%expr_pat)
                                               else
                                                if args =? 0
                                                then
                                                 UnderLets.UnderLet
                                                   (#(ident.Z_add_get_carry)%expr @
                                                    x @ x1 @ x2)%expr_pat
                                                   (fun
                                                      v1 : var
                                                             (type.base
                                                                (base.type.Z *
                                                                 base.type.Z)%etype)
                                                    =>
                                                    UnderLets.Base
                                                      (#(ident.fst)%expr @
                                                       ($v1)%expr,
                                                      #(ident.snd)%expr @
                                                      ($v1)%expr)%expr_pat)
                                                else
                                                 UnderLets.UnderLet
                                                   (#(ident.Z_add_with_get_carry)%expr @
                                                    x @ x0 @ x1 @ x2)%expr_pat
                                                   (fun
                                                      v1 : var
                                                             (type.base
                                                                (base.type.Z *
                                                                 base.type.Z)%etype)
                                                    =>
                                                    UnderLets.Base
                                                      (#(ident.fst)%expr @
                                                       ($v1)%expr,
                                                      #(ident.snd)%expr @
                                                      ($v1)%expr)%expr_pat)
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_with_get_carry)%expr @
                                                  x @ x0 @ x1 @ x2)%expr_pat
                                           end)
                                    | (s2 -> d2)%ptype =>
                                        fun
                                          _ : Compile.value' false s2 ->
                                              Compile.value' true d2 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ x1 @ x2)%expr_pat
                                    end (Compile.reflect x5)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry)%expr @ x @
                                      x0 @ x1 @ x2)%expr_pat
                               end)
                        | (s2 -> d2)%ptype =>
                            fun
                              _ : Compile.value' false s2 ->
                                  Compile.value' true d2 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                               x1 @ x2)%expr_pat
                        end (Compile.reflect x5)
                    | None =>
                        if args =? 0
                        then
                         UnderLets.UnderLet
                           (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                           (fun
                              v : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v)%expr,
                              #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                        else
                         UnderLets.UnderLet
                           (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                            x2)%expr_pat
                           (fun
                              v : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v)%expr,
                              #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    end
                | @expr.App _ _ _ s1 _ ($_)%expr _ =>
                    if args =? 0
                    then
                     UnderLets.UnderLet
                       (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                       (fun
                          v0 : var
                                 (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v0)%expr,
                          #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                    else
                     UnderLets.UnderLet
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                       (fun
                          v0 : var
                                 (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v0)%expr,
                          #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                | @expr.App _ _ _ s1 _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App
                  _ _ _ s1 _ (_ @ _)%expr_pat _ | @expr.App _ _ _ s1 _
                  (@expr.LetIn _ _ _ _ _ _ _) _ =>
                    if args =? 0
                    then
                     UnderLets.UnderLet
                       (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                       (fun
                          v : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v)%expr,
                          #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    else
                     UnderLets.UnderLet
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                       (fun
                          v : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v)%expr,
                          #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                | _ =>
                    if args =? 0
                    then
                     UnderLets.UnderLet
                       (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                       (fun
                          v : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v)%expr,
                          #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    else
                     UnderLets.UnderLet
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                       (fun
                          v : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v)%expr,
                          #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                end
            | @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
                match x2 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t1 v =>
                          match
                            t1 as t2 return (base.base_interp t2 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v0 : Z => Some v0
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        if
                         (args0 <=? 0) && (args <=? 0) && (args0 + args <? 0)
                        then
                         UnderLets.UnderLet
                           (#(ident.Z_sub_with_get_borrow)%expr @ x @
                            ##((- args)%Z)%expr @ x1 @ ##((- args0)%Z)%expr)%expr_pat
                           (fun
                              v : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v)%expr,
                              (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
                        else
                         match x with
                         | #(idc1)%expr_pat =>
                             match
                               match idc1 with
                               | @ident.Literal t2 v =>
                                   match
                                     t2 as t3
                                     return (base.base_interp t3 -> option Z)
                                   with
                                   | base.type.unit => fun _ : unit => None
                                   | base.type.Z => fun v0 : Z => Some v0
                                   | base.type.bool => fun _ : bool => None
                                   | base.type.nat => fun _ : nat => None
                                   end v
                               | _ => None
                               end
                             with
                             | Some _ =>
                                 if (args =? 0) && (args0 =? 0)
                                 then
                                  UnderLets.Base (x1, ##(0)%expr)%expr_pat
                                 else
                                  if args =? 0
                                  then
                                   UnderLets.UnderLet
                                     (#(ident.Z_add_get_carry)%expr @ x @ x1 @
                                      x2)%expr_pat
                                     (fun
                                        v : var
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)
                                      =>
                                      UnderLets.Base
                                        (#(ident.fst)%expr @ ($v)%expr,
                                        #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                                  else
                                   UnderLets.UnderLet
                                     (#(ident.Z_add_with_get_carry)%expr @ x @
                                      x0 @ x1 @ x2)%expr_pat
                                     (fun
                                        v : var
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)
                                      =>
                                      UnderLets.Base
                                        (#(ident.fst)%expr @ ($v)%expr,
                                        #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                             | None =>
                                 if args =? 0
                                 then
                                  UnderLets.UnderLet
                                    (#(ident.Z_add_get_carry)%expr @ x @ x1 @
                                     x2)%expr_pat
                                    (fun
                                       v : var
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)
                                     =>
                                     UnderLets.Base
                                       (#(ident.fst)%expr @ ($v)%expr,
                                       #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                                 else
                                  UnderLets.UnderLet
                                    (#(ident.Z_add_with_get_carry)%expr @ x @
                                     x0 @ x1 @ x2)%expr_pat
                                    (fun
                                       v : var
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)
                                     =>
                                     UnderLets.Base
                                       (#(ident.fst)%expr @ ($v)%expr,
                                       #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                             end
                         | ($_)%expr =>
                             if args =? 0
                             then
                              UnderLets.UnderLet
                                (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                                (fun
                                   v0 : var
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v0)%expr,
                                   #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                             else
                              UnderLets.UnderLet
                                (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                 x1 @ x2)%expr_pat
                                (fun
                                   v0 : var
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v0)%expr,
                                   #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                         | _ =>
                             if args =? 0
                             then
                              UnderLets.UnderLet
                                (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                                (fun
                                   v : var
                                         (type.base
                                            (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v)%expr,
                                   #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                             else
                              UnderLets.UnderLet
                                (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                 x1 @ x2)%expr_pat
                                (fun
                                   v : var
                                         (type.base
                                            (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v)%expr,
                                   #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                         end
                    | None =>
                        if args =? 0
                        then
                         UnderLets.UnderLet
                           (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                           (fun
                              v : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v)%expr,
                              #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                        else
                         UnderLets.UnderLet
                           (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                            x2)%expr_pat
                           (fun
                              v : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v)%expr,
                              #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    end
                | ($_)%expr =>
                    if args =? 0
                    then
                     UnderLets.UnderLet
                       (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                       (fun
                          v0 : var
                                 (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v0)%expr,
                          #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                    else
                     UnderLets.UnderLet
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                       (fun
                          v0 : var
                                 (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v0)%expr,
                          #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                | @expr.App _ _ _ s0 _ #(idc0)%expr_pat x5 =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s0 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (defaults.expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : defaults.expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type =>
                               defaults.expr (type.base t1)) t2 base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (defaults.expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (defaults.expr (type.base t2) ->
                                        defaults.expr (type.base base.type.Z))
                               =>
                               match a with
                               | Some x' =>
                                   if args =? 0
                                   then
                                    UnderLets.UnderLet
                                      (#(ident.Z_sub_get_borrow)%expr @ x @
                                       x1 @ x' v)%expr_pat
                                      (fun
                                         v0 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v0)%expr,
                                         (-
                                          (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                   else
                                    match
                                      s0 as t3
                                      return
                                        (Compile.value' false t3 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t3 =>
                                        fun v0 : defaults.expr (type.base t3)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t1 : base.type =>
                                           defaults.expr (type.base t1)) t3
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a0 : option
                                                    (defaults.expr
                                                       (type.base t3) ->
                                                     defaults.expr
                                                       (type.base base.type.Z))
                                           =>
                                           match a0 with
                                           | Some x'0 =>
                                               if args <? 0
                                               then
                                                UnderLets.UnderLet
                                                  (#(ident.Z_sub_with_get_borrow)%expr @
                                                   x @ ##((- args)%Z)%expr @
                                                   x1 @ x'0 v0)%expr_pat
                                                  (fun
                                                     v1 : var
                                                            (type.base
                                                               (base.type.Z *
                                                                base.type.Z)%etype)
                                                   =>
                                                   UnderLets.Base
                                                     (#(ident.fst)%expr @
                                                      ($v1)%expr,
                                                     (-
                                                      (#(ident.snd)%expr @
                                                       $v1)%expr_pat)%expr)%expr_pat)
                                               else
                                                if args =? 0
                                                then
                                                 UnderLets.UnderLet
                                                   (#(ident.Z_add_get_carry)%expr @
                                                    x @ x1 @ x2)%expr_pat
                                                   (fun
                                                      v1 : var
                                                             (type.base
                                                                (base.type.Z *
                                                                 base.type.Z)%etype)
                                                    =>
                                                    UnderLets.Base
                                                      (#(ident.fst)%expr @
                                                       ($v1)%expr,
                                                      #(ident.snd)%expr @
                                                      ($v1)%expr)%expr_pat)
                                                else
                                                 UnderLets.UnderLet
                                                   (#(ident.Z_add_with_get_carry)%expr @
                                                    x @ x0 @ x1 @ x2)%expr_pat
                                                   (fun
                                                      v1 : var
                                                             (type.base
                                                                (base.type.Z *
                                                                 base.type.Z)%etype)
                                                    =>
                                                    UnderLets.Base
                                                      (#(ident.fst)%expr @
                                                       ($v1)%expr,
                                                      #(ident.snd)%expr @
                                                      ($v1)%expr)%expr_pat)
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_with_get_carry)%expr @
                                                  x @ x0 @ x1 @ x2)%expr_pat
                                           end)
                                    | (s1 -> d1)%ptype =>
                                        fun
                                          _ : Compile.value' false s1 ->
                                              Compile.value' true d1 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ x1 @ x2)%expr_pat
                                    end (Compile.reflect x5)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry)%expr @ x @
                                      x0 @ x1 @ x2)%expr_pat
                               end)
                        | (s1 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                               x1 @ x2)%expr_pat
                        end (Compile.reflect x5)
                    | None =>
                        if args =? 0
                        then
                         UnderLets.UnderLet
                           (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                           (fun
                              v : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v)%expr,
                              #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                        else
                         UnderLets.UnderLet
                           (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                            x2)%expr_pat
                           (fun
                              v : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v)%expr,
                              #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    end
                | @expr.App _ _ _ s0 _ ($_)%expr _ =>
                    if args =? 0
                    then
                     UnderLets.UnderLet
                       (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                       (fun
                          v0 : var
                                 (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v0)%expr,
                          #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                    else
                     UnderLets.UnderLet
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                       (fun
                          v0 : var
                                 (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v0)%expr,
                          #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                | @expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App
                  _ _ _ s0 _ (_ @ _)%expr_pat _ | @expr.App _ _ _ s0 _
                  (@expr.LetIn _ _ _ _ _ _ _) _ =>
                    if args =? 0
                    then
                     UnderLets.UnderLet
                       (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                       (fun
                          v : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v)%expr,
                          #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    else
                     UnderLets.UnderLet
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                       (fun
                          v : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v)%expr,
                          #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                | _ =>
                    if args =? 0
                    then
                     UnderLets.UnderLet
                       (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                       (fun
                          v : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v)%expr,
                          #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    else
                     UnderLets.UnderLet
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                       (fun
                          v : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v)%expr,
                          #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                end
            | @expr.LetIn _ _ _ _ _ _ _ =>
                match x2 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t1 v =>
                          match
                            t1 as t2 return (base.base_interp t2 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v0 : Z => Some v0
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        if
                         (args0 <=? 0) && (args <=? 0) && (args0 + args <? 0)
                        then
                         UnderLets.UnderLet
                           (#(ident.Z_sub_with_get_borrow)%expr @ x @
                            ##((- args)%Z)%expr @ x1 @ ##((- args0)%Z)%expr)%expr_pat
                           (fun
                              v : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v)%expr,
                              (- (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
                        else
                         match x with
                         | #(idc1)%expr_pat =>
                             match
                               match idc1 with
                               | @ident.Literal t2 v =>
                                   match
                                     t2 as t3
                                     return (base.base_interp t3 -> option Z)
                                   with
                                   | base.type.unit => fun _ : unit => None
                                   | base.type.Z => fun v0 : Z => Some v0
                                   | base.type.bool => fun _ : bool => None
                                   | base.type.nat => fun _ : nat => None
                                   end v
                               | _ => None
                               end
                             with
                             | Some _ =>
                                 if (args =? 0) && (args0 =? 0)
                                 then
                                  UnderLets.Base (x1, ##(0)%expr)%expr_pat
                                 else
                                  if args =? 0
                                  then
                                   UnderLets.UnderLet
                                     (#(ident.Z_add_get_carry)%expr @ x @ x1 @
                                      x2)%expr_pat
                                     (fun
                                        v : var
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)
                                      =>
                                      UnderLets.Base
                                        (#(ident.fst)%expr @ ($v)%expr,
                                        #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                                  else
                                   UnderLets.UnderLet
                                     (#(ident.Z_add_with_get_carry)%expr @ x @
                                      x0 @ x1 @ x2)%expr_pat
                                     (fun
                                        v : var
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)
                                      =>
                                      UnderLets.Base
                                        (#(ident.fst)%expr @ ($v)%expr,
                                        #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                             | None =>
                                 if args =? 0
                                 then
                                  UnderLets.UnderLet
                                    (#(ident.Z_add_get_carry)%expr @ x @ x1 @
                                     x2)%expr_pat
                                    (fun
                                       v : var
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)
                                     =>
                                     UnderLets.Base
                                       (#(ident.fst)%expr @ ($v)%expr,
                                       #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                                 else
                                  UnderLets.UnderLet
                                    (#(ident.Z_add_with_get_carry)%expr @ x @
                                     x0 @ x1 @ x2)%expr_pat
                                    (fun
                                       v : var
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)
                                     =>
                                     UnderLets.Base
                                       (#(ident.fst)%expr @ ($v)%expr,
                                       #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                             end
                         | ($_)%expr =>
                             if args =? 0
                             then
                              UnderLets.UnderLet
                                (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                                (fun
                                   v0 : var
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v0)%expr,
                                   #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                             else
                              UnderLets.UnderLet
                                (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                 x1 @ x2)%expr_pat
                                (fun
                                   v0 : var
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v0)%expr,
                                   #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                         | _ =>
                             if args =? 0
                             then
                              UnderLets.UnderLet
                                (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                                (fun
                                   v : var
                                         (type.base
                                            (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v)%expr,
                                   #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                             else
                              UnderLets.UnderLet
                                (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                 x1 @ x2)%expr_pat
                                (fun
                                   v : var
                                         (type.base
                                            (base.type.Z * base.type.Z)%etype)
                                 =>
                                 UnderLets.Base
                                   (#(ident.fst)%expr @ ($v)%expr,
                                   #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                         end
                    | None =>
                        if args =? 0
                        then
                         UnderLets.UnderLet
                           (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                           (fun
                              v : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v)%expr,
                              #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                        else
                         UnderLets.UnderLet
                           (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                            x2)%expr_pat
                           (fun
                              v : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v)%expr,
                              #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    end
                | ($_)%expr =>
                    if args =? 0
                    then
                     UnderLets.UnderLet
                       (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                       (fun
                          v0 : var
                                 (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v0)%expr,
                          #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                    else
                     UnderLets.UnderLet
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                       (fun
                          v0 : var
                                 (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v0)%expr,
                          #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                | @expr.App _ _ _ s _ #(idc0)%expr_pat x4 =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (defaults.expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : defaults.expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type =>
                               defaults.expr (type.base t1)) t2 base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (defaults.expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (defaults.expr (type.base t2) ->
                                        defaults.expr (type.base base.type.Z))
                               =>
                               match a with
                               | Some x' =>
                                   if args =? 0
                                   then
                                    UnderLets.UnderLet
                                      (#(ident.Z_sub_get_borrow)%expr @ x @
                                       x1 @ x' v)%expr_pat
                                      (fun
                                         v0 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v0)%expr,
                                         (-
                                          (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                   else
                                    match
                                      s as t3
                                      return
                                        (Compile.value' false t3 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t3 =>
                                        fun v0 : defaults.expr (type.base t3)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t1 : base.type =>
                                           defaults.expr (type.base t1)) t3
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a0 : option
                                                    (defaults.expr
                                                       (type.base t3) ->
                                                     defaults.expr
                                                       (type.base base.type.Z))
                                           =>
                                           match a0 with
                                           | Some x'0 =>
                                               if args <? 0
                                               then
                                                UnderLets.UnderLet
                                                  (#(ident.Z_sub_with_get_borrow)%expr @
                                                   x @ ##((- args)%Z)%expr @
                                                   x1 @ x'0 v0)%expr_pat
                                                  (fun
                                                     v1 : var
                                                            (type.base
                                                               (base.type.Z *
                                                                base.type.Z)%etype)
                                                   =>
                                                   UnderLets.Base
                                                     (#(ident.fst)%expr @
                                                      ($v1)%expr,
                                                     (-
                                                      (#(ident.snd)%expr @
                                                       $v1)%expr_pat)%expr)%expr_pat)
                                               else
                                                if args =? 0
                                                then
                                                 UnderLets.UnderLet
                                                   (#(ident.Z_add_get_carry)%expr @
                                                    x @ x1 @ x2)%expr_pat
                                                   (fun
                                                      v1 : var
                                                             (type.base
                                                                (base.type.Z *
                                                                 base.type.Z)%etype)
                                                    =>
                                                    UnderLets.Base
                                                      (#(ident.fst)%expr @
                                                       ($v1)%expr,
                                                      #(ident.snd)%expr @
                                                      ($v1)%expr)%expr_pat)
                                                else
                                                 UnderLets.UnderLet
                                                   (#(ident.Z_add_with_get_carry)%expr @
                                                    x @ x0 @ x1 @ x2)%expr_pat
                                                   (fun
                                                      v1 : var
                                                             (type.base
                                                                (base.type.Z *
                                                                 base.type.Z)%etype)
                                                    =>
                                                    UnderLets.Base
                                                      (#(ident.fst)%expr @
                                                       ($v1)%expr,
                                                      #(ident.snd)%expr @
                                                      ($v1)%expr)%expr_pat)
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_with_get_carry)%expr @
                                                  x @ x0 @ x1 @ x2)%expr_pat
                                           end)
                                    | (s0 -> d0)%ptype =>
                                        fun
                                          _ : Compile.value' false s0 ->
                                              Compile.value' true d0 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ x1 @ x2)%expr_pat
                                    end (Compile.reflect x4)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry)%expr @ x @
                                      x0 @ x1 @ x2)%expr_pat
                               end)
                        | (s0 -> d0)%ptype =>
                            fun
                              _ : Compile.value' false s0 ->
                                  Compile.value' true d0 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                               x1 @ x2)%expr_pat
                        end (Compile.reflect x4)
                    | None =>
                        if args =? 0
                        then
                         UnderLets.UnderLet
                           (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                           (fun
                              v : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v)%expr,
                              #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                        else
                         UnderLets.UnderLet
                           (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                            x2)%expr_pat
                           (fun
                              v : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v)%expr,
                              #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    end
                | @expr.App _ _ _ s _ ($_)%expr _ =>
                    if args =? 0
                    then
                     UnderLets.UnderLet
                       (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                       (fun
                          v0 : var
                                 (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v0)%expr,
                          #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                    else
                     UnderLets.UnderLet
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                       (fun
                          v0 : var
                                 (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v0)%expr,
                          #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                | @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _
                  _ _ s _ (_ @ _)%expr_pat _ | @expr.App _ _ _ s _
                  (@expr.LetIn _ _ _ _ _ _ _) _ =>
                    if args =? 0
                    then
                     UnderLets.UnderLet
                       (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                       (fun
                          v : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v)%expr,
                          #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    else
                     UnderLets.UnderLet
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                       (fun
                          v : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v)%expr,
                          #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                | _ =>
                    if args =? 0
                    then
                     UnderLets.UnderLet
                       (#(ident.Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                       (fun
                          v : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v)%expr,
                          #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    else
                     UnderLets.UnderLet
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                       (fun
                          v : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v)%expr,
                          #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                end
            end
        | None =>
            match x1 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args =>
                    match x2 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args0 =>
                            if (args =? 0) && (args0 =? 0)
                            then
                             UnderLets.UnderLet
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                ##(args)%expr @ ##(args0)%expr)%expr_pat
                               (fun
                                  v : var
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)
                                =>
                                UnderLets.Base
                                  (#(ident.fst)%expr @ ($v)%expr, ##(0)%expr)%expr_pat)
                            else
                             UnderLets.UnderLet
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                               (fun
                                  v : var
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)
                                =>
                                UnderLets.Base
                                  (#(ident.fst)%expr @ ($v)%expr,
                                  #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                        | None =>
                            UnderLets.UnderLet
                              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                               x1 @ x2)%expr_pat
                              (fun
                                 v : var
                                       (type.base
                                          (base.type.Z * base.type.Z)%etype)
                               =>
                               UnderLets.Base
                                 (#(ident.fst)%expr @ ($v)%expr,
                                 #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                        end
                    | ($_)%expr =>
                        UnderLets.UnderLet
                          (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                           x2)%expr_pat
                          (fun
                             v0 : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                           UnderLets.Base
                             (#(ident.fst)%expr @ ($v0)%expr,
                             #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                    | _ =>
                        UnderLets.UnderLet
                          (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                           x2)%expr_pat
                          (fun
                             v : var
                                   (type.base
                                      (base.type.Z * base.type.Z)%etype) =>
                           UnderLets.Base
                             (#(ident.fst)%expr @ ($v)%expr,
                             #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    end
                | None =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                      (fun
                         v : var
                               (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v)%expr,
                         #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                end
            | ($_)%expr =>
                UnderLets.UnderLet
                  (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                  (fun v0 : var (type.base (base.type.Z * base.type.Z)%etype)
                   =>
                   UnderLets.Base
                     (#(ident.fst)%expr @ ($v0)%expr,
                     #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
            | _ =>
                UnderLets.UnderLet
                  (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                  (fun v : var (type.base (base.type.Z * base.type.Z)%etype)
                   =>
                   UnderLets.Base
                     (#(ident.fst)%expr @ ($v)%expr,
                     #(ident.snd)%expr @ ($v)%expr)%expr_pat)
            end
        end
    | ($_)%expr =>
        match x1 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t1 v0 =>
                  match
                    t1 as t2 return (base.base_interp t2 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v1 : Z => Some v1
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v0
              | _ => None
              end
            with
            | Some args =>
                match x2 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t2 v0 =>
                          match
                            t2 as t3 return (base.base_interp t3 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v1 : Z => Some v1
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v0
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        if (args =? 0) && (args0 =? 0)
                        then
                         UnderLets.UnderLet
                           (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                            ##(args)%expr @ ##(args0)%expr)%expr_pat
                           (fun
                              v0 : var
                                     (type.base
                                        (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v0)%expr, ##(0)%expr)%expr_pat)
                        else
                         UnderLets.UnderLet
                           (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                            x2)%expr_pat
                           (fun
                              v0 : var
                                     (type.base
                                        (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v0)%expr,
                              #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                    | None =>
                        UnderLets.UnderLet
                          (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                           x2)%expr_pat
                          (fun
                             v0 : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                           UnderLets.Base
                             (#(ident.fst)%expr @ ($v0)%expr,
                             #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                    end
                | ($_)%expr =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                      (fun
                         v1 : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v1)%expr,
                         #(ident.snd)%expr @ ($v1)%expr)%expr_pat)
                | _ =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                      (fun
                         v0 : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v0)%expr,
                         #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                end
            | None =>
                UnderLets.UnderLet
                  (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                  (fun v0 : var (type.base (base.type.Z * base.type.Z)%etype)
                   =>
                   UnderLets.Base
                     (#(ident.fst)%expr @ ($v0)%expr,
                     #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
            end
        | ($_)%expr =>
            UnderLets.UnderLet
              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
              (fun v1 : var (type.base (base.type.Z * base.type.Z)%etype) =>
               UnderLets.Base
                 (#(ident.fst)%expr @ ($v1)%expr,
                 #(ident.snd)%expr @ ($v1)%expr)%expr_pat)
        | _ =>
            UnderLets.UnderLet
              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
              (fun v0 : var (type.base (base.type.Z * base.type.Z)%etype) =>
               UnderLets.Base
                 (#(ident.fst)%expr @ ($v0)%expr,
                 #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
        end
    | @expr.App _ _ _ s _ #(idc)%expr_pat x3 =>
        match match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end with
        | Some _ =>
            match x1 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 =>
                    match x2 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args1 =>
                            match
                              s as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (defaults.expr
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)))
                            with
                            | type.base t2 =>
                                fun v : defaults.expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t3 : base.type =>
                                   defaults.expr (type.base t3)) t2
                                  base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (defaults.expr
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)))
                                  (fun
                                     a : option
                                           (defaults.expr (type.base t2) ->
                                            defaults.expr
                                              (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       if args0 <=? 0
                                       then
                                        UnderLets.UnderLet
                                          (#(ident.Z_sub_with_get_borrow)%expr @
                                           x @ x' v @ x2 @
                                           ##((- args0)%Z)%expr)%expr_pat
                                          (fun
                                             v0 : var
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)
                                           =>
                                           UnderLets.Base
                                             (#(ident.fst)%expr @ ($v0)%expr,
                                             (-
                                              (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                       else
                                        match
                                          s as t3
                                          return
                                            (Compile.value' false t3 ->
                                             UnderLets.UnderLets base.type
                                               ident var
                                               (defaults.expr
                                                  (type.base
                                                     (base.type.Z *
                                                      base.type.Z)%etype)))
                                        with
                                        | type.base t3 =>
                                            fun
                                              v0 : defaults.expr
                                                     (type.base t3) =>
                                            base.try_make_transport_cps
                                              (fun t4 : base.type =>
                                               defaults.expr (type.base t4))
                                              t3 base.type.Z
                                              (UnderLets.UnderLets base.type
                                                 ident var
                                                 (defaults.expr
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)))
                                              (fun
                                                 a0 : option
                                                        (defaults.expr
                                                           (type.base t3) ->
                                                         defaults.expr
                                                           (type.base
                                                              base.type.Z))
                                               =>
                                               match a0 with
                                               | Some x'0 =>
                                                   if args1 <=? 0
                                                   then
                                                    UnderLets.UnderLet
                                                      (#(ident.Z_sub_with_get_borrow)%expr @
                                                       x @ x'0 v0 @ x1 @
                                                       ##((- args1)%Z)%expr)%expr_pat
                                                      (fun
                                                         v1 : var
                                                                (type.base
                                                                   (base.type.Z *
                                                                    base.type.Z)%etype)
                                                       =>
                                                       UnderLets.Base
                                                         (#(ident.fst)%expr @
                                                          ($v1)%expr,
                                                         (-
                                                          (#(ident.snd)%expr @
                                                           $v1)%expr_pat)%expr)%expr_pat)
                                                   else
                                                    if
                                                     (args0 =? 0) &&
                                                     (args1 =? 0)
                                                    then
                                                     UnderLets.UnderLet
                                                       (#(ident.Z_add_with_get_carry)%expr @
                                                        x @ x0 @
                                                        ##(args0)%expr @
                                                        ##(args1)%expr)%expr_pat
                                                       (fun
                                                          v1 : var
                                                                 (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                        =>
                                                        UnderLets.Base
                                                          (#(ident.fst)%expr @
                                                           ($v1)%expr,
                                                          ##(0)%expr)%expr_pat)
                                                    else
                                                     UnderLets.UnderLet
                                                       (#(ident.Z_add_with_get_carry)%expr @
                                                        x @ x0 @ x1 @ x2)%expr_pat
                                                       (fun
                                                          v1 : var
                                                                 (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                        =>
                                                        UnderLets.Base
                                                          (#(ident.fst)%expr @
                                                           ($v1)%expr,
                                                          #(ident.snd)%expr @
                                                          ($v1)%expr)%expr_pat)
                                               | None =>
                                                   UnderLets.Base
                                                     (#(ident.Z_add_with_get_carry)%expr @
                                                      x @ x0 @ x1 @ x2)%expr_pat
                                               end)
                                        | (s0 -> d0)%ptype =>
                                            fun
                                              _ : Compile.value' false s0 ->
                                                  Compile.value' true d0 =>
                                            UnderLets.Base
                                              (#(ident.Z_add_with_get_carry)%expr @
                                               x @ x0 @ x1 @ x2)%expr_pat
                                        end (Compile.reflect x3)
                                   | None =>
                                       UnderLets.Base
                                         (#(ident.Z_add_with_get_carry)%expr @
                                          x @ x0 @ x1 @ x2)%expr_pat
                                   end)
                            | (s0 -> d0)%ptype =>
                                fun
                                  _ : Compile.value' false s0 ->
                                      Compile.value' true d0 =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry)%expr @ x @
                                   x0 @ x1 @ x2)%expr_pat
                            end (Compile.reflect x3)
                        | None =>
                            match
                              s as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (defaults.expr
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)))
                            with
                            | type.base t2 =>
                                fun v : defaults.expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t3 : base.type =>
                                   defaults.expr (type.base t3)) t2
                                  base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (defaults.expr
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)))
                                  (fun
                                     a : option
                                           (defaults.expr (type.base t2) ->
                                            defaults.expr
                                              (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       if args0 <=? 0
                                       then
                                        UnderLets.UnderLet
                                          (#(ident.Z_sub_with_get_borrow)%expr @
                                           x @ x' v @ x2 @
                                           ##((- args0)%Z)%expr)%expr_pat
                                          (fun
                                             v0 : var
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)
                                           =>
                                           UnderLets.Base
                                             (#(ident.fst)%expr @ ($v0)%expr,
                                             (-
                                              (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                       else
                                        UnderLets.UnderLet
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ x1 @ x2)%expr_pat
                                          (fun
                                             v0 : var
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)
                                           =>
                                           UnderLets.Base
                                             (#(ident.fst)%expr @ ($v0)%expr,
                                             #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                                   | None =>
                                       UnderLets.Base
                                         (#(ident.Z_add_with_get_carry)%expr @
                                          x @ x0 @ x1 @ x2)%expr_pat
                                   end)
                            | (s0 -> d0)%ptype =>
                                fun
                                  _ : Compile.value' false s0 ->
                                      Compile.value' true d0 =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry)%expr @ x @
                                   x0 @ x1 @ x2)%expr_pat
                            end (Compile.reflect x3)
                        end
                    | ($_)%expr =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (defaults.expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v0 : defaults.expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t3 : base.type =>
                               defaults.expr (type.base t3)) t2 base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (defaults.expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (defaults.expr (type.base t2) ->
                                        defaults.expr (type.base base.type.Z))
                               =>
                               match a with
                               | Some x' =>
                                   if args0 <=? 0
                                   then
                                    UnderLets.UnderLet
                                      (#(ident.Z_sub_with_get_borrow)%expr @
                                       x @ x' v0 @ x2 @ ##((- args0)%Z)%expr)%expr_pat
                                      (fun
                                         v1 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v1)%expr,
                                         (-
                                          (#(ident.snd)%expr @ $v1)%expr_pat)%expr)%expr_pat)
                                   else
                                    UnderLets.UnderLet
                                      (#(ident.Z_add_with_get_carry)%expr @ x @
                                       x0 @ x1 @ x2)%expr_pat
                                      (fun
                                         v1 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v1)%expr,
                                         #(ident.snd)%expr @ ($v1)%expr)%expr_pat)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry)%expr @ x @
                                      x0 @ x1 @ x2)%expr_pat
                               end)
                        | (s0 -> d0)%ptype =>
                            fun
                              _ : Compile.value' false s0 ->
                                  Compile.value' true d0 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                               x1 @ x2)%expr_pat
                        end (Compile.reflect x3)
                    | @expr.Abs _ _ _ _ _ _ =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (defaults.expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : defaults.expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type =>
                               defaults.expr (type.base t1)) t2 base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (defaults.expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (defaults.expr (type.base t2) ->
                                        defaults.expr (type.base base.type.Z))
                               =>
                               match a with
                               | Some x' =>
                                   if args0 <=? 0
                                   then
                                    UnderLets.UnderLet
                                      (#(ident.Z_sub_with_get_borrow)%expr @
                                       x @ x' v @ x2 @ ##((- args0)%Z)%expr)%expr_pat
                                      (fun
                                         v0 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v0)%expr,
                                         (-
                                          (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                   else
                                    UnderLets.UnderLet
                                      (#(ident.Z_add_with_get_carry)%expr @ x @
                                       x0 @ x1 @ x2)%expr_pat
                                      (fun
                                         v0 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v0)%expr,
                                         #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry)%expr @ x @
                                      x0 @ x1 @ x2)%expr_pat
                               end)
                        | (s1 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                               x1 @ x2)%expr_pat
                        end (Compile.reflect x3)
                    | @expr.App _ _ _ s0 _ #(idc1)%expr_pat x4 =>
                        match
                          match idc1 with
                          | ident.Z_opp => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match
                              s as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (defaults.expr
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)))
                            with
                            | type.base t2 =>
                                fun v : defaults.expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t3 : base.type =>
                                   defaults.expr (type.base t3)) t2
                                  base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (defaults.expr
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)))
                                  (fun
                                     a : option
                                           (defaults.expr (type.base t2) ->
                                            defaults.expr
                                              (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       match
                                         s0 as t3
                                         return
                                           (Compile.value' false t3 ->
                                            UnderLets.UnderLets base.type
                                              ident var
                                              (defaults.expr
                                                 (type.base
                                                    (base.type.Z *
                                                     base.type.Z)%etype)))
                                       with
                                       | type.base t3 =>
                                           fun
                                             v0 : defaults.expr
                                                    (type.base t3) =>
                                           base.try_make_transport_cps
                                             (fun t4 : base.type =>
                                              defaults.expr (type.base t4))
                                             t3 base.type.Z
                                             (UnderLets.UnderLets base.type
                                                ident var
                                                (defaults.expr
                                                   (type.base
                                                      (base.type.Z *
                                                       base.type.Z)%etype)))
                                             (fun
                                                a0 : option
                                                       (defaults.expr
                                                          (type.base t3) ->
                                                        defaults.expr
                                                          (type.base
                                                             base.type.Z)) =>
                                              match a0 with
                                              | Some x'0 =>
                                                  UnderLets.UnderLet
                                                    (#(ident.Z_sub_with_get_borrow)%expr @
                                                     x @ x' v @ x1 @ 
                                                     x'0 v0)%expr_pat
                                                    (fun
                                                       v1 : var
                                                              (type.base
                                                                 (base.type.Z *
                                                                  base.type.Z)%etype)
                                                     =>
                                                     UnderLets.Base
                                                       (#(ident.fst)%expr @
                                                        ($v1)%expr,
                                                       (-
                                                        (#(ident.snd)%expr @
                                                         $v1)%expr_pat)%expr)%expr_pat)
                                              | None =>
                                                  UnderLets.Base
                                                    (#(ident.Z_add_with_get_carry)%expr @
                                                     x @ x0 @ x1 @ x2)%expr_pat
                                              end)
                                       | (s1 -> d1)%ptype =>
                                           fun
                                             _ : Compile.value' false s1 ->
                                                 Compile.value' true d1 =>
                                           UnderLets.Base
                                             (#(ident.Z_add_with_get_carry)%expr @
                                              x @ x0 @ x1 @ x2)%expr_pat
                                       end (Compile.reflect x4)
                                   | None =>
                                       UnderLets.Base
                                         (#(ident.Z_add_with_get_carry)%expr @
                                          x @ x0 @ x1 @ x2)%expr_pat
                                   end)
                            | (s1 -> d1)%ptype =>
                                fun
                                  _ : Compile.value' false s1 ->
                                      Compile.value' true d1 =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry)%expr @ x @
                                   x0 @ x1 @ x2)%expr_pat
                            end (Compile.reflect x3)
                        | None =>
                            match
                              s as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (defaults.expr
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)))
                            with
                            | type.base t2 =>
                                fun v : defaults.expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t3 : base.type =>
                                   defaults.expr (type.base t3)) t2
                                  base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (defaults.expr
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)))
                                  (fun
                                     a : option
                                           (defaults.expr (type.base t2) ->
                                            defaults.expr
                                              (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       if args0 <=? 0
                                       then
                                        UnderLets.UnderLet
                                          (#(ident.Z_sub_with_get_borrow)%expr @
                                           x @ x' v @ x2 @
                                           ##((- args0)%Z)%expr)%expr_pat
                                          (fun
                                             v0 : var
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)
                                           =>
                                           UnderLets.Base
                                             (#(ident.fst)%expr @ ($v0)%expr,
                                             (-
                                              (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                       else
                                        UnderLets.UnderLet
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ x1 @ x2)%expr_pat
                                          (fun
                                             v0 : var
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)
                                           =>
                                           UnderLets.Base
                                             (#(ident.fst)%expr @ ($v0)%expr,
                                             #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                                   | None =>
                                       UnderLets.Base
                                         (#(ident.Z_add_with_get_carry)%expr @
                                          x @ x0 @ x1 @ x2)%expr_pat
                                   end)
                            | (s1 -> d1)%ptype =>
                                fun
                                  _ : Compile.value' false s1 ->
                                      Compile.value' true d1 =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry)%expr @ x @
                                   x0 @ x1 @ x2)%expr_pat
                            end (Compile.reflect x3)
                        end
                    | @expr.App _ _ _ s0 _ ($_)%expr _ =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (defaults.expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v0 : defaults.expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t3 : base.type =>
                               defaults.expr (type.base t3)) t2 base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (defaults.expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (defaults.expr (type.base t2) ->
                                        defaults.expr (type.base base.type.Z))
                               =>
                               match a with
                               | Some x' =>
                                   if args0 <=? 0
                                   then
                                    UnderLets.UnderLet
                                      (#(ident.Z_sub_with_get_borrow)%expr @
                                       x @ x' v0 @ x2 @ ##((- args0)%Z)%expr)%expr_pat
                                      (fun
                                         v1 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v1)%expr,
                                         (-
                                          (#(ident.snd)%expr @ $v1)%expr_pat)%expr)%expr_pat)
                                   else
                                    UnderLets.UnderLet
                                      (#(ident.Z_add_with_get_carry)%expr @ x @
                                       x0 @ x1 @ x2)%expr_pat
                                      (fun
                                         v1 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v1)%expr,
                                         #(ident.snd)%expr @ ($v1)%expr)%expr_pat)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry)%expr @ x @
                                      x0 @ x1 @ x2)%expr_pat
                               end)
                        | (s1 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                               x1 @ x2)%expr_pat
                        end (Compile.reflect x3)
                    | @expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ |
                      @expr.App _ _ _ s0 _ (_ @ _)%expr_pat _ =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (defaults.expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : defaults.expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type =>
                               defaults.expr (type.base t1)) t2 base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (defaults.expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (defaults.expr (type.base t2) ->
                                        defaults.expr (type.base base.type.Z))
                               =>
                               match a with
                               | Some x' =>
                                   if args0 <=? 0
                                   then
                                    UnderLets.UnderLet
                                      (#(ident.Z_sub_with_get_borrow)%expr @
                                       x @ x' v @ x2 @ ##((- args0)%Z)%expr)%expr_pat
                                      (fun
                                         v0 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v0)%expr,
                                         (-
                                          (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                   else
                                    UnderLets.UnderLet
                                      (#(ident.Z_add_with_get_carry)%expr @ x @
                                       x0 @ x1 @ x2)%expr_pat
                                      (fun
                                         v0 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v0)%expr,
                                         #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry)%expr @ x @
                                      x0 @ x1 @ x2)%expr_pat
                               end)
                        | (s2 -> d2)%ptype =>
                            fun
                              _ : Compile.value' false s2 ->
                                  Compile.value' true d2 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                               x1 @ x2)%expr_pat
                        end (Compile.reflect x3)
                    | @expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (defaults.expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : defaults.expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type =>
                               defaults.expr (type.base t1)) t2 base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (defaults.expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (defaults.expr (type.base t2) ->
                                        defaults.expr (type.base base.type.Z))
                               =>
                               match a with
                               | Some x' =>
                                   if args0 <=? 0
                                   then
                                    UnderLets.UnderLet
                                      (#(ident.Z_sub_with_get_borrow)%expr @
                                       x @ x' v @ x2 @ ##((- args0)%Z)%expr)%expr_pat
                                      (fun
                                         v0 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v0)%expr,
                                         (-
                                          (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                   else
                                    UnderLets.UnderLet
                                      (#(ident.Z_add_with_get_carry)%expr @ x @
                                       x0 @ x1 @ x2)%expr_pat
                                      (fun
                                         v0 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v0)%expr,
                                         #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry)%expr @ x @
                                      x0 @ x1 @ x2)%expr_pat
                               end)
                        | (s1 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                               x1 @ x2)%expr_pat
                        end (Compile.reflect x3)
                    | @expr.LetIn _ _ _ _ _ _ _ =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (defaults.expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : defaults.expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type =>
                               defaults.expr (type.base t1)) t2 base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (defaults.expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (defaults.expr (type.base t2) ->
                                        defaults.expr (type.base base.type.Z))
                               =>
                               match a with
                               | Some x' =>
                                   if args0 <=? 0
                                   then
                                    UnderLets.UnderLet
                                      (#(ident.Z_sub_with_get_borrow)%expr @
                                       x @ x' v @ x2 @ ##((- args0)%Z)%expr)%expr_pat
                                      (fun
                                         v0 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v0)%expr,
                                         (-
                                          (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                   else
                                    UnderLets.UnderLet
                                      (#(ident.Z_add_with_get_carry)%expr @ x @
                                       x0 @ x1 @ x2)%expr_pat
                                      (fun
                                         v0 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v0)%expr,
                                         #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry)%expr @ x @
                                      x0 @ x1 @ x2)%expr_pat
                               end)
                        | (s0 -> d0)%ptype =>
                            fun
                              _ : Compile.value' false s0 ->
                                  Compile.value' true d0 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                               x1 @ x2)%expr_pat
                        end (Compile.reflect x3)
                    end
                | None =>
                    match x2 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args0 =>
                            match
                              s as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (defaults.expr
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)))
                            with
                            | type.base t2 =>
                                fun v : defaults.expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t3 : base.type =>
                                   defaults.expr (type.base t3)) t2
                                  base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (defaults.expr
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)))
                                  (fun
                                     a : option
                                           (defaults.expr (type.base t2) ->
                                            defaults.expr
                                              (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       if args0 <=? 0
                                       then
                                        UnderLets.UnderLet
                                          (#(ident.Z_sub_with_get_borrow)%expr @
                                           x @ x' v @ x1 @
                                           ##((- args0)%Z)%expr)%expr_pat
                                          (fun
                                             v0 : var
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)
                                           =>
                                           UnderLets.Base
                                             (#(ident.fst)%expr @ ($v0)%expr,
                                             (-
                                              (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                       else
                                        UnderLets.UnderLet
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ x1 @ x2)%expr_pat
                                          (fun
                                             v0 : var
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)
                                           =>
                                           UnderLets.Base
                                             (#(ident.fst)%expr @ ($v0)%expr,
                                             #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                                   | None =>
                                       UnderLets.Base
                                         (#(ident.Z_add_with_get_carry)%expr @
                                          x @ x0 @ x1 @ x2)%expr_pat
                                   end)
                            | (s0 -> d0)%ptype =>
                                fun
                                  _ : Compile.value' false s0 ->
                                      Compile.value' true d0 =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry)%expr @ x @
                                   x0 @ x1 @ x2)%expr_pat
                            end (Compile.reflect x3)
                        | None =>
                            UnderLets.UnderLet
                              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                               x1 @ x2)%expr_pat
                              (fun
                                 v : var
                                       (type.base
                                          (base.type.Z * base.type.Z)%etype)
                               =>
                               UnderLets.Base
                                 (#(ident.fst)%expr @ ($v)%expr,
                                 #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                        end
                    | ($_)%expr =>
                        UnderLets.UnderLet
                          (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                           x2)%expr_pat
                          (fun
                             v0 : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                           UnderLets.Base
                             (#(ident.fst)%expr @ ($v0)%expr,
                             #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                    | @expr.App _ _ _ s0 _ #(idc1)%expr_pat x4 =>
                        match
                          match idc1 with
                          | ident.Z_opp => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match
                              s as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (defaults.expr
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)))
                            with
                            | type.base t2 =>
                                fun v : defaults.expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t3 : base.type =>
                                   defaults.expr (type.base t3)) t2
                                  base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (defaults.expr
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)))
                                  (fun
                                     a : option
                                           (defaults.expr (type.base t2) ->
                                            defaults.expr
                                              (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       match
                                         s0 as t3
                                         return
                                           (Compile.value' false t3 ->
                                            UnderLets.UnderLets base.type
                                              ident var
                                              (defaults.expr
                                                 (type.base
                                                    (base.type.Z *
                                                     base.type.Z)%etype)))
                                       with
                                       | type.base t3 =>
                                           fun
                                             v0 : defaults.expr
                                                    (type.base t3) =>
                                           base.try_make_transport_cps
                                             (fun t4 : base.type =>
                                              defaults.expr (type.base t4))
                                             t3 base.type.Z
                                             (UnderLets.UnderLets base.type
                                                ident var
                                                (defaults.expr
                                                   (type.base
                                                      (base.type.Z *
                                                       base.type.Z)%etype)))
                                             (fun
                                                a0 : option
                                                       (defaults.expr
                                                          (type.base t3) ->
                                                        defaults.expr
                                                          (type.base
                                                             base.type.Z)) =>
                                              match a0 with
                                              | Some x'0 =>
                                                  UnderLets.UnderLet
                                                    (#(ident.Z_sub_with_get_borrow)%expr @
                                                     x @ x' v @ x1 @ 
                                                     x'0 v0)%expr_pat
                                                    (fun
                                                       v1 : var
                                                              (type.base
                                                                 (base.type.Z *
                                                                  base.type.Z)%etype)
                                                     =>
                                                     UnderLets.Base
                                                       (#(ident.fst)%expr @
                                                        ($v1)%expr,
                                                       (-
                                                        (#(ident.snd)%expr @
                                                         $v1)%expr_pat)%expr)%expr_pat)
                                              | None =>
                                                  UnderLets.Base
                                                    (#(ident.Z_add_with_get_carry)%expr @
                                                     x @ x0 @ x1 @ x2)%expr_pat
                                              end)
                                       | (s1 -> d1)%ptype =>
                                           fun
                                             _ : Compile.value' false s1 ->
                                                 Compile.value' true d1 =>
                                           UnderLets.Base
                                             (#(ident.Z_add_with_get_carry)%expr @
                                              x @ x0 @ x1 @ x2)%expr_pat
                                       end (Compile.reflect x4)
                                   | None =>
                                       UnderLets.Base
                                         (#(ident.Z_add_with_get_carry)%expr @
                                          x @ x0 @ x1 @ x2)%expr_pat
                                   end)
                            | (s1 -> d1)%ptype =>
                                fun
                                  _ : Compile.value' false s1 ->
                                      Compile.value' true d1 =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry)%expr @ x @
                                   x0 @ x1 @ x2)%expr_pat
                            end (Compile.reflect x3)
                        | None =>
                            UnderLets.UnderLet
                              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                               x1 @ x2)%expr_pat
                              (fun
                                 v : var
                                       (type.base
                                          (base.type.Z * base.type.Z)%etype)
                               =>
                               UnderLets.Base
                                 (#(ident.fst)%expr @ ($v)%expr,
                                 #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                        end
                    | @expr.App _ _ _ s0 _ ($_)%expr _ =>
                        UnderLets.UnderLet
                          (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                           x2)%expr_pat
                          (fun
                             v0 : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                           UnderLets.Base
                             (#(ident.fst)%expr @ ($v0)%expr,
                             #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                    | @expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ |
                      @expr.App _ _ _ s0 _ (_ @ _)%expr_pat _ | @expr.App _ _
                      _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
                        UnderLets.UnderLet
                          (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                           x2)%expr_pat
                          (fun
                             v : var
                                   (type.base
                                      (base.type.Z * base.type.Z)%etype) =>
                           UnderLets.Base
                             (#(ident.fst)%expr @ ($v)%expr,
                             #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    | _ =>
                        UnderLets.UnderLet
                          (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                           x2)%expr_pat
                          (fun
                             v : var
                                   (type.base
                                      (base.type.Z * base.type.Z)%etype) =>
                           UnderLets.Base
                             (#(ident.fst)%expr @ ($v)%expr,
                             #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    end
                end
            | ($_)%expr =>
                match x2 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t2 v0 =>
                          match
                            t2 as t3 return (base.base_interp t3 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v1 : Z => Some v1
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v0
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (defaults.expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v0 : defaults.expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t3 : base.type =>
                               defaults.expr (type.base t3)) t2 base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (defaults.expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (defaults.expr (type.base t2) ->
                                        defaults.expr (type.base base.type.Z))
                               =>
                               match a with
                               | Some x' =>
                                   if args0 <=? 0
                                   then
                                    UnderLets.UnderLet
                                      (#(ident.Z_sub_with_get_borrow)%expr @
                                       x @ x' v0 @ x1 @ ##((- args0)%Z)%expr)%expr_pat
                                      (fun
                                         v1 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v1)%expr,
                                         (-
                                          (#(ident.snd)%expr @ $v1)%expr_pat)%expr)%expr_pat)
                                   else
                                    UnderLets.UnderLet
                                      (#(ident.Z_add_with_get_carry)%expr @ x @
                                       x0 @ x1 @ x2)%expr_pat
                                      (fun
                                         v1 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v1)%expr,
                                         #(ident.snd)%expr @ ($v1)%expr)%expr_pat)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry)%expr @ x @
                                      x0 @ x1 @ x2)%expr_pat
                               end)
                        | (s0 -> d0)%ptype =>
                            fun
                              _ : Compile.value' false s0 ->
                                  Compile.value' true d0 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                               x1 @ x2)%expr_pat
                        end (Compile.reflect x3)
                    | None =>
                        UnderLets.UnderLet
                          (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                           x2)%expr_pat
                          (fun
                             v0 : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                           UnderLets.Base
                             (#(ident.fst)%expr @ ($v0)%expr,
                             #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                    end
                | ($_)%expr =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                      (fun
                         v1 : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v1)%expr,
                         #(ident.snd)%expr @ ($v1)%expr)%expr_pat)
                | @expr.App _ _ _ s0 _ #(idc0)%expr_pat x4 =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (defaults.expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v0 : defaults.expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t3 : base.type =>
                               defaults.expr (type.base t3)) t2 base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (defaults.expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (defaults.expr (type.base t2) ->
                                        defaults.expr (type.base base.type.Z))
                               =>
                               match a with
                               | Some x' =>
                                   match
                                     s0 as t3
                                     return
                                       (Compile.value' false t3 ->
                                        UnderLets.UnderLets base.type ident
                                          var
                                          (defaults.expr
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)))
                                   with
                                   | type.base t3 =>
                                       fun v1 : defaults.expr (type.base t3)
                                       =>
                                       base.try_make_transport_cps
                                         (fun t4 : base.type =>
                                          defaults.expr (type.base t4)) t3
                                         base.type.Z
                                         (UnderLets.UnderLets base.type ident
                                            var
                                            (defaults.expr
                                               (type.base
                                                  (base.type.Z * base.type.Z)%etype)))
                                         (fun
                                            a0 : option
                                                   (defaults.expr
                                                      (type.base t3) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                          =>
                                          match a0 with
                                          | Some x'0 =>
                                              UnderLets.UnderLet
                                                (#(ident.Z_sub_with_get_borrow)%expr @
                                                 x @ x' v0 @ x1 @ x'0 v1)%expr_pat
                                                (fun
                                                   v2 : var
                                                          (type.base
                                                             (base.type.Z *
                                                              base.type.Z)%etype)
                                                 =>
                                                 UnderLets.Base
                                                   (#(ident.fst)%expr @
                                                    ($v2)%expr,
                                                   (-
                                                    (#(ident.snd)%expr @ $v2)%expr_pat)%expr)%expr_pat)
                                          | None =>
                                              UnderLets.Base
                                                (#(ident.Z_add_with_get_carry)%expr @
                                                 x @ x0 @ x1 @ x2)%expr_pat
                                          end)
                                   | (s1 -> d1)%ptype =>
                                       fun
                                         _ : Compile.value' false s1 ->
                                             Compile.value' true d1 =>
                                       UnderLets.Base
                                         (#(ident.Z_add_with_get_carry)%expr @
                                          x @ x0 @ x1 @ x2)%expr_pat
                                   end (Compile.reflect x4)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry)%expr @ x @
                                      x0 @ x1 @ x2)%expr_pat
                               end)
                        | (s1 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                               x1 @ x2)%expr_pat
                        end (Compile.reflect x3)
                    | None =>
                        UnderLets.UnderLet
                          (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                           x2)%expr_pat
                          (fun
                             v0 : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                           UnderLets.Base
                             (#(ident.fst)%expr @ ($v0)%expr,
                             #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                    end
                | @expr.App _ _ _ s0 _ ($_)%expr _ =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                      (fun
                         v1 : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v1)%expr,
                         #(ident.snd)%expr @ ($v1)%expr)%expr_pat)
                | @expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App
                  _ _ _ s0 _ (_ @ _)%expr_pat _ | @expr.App _ _ _ s0 _
                  (@expr.LetIn _ _ _ _ _ _ _) _ =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                      (fun
                         v0 : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v0)%expr,
                         #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                | _ =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                      (fun
                         v0 : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v0)%expr,
                         #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                end
            | @expr.Abs _ _ _ _ _ _ =>
                match x2 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t1 v =>
                          match
                            t1 as t2 return (base.base_interp t2 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v0 : Z => Some v0
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (defaults.expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : defaults.expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type =>
                               defaults.expr (type.base t1)) t2 base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (defaults.expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (defaults.expr (type.base t2) ->
                                        defaults.expr (type.base base.type.Z))
                               =>
                               match a with
                               | Some x' =>
                                   if args0 <=? 0
                                   then
                                    UnderLets.UnderLet
                                      (#(ident.Z_sub_with_get_borrow)%expr @
                                       x @ x' v @ x1 @ ##((- args0)%Z)%expr)%expr_pat
                                      (fun
                                         v0 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v0)%expr,
                                         (-
                                          (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                   else
                                    UnderLets.UnderLet
                                      (#(ident.Z_add_with_get_carry)%expr @ x @
                                       x0 @ x1 @ x2)%expr_pat
                                      (fun
                                         v0 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v0)%expr,
                                         #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry)%expr @ x @
                                      x0 @ x1 @ x2)%expr_pat
                               end)
                        | (s1 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                               x1 @ x2)%expr_pat
                        end (Compile.reflect x3)
                    | None =>
                        UnderLets.UnderLet
                          (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                           x2)%expr_pat
                          (fun
                             v : var
                                   (type.base
                                      (base.type.Z * base.type.Z)%etype) =>
                           UnderLets.Base
                             (#(ident.fst)%expr @ ($v)%expr,
                             #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    end
                | ($_)%expr =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                      (fun
                         v0 : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v0)%expr,
                         #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                | @expr.App _ _ _ s1 _ #(idc0)%expr_pat x4 =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (defaults.expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : defaults.expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type =>
                               defaults.expr (type.base t1)) t2 base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (defaults.expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (defaults.expr (type.base t2) ->
                                        defaults.expr (type.base base.type.Z))
                               =>
                               match a with
                               | Some x' =>
                                   match
                                     s1 as t3
                                     return
                                       (Compile.value' false t3 ->
                                        UnderLets.UnderLets base.type ident
                                          var
                                          (defaults.expr
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)))
                                   with
                                   | type.base t3 =>
                                       fun v0 : defaults.expr (type.base t3)
                                       =>
                                       base.try_make_transport_cps
                                         (fun t1 : base.type =>
                                          defaults.expr (type.base t1)) t3
                                         base.type.Z
                                         (UnderLets.UnderLets base.type ident
                                            var
                                            (defaults.expr
                                               (type.base
                                                  (base.type.Z * base.type.Z)%etype)))
                                         (fun
                                            a0 : option
                                                   (defaults.expr
                                                      (type.base t3) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                          =>
                                          match a0 with
                                          | Some x'0 =>
                                              UnderLets.UnderLet
                                                (#(ident.Z_sub_with_get_borrow)%expr @
                                                 x @ x' v @ x1 @ x'0 v0)%expr_pat
                                                (fun
                                                   v1 : var
                                                          (type.base
                                                             (base.type.Z *
                                                              base.type.Z)%etype)
                                                 =>
                                                 UnderLets.Base
                                                   (#(ident.fst)%expr @
                                                    ($v1)%expr,
                                                   (-
                                                    (#(ident.snd)%expr @ $v1)%expr_pat)%expr)%expr_pat)
                                          | None =>
                                              UnderLets.Base
                                                (#(ident.Z_add_with_get_carry)%expr @
                                                 x @ x0 @ x1 @ x2)%expr_pat
                                          end)
                                   | (s2 -> d2)%ptype =>
                                       fun
                                         _ : Compile.value' false s2 ->
                                             Compile.value' true d2 =>
                                       UnderLets.Base
                                         (#(ident.Z_add_with_get_carry)%expr @
                                          x @ x0 @ x1 @ x2)%expr_pat
                                   end (Compile.reflect x4)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry)%expr @ x @
                                      x0 @ x1 @ x2)%expr_pat
                               end)
                        | (s2 -> d2)%ptype =>
                            fun
                              _ : Compile.value' false s2 ->
                                  Compile.value' true d2 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                               x1 @ x2)%expr_pat
                        end (Compile.reflect x3)
                    | None =>
                        UnderLets.UnderLet
                          (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                           x2)%expr_pat
                          (fun
                             v : var
                                   (type.base
                                      (base.type.Z * base.type.Z)%etype) =>
                           UnderLets.Base
                             (#(ident.fst)%expr @ ($v)%expr,
                             #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    end
                | @expr.App _ _ _ s1 _ ($_)%expr _ =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                      (fun
                         v0 : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v0)%expr,
                         #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                | @expr.App _ _ _ s1 _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App
                  _ _ _ s1 _ (_ @ _)%expr_pat _ | @expr.App _ _ _ s1 _
                  (@expr.LetIn _ _ _ _ _ _ _) _ =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                      (fun
                         v : var
                               (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v)%expr,
                         #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                | _ =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                      (fun
                         v : var
                               (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v)%expr,
                         #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                end
            | @expr.App _ _ _ s0 _ #(idc0)%expr_pat x4 =>
                match
                  match idc0 with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (defaults.expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v : defaults.expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => defaults.expr (type.base t1))
                          t2 base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (defaults.expr (type.base t2) ->
                                    defaults.expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               match
                                 s0 as t3
                                 return
                                   (Compile.value' false t3 ->
                                    UnderLets.UnderLets base.type ident var
                                      (defaults.expr
                                         (type.base
                                            (base.type.Z * base.type.Z)%etype)))
                               with
                               | type.base t3 =>
                                   fun v0 : defaults.expr (type.base t3) =>
                                   base.try_make_transport_cps
                                     (fun t1 : base.type =>
                                      defaults.expr (type.base t1)) t3
                                     base.type.Z
                                     (UnderLets.UnderLets base.type ident var
                                        (defaults.expr
                                           (type.base
                                              (base.type.Z * base.type.Z)%etype)))
                                     (fun
                                        a0 : option
                                               (defaults.expr (type.base t3) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                      match a0 with
                                      | Some x'0 =>
                                          UnderLets.UnderLet
                                            (#(ident.Z_sub_with_get_borrow)%expr @
                                             x @ x' v @ x2 @ x'0 v0)%expr_pat
                                            (fun
                                               v1 : var
                                                      (type.base
                                                         (base.type.Z *
                                                          base.type.Z)%etype)
                                             =>
                                             UnderLets.Base
                                               (#(ident.fst)%expr @
                                                ($v1)%expr,
                                               (-
                                                (#(ident.snd)%expr @ $v1)%expr_pat)%expr)%expr_pat)
                                      | None =>
                                          UnderLets.Base
                                            (#(ident.Z_add_with_get_carry)%expr @
                                             x @ x0 @ x1 @ x2)%expr_pat
                                      end)
                               | (s1 -> d1)%ptype =>
                                   fun
                                     _ : Compile.value' false s1 ->
                                         Compile.value' true d1 =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry)%expr @ x @
                                      x0 @ x1 @ x2)%expr_pat
                               end (Compile.reflect x4)
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                  x1 @ x2)%expr_pat
                           end)
                    | (s1 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d1 =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                           x2)%expr_pat
                    end (Compile.reflect x3)
                | None =>
                    match x2 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args0 =>
                            match
                              s as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (defaults.expr
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)))
                            with
                            | type.base t2 =>
                                fun v : defaults.expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t3 : base.type =>
                                   defaults.expr (type.base t3)) t2
                                  base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (defaults.expr
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)))
                                  (fun
                                     a : option
                                           (defaults.expr (type.base t2) ->
                                            defaults.expr
                                              (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       if args0 <=? 0
                                       then
                                        UnderLets.UnderLet
                                          (#(ident.Z_sub_with_get_borrow)%expr @
                                           x @ x' v @ x1 @
                                           ##((- args0)%Z)%expr)%expr_pat
                                          (fun
                                             v0 : var
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)
                                           =>
                                           UnderLets.Base
                                             (#(ident.fst)%expr @ ($v0)%expr,
                                             (-
                                              (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                       else
                                        UnderLets.UnderLet
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ x1 @ x2)%expr_pat
                                          (fun
                                             v0 : var
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)
                                           =>
                                           UnderLets.Base
                                             (#(ident.fst)%expr @ ($v0)%expr,
                                             #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                                   | None =>
                                       UnderLets.Base
                                         (#(ident.Z_add_with_get_carry)%expr @
                                          x @ x0 @ x1 @ x2)%expr_pat
                                   end)
                            | (s1 -> d1)%ptype =>
                                fun
                                  _ : Compile.value' false s1 ->
                                      Compile.value' true d1 =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry)%expr @ x @
                                   x0 @ x1 @ x2)%expr_pat
                            end (Compile.reflect x3)
                        | None =>
                            UnderLets.UnderLet
                              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                               x1 @ x2)%expr_pat
                              (fun
                                 v : var
                                       (type.base
                                          (base.type.Z * base.type.Z)%etype)
                               =>
                               UnderLets.Base
                                 (#(ident.fst)%expr @ ($v)%expr,
                                 #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                        end
                    | ($_)%expr =>
                        UnderLets.UnderLet
                          (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                           x2)%expr_pat
                          (fun
                             v0 : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                           UnderLets.Base
                             (#(ident.fst)%expr @ ($v0)%expr,
                             #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                    | @expr.App _ _ _ s1 _ #(idc1)%expr_pat x5 =>
                        match
                          match idc1 with
                          | ident.Z_opp => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match
                              s as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (defaults.expr
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)))
                            with
                            | type.base t2 =>
                                fun v : defaults.expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t3 : base.type =>
                                   defaults.expr (type.base t3)) t2
                                  base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (defaults.expr
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)))
                                  (fun
                                     a : option
                                           (defaults.expr (type.base t2) ->
                                            defaults.expr
                                              (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       match
                                         s1 as t3
                                         return
                                           (Compile.value' false t3 ->
                                            UnderLets.UnderLets base.type
                                              ident var
                                              (defaults.expr
                                                 (type.base
                                                    (base.type.Z *
                                                     base.type.Z)%etype)))
                                       with
                                       | type.base t3 =>
                                           fun
                                             v0 : defaults.expr
                                                    (type.base t3) =>
                                           base.try_make_transport_cps
                                             (fun t4 : base.type =>
                                              defaults.expr (type.base t4))
                                             t3 base.type.Z
                                             (UnderLets.UnderLets base.type
                                                ident var
                                                (defaults.expr
                                                   (type.base
                                                      (base.type.Z *
                                                       base.type.Z)%etype)))
                                             (fun
                                                a0 : option
                                                       (defaults.expr
                                                          (type.base t3) ->
                                                        defaults.expr
                                                          (type.base
                                                             base.type.Z)) =>
                                              match a0 with
                                              | Some x'0 =>
                                                  UnderLets.UnderLet
                                                    (#(ident.Z_sub_with_get_borrow)%expr @
                                                     x @ x' v @ x1 @ 
                                                     x'0 v0)%expr_pat
                                                    (fun
                                                       v1 : var
                                                              (type.base
                                                                 (base.type.Z *
                                                                  base.type.Z)%etype)
                                                     =>
                                                     UnderLets.Base
                                                       (#(ident.fst)%expr @
                                                        ($v1)%expr,
                                                       (-
                                                        (#(ident.snd)%expr @
                                                         $v1)%expr_pat)%expr)%expr_pat)
                                              | None =>
                                                  UnderLets.Base
                                                    (#(ident.Z_add_with_get_carry)%expr @
                                                     x @ x0 @ x1 @ x2)%expr_pat
                                              end)
                                       | (s2 -> d2)%ptype =>
                                           fun
                                             _ : Compile.value' false s2 ->
                                                 Compile.value' true d2 =>
                                           UnderLets.Base
                                             (#(ident.Z_add_with_get_carry)%expr @
                                              x @ x0 @ x1 @ x2)%expr_pat
                                       end (Compile.reflect x5)
                                   | None =>
                                       UnderLets.Base
                                         (#(ident.Z_add_with_get_carry)%expr @
                                          x @ x0 @ x1 @ x2)%expr_pat
                                   end)
                            | (s2 -> d2)%ptype =>
                                fun
                                  _ : Compile.value' false s2 ->
                                      Compile.value' true d2 =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry)%expr @ x @
                                   x0 @ x1 @ x2)%expr_pat
                            end (Compile.reflect x3)
                        | None =>
                            UnderLets.UnderLet
                              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                               x1 @ x2)%expr_pat
                              (fun
                                 v : var
                                       (type.base
                                          (base.type.Z * base.type.Z)%etype)
                               =>
                               UnderLets.Base
                                 (#(ident.fst)%expr @ ($v)%expr,
                                 #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                        end
                    | @expr.App _ _ _ s1 _ ($_)%expr _ =>
                        UnderLets.UnderLet
                          (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                           x2)%expr_pat
                          (fun
                             v0 : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                           UnderLets.Base
                             (#(ident.fst)%expr @ ($v0)%expr,
                             #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                    | @expr.App _ _ _ s1 _ (@expr.Abs _ _ _ _ _ _) _ |
                      @expr.App _ _ _ s1 _ (_ @ _)%expr_pat _ | @expr.App _ _
                      _ s1 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
                        UnderLets.UnderLet
                          (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                           x2)%expr_pat
                          (fun
                             v : var
                                   (type.base
                                      (base.type.Z * base.type.Z)%etype) =>
                           UnderLets.Base
                             (#(ident.fst)%expr @ ($v)%expr,
                             #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    | _ =>
                        UnderLets.UnderLet
                          (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                           x2)%expr_pat
                          (fun
                             v : var
                                   (type.base
                                      (base.type.Z * base.type.Z)%etype) =>
                           UnderLets.Base
                             (#(ident.fst)%expr @ ($v)%expr,
                             #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    end
                end
            | @expr.App _ _ _ s0 _ ($_)%expr _ =>
                match x2 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t2 v0 =>
                          match
                            t2 as t3 return (base.base_interp t3 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v1 : Z => Some v1
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v0
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (defaults.expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v0 : defaults.expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t3 : base.type =>
                               defaults.expr (type.base t3)) t2 base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (defaults.expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (defaults.expr (type.base t2) ->
                                        defaults.expr (type.base base.type.Z))
                               =>
                               match a with
                               | Some x' =>
                                   if args0 <=? 0
                                   then
                                    UnderLets.UnderLet
                                      (#(ident.Z_sub_with_get_borrow)%expr @
                                       x @ x' v0 @ x1 @ ##((- args0)%Z)%expr)%expr_pat
                                      (fun
                                         v1 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v1)%expr,
                                         (-
                                          (#(ident.snd)%expr @ $v1)%expr_pat)%expr)%expr_pat)
                                   else
                                    UnderLets.UnderLet
                                      (#(ident.Z_add_with_get_carry)%expr @ x @
                                       x0 @ x1 @ x2)%expr_pat
                                      (fun
                                         v1 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v1)%expr,
                                         #(ident.snd)%expr @ ($v1)%expr)%expr_pat)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry)%expr @ x @
                                      x0 @ x1 @ x2)%expr_pat
                               end)
                        | (s1 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                               x1 @ x2)%expr_pat
                        end (Compile.reflect x3)
                    | None =>
                        UnderLets.UnderLet
                          (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                           x2)%expr_pat
                          (fun
                             v0 : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                           UnderLets.Base
                             (#(ident.fst)%expr @ ($v0)%expr,
                             #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                    end
                | ($_)%expr =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                      (fun
                         v1 : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v1)%expr,
                         #(ident.snd)%expr @ ($v1)%expr)%expr_pat)
                | @expr.App _ _ _ s1 _ #(idc0)%expr_pat x5 =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (defaults.expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v0 : defaults.expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t3 : base.type =>
                               defaults.expr (type.base t3)) t2 base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (defaults.expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (defaults.expr (type.base t2) ->
                                        defaults.expr (type.base base.type.Z))
                               =>
                               match a with
                               | Some x' =>
                                   match
                                     s1 as t3
                                     return
                                       (Compile.value' false t3 ->
                                        UnderLets.UnderLets base.type ident
                                          var
                                          (defaults.expr
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)))
                                   with
                                   | type.base t3 =>
                                       fun v1 : defaults.expr (type.base t3)
                                       =>
                                       base.try_make_transport_cps
                                         (fun t4 : base.type =>
                                          defaults.expr (type.base t4)) t3
                                         base.type.Z
                                         (UnderLets.UnderLets base.type ident
                                            var
                                            (defaults.expr
                                               (type.base
                                                  (base.type.Z * base.type.Z)%etype)))
                                         (fun
                                            a0 : option
                                                   (defaults.expr
                                                      (type.base t3) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                          =>
                                          match a0 with
                                          | Some x'0 =>
                                              UnderLets.UnderLet
                                                (#(ident.Z_sub_with_get_borrow)%expr @
                                                 x @ x' v0 @ x1 @ x'0 v1)%expr_pat
                                                (fun
                                                   v2 : var
                                                          (type.base
                                                             (base.type.Z *
                                                              base.type.Z)%etype)
                                                 =>
                                                 UnderLets.Base
                                                   (#(ident.fst)%expr @
                                                    ($v2)%expr,
                                                   (-
                                                    (#(ident.snd)%expr @ $v2)%expr_pat)%expr)%expr_pat)
                                          | None =>
                                              UnderLets.Base
                                                (#(ident.Z_add_with_get_carry)%expr @
                                                 x @ x0 @ x1 @ x2)%expr_pat
                                          end)
                                   | (s2 -> d2)%ptype =>
                                       fun
                                         _ : Compile.value' false s2 ->
                                             Compile.value' true d2 =>
                                       UnderLets.Base
                                         (#(ident.Z_add_with_get_carry)%expr @
                                          x @ x0 @ x1 @ x2)%expr_pat
                                   end (Compile.reflect x5)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry)%expr @ x @
                                      x0 @ x1 @ x2)%expr_pat
                               end)
                        | (s2 -> d2)%ptype =>
                            fun
                              _ : Compile.value' false s2 ->
                                  Compile.value' true d2 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                               x1 @ x2)%expr_pat
                        end (Compile.reflect x3)
                    | None =>
                        UnderLets.UnderLet
                          (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                           x2)%expr_pat
                          (fun
                             v0 : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                           UnderLets.Base
                             (#(ident.fst)%expr @ ($v0)%expr,
                             #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                    end
                | @expr.App _ _ _ s1 _ ($_)%expr _ =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                      (fun
                         v1 : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v1)%expr,
                         #(ident.snd)%expr @ ($v1)%expr)%expr_pat)
                | @expr.App _ _ _ s1 _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App
                  _ _ _ s1 _ (_ @ _)%expr_pat _ | @expr.App _ _ _ s1 _
                  (@expr.LetIn _ _ _ _ _ _ _) _ =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                      (fun
                         v0 : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v0)%expr,
                         #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                | _ =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                      (fun
                         v0 : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v0)%expr,
                         #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                end
            | @expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ =>
                match x2 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t1 v =>
                          match
                            t1 as t2 return (base.base_interp t2 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v0 : Z => Some v0
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (defaults.expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : defaults.expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type =>
                               defaults.expr (type.base t1)) t2 base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (defaults.expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (defaults.expr (type.base t2) ->
                                        defaults.expr (type.base base.type.Z))
                               =>
                               match a with
                               | Some x' =>
                                   if args0 <=? 0
                                   then
                                    UnderLets.UnderLet
                                      (#(ident.Z_sub_with_get_borrow)%expr @
                                       x @ x' v @ x1 @ ##((- args0)%Z)%expr)%expr_pat
                                      (fun
                                         v0 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v0)%expr,
                                         (-
                                          (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                   else
                                    UnderLets.UnderLet
                                      (#(ident.Z_add_with_get_carry)%expr @ x @
                                       x0 @ x1 @ x2)%expr_pat
                                      (fun
                                         v0 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v0)%expr,
                                         #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry)%expr @ x @
                                      x0 @ x1 @ x2)%expr_pat
                               end)
                        | (s2 -> d2)%ptype =>
                            fun
                              _ : Compile.value' false s2 ->
                                  Compile.value' true d2 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                               x1 @ x2)%expr_pat
                        end (Compile.reflect x3)
                    | None =>
                        UnderLets.UnderLet
                          (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                           x2)%expr_pat
                          (fun
                             v : var
                                   (type.base
                                      (base.type.Z * base.type.Z)%etype) =>
                           UnderLets.Base
                             (#(ident.fst)%expr @ ($v)%expr,
                             #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    end
                | ($_)%expr =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                      (fun
                         v0 : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v0)%expr,
                         #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                | @expr.App _ _ _ s2 _ #(idc0)%expr_pat x5 =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (defaults.expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : defaults.expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type =>
                               defaults.expr (type.base t1)) t2 base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (defaults.expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (defaults.expr (type.base t2) ->
                                        defaults.expr (type.base base.type.Z))
                               =>
                               match a with
                               | Some x' =>
                                   match
                                     s2 as t3
                                     return
                                       (Compile.value' false t3 ->
                                        UnderLets.UnderLets base.type ident
                                          var
                                          (defaults.expr
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)))
                                   with
                                   | type.base t3 =>
                                       fun v0 : defaults.expr (type.base t3)
                                       =>
                                       base.try_make_transport_cps
                                         (fun t1 : base.type =>
                                          defaults.expr (type.base t1)) t3
                                         base.type.Z
                                         (UnderLets.UnderLets base.type ident
                                            var
                                            (defaults.expr
                                               (type.base
                                                  (base.type.Z * base.type.Z)%etype)))
                                         (fun
                                            a0 : option
                                                   (defaults.expr
                                                      (type.base t3) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                          =>
                                          match a0 with
                                          | Some x'0 =>
                                              UnderLets.UnderLet
                                                (#(ident.Z_sub_with_get_borrow)%expr @
                                                 x @ x' v @ x1 @ x'0 v0)%expr_pat
                                                (fun
                                                   v1 : var
                                                          (type.base
                                                             (base.type.Z *
                                                              base.type.Z)%etype)
                                                 =>
                                                 UnderLets.Base
                                                   (#(ident.fst)%expr @
                                                    ($v1)%expr,
                                                   (-
                                                    (#(ident.snd)%expr @ $v1)%expr_pat)%expr)%expr_pat)
                                          | None =>
                                              UnderLets.Base
                                                (#(ident.Z_add_with_get_carry)%expr @
                                                 x @ x0 @ x1 @ x2)%expr_pat
                                          end)
                                   | (s3 -> d3)%ptype =>
                                       fun
                                         _ : Compile.value' false s3 ->
                                             Compile.value' true d3 =>
                                       UnderLets.Base
                                         (#(ident.Z_add_with_get_carry)%expr @
                                          x @ x0 @ x1 @ x2)%expr_pat
                                   end (Compile.reflect x5)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry)%expr @ x @
                                      x0 @ x1 @ x2)%expr_pat
                               end)
                        | (s3 -> d3)%ptype =>
                            fun
                              _ : Compile.value' false s3 ->
                                  Compile.value' true d3 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                               x1 @ x2)%expr_pat
                        end (Compile.reflect x3)
                    | None =>
                        UnderLets.UnderLet
                          (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                           x2)%expr_pat
                          (fun
                             v : var
                                   (type.base
                                      (base.type.Z * base.type.Z)%etype) =>
                           UnderLets.Base
                             (#(ident.fst)%expr @ ($v)%expr,
                             #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    end
                | @expr.App _ _ _ s2 _ ($_)%expr _ =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                      (fun
                         v0 : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v0)%expr,
                         #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                | @expr.App _ _ _ s2 _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App
                  _ _ _ s2 _ (_ @ _)%expr_pat _ | @expr.App _ _ _ s2 _
                  (@expr.LetIn _ _ _ _ _ _ _) _ =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                      (fun
                         v : var
                               (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v)%expr,
                         #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                | _ =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                      (fun
                         v : var
                               (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v)%expr,
                         #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                end
            | @expr.App _ _ _ s0 _ (_ @ _)%expr_pat _ =>
                match x2 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t1 v =>
                          match
                            t1 as t2 return (base.base_interp t2 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v0 : Z => Some v0
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (defaults.expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : defaults.expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type =>
                               defaults.expr (type.base t1)) t2 base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (defaults.expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (defaults.expr (type.base t2) ->
                                        defaults.expr (type.base base.type.Z))
                               =>
                               match a with
                               | Some x' =>
                                   if args0 <=? 0
                                   then
                                    UnderLets.UnderLet
                                      (#(ident.Z_sub_with_get_borrow)%expr @
                                       x @ x' v @ x1 @ ##((- args0)%Z)%expr)%expr_pat
                                      (fun
                                         v0 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v0)%expr,
                                         (-
                                          (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                   else
                                    UnderLets.UnderLet
                                      (#(ident.Z_add_with_get_carry)%expr @ x @
                                       x0 @ x1 @ x2)%expr_pat
                                      (fun
                                         v0 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v0)%expr,
                                         #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry)%expr @ x @
                                      x0 @ x1 @ x2)%expr_pat
                               end)
                        | (s2 -> d2)%ptype =>
                            fun
                              _ : Compile.value' false s2 ->
                                  Compile.value' true d2 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                               x1 @ x2)%expr_pat
                        end (Compile.reflect x3)
                    | None =>
                        UnderLets.UnderLet
                          (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                           x2)%expr_pat
                          (fun
                             v : var
                                   (type.base
                                      (base.type.Z * base.type.Z)%etype) =>
                           UnderLets.Base
                             (#(ident.fst)%expr @ ($v)%expr,
                             #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    end
                | ($_)%expr =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                      (fun
                         v0 : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v0)%expr,
                         #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                | @expr.App _ _ _ s2 _ #(idc0)%expr_pat x6 =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (defaults.expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : defaults.expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type =>
                               defaults.expr (type.base t1)) t2 base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (defaults.expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (defaults.expr (type.base t2) ->
                                        defaults.expr (type.base base.type.Z))
                               =>
                               match a with
                               | Some x' =>
                                   match
                                     s2 as t3
                                     return
                                       (Compile.value' false t3 ->
                                        UnderLets.UnderLets base.type ident
                                          var
                                          (defaults.expr
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)))
                                   with
                                   | type.base t3 =>
                                       fun v0 : defaults.expr (type.base t3)
                                       =>
                                       base.try_make_transport_cps
                                         (fun t1 : base.type =>
                                          defaults.expr (type.base t1)) t3
                                         base.type.Z
                                         (UnderLets.UnderLets base.type ident
                                            var
                                            (defaults.expr
                                               (type.base
                                                  (base.type.Z * base.type.Z)%etype)))
                                         (fun
                                            a0 : option
                                                   (defaults.expr
                                                      (type.base t3) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                          =>
                                          match a0 with
                                          | Some x'0 =>
                                              UnderLets.UnderLet
                                                (#(ident.Z_sub_with_get_borrow)%expr @
                                                 x @ x' v @ x1 @ x'0 v0)%expr_pat
                                                (fun
                                                   v1 : var
                                                          (type.base
                                                             (base.type.Z *
                                                              base.type.Z)%etype)
                                                 =>
                                                 UnderLets.Base
                                                   (#(ident.fst)%expr @
                                                    ($v1)%expr,
                                                   (-
                                                    (#(ident.snd)%expr @ $v1)%expr_pat)%expr)%expr_pat)
                                          | None =>
                                              UnderLets.Base
                                                (#(ident.Z_add_with_get_carry)%expr @
                                                 x @ x0 @ x1 @ x2)%expr_pat
                                          end)
                                   | (s3 -> d3)%ptype =>
                                       fun
                                         _ : Compile.value' false s3 ->
                                             Compile.value' true d3 =>
                                       UnderLets.Base
                                         (#(ident.Z_add_with_get_carry)%expr @
                                          x @ x0 @ x1 @ x2)%expr_pat
                                   end (Compile.reflect x6)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry)%expr @ x @
                                      x0 @ x1 @ x2)%expr_pat
                               end)
                        | (s3 -> d3)%ptype =>
                            fun
                              _ : Compile.value' false s3 ->
                                  Compile.value' true d3 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                               x1 @ x2)%expr_pat
                        end (Compile.reflect x3)
                    | None =>
                        UnderLets.UnderLet
                          (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                           x2)%expr_pat
                          (fun
                             v : var
                                   (type.base
                                      (base.type.Z * base.type.Z)%etype) =>
                           UnderLets.Base
                             (#(ident.fst)%expr @ ($v)%expr,
                             #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    end
                | @expr.App _ _ _ s2 _ ($_)%expr _ =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                      (fun
                         v0 : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v0)%expr,
                         #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                | @expr.App _ _ _ s2 _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App
                  _ _ _ s2 _ (_ @ _)%expr_pat _ | @expr.App _ _ _ s2 _
                  (@expr.LetIn _ _ _ _ _ _ _) _ =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                      (fun
                         v : var
                               (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v)%expr,
                         #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                | _ =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                      (fun
                         v : var
                               (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v)%expr,
                         #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                end
            | @expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
                match x2 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t1 v =>
                          match
                            t1 as t2 return (base.base_interp t2 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v0 : Z => Some v0
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (defaults.expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : defaults.expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type =>
                               defaults.expr (type.base t1)) t2 base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (defaults.expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (defaults.expr (type.base t2) ->
                                        defaults.expr (type.base base.type.Z))
                               =>
                               match a with
                               | Some x' =>
                                   if args0 <=? 0
                                   then
                                    UnderLets.UnderLet
                                      (#(ident.Z_sub_with_get_borrow)%expr @
                                       x @ x' v @ x1 @ ##((- args0)%Z)%expr)%expr_pat
                                      (fun
                                         v0 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v0)%expr,
                                         (-
                                          (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                   else
                                    UnderLets.UnderLet
                                      (#(ident.Z_add_with_get_carry)%expr @ x @
                                       x0 @ x1 @ x2)%expr_pat
                                      (fun
                                         v0 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v0)%expr,
                                         #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry)%expr @ x @
                                      x0 @ x1 @ x2)%expr_pat
                               end)
                        | (s1 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                               x1 @ x2)%expr_pat
                        end (Compile.reflect x3)
                    | None =>
                        UnderLets.UnderLet
                          (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                           x2)%expr_pat
                          (fun
                             v : var
                                   (type.base
                                      (base.type.Z * base.type.Z)%etype) =>
                           UnderLets.Base
                             (#(ident.fst)%expr @ ($v)%expr,
                             #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    end
                | ($_)%expr =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                      (fun
                         v0 : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v0)%expr,
                         #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                | @expr.App _ _ _ s1 _ #(idc0)%expr_pat x6 =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (defaults.expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : defaults.expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type =>
                               defaults.expr (type.base t1)) t2 base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (defaults.expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (defaults.expr (type.base t2) ->
                                        defaults.expr (type.base base.type.Z))
                               =>
                               match a with
                               | Some x' =>
                                   match
                                     s1 as t3
                                     return
                                       (Compile.value' false t3 ->
                                        UnderLets.UnderLets base.type ident
                                          var
                                          (defaults.expr
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)))
                                   with
                                   | type.base t3 =>
                                       fun v0 : defaults.expr (type.base t3)
                                       =>
                                       base.try_make_transport_cps
                                         (fun t1 : base.type =>
                                          defaults.expr (type.base t1)) t3
                                         base.type.Z
                                         (UnderLets.UnderLets base.type ident
                                            var
                                            (defaults.expr
                                               (type.base
                                                  (base.type.Z * base.type.Z)%etype)))
                                         (fun
                                            a0 : option
                                                   (defaults.expr
                                                      (type.base t3) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                          =>
                                          match a0 with
                                          | Some x'0 =>
                                              UnderLets.UnderLet
                                                (#(ident.Z_sub_with_get_borrow)%expr @
                                                 x @ x' v @ x1 @ x'0 v0)%expr_pat
                                                (fun
                                                   v1 : var
                                                          (type.base
                                                             (base.type.Z *
                                                              base.type.Z)%etype)
                                                 =>
                                                 UnderLets.Base
                                                   (#(ident.fst)%expr @
                                                    ($v1)%expr,
                                                   (-
                                                    (#(ident.snd)%expr @ $v1)%expr_pat)%expr)%expr_pat)
                                          | None =>
                                              UnderLets.Base
                                                (#(ident.Z_add_with_get_carry)%expr @
                                                 x @ x0 @ x1 @ x2)%expr_pat
                                          end)
                                   | (s2 -> d2)%ptype =>
                                       fun
                                         _ : Compile.value' false s2 ->
                                             Compile.value' true d2 =>
                                       UnderLets.Base
                                         (#(ident.Z_add_with_get_carry)%expr @
                                          x @ x0 @ x1 @ x2)%expr_pat
                                   end (Compile.reflect x6)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry)%expr @ x @
                                      x0 @ x1 @ x2)%expr_pat
                               end)
                        | (s2 -> d2)%ptype =>
                            fun
                              _ : Compile.value' false s2 ->
                                  Compile.value' true d2 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                               x1 @ x2)%expr_pat
                        end (Compile.reflect x3)
                    | None =>
                        UnderLets.UnderLet
                          (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                           x2)%expr_pat
                          (fun
                             v : var
                                   (type.base
                                      (base.type.Z * base.type.Z)%etype) =>
                           UnderLets.Base
                             (#(ident.fst)%expr @ ($v)%expr,
                             #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    end
                | @expr.App _ _ _ s1 _ ($_)%expr _ =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                      (fun
                         v0 : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v0)%expr,
                         #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                | @expr.App _ _ _ s1 _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App
                  _ _ _ s1 _ (_ @ _)%expr_pat _ | @expr.App _ _ _ s1 _
                  (@expr.LetIn _ _ _ _ _ _ _) _ =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                      (fun
                         v : var
                               (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v)%expr,
                         #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                | _ =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                      (fun
                         v : var
                               (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v)%expr,
                         #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                end
            | @expr.LetIn _ _ _ _ _ _ _ =>
                match x2 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t1 v =>
                          match
                            t1 as t2 return (base.base_interp t2 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v0 : Z => Some v0
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (defaults.expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : defaults.expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type =>
                               defaults.expr (type.base t1)) t2 base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (defaults.expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (defaults.expr (type.base t2) ->
                                        defaults.expr (type.base base.type.Z))
                               =>
                               match a with
                               | Some x' =>
                                   if args0 <=? 0
                                   then
                                    UnderLets.UnderLet
                                      (#(ident.Z_sub_with_get_borrow)%expr @
                                       x @ x' v @ x1 @ ##((- args0)%Z)%expr)%expr_pat
                                      (fun
                                         v0 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v0)%expr,
                                         (-
                                          (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                   else
                                    UnderLets.UnderLet
                                      (#(ident.Z_add_with_get_carry)%expr @ x @
                                       x0 @ x1 @ x2)%expr_pat
                                      (fun
                                         v0 : var
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)
                                       =>
                                       UnderLets.Base
                                         (#(ident.fst)%expr @ ($v0)%expr,
                                         #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry)%expr @ x @
                                      x0 @ x1 @ x2)%expr_pat
                               end)
                        | (s0 -> d0)%ptype =>
                            fun
                              _ : Compile.value' false s0 ->
                                  Compile.value' true d0 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                               x1 @ x2)%expr_pat
                        end (Compile.reflect x3)
                    | None =>
                        UnderLets.UnderLet
                          (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                           x2)%expr_pat
                          (fun
                             v : var
                                   (type.base
                                      (base.type.Z * base.type.Z)%etype) =>
                           UnderLets.Base
                             (#(ident.fst)%expr @ ($v)%expr,
                             #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    end
                | ($_)%expr =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                      (fun
                         v0 : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v0)%expr,
                         #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                | @expr.App _ _ _ s0 _ #(idc0)%expr_pat x5 =>
                    match
                      match idc0 with
                      | ident.Z_opp => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (defaults.expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : defaults.expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type =>
                               defaults.expr (type.base t1)) t2 base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (defaults.expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (defaults.expr (type.base t2) ->
                                        defaults.expr (type.base base.type.Z))
                               =>
                               match a with
                               | Some x' =>
                                   match
                                     s0 as t3
                                     return
                                       (Compile.value' false t3 ->
                                        UnderLets.UnderLets base.type ident
                                          var
                                          (defaults.expr
                                             (type.base
                                                (base.type.Z * base.type.Z)%etype)))
                                   with
                                   | type.base t3 =>
                                       fun v0 : defaults.expr (type.base t3)
                                       =>
                                       base.try_make_transport_cps
                                         (fun t1 : base.type =>
                                          defaults.expr (type.base t1)) t3
                                         base.type.Z
                                         (UnderLets.UnderLets base.type ident
                                            var
                                            (defaults.expr
                                               (type.base
                                                  (base.type.Z * base.type.Z)%etype)))
                                         (fun
                                            a0 : option
                                                   (defaults.expr
                                                      (type.base t3) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                          =>
                                          match a0 with
                                          | Some x'0 =>
                                              UnderLets.UnderLet
                                                (#(ident.Z_sub_with_get_borrow)%expr @
                                                 x @ x' v @ x1 @ x'0 v0)%expr_pat
                                                (fun
                                                   v1 : var
                                                          (type.base
                                                             (base.type.Z *
                                                              base.type.Z)%etype)
                                                 =>
                                                 UnderLets.Base
                                                   (#(ident.fst)%expr @
                                                    ($v1)%expr,
                                                   (-
                                                    (#(ident.snd)%expr @ $v1)%expr_pat)%expr)%expr_pat)
                                          | None =>
                                              UnderLets.Base
                                                (#(ident.Z_add_with_get_carry)%expr @
                                                 x @ x0 @ x1 @ x2)%expr_pat
                                          end)
                                   | (s1 -> d1)%ptype =>
                                       fun
                                         _ : Compile.value' false s1 ->
                                             Compile.value' true d1 =>
                                       UnderLets.Base
                                         (#(ident.Z_add_with_get_carry)%expr @
                                          x @ x0 @ x1 @ x2)%expr_pat
                                   end (Compile.reflect x5)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry)%expr @ x @
                                      x0 @ x1 @ x2)%expr_pat
                               end)
                        | (s1 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                               x1 @ x2)%expr_pat
                        end (Compile.reflect x3)
                    | None =>
                        UnderLets.UnderLet
                          (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                           x2)%expr_pat
                          (fun
                             v : var
                                   (type.base
                                      (base.type.Z * base.type.Z)%etype) =>
                           UnderLets.Base
                             (#(ident.fst)%expr @ ($v)%expr,
                             #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    end
                | @expr.App _ _ _ s0 _ ($_)%expr _ =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                      (fun
                         v0 : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v0)%expr,
                         #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                | @expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App
                  _ _ _ s0 _ (_ @ _)%expr_pat _ | @expr.App _ _ _ s0 _
                  (@expr.LetIn _ _ _ _ _ _ _) _ =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                      (fun
                         v : var
                               (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v)%expr,
                         #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                | _ =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                      (fun
                         v : var
                               (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v)%expr,
                         #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                end
            end
        | None =>
            match x1 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args =>
                    match x2 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args0 =>
                            if (args =? 0) && (args0 =? 0)
                            then
                             UnderLets.UnderLet
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                ##(args)%expr @ ##(args0)%expr)%expr_pat
                               (fun
                                  v : var
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)
                                =>
                                UnderLets.Base
                                  (#(ident.fst)%expr @ ($v)%expr, ##(0)%expr)%expr_pat)
                            else
                             UnderLets.UnderLet
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                               (fun
                                  v : var
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)
                                =>
                                UnderLets.Base
                                  (#(ident.fst)%expr @ ($v)%expr,
                                  #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                        | None =>
                            UnderLets.UnderLet
                              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                               x1 @ x2)%expr_pat
                              (fun
                                 v : var
                                       (type.base
                                          (base.type.Z * base.type.Z)%etype)
                               =>
                               UnderLets.Base
                                 (#(ident.fst)%expr @ ($v)%expr,
                                 #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                        end
                    | ($_)%expr =>
                        UnderLets.UnderLet
                          (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                           x2)%expr_pat
                          (fun
                             v0 : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                           UnderLets.Base
                             (#(ident.fst)%expr @ ($v0)%expr,
                             #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                    | _ =>
                        UnderLets.UnderLet
                          (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                           x2)%expr_pat
                          (fun
                             v : var
                                   (type.base
                                      (base.type.Z * base.type.Z)%etype) =>
                           UnderLets.Base
                             (#(ident.fst)%expr @ ($v)%expr,
                             #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    end
                | None =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                      (fun
                         v : var
                               (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v)%expr,
                         #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                end
            | ($_)%expr =>
                UnderLets.UnderLet
                  (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                  (fun v0 : var (type.base (base.type.Z * base.type.Z)%etype)
                   =>
                   UnderLets.Base
                     (#(ident.fst)%expr @ ($v0)%expr,
                     #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
            | _ =>
                UnderLets.UnderLet
                  (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                  (fun v : var (type.base (base.type.Z * base.type.Z)%etype)
                   =>
                   UnderLets.Base
                     (#(ident.fst)%expr @ ($v)%expr,
                     #(ident.snd)%expr @ ($v)%expr)%expr_pat)
            end
        end
    | @expr.App _ _ _ s _ ($_)%expr _ =>
        match x1 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t1 v0 =>
                  match
                    t1 as t2 return (base.base_interp t2 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v1 : Z => Some v1
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v0
              | _ => None
              end
            with
            | Some args =>
                match x2 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t2 v0 =>
                          match
                            t2 as t3 return (base.base_interp t3 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v1 : Z => Some v1
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v0
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        if (args =? 0) && (args0 =? 0)
                        then
                         UnderLets.UnderLet
                           (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                            ##(args)%expr @ ##(args0)%expr)%expr_pat
                           (fun
                              v0 : var
                                     (type.base
                                        (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v0)%expr, ##(0)%expr)%expr_pat)
                        else
                         UnderLets.UnderLet
                           (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                            x2)%expr_pat
                           (fun
                              v0 : var
                                     (type.base
                                        (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v0)%expr,
                              #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                    | None =>
                        UnderLets.UnderLet
                          (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                           x2)%expr_pat
                          (fun
                             v0 : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                           UnderLets.Base
                             (#(ident.fst)%expr @ ($v0)%expr,
                             #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                    end
                | ($_)%expr =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                      (fun
                         v1 : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v1)%expr,
                         #(ident.snd)%expr @ ($v1)%expr)%expr_pat)
                | _ =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                      (fun
                         v0 : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v0)%expr,
                         #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                end
            | None =>
                UnderLets.UnderLet
                  (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                  (fun v0 : var (type.base (base.type.Z * base.type.Z)%etype)
                   =>
                   UnderLets.Base
                     (#(ident.fst)%expr @ ($v0)%expr,
                     #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
            end
        | ($_)%expr =>
            UnderLets.UnderLet
              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
              (fun v1 : var (type.base (base.type.Z * base.type.Z)%etype) =>
               UnderLets.Base
                 (#(ident.fst)%expr @ ($v1)%expr,
                 #(ident.snd)%expr @ ($v1)%expr)%expr_pat)
        | _ =>
            UnderLets.UnderLet
              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
              (fun v0 : var (type.base (base.type.Z * base.type.Z)%etype) =>
               UnderLets.Base
                 (#(ident.fst)%expr @ ($v0)%expr,
                 #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
        end
    | @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _
      (_ @ _)%expr_pat _ | @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _)
      _ =>
        match x1 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t0 v =>
                  match
                    t0 as t1 return (base.base_interp t1 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v0 : Z => Some v0
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v
              | _ => None
              end
            with
            | Some args =>
                match x2 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t1 v =>
                          match
                            t1 as t2 return (base.base_interp t2 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v0 : Z => Some v0
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        if (args =? 0) && (args0 =? 0)
                        then
                         UnderLets.UnderLet
                           (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                            ##(args)%expr @ ##(args0)%expr)%expr_pat
                           (fun
                              v : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v)%expr, ##(0)%expr)%expr_pat)
                        else
                         UnderLets.UnderLet
                           (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                            x2)%expr_pat
                           (fun
                              v : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v)%expr,
                              #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    | None =>
                        UnderLets.UnderLet
                          (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                           x2)%expr_pat
                          (fun
                             v : var
                                   (type.base
                                      (base.type.Z * base.type.Z)%etype) =>
                           UnderLets.Base
                             (#(ident.fst)%expr @ ($v)%expr,
                             #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    end
                | ($_)%expr =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                      (fun
                         v0 : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v0)%expr,
                         #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                | _ =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                      (fun
                         v : var
                               (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v)%expr,
                         #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                end
            | None =>
                UnderLets.UnderLet
                  (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                  (fun v : var (type.base (base.type.Z * base.type.Z)%etype)
                   =>
                   UnderLets.Base
                     (#(ident.fst)%expr @ ($v)%expr,
                     #(ident.snd)%expr @ ($v)%expr)%expr_pat)
            end
        | ($_)%expr =>
            UnderLets.UnderLet
              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
              (fun v0 : var (type.base (base.type.Z * base.type.Z)%etype) =>
               UnderLets.Base
                 (#(ident.fst)%expr @ ($v0)%expr,
                 #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
        | _ =>
            UnderLets.UnderLet
              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
              (fun v : var (type.base (base.type.Z * base.type.Z)%etype) =>
               UnderLets.Base
                 (#(ident.fst)%expr @ ($v)%expr,
                 #(ident.snd)%expr @ ($v)%expr)%expr_pat)
        end
    | _ =>
        match x1 with
        | #(idc)%expr_pat =>
            match
              match idc with
              | @ident.Literal t0 v =>
                  match
                    t0 as t1 return (base.base_interp t1 -> option Z)
                  with
                  | base.type.unit => fun _ : unit => None
                  | base.type.Z => fun v0 : Z => Some v0
                  | base.type.bool => fun _ : bool => None
                  | base.type.nat => fun _ : nat => None
                  end v
              | _ => None
              end
            with
            | Some args =>
                match x2 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t1 v =>
                          match
                            t1 as t2 return (base.base_interp t2 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v0 : Z => Some v0
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        if (args =? 0) && (args0 =? 0)
                        then
                         UnderLets.UnderLet
                           (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                            ##(args)%expr @ ##(args0)%expr)%expr_pat
                           (fun
                              v : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v)%expr, ##(0)%expr)%expr_pat)
                        else
                         UnderLets.UnderLet
                           (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                            x2)%expr_pat
                           (fun
                              v : var
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype) =>
                            UnderLets.Base
                              (#(ident.fst)%expr @ ($v)%expr,
                              #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    | None =>
                        UnderLets.UnderLet
                          (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @
                           x2)%expr_pat
                          (fun
                             v : var
                                   (type.base
                                      (base.type.Z * base.type.Z)%etype) =>
                           UnderLets.Base
                             (#(ident.fst)%expr @ ($v)%expr,
                             #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                    end
                | ($_)%expr =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                      (fun
                         v0 : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v0)%expr,
                         #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
                | _ =>
                    UnderLets.UnderLet
                      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                      (fun
                         v : var
                               (type.base (base.type.Z * base.type.Z)%etype)
                       =>
                       UnderLets.Base
                         (#(ident.fst)%expr @ ($v)%expr,
                         #(ident.snd)%expr @ ($v)%expr)%expr_pat)
                end
            | None =>
                UnderLets.UnderLet
                  (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                  (fun v : var (type.base (base.type.Z * base.type.Z)%etype)
                   =>
                   UnderLets.Base
                     (#(ident.fst)%expr @ ($v)%expr,
                     #(ident.snd)%expr @ ($v)%expr)%expr_pat)
            end
        | ($_)%expr =>
            UnderLets.UnderLet
              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
              (fun v0 : var (type.base (base.type.Z * base.type.Z)%etype) =>
               UnderLets.Base
                 (#(ident.fst)%expr @ ($v0)%expr,
                 #(ident.snd)%expr @ ($v0)%expr)%expr_pat)
        | _ =>
            UnderLets.UnderLet
              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
              (fun v : var (type.base (base.type.Z * base.type.Z)%etype) =>
               UnderLets.Base
                 (#(ident.fst)%expr @ ($v)%expr,
                 #(ident.snd)%expr @ ($v)%expr)%expr_pat)
        end
    end
| ident.Z_sub_get_borrow =>
    fun x x0 x1 : defaults.expr (type.base base.type.Z) =>
    UnderLets.UnderLet
      (#(ident.Z_sub_get_borrow)%expr @ x @ x0 @ x1)%expr_pat
      (fun v : var (type.base (base.type.Z * base.type.Z)%etype) =>
       UnderLets.Base
         (#(ident.fst)%expr @ ($v)%expr, #(ident.snd)%expr @ ($v)%expr)%expr_pat)
| ident.Z_sub_with_get_borrow =>
    fun x x0 x1 x2 : defaults.expr (type.base base.type.Z) =>
    UnderLets.UnderLet
      (#(ident.Z_sub_with_get_borrow)%expr @ x @ x0 @ x1 @ x2)%expr_pat
      (fun v : var (type.base (base.type.Z * base.type.Z)%etype) =>
       UnderLets.Base
         (#(ident.fst)%expr @ ($v)%expr, #(ident.snd)%expr @ ($v)%expr)%expr_pat)
| ident.Z_zselect =>
    fun x x0 x1 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_zselect)%expr @ x @ x0 @ x1)%expr_pat
| ident.Z_add_modulo =>
    fun x x0 x1 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_add_modulo)%expr @ x @ x0 @ x1)%expr_pat
| ident.Z_rshi =>
    fun x x0 x1 x2 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_rshi)%expr @ x @ x0 @ x1 @ x2)%expr_pat
| ident.Z_cc_m =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_cc_m)%expr @ x @ x0)%expr_pat
| ident.Z_cast range =>
    fun x : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_cast range)%expr @ x)%expr_pat
| ident.Z_cast2 range =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    match x with
    | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ #(idc)%expr_pat x1) x0 =>
        match
          match idc with
          | @ident.pair A B => Some (A, B)
          | _ => None
          end
        with
        | Some _ =>
            match
              s0 as t2
              return
                (Compile.value' false t2 ->
                 UnderLets.UnderLets base.type ident var
                   (defaults.expr
                      (type.base (base.type.Z * base.type.Z)%etype)))
            with
            | type.base t2 =>
                fun v : defaults.expr (type.base t2) =>
                base.try_make_transport_cps
                  (fun t0 : base.type => defaults.expr (type.base t0)) t2
                  base.type.Z
                  (UnderLets.UnderLets base.type ident var
                     (defaults.expr
                        (type.base (base.type.Z * base.type.Z)%etype)))
                  (fun
                     a : option
                           (defaults.expr (type.base t2) ->
                            defaults.expr (type.base base.type.Z)) =>
                   match a with
                   | Some x' =>
                       match
                         s as t3
                         return
                           (Compile.value' false t3 ->
                            UnderLets.UnderLets base.type ident var
                              (defaults.expr
                                 (type.base (base.type.Z * base.type.Z)%etype)))
                       with
                       | type.base t3 =>
                           fun v0 : defaults.expr (type.base t3) =>
                           base.try_make_transport_cps
                             (fun t0 : base.type =>
                              defaults.expr (type.base t0)) t3 base.type.Z
                             (UnderLets.UnderLets base.type ident var
                                (defaults.expr
                                   (type.base
                                      (base.type.Z * base.type.Z)%etype)))
                             (fun
                                a0 : option
                                       (defaults.expr (type.base t3) ->
                                        defaults.expr (type.base base.type.Z))
                              =>
                              match a0 with
                              | Some x'0 =>
                                  (fv <-- do_again
                                            (base.type.Z * base.type.Z)
                                            (#(ident.Z_cast (fst range))%expr @
                                             ($(x' v))%expr,
                                            #(ident.Z_cast (snd range))%expr @
                                            ($(x'0 v0))%expr)%expr_pat;
                                   UnderLets.Base (id (id fv)))%under_lets
                              | None =>
                                  UnderLets.Base
                                    (#(ident.Z_cast2 range)%expr @ x)%expr_pat
                              end)
                       | (s1 -> d1)%ptype =>
                           fun
                             _ : Compile.value' false s1 ->
                                 Compile.value' true d1 =>
                           UnderLets.Base
                             (#(ident.Z_cast2 range)%expr @ x)%expr_pat
                       end (Compile.reflect x0)
                   | None =>
                       UnderLets.Base
                         (#(ident.Z_cast2 range)%expr @ x)%expr_pat
                   end)
            | (s1 -> d1)%ptype =>
                fun _ : Compile.value' false s1 -> Compile.value' true d1 =>
                UnderLets.Base (#(ident.Z_cast2 range)%expr @ x)%expr_pat
            end (Compile.reflect x1)
        | None => UnderLets.Base (#(ident.Z_cast2 range)%expr @ x)%expr_pat
        end
    | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ ($_)%expr _) _ | @expr.App _
      _ _ s _ (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _) _ | @expr.App
      _ _ _ s _ (@expr.App _ _ _ s0 _ (_ @ _)%expr_pat _) _ | @expr.App _ _ _
      s _ (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _) _ =>
        UnderLets.Base (#(ident.Z_cast2 range)%expr @ x)%expr_pat
    | @expr.App _ _ _ s _ #(_)%expr_pat _ | @expr.App _ _ _ s _ ($_)%expr _ |
      @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _
      (@expr.LetIn _ _ _ _ _ _ _) _ =>
        UnderLets.Base (#(ident.Z_cast2 range)%expr @ x)%expr_pat
    | _ => UnderLets.Base (#(ident.Z_cast2 range)%expr @ x)%expr_pat
    end
| ident.fancy_add log2wordmax imm =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_add log2wordmax imm)%expr @ x)%expr_pat
| ident.fancy_addc log2wordmax imm =>
    fun
      x : defaults.expr
            (type.base (base.type.Z * base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_addc log2wordmax imm)%expr @ x)%expr_pat
| ident.fancy_sub log2wordmax imm =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_sub log2wordmax imm)%expr @ x)%expr_pat
| ident.fancy_subb log2wordmax imm =>
    fun
      x : defaults.expr
            (type.base (base.type.Z * base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_subb log2wordmax imm)%expr @ x)%expr_pat
| ident.fancy_mulll log2wordmax =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_mulll log2wordmax)%expr @ x)%expr_pat
| ident.fancy_mullh log2wordmax =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_mullh log2wordmax)%expr @ x)%expr_pat
| ident.fancy_mulhl log2wordmax =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_mulhl log2wordmax)%expr @ x)%expr_pat
| ident.fancy_mulhh log2wordmax =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_mulhh log2wordmax)%expr @ x)%expr_pat
| ident.fancy_rshi log2wordmax x =>
    fun x0 : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_rshi log2wordmax x)%expr @ x0)%expr_pat
| ident.fancy_selc =>
    fun
      x : defaults.expr
            (type.base (base.type.Z * base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_selc)%expr @ x)%expr_pat
| ident.fancy_selm log2wordmax =>
    fun
      x : defaults.expr
            (type.base (base.type.Z * base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_selm log2wordmax)%expr @ x)%expr_pat
| ident.fancy_sell =>
    fun
      x : defaults.expr
            (type.base (base.type.Z * base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_sell)%expr @ x)%expr_pat
| ident.fancy_addm =>
    fun
      x : defaults.expr
            (type.base (base.type.Z * base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_addm)%expr @ x)%expr_pat
end
     : Compile.value' true t
