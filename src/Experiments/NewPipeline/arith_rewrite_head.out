arith_rewrite_head = 
match idc in (Compilers.ident t) return (Compile.value' true t) with
| @Literal t v => Base (##v)%expr
| Nat_succ => fun x : expr ℕ => Base (#(Nat_succ)%expr @ x)%expr_pat
| Nat_pred => fun x : expr ℕ => Base (#(Nat_pred)%expr @ x)%expr_pat
| Nat_max => fun x x0 : expr ℕ => Base (#(Nat_max)%expr @ x @ x0)%expr_pat
| Nat_mul => fun x x0 : expr ℕ => Base (#(Nat_mul)%expr @ x @ x0)%expr_pat
| Nat_add => fun x x0 : expr ℕ => Base (#(Nat_add)%expr @ x @ x0)%expr_pat
| Nat_sub => fun x x0 : expr ℕ => Base (#(Nat_sub)%expr @ x @ x0)%expr_pat
| @nil t => Base []%expr_pat
| @cons t => fun (x : expr t) (x0 : expr (list t)) => Base (x :: x0)%expr_pat
| @pair A B => fun (x : expr A) (x0 : expr B) => Base (x, x0)%expr_pat
| @fst A B =>
    fun x : expr (A * B)%etype =>
    ((match x with
      | @expr.App _ _ _ s _
        (@expr.App _ _ _ s0 _ (@expr.Ident _ _ _ t idc) x1) _ =>
          args <- invert_bind_args idc Raw.ident.pair;
          match
            pattern.type.unify_extracted_cps
              ((('1 * '2)%pbtype -> '1%pbtype) ->
               (('1%pbtype -> '2%pbtype -> ('1 * '2)%pbtype) -> '1%pbtype) ->
               '2%pbtype)%ptype
              (((A * B)%etype -> A) ->
               (((let (x2, _) := args in x2) ->
                 (let (_, y) := args in y) ->
                 ((let (x2, _) := args in x2) * (let (_, y) := args in y))%etype) ->
                s0) -> s)%ptype option (fun x2 : option => x2)
          with
          | Some (_, _, _, (_, (_, (_, _)), b3, b2)) =>
              _ <- ident.unify pattern.ident.fst fst;
              _ <- ident.unify pattern.ident.pair pair;
              v <- type.try_make_transport_cps s0 b3;
              _ <- type.try_make_transport_cps s b2;
              v1 <- base.try_make_transport_cps b3 A;
              v2 <- base.try_make_transport_cps A A;
              v3 <- base.try_make_transport_cps A A;
              Some (Base (v3 (v2 (v1 (v (Compile.reflect x1))))))
          | None => None
          end
      | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ ($_)%expr _) _ | @expr.App
        _ _ _ s _ (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _) _ |
        @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ (_ @ _)%expr_pat _) _ |
        @expr.App _ _ _ s _
        (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _) _ => None
      | @expr.App _ _ _ s _ #(_)%expr_pat _ | @expr.App _ _ _ s _ ($_)%expr
        _ | @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s
        _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
      | _ => None
      end;;
      None);;;
     Base (#(fst)%expr @ x)%expr_pat)%option
| @snd A B =>
    fun x : expr (A * B)%etype =>
    ((match x with
      | @expr.App _ _ _ s _
        (@expr.App _ _ _ s0 _ (@expr.Ident _ _ _ t idc) _) x0 =>
          args <- invert_bind_args idc Raw.ident.pair;
          match
            pattern.type.unify_extracted_cps
              ((('1 * '2)%pbtype -> '2%pbtype) ->
               (('1%pbtype -> '2%pbtype -> ('1 * '2)%pbtype) -> '1%pbtype) ->
               '2%pbtype)%ptype
              (((A * B)%etype -> B) ->
               (((let (x2, _) := args in x2) ->
                 (let (_, y) := args in y) ->
                 ((let (x2, _) := args in x2) * (let (_, y) := args in y))%etype) ->
                s0) -> s)%ptype option (fun x2 : option => x2)
          with
          | Some (_, _, _, (_, (_, (_, _)), b3, b2)) =>
              _ <- ident.unify pattern.ident.snd snd;
              _ <- ident.unify pattern.ident.pair pair;
              _ <- type.try_make_transport_cps s0 b3;
              v0 <- type.try_make_transport_cps s b2;
              v1 <- base.try_make_transport_cps b2 B;
              v2 <- base.try_make_transport_cps B B;
              v3 <- base.try_make_transport_cps B B;
              Some (Base (v3 (v2 (v1 (v0 (Compile.reflect x0))))))
          | None => None
          end
      | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ ($_)%expr _) _ | @expr.App
        _ _ _ s _ (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _) _ |
        @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ (_ @ _)%expr_pat _) _ |
        @expr.App _ _ _ s _
        (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _) _ => None
      | @expr.App _ _ _ s _ #(_)%expr_pat _ | @expr.App _ _ _ s _ ($_)%expr
        _ | @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s
        _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
      | _ => None
      end;;
      None);;;
     Base (#(snd)%expr @ x)%expr_pat)%option
| @prod_rect A B T =>
    fun (x : expr A -> expr B -> UnderLets (expr T))
      (x0 : expr (A * B)%etype) =>
    Base
      (#(prod_rect)%expr @
       (λ (x1 : var A)(x2 : var B),
        to_expr (x ($x1) ($x2)))%expr @ x0)%expr_pat
| @bool_rect T =>
    fun (x x0 : expr unit -> UnderLets (expr T)) (x1 : expr bool) =>
    Base
      (#(bool_rect)%expr @ (λ x2 : var unit,
                            to_expr (x ($x2)))%expr @
       (λ x2 : var unit,
        to_expr (x0 ($x2)))%expr @ x1)%expr_pat
| @nat_rect P =>
    fun (x : expr unit -> UnderLets (expr P))
      (x0 : expr ℕ -> expr P -> UnderLets (expr P)) (x1 : expr ℕ) =>
    Base
      (#(nat_rect)%expr @ (λ x2 : var unit,
                           to_expr (x ($x2)))%expr @
       (λ (x2 : var ℕ)(x3 : var P),
        to_expr (x0 ($x2) ($x3)))%expr @ x1)%expr_pat
| @nat_rect_arrow P Q =>
    fun (x : expr P -> UnderLets (expr Q))
      (x0 : expr ℕ ->
            (expr P -> UnderLets (expr Q)) -> expr P -> UnderLets (expr Q))
      (x1 : expr ℕ) (x2 : expr P) =>
    Base
      (#(nat_rect_arrow)%expr @ (λ x3 : var P,
                                 to_expr (x ($x3)))%expr @
       (λ (x3 : var ℕ)(x4 : var (P -> Q)%ptype)(x5 : var P),
        to_expr
          (x0 ($x3) (fun x6 : expr P => Base ($x4 @ x6)%expr_pat) ($x5)))%expr @
       x1 @ x2)%expr_pat
| @list_rect A P =>
    fun (x : expr unit -> UnderLets (expr P))
      (x0 : expr A -> expr (list A) -> expr P -> UnderLets (expr P))
      (x1 : expr (list A)) =>
    Base
      (#(list_rect)%expr @ (λ x2 : var unit,
                            to_expr (x ($x2)))%expr @
       (λ (x2 : var A)(x3 : var (list A))(x4 : var P),
        to_expr (x0 ($x2) ($x3) ($x4)))%expr @ x1)%expr_pat
| @list_case A P =>
    fun (x : expr unit -> UnderLets (expr P))
      (x0 : expr A -> expr (list A) -> UnderLets (expr P))
      (x1 : expr (list A)) =>
    Base
      (#(list_case)%expr @ (λ x2 : var unit,
                            to_expr (x ($x2)))%expr @
       (λ (x2 : var A)(x3 : var (list A)),
        to_expr (x0 ($x2) ($x3)))%expr @ x1)%expr_pat
| @List_length T =>
    fun x : expr (list T) => Base (#(List_length)%expr @ x)%expr_pat
| List_seq => fun x x0 : expr ℕ => Base (#(List_seq)%expr @ x @ x0)%expr_pat
| @List_firstn A =>
    fun (x : expr ℕ) (x0 : expr (list A)) =>
    Base (#(List_firstn)%expr @ x @ x0)%expr_pat
| @List_skipn A =>
    fun (x : expr ℕ) (x0 : expr (list A)) =>
    Base (#(List_skipn)%expr @ x @ x0)%expr_pat
| @List_repeat A =>
    fun (x : expr A) (x0 : expr ℕ) =>
    Base (#(List_repeat)%expr @ x @ x0)%expr_pat
| @List_combine A B =>
    fun (x : expr (list A)) (x0 : expr (list B)) =>
    Base (#(List_combine)%expr @ x @ x0)%expr_pat
| @List_map A B =>
    fun (x : expr A -> UnderLets (expr B)) (x0 : expr (list A)) =>
    Base
      (#(List_map)%expr @ (λ x1 : var A,
                           to_expr (x ($x1)))%expr @ x0)%expr_pat
| @List_app A => fun x x0 : expr (list A) => Base (x ++ x0)%expr
| @List_rev A =>
    fun x : expr (list A) => Base (#(List_rev)%expr @ x)%expr_pat
| @List_flat_map A B =>
    fun (x : expr A -> UnderLets (expr (list B))) (x0 : expr (list A)) =>
    Base
      (#(List_flat_map)%expr @ (λ x1 : var A,
                                to_expr (x ($x1)))%expr @ x0)%expr_pat
| @List_partition A =>
    fun (x : expr A -> UnderLets (expr bool)) (x0 : expr (list A)) =>
    Base
      (#(List_partition)%expr @ (λ x1 : var A,
                                 to_expr (x ($x1)))%expr @ x0)%expr_pat
| @List_fold_right A B =>
    fun (x : expr B -> expr A -> UnderLets (expr A)) (x0 : expr A)
      (x1 : expr (list B)) =>
    Base
      (#(List_fold_right)%expr @
       (λ (x2 : var B)(x3 : var A),
        to_expr (x ($x2) ($x3)))%expr @ x0 @ x1)%expr_pat
| @List_update_nth T =>
    fun (x : expr ℕ) (x0 : expr T -> UnderLets (expr T)) (x1 : expr (list T))
    =>
    Base
      (#(List_update_nth)%expr @ x @ (λ x2 : var T,
                                      to_expr (x0 ($x2)))%expr @ x1)%expr_pat
| @List_nth_default T =>
    fun (x : expr T) (x0 : expr (list T)) (x1 : expr ℕ) =>
    Base (#(List_nth_default)%expr @ x @ x0 @ x1)%expr_pat
| Z_add =>
    fun x x0 : expr ℤ =>
    (((match x with
       | @expr.Ident _ _ _ t idc =>
           args <- invert_bind_args idc Raw.ident.Literal;
           match
             pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype
               ((projT1 args) -> ℤ)%ptype option (fun x1 : option => x1)
           with
           | Some (_, _) =>
               idc_args <- ident.unify pattern.ident.Literal ##(projT2 args);
               x1 <- (if (let (x1, _) := idc_args in x1) =? 0
                      then Some x0
                      else None);
               Some (Base x1)
           | None => None
           end
       | _ => None
       end;;
       match x0 with
       | @expr.Ident _ _ _ t idc =>
           (args <- invert_bind_args idc Raw.ident.Literal;
            match
              pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype
                (ℤ -> (projT1 args))%ptype option (fun x1 : option => x1)
            with
            | Some (_, _) =>
                idc_args <- ident.unify pattern.ident.Literal ##(projT2 args);
                x1 <- (if (let (x1, _) := idc_args in x1) =? 0
                       then Some x
                       else None);
                Some (Base x1)
            | None => None
            end);;
           match x with
           | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t0 idc0) x1 =>
               (_ <- invert_bind_args idc0 Raw.ident.Z_opp;
                args0 <- invert_bind_args idc Raw.ident.Literal;
                match
                  pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype
                    (s -> (projT1 args0))%ptype option
                    (fun x2 : option => x2)
                with
                | Some (_, _) =>
                    v <- type.try_make_transport_cps s ℤ;
                    idc_args <- ident.unify pattern.ident.Literal
                                  ##(projT2 args0);
                    x2 <- (if (let (x2, _) := idc_args in x2) >? 0
                           then
                            Some
                              (##(let (x2, _) := idc_args in x2) -
                               v (Compile.reflect x1))%expr
                           else None);
                    Some (Base x2)
                | None => None
                end);;
               _ <- invert_bind_args idc0 Raw.ident.Z_opp;
               args0 <- invert_bind_args idc Raw.ident.Literal;
               match
                 pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype
                   (s -> (projT1 args0))%ptype option (fun x2 : option => x2)
               with
               | Some (_, _) =>
                   v <- type.try_make_transport_cps s ℤ;
                   idc_args <- ident.unify pattern.ident.Literal
                                 ##(projT2 args0);
                   x2 <- (if (let (x2, _) := idc_args in x2) <? 0
                          then
                           Some
                             (-
                              (v (Compile.reflect x1) +
                               ##(- (let (x2, _) := idc_args in x2))%Z))%expr
                          else None);
                   Some (Base x2)
               | None => None
               end
           | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
             (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat
             _ | @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
           | _ => None
           end
       | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t idc) x1 =>
           match x with
           | @expr.Ident _ _ _ t0 idc0 =>
               (args <- invert_bind_args idc0 Raw.ident.Literal;
                _ <- invert_bind_args idc Raw.ident.Z_opp;
                match
                  pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype
                    ((projT1 args) -> s)%ptype option (fun x2 : option => x2)
                with
                | Some (_, _) =>
                    idc_args <- ident.unify pattern.ident.Literal
                                  ##(projT2 args);
                    v <- type.try_make_transport_cps s ℤ;
                    x2 <- (if (let (x2, _) := idc_args in x2) >? 0
                           then
                            Some
                              (##(let (x2, _) := idc_args in x2) -
                               v (Compile.reflect x1))%expr
                           else None);
                    Some (Base x2)
                | None => None
                end);;
               args <- invert_bind_args idc0 Raw.ident.Literal;
               _ <- invert_bind_args idc Raw.ident.Z_opp;
               match
                 pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype
                   ((projT1 args) -> s)%ptype option (fun x2 : option => x2)
               with
               | Some (_, _) =>
                   idc_args <- ident.unify pattern.ident.Literal
                                 ##(projT2 args);
                   v <- type.try_make_transport_cps s ℤ;
                   x2 <- (if (let (x2, _) := idc_args in x2) <? 0
                          then
                           Some
                             (-
                              (##(- (let (x2, _) := idc_args in x2))%Z +
                               v (Compile.reflect x1)))%expr
                          else None);
                   Some (Base x2)
               | None => None
               end
           | @expr.App _ _ _ s0 _ (@expr.Ident _ _ _ t0 idc0) x2 =>
               _ <- invert_bind_args idc0 Raw.ident.Z_opp;
               _ <- invert_bind_args idc Raw.ident.Z_opp;
               match
                 pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype
                   (s0 -> s)%ptype option (fun x3 : option => x3)
               with
               | Some (_, _) =>
                   v <- type.try_make_transport_cps s0 ℤ;
                   v0 <- type.try_make_transport_cps s ℤ;
                   Some
                     (Base
                        (- (v (Compile.reflect x2) + v0 (Compile.reflect x1)))%expr)
               | None => None
               end
           | @expr.App _ _ _ s0 _ ($_)%expr _ | @expr.App _ _ _ s0 _
             (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0 _
             (_ @ _)%expr_pat _ | @expr.App _ _ _ s0 _
             (@expr.LetIn _ _ _ _ _ _ _) _ => None
           | _ => None
           end
       | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
         (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat _ |
         @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
       | _ => None
       end;;
       match x with
       | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t idc) x1 =>
           _ <- invert_bind_args idc Raw.ident.Z_opp;
           match
             pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype (s -> ℤ)%ptype
               option (fun x2 : option => x2)
           with
           | Some (_, _) =>
               v <- type.try_make_transport_cps s ℤ;
               Some (Base (x0 - v (Compile.reflect x1))%expr)
           | None => None
           end
       | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
         (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat _ |
         @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
       | _ => None
       end;;
       match x0 with
       | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t idc) x1 =>
           _ <- invert_bind_args idc Raw.ident.Z_opp;
           match
             pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype (ℤ -> s)%ptype
               option (fun x2 : option => x2)
           with
           | Some (_, _) =>
               v <- type.try_make_transport_cps s ℤ;
               Some (Base (x - v (Compile.reflect x1))%expr)
           | None => None
           end
       | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
         (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat _ |
         @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
       | _ => None
       end);;
      None);;;
     Base (x + x0)%expr)%option
| Z_mul =>
    fun x x0 : expr ℤ =>
    (((match x with
       | @expr.Ident _ _ _ t idc =>
           match x0 with
           | @expr.Ident _ _ _ t0 idc0 =>
               args <- invert_bind_args idc0 Raw.ident.Literal;
               args0 <- invert_bind_args idc Raw.ident.Literal;
               match
                 pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype
                   ((projT1 args0) -> (projT1 args))%ptype option
                   (fun x1 : option => x1)
               with
               | Some (_, _) =>
                   idc_args <- ident.unify pattern.ident.Literal
                                 ##(projT2 args0);
                   idc_args0 <- ident.unify pattern.ident.Literal
                                  ##(projT2 args);
                   Some
                     (Base
                        (##((let (x1, _) := idc_args in x1) *
                            (let (x1, _) := idc_args0 in x1))%Z)%expr)
               | None => None
               end
           | _ => None
           end;;
           args <- invert_bind_args idc Raw.ident.Literal;
           match
             pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype
               ((projT1 args) -> ℤ)%ptype option (fun x1 : option => x1)
           with
           | Some (_, _) =>
               idc_args <- ident.unify pattern.ident.Literal ##(projT2 args);
               x1 <- (if (let (x1, _) := idc_args in x1) =? 0
                      then Some (##0)%expr
                      else None);
               Some (Base x1)
           | None => None
           end
       | _ => None
       end;;
       match x0 with
       | @expr.Ident _ _ _ t idc =>
           args <- invert_bind_args idc Raw.ident.Literal;
           match
             pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype
               (ℤ -> (projT1 args))%ptype option (fun x1 : option => x1)
           with
           | Some (_, _) =>
               idc_args <- ident.unify pattern.ident.Literal ##(projT2 args);
               x1 <- (if (let (x1, _) := idc_args in x1) =? 0
                      then Some (##0)%expr
                      else None);
               Some (Base x1)
           | None => None
           end
       | _ => None
       end;;
       match x with
       | @expr.Ident _ _ _ t idc =>
           args <- invert_bind_args idc Raw.ident.Literal;
           match
             pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype
               ((projT1 args) -> ℤ)%ptype option (fun x1 : option => x1)
           with
           | Some (_, _) =>
               idc_args <- ident.unify pattern.ident.Literal ##(projT2 args);
               x1 <- (if (let (x1, _) := idc_args in x1) =? 1
                      then Some x0
                      else None);
               Some (Base x1)
           | None => None
           end
       | _ => None
       end;;
       match x0 with
       | @expr.Ident _ _ _ t idc =>
           (args <- invert_bind_args idc Raw.ident.Literal;
            match
              pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype
                (ℤ -> (projT1 args))%ptype option (fun x1 : option => x1)
            with
            | Some (_, _) =>
                idc_args <- ident.unify pattern.ident.Literal ##(projT2 args);
                x1 <- (if (let (x1, _) := idc_args in x1) =? 1
                       then Some x
                       else None);
                Some (Base x1)
            | None => None
            end);;
           match x with
           | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t0 idc0) x1 =>
               _ <- invert_bind_args idc0 Raw.ident.Z_opp;
               args0 <- invert_bind_args idc Raw.ident.Literal;
               match
                 pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype
                   (s -> (projT1 args0))%ptype option (fun x2 : option => x2)
               with
               | Some (_, _) =>
                   v <- type.try_make_transport_cps s ℤ;
                   idc_args <- ident.unify pattern.ident.Literal
                                 ##(projT2 args0);
                   x2 <- (if (let (x2, _) := idc_args in x2) =? -1
                          then Some (v (Compile.reflect x1))
                          else None);
                   Some (Base x2)
               | None => None
               end
           | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
             (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat
             _ | @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
           | _ => None
           end
       | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t idc) x1 =>
           match x with
           | @expr.Ident _ _ _ t0 idc0 =>
               args <- invert_bind_args idc0 Raw.ident.Literal;
               _ <- invert_bind_args idc Raw.ident.Z_opp;
               match
                 pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype
                   ((projT1 args) -> s)%ptype option (fun x2 : option => x2)
               with
               | Some (_, _) =>
                   idc_args <- ident.unify pattern.ident.Literal
                                 ##(projT2 args);
                   v <- type.try_make_transport_cps s ℤ;
                   x2 <- (if (let (x2, _) := idc_args in x2) =? -1
                          then Some (v (Compile.reflect x1))
                          else None);
                   Some (Base x2)
               | None => None
               end
           | _ => None
           end
       | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
         (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat _ |
         @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
       | _ => None
       end;;
       match x with
       | @expr.Ident _ _ _ t idc =>
           args <- invert_bind_args idc Raw.ident.Literal;
           match
             pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype
               ((projT1 args) -> ℤ)%ptype option (fun x1 : option => x1)
           with
           | Some (_, _) =>
               idc_args <- ident.unify pattern.ident.Literal ##(projT2 args);
               x1 <- (if (let (x1, _) := idc_args in x1) =? -1
                      then Some (- x0)%expr
                      else None);
               Some (Base x1)
           | None => None
           end
       | _ => None
       end;;
       match x0 with
       | @expr.Ident _ _ _ t idc =>
           args <- invert_bind_args idc Raw.ident.Literal;
           match
             pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype
               (ℤ -> (projT1 args))%ptype option (fun x1 : option => x1)
           with
           | Some (_, _) =>
               idc_args <- ident.unify pattern.ident.Literal ##(projT2 args);
               x1 <- (if (let (x1, _) := idc_args in x1) =? -1
                      then Some (- x)%expr
                      else None);
               Some (Base x1)
           | None => None
           end
       | _ => None
       end;;
       match x with
       | @expr.Ident _ _ _ t idc =>
           args <- invert_bind_args idc Raw.ident.Literal;
           match
             pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype
               ((projT1 args) -> ℤ)%ptype option (fun x1 : option => x1)
           with
           | Some (_, _) =>
               idc_args <- ident.unify pattern.ident.Literal ##(projT2 args);
               x1 <- (if (let (x1, _) := idc_args in x1) <? 0
                      then
                       Some
                         (- (##(- (let (x1, _) := idc_args in x1))%Z * x0))%expr
                      else None);
               Some (Base x1)
           | None => None
           end
       | _ => None
       end;;
       match x0 with
       | @expr.Ident _ _ _ t idc =>
           args <- invert_bind_args idc Raw.ident.Literal;
           match
             pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype
               (ℤ -> (projT1 args))%ptype option (fun x1 : option => x1)
           with
           | Some (_, _) =>
               idc_args <- ident.unify pattern.ident.Literal ##(projT2 args);
               x1 <- (if (let (x1, _) := idc_args in x1) <? 0
                      then
                       Some
                         (- (x * ##(- (let (x1, _) := idc_args in x1))%Z))%expr
                      else None);
               Some (Base x1)
           | None => None
           end
       | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t idc) x1 =>
           match x with
           | @expr.App _ _ _ s0 _ (@expr.Ident _ _ _ t0 idc0) x2 =>
               _ <- invert_bind_args idc0 Raw.ident.Z_opp;
               _ <- invert_bind_args idc Raw.ident.Z_opp;
               match
                 pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype
                   (s0 -> s)%ptype option (fun x3 : option => x3)
               with
               | Some (_, _) =>
                   v <- type.try_make_transport_cps s0 ℤ;
                   v0 <- type.try_make_transport_cps s ℤ;
                   Some
                     (Base
                        (v (Compile.reflect x2) * v0 (Compile.reflect x1))%expr)
               | None => None
               end
           | @expr.App _ _ _ s0 _ ($_)%expr _ | @expr.App _ _ _ s0 _
             (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0 _
             (_ @ _)%expr_pat _ | @expr.App _ _ _ s0 _
             (@expr.LetIn _ _ _ _ _ _ _) _ => None
           | _ => None
           end
       | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
         (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat _ |
         @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
       | _ => None
       end;;
       match x with
       | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t idc) x1 =>
           _ <- invert_bind_args idc Raw.ident.Z_opp;
           match
             pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype (s -> ℤ)%ptype
               option (fun x2 : option => x2)
           with
           | Some (_, _) =>
               v <- type.try_make_transport_cps s ℤ;
               Some (Base (- (v (Compile.reflect x1) * x0))%expr)
           | None => None
           end
       | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
         (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat _ |
         @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
       | _ => None
       end;;
       match x0 with
       | @expr.Ident _ _ _ t idc =>
           args <- invert_bind_args idc Raw.ident.Literal;
           match
             pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype
               (ℤ -> (projT1 args))%ptype option (fun x1 : option => x1)
           with
           | Some (_, _) =>
               idc_args <- ident.unify pattern.ident.Literal ##(projT2 args);
               x1 <- (if
                       ((let (x1, _) := idc_args in x1) =?
                        2 ^ Z.log2 (let (x1, _) := idc_args in x1)) &&
                       negb ((let (x1, _) := idc_args in x1) =? 2)
                      then
                       Some
                         (x << ##(Z.log2 (let (x1, _) := idc_args in x1)))%expr
                      else None);
               Some (Base x1)
           | None => None
           end
       | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t idc) x1 =>
           _ <- invert_bind_args idc Raw.ident.Z_opp;
           match
             pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype (ℤ -> s)%ptype
               option (fun x2 : option => x2)
           with
           | Some (_, _) =>
               v <- type.try_make_transport_cps s ℤ;
               Some (Base (- (x * v (Compile.reflect x1)))%expr)
           | None => None
           end
       | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
         (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat _ |
         @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
       | _ => None
       end;;
       match x with
       | @expr.Ident _ _ _ t idc =>
           (args <- invert_bind_args idc Raw.ident.Literal;
            match
              pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype
                ((projT1 args) -> ℤ)%ptype option (fun x1 : option => x1)
            with
            | Some (_, _) =>
                idc_args <- ident.unify pattern.ident.Literal ##(projT2 args);
                x1 <- (if
                        ((let (x1, _) := idc_args in x1) =?
                         2 ^ Z.log2 (let (x1, _) := idc_args in x1)) &&
                        negb ((let (x1, _) := idc_args in x1) =? 2)
                       then
                        Some
                          (x0 << ##(Z.log2 (let (x1, _) := idc_args in x1)))%expr
                       else None);
                Some (Base x1)
            | None => None
            end);;
           match x0 with
           | @expr.App _ _ _ s _
             (@expr.App _ _ _ s0 _ (@expr.Ident _ _ _ t0 idc0) x2) x1 =>
               match x2 with
               | @expr.Ident _ _ _ t1 idc1 =>
                   match x1 with
                   | @expr.App _ _ _ s1 _
                     (@expr.App _ _ _ s2 _ (@expr.Ident _ _ _ t2 idc2) x4)
                     x3 =>
                       _ <- invert_bind_args idc2 Raw.ident.Z_mul;
                       args0 <- invert_bind_args idc1 Raw.ident.Literal;
                       _ <- invert_bind_args idc0 Raw.ident.Z_mul;
                       args2 <- invert_bind_args idc Raw.ident.Literal;
                       match
                         pattern.type.unify_extracted_cps
                           (ℤ -> ℤ -> ℤ -> ℤ)%ptype
                           ((projT1 args2) -> (projT1 args0) -> s2 -> s1)%ptype
                           option (fun x5 : option => x5)
                       with
                       | Some (_, (_, (_, _))) =>
                           idc_args <- ident.unify pattern.ident.Literal
                                         ##(projT2 args2);
                           idc_args0 <- ident.unify pattern.ident.Literal
                                          ##(projT2 args0);
                           v <- type.try_make_transport_cps s2 ℤ;
                           v0 <- type.try_make_transport_cps s1 ℤ;
                           x5 <- (if
                                   (Z.abs (let (x5, _) := idc_args in x5) <=?
                                    Z.abs max_const_val) &&
                                   (Z.abs (let (x5, _) := idc_args0 in x5) <=?
                                    Z.abs max_const_val)
                                  then
                                   Some
                                     (v (Compile.reflect x4) *
                                      (v0 (Compile.reflect x3) *
                                       (##(let (x5, _) := idc_args in x5) *
                                        ##(let (x5, _) := idc_args0 in x5))))%expr
                                  else None);
                           Some (Base x5)
                       | None => None
                       end
                   | @expr.App _ _ _ s1 _ (@expr.App _ _ _ s2 _ ($_)%expr _)
                     _ | @expr.App _ _ _ s1 _
                     (@expr.App _ _ _ s2 _ (@expr.Abs _ _ _ _ _ _) _) _ |
                     @expr.App _ _ _ s1 _
                     (@expr.App _ _ _ s2 _ (_ @ _)%expr_pat _) _ | @expr.App
                     _ _ _ s1 _
                     (@expr.App _ _ _ s2 _ (@expr.LetIn _ _ _ _ _ _ _) _)
                     _ => None
                   | @expr.App _ _ _ s1 _ #(_)%expr_pat _ | @expr.App _ _ _
                     s1 _ ($_)%expr _ | @expr.App _ _ _ s1 _
                     (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s1 _
                     (@expr.LetIn _ _ _ _ _ _ _) _ => None
                   | _ => None
                   end
               | _ => None
               end;;
               match x1 with
               | (@expr.App _ _ _ s2 _ (@expr.Ident _ _ _ t1 idc1) x4 @
                  @expr.Ident _ _ _ t2 idc2)%expr_pat =>
                   args <- invert_bind_args idc2 Raw.ident.Literal;
                   _ <- invert_bind_args idc1 Raw.ident.Z_mul;
                   _ <- invert_bind_args idc0 Raw.ident.Z_mul;
                   args2 <- invert_bind_args idc Raw.ident.Literal;
                   match
                     pattern.type.unify_extracted_cps
                       (ℤ -> ℤ -> ℤ -> ℤ)%ptype
                       ((projT1 args2) -> s0 -> s2 -> (projT1 args))%ptype
                       option (fun x5 : option => x5)
                   with
                   | Some (_, (_, (_, _))) =>
                       idc_args <- ident.unify pattern.ident.Literal
                                     ##(projT2 args2);
                       v <- type.try_make_transport_cps s0 ℤ;
                       v0 <- type.try_make_transport_cps s2 ℤ;
                       idc_args0 <- ident.unify pattern.ident.Literal
                                      ##(projT2 args);
                       x5 <- (if
                               (Z.abs (let (x5, _) := idc_args in x5) <=?
                                Z.abs max_const_val) &&
                               (Z.abs (let (x5, _) := idc_args0 in x5) <=?
                                Z.abs max_const_val)
                              then
                               Some
                                 (v (Compile.reflect x2) *
                                  (v0 (Compile.reflect x4) *
                                   (##(let (x5, _) := idc_args in x5) *
                                    ##(let (x5, _) := idc_args0 in x5))))%expr
                              else None);
                       Some (Base x5)
                   | None => None
                   end
               | (@expr.App _ _ _ s2 _ (@expr.Ident _ _ _ t1 idc1) x4 @
                  ($_)%expr)%expr_pat |
                 (@expr.App _ _ _ s2 _ (@expr.Ident _ _ _ t1 idc1) x4 @
                  @expr.Abs _ _ _ _ _ _)%expr_pat |
                 (@expr.App _ _ _ s2 _ (@expr.Ident _ _ _ t1 idc1) x4 @
                  (_ @ _))%expr_pat |
                 (@expr.App _ _ _ s2 _ (@expr.Ident _ _ _ t1 idc1) x4 @
                  @expr.LetIn _ _ _ _ _ _ _)%expr_pat => None
               | (@expr.App _ _ _ s2 _ ($_)%expr _ @ _)%expr_pat |
                 (@expr.App _ _ _ s2 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                 (@expr.App _ _ _ s2 _ (_ @ _) _ @ _)%expr_pat |
                 (@expr.App _ _ _ s2 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                   None
               | _ => None
               end;;
               _ <- invert_bind_args idc0 Raw.ident.Z_mul;
               args0 <- invert_bind_args idc Raw.ident.Literal;
               match
                 pattern.type.unify_extracted_cps (ℤ -> ℤ -> ℤ)%ptype
                   ((projT1 args0) -> s0 -> s)%ptype option
                   (fun x3 : option => x3)
               with
               | Some (_, (_, _)) =>
                   idc_args <- ident.unify pattern.ident.Literal
                                 ##(projT2 args0);
                   v <- type.try_make_transport_cps s0 ℤ;
                   v0 <- type.try_make_transport_cps s ℤ;
                   x3 <- (if
                           Z.abs (let (x3, _) := idc_args in x3) <=?
                           Z.abs max_const_val
                          then
                           Some
                             (v (Compile.reflect x2) *
                              (v0 (Compile.reflect x1) *
                               ##(let (x3, _) := idc_args in x3)))%expr
                          else None);
                   Some (Base x3)
               | None => None
               end
           | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ ($_)%expr _) _ |
             @expr.App _ _ _ s _
             (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _) _ | @expr.App _
             _ _ s _ (@expr.App _ _ _ s0 _ (_ @ _)%expr_pat _) _ | @expr.App
             _ _ _ s _ (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _)
             _ => None
           | @expr.App _ _ _ s _ #(_)%expr_pat _ | @expr.App _ _ _ s _
             ($_)%expr _ | @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ |
             @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
           | _ => None
           end;;
           args <- invert_bind_args idc Raw.ident.Literal;
           match
             pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype
               ((projT1 args) -> ℤ)%ptype option (fun x1 : option => x1)
           with
           | Some (_, _) =>
               idc_args <- ident.unify pattern.ident.Literal ##(projT2 args);
               x1 <- (if
                       Z.abs (let (x1, _) := idc_args in x1) <=?
                       Z.abs max_const_val
                      then Some (x0 * ##(let (x1, _) := idc_args in x1))%expr
                      else None);
               Some (Base x1)
           | None => None
           end
       | _ => None
       end);;
      None);;;
     Base (x * x0)%expr)%option
| Z_pow => fun x x0 : expr ℤ => Base (#(Z_pow)%expr @ x @ x0)%expr_pat
| Z_sub =>
    fun x x0 : expr ℤ =>
    (((match x with
       | @expr.Ident _ _ _ t idc =>
           match x0 with
           | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t0 idc0) x1 =>
               _ <- invert_bind_args idc0 Raw.ident.Z_opp;
               args0 <- invert_bind_args idc Raw.ident.Literal;
               match
                 pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype
                   ((projT1 args0) -> s)%ptype option (fun x2 : option => x2)
               with
               | Some (_, _) =>
                   idc_args <- ident.unify pattern.ident.Literal
                                 ##(projT2 args0);
                   v <- type.try_make_transport_cps s ℤ;
                   x2 <- (if (let (x2, _) := idc_args in x2) =? 0
                          then Some (v (Compile.reflect x1))
                          else None);
                   Some (Base x2)
               | None => None
               end
           | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
             (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat
             _ | @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
           | _ => None
           end;;
           args <- invert_bind_args idc Raw.ident.Literal;
           match
             pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype
               ((projT1 args) -> ℤ)%ptype option (fun x1 : option => x1)
           with
           | Some (_, _) =>
               idc_args <- ident.unify pattern.ident.Literal ##(projT2 args);
               x1 <- (if (let (x1, _) := idc_args in x1) =? 0
                      then Some (- x0)%expr
                      else None);
               Some (Base x1)
           | None => None
           end
       | _ => None
       end;;
       match x0 with
       | @expr.Ident _ _ _ t idc =>
           args <- invert_bind_args idc Raw.ident.Literal;
           match
             pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype
               (ℤ -> (projT1 args))%ptype option (fun x1 : option => x1)
           with
           | Some (_, _) =>
               idc_args <- ident.unify pattern.ident.Literal ##(projT2 args);
               x1 <- (if (let (x1, _) := idc_args in x1) =? 0
                      then Some x
                      else None);
               Some (Base x1)
           | None => None
           end
       | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t idc) x1 =>
           match x with
           | @expr.Ident _ _ _ t0 idc0 =>
               (args <- invert_bind_args idc0 Raw.ident.Literal;
                _ <- invert_bind_args idc Raw.ident.Z_opp;
                match
                  pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype
                    ((projT1 args) -> s)%ptype option (fun x2 : option => x2)
                with
                | Some (_, _) =>
                    idc_args <- ident.unify pattern.ident.Literal
                                  ##(projT2 args);
                    v <- type.try_make_transport_cps s ℤ;
                    x2 <- (if (let (x2, _) := idc_args in x2) >? 0
                           then
                            Some
                              (##(let (x2, _) := idc_args in x2) +
                               v (Compile.reflect x1))%expr
                           else None);
                    Some (Base x2)
                | None => None
                end);;
               args <- invert_bind_args idc0 Raw.ident.Literal;
               _ <- invert_bind_args idc Raw.ident.Z_opp;
               match
                 pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype
                   ((projT1 args) -> s)%ptype option (fun x2 : option => x2)
               with
               | Some (_, _) =>
                   idc_args <- ident.unify pattern.ident.Literal
                                 ##(projT2 args);
                   v <- type.try_make_transport_cps s ℤ;
                   x2 <- (if (let (x2, _) := idc_args in x2) <? 0
                          then
                           Some
                             (v (Compile.reflect x1) -
                              ##(- (let (x2, _) := idc_args in x2))%Z)%expr
                          else None);
                   Some (Base x2)
               | None => None
               end
           | _ => None
           end
       | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
         (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat _ |
         @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
       | _ => None
       end;;
       match x with
       | @expr.Ident _ _ _ t idc =>
           args <- invert_bind_args idc Raw.ident.Literal;
           match
             pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype
               ((projT1 args) -> ℤ)%ptype option (fun x1 : option => x1)
           with
           | Some (_, _) =>
               idc_args <- ident.unify pattern.ident.Literal ##(projT2 args);
               x1 <- (if (let (x1, _) := idc_args in x1) <? 0
                      then
                       Some
                         (- (##(- (let (x1, _) := idc_args in x1))%Z + x0))%expr
                      else None);
               Some (Base x1)
           | None => None
           end
       | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t idc) x1 =>
           match x0 with
           | @expr.Ident _ _ _ t0 idc0 =>
               (args <- invert_bind_args idc0 Raw.ident.Literal;
                _ <- invert_bind_args idc Raw.ident.Z_opp;
                match
                  pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype
                    (s -> (projT1 args))%ptype option (fun x2 : option => x2)
                with
                | Some (_, _) =>
                    v <- type.try_make_transport_cps s ℤ;
                    idc_args <- ident.unify pattern.ident.Literal
                                  ##(projT2 args);
                    x2 <- (if (let (x2, _) := idc_args in x2) >? 0
                           then
                            Some
                              (-
                               (v (Compile.reflect x1) +
                                ##(let (x2, _) := idc_args in x2)))%expr
                           else None);
                    Some (Base x2)
                | None => None
                end);;
               args <- invert_bind_args idc0 Raw.ident.Literal;
               _ <- invert_bind_args idc Raw.ident.Z_opp;
               match
                 pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype
                   (s -> (projT1 args))%ptype option (fun x2 : option => x2)
               with
               | Some (_, _) =>
                   v <- type.try_make_transport_cps s ℤ;
                   idc_args <- ident.unify pattern.ident.Literal
                                 ##(projT2 args);
                   x2 <- (if (let (x2, _) := idc_args in x2) <? 0
                          then
                           Some
                             (##(- (let (x2, _) := idc_args in x2))%Z -
                              v (Compile.reflect x1))%expr
                          else None);
                   Some (Base x2)
               | None => None
               end
           | _ => None
           end
       | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
         (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat _ |
         @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
       | _ => None
       end;;
       match x0 with
       | @expr.Ident _ _ _ t idc =>
           args <- invert_bind_args idc Raw.ident.Literal;
           match
             pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype
               (ℤ -> (projT1 args))%ptype option (fun x1 : option => x1)
           with
           | Some (_, _) =>
               idc_args <- ident.unify pattern.ident.Literal ##(projT2 args);
               x1 <- (if (let (x1, _) := idc_args in x1) <? 0
                      then
                       Some
                         (x + ##(- (let (x1, _) := idc_args in x1))%Z)%expr
                      else None);
               Some (Base x1)
           | None => None
           end
       | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t idc) x1 =>
           match x with
           | @expr.App _ _ _ s0 _ (@expr.Ident _ _ _ t0 idc0) x2 =>
               _ <- invert_bind_args idc0 Raw.ident.Z_opp;
               _ <- invert_bind_args idc Raw.ident.Z_opp;
               match
                 pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype
                   (s0 -> s)%ptype option (fun x3 : option => x3)
               with
               | Some (_, _) =>
                   v <- type.try_make_transport_cps s0 ℤ;
                   v0 <- type.try_make_transport_cps s ℤ;
                   Some
                     (Base
                        (v0 (Compile.reflect x1) - v (Compile.reflect x2))%expr)
               | None => None
               end
           | @expr.App _ _ _ s0 _ ($_)%expr _ | @expr.App _ _ _ s0 _
             (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0 _
             (_ @ _)%expr_pat _ | @expr.App _ _ _ s0 _
             (@expr.LetIn _ _ _ _ _ _ _) _ => None
           | _ => None
           end
       | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
         (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat _ |
         @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
       | _ => None
       end;;
       match x with
       | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t idc) x1 =>
           _ <- invert_bind_args idc Raw.ident.Z_opp;
           match
             pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype (s -> ℤ)%ptype
               option (fun x2 : option => x2)
           with
           | Some (_, _) =>
               v <- type.try_make_transport_cps s ℤ;
               Some (Base (- (v (Compile.reflect x1) + x0))%expr)
           | None => None
           end
       | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
         (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat _ |
         @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
       | _ => None
       end;;
       match x0 with
       | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t idc) x1 =>
           _ <- invert_bind_args idc Raw.ident.Z_opp;
           match
             pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype (ℤ -> s)%ptype
               option (fun x2 : option => x2)
           with
           | Some (_, _) =>
               v <- type.try_make_transport_cps s ℤ;
               Some (Base (x + v (Compile.reflect x1))%expr)
           | None => None
           end
       | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
         (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat _ |
         @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
       | _ => None
       end);;
      None);;;
     Base (x - x0)%expr)%option
| Z_opp =>
    fun x : expr ℤ =>
    (((match x with
       | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t idc) x0 =>
           _ <- invert_bind_args idc Raw.ident.Z_opp;
           match
             pattern.type.unify_extracted_cps ℤ s option
               (fun x1 : option => x1)
           with
           | Some _ =>
               v <- type.try_make_transport_cps s ℤ;
               Some (Base (v (Compile.reflect x0)))
           | None => None
           end
       | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
         (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat _ |
         @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
       | _ => None
       end;;
       match
         pattern.type.unify_extracted_cps ℤ ℤ option (fun x0 : option => x0)
       with
       | Some _ =>
           fv <- (if negb (SubstVarLike.is_var_fst_snd_pair_opp x)
                  then
                   Some
                     (UnderLet x
                        (fun
                           v : var
                                 (base.subst_default ℤ
                                    (PositiveMap.empty base.type)) =>
                         Base (- $v)%expr))
                  else None);
           Some (fv0 <-- fv;
                 Base fv0)%under_lets
       | None => None
       end);;
      None);;;
     Base (- x)%expr)%option
| Z_div =>
    fun x x0 : expr ℤ =>
    ((match x0 with
      | @expr.Ident _ _ _ t idc =>
          (args <- invert_bind_args idc Raw.ident.Literal;
           match
             pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype
               (ℤ -> (projT1 args))%ptype option (fun x1 : option => x1)
           with
           | Some (_, _) =>
               idc_args <- ident.unify pattern.ident.Literal ##(projT2 args);
               x1 <- (if (let (x1, _) := idc_args in x1) =? 1
                      then Some x
                      else None);
               Some (Base x1)
           | None => None
           end);;
          args <- invert_bind_args idc Raw.ident.Literal;
          match
            pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype
              (ℤ -> (projT1 args))%ptype option (fun x1 : option => x1)
          with
          | Some (_, _) =>
              idc_args <- ident.unify pattern.ident.Literal ##(projT2 args);
              x1 <- (if
                      (let (x1, _) := idc_args in x1) =?
                      2 ^ Z.log2 (let (x1, _) := idc_args in x1)
                     then
                      Some
                        (x >> ##(Z.log2 (let (x1, _) := idc_args in x1)))%expr
                     else None);
              Some (Base x1)
          | None => None
          end
      | _ => None
      end;;
      None);;;
     Base (x / x0)%expr)%option
| Z_modulo =>
    fun x x0 : expr ℤ =>
    (match x0 with
     | @expr.Ident _ _ _ t idc =>
         (args <- invert_bind_args idc Raw.ident.Literal;
          match
            pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype
              (ℤ -> (projT1 args))%ptype option (fun x1 : option => x1)
          with
          | Some (_, _) =>
              idc_args <- ident.unify pattern.ident.Literal ##(projT2 args);
              x1 <- (if (let (x1, _) := idc_args in x1) =? 1
                     then Some (##0)%expr
                     else None);
              Some (Base x1)
          | None => None
          end);;
         args <- invert_bind_args idc Raw.ident.Literal;
         match
           pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype
             (ℤ -> (projT1 args))%ptype option (fun x1 : option => x1)
         with
         | Some (_, _) =>
             idc_args <- ident.unify pattern.ident.Literal ##(projT2 args);
             x1 <- (if
                     (let (x1, _) := idc_args in x1) =?
                     2 ^ Z.log2 (let (x1, _) := idc_args in x1)
                    then
                     Some
                       (x &' ##((let (x1, _) := idc_args in x1) - 1)%Z)%expr
                    else None);
             Some (Base x1)
         | None => None
         end
     | _ => None
     end;;;
     Base (x mod x0)%expr)%option
| Z_log2 => fun x : expr ℤ => Base (#(Z_log2)%expr @ x)%expr_pat
| Z_log2_up => fun x : expr ℤ => Base (#(Z_log2_up)%expr @ x)%expr_pat
| Z_eqb => fun x x0 : expr ℤ => Base (#(Z_eqb)%expr @ x @ x0)%expr_pat
| Z_leb => fun x x0 : expr ℤ => Base (#(Z_leb)%expr @ x @ x0)%expr_pat
| Z_geb => fun x x0 : expr ℤ => Base (#(Z_geb)%expr @ x @ x0)%expr_pat
| Z_of_nat => fun x : expr ℕ => Base (#(Z_of_nat)%expr @ x)%expr_pat
| Z_to_nat => fun x : expr ℤ => Base (#(Z_to_nat)%expr @ x)%expr_pat
| Z_shiftr => fun x x0 : expr ℤ => Base (x >> x0)%expr
| Z_shiftl => fun x x0 : expr ℤ => Base (x << x0)%expr
| Z_land =>
    fun x x0 : expr ℤ =>
    (((match x0 with
       | @expr.Ident _ _ _ t idc =>
           args <- invert_bind_args idc Raw.ident.Literal;
           match
             pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype
               (ℤ -> (projT1 args))%ptype option (fun x1 : option => x1)
           with
           | Some (_, _) =>
               idc_args <- ident.unify pattern.ident.Literal ##(projT2 args);
               x1 <- (if (let (x1, _) := idc_args in x1) =? 0
                      then Some (##0)%expr
                      else None);
               Some (Base x1)
           | None => None
           end
       | _ => None
       end;;
       match x with
       | @expr.Ident _ _ _ t idc =>
           args <- invert_bind_args idc Raw.ident.Literal;
           match
             pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype
               ((projT1 args) -> ℤ)%ptype option (fun x1 : option => x1)
           with
           | Some (_, _) =>
               idc_args <- ident.unify pattern.ident.Literal ##(projT2 args);
               x1 <- (if (let (x1, _) := idc_args in x1) =? 0
                      then Some (##0)%expr
                      else None);
               Some (Base x1)
           | None => None
           end
       | _ => None
       end);;
      None);;;
     Base (x &' x0)%expr)%option
| Z_lor => fun x x0 : expr ℤ => Base (x || x0)%expr
| Z_bneg => fun x : expr ℤ => Base (#(Z_bneg)%expr @ x)%expr_pat
| Z_lnot_modulo =>
    fun x x0 : expr ℤ => Base (#(Z_lnot_modulo)%expr @ x @ x0)%expr_pat
| Z_mul_split =>
    fun x x0 x1 : expr ℤ =>
    (((match x with
       | @expr.Ident _ _ _ t idc =>
           match x0 with
           | @expr.Ident _ _ _ t0 idc0 =>
               args <- invert_bind_args idc0 Raw.ident.Literal;
               args0 <- invert_bind_args idc Raw.ident.Literal;
               match
                 pattern.type.unify_extracted_cps ((ℤ -> ℤ) -> ℤ)%ptype
                   (((projT1 args0) -> (projT1 args)) -> ℤ)%ptype option
                   (fun x2 : option => x2)
               with
               | Some (_, _, _) =>
                   _ <- ident.unify pattern.ident.Literal ##(projT2 args0);
                   idc_args0 <- ident.unify pattern.ident.Literal
                                  ##(projT2 args);
                   x2 <- (if (let (x2, _) := idc_args0 in x2) =? 0
                          then Some ((##0)%expr, (##0)%expr)%expr_pat
                          else None);
                   Some (Base x2)
               | None => None
               end
           | _ => None
           end;;
           match x1 with
           | @expr.Ident _ _ _ t0 idc0 =>
               args <- invert_bind_args idc0 Raw.ident.Literal;
               args0 <- invert_bind_args idc Raw.ident.Literal;
               match
                 pattern.type.unify_extracted_cps ((ℤ -> ℤ) -> ℤ)%ptype
                   (((projT1 args0) -> ℤ) -> (projT1 args))%ptype option
                   (fun x2 : option => x2)
               with
               | Some (_, _, _) =>
                   _ <- ident.unify pattern.ident.Literal ##(projT2 args0);
                   idc_args0 <- ident.unify pattern.ident.Literal
                                  ##(projT2 args);
                   x2 <- (if (let (x2, _) := idc_args0 in x2) =? 0
                          then Some ((##0)%expr, (##0)%expr)%expr_pat
                          else None);
                   Some (Base x2)
               | None => None
               end
           | _ => None
           end;;
           match x0 with
           | @expr.Ident _ _ _ t0 idc0 =>
               args <- invert_bind_args idc0 Raw.ident.Literal;
               args0 <- invert_bind_args idc Raw.ident.Literal;
               match
                 pattern.type.unify_extracted_cps ((ℤ -> ℤ) -> ℤ)%ptype
                   (((projT1 args0) -> (projT1 args)) -> ℤ)%ptype option
                   (fun x2 : option => x2)
               with
               | Some (_, _, _) =>
                   _ <- ident.unify pattern.ident.Literal ##(projT2 args0);
                   idc_args0 <- ident.unify pattern.ident.Literal
                                  ##(projT2 args);
                   x2 <- (if (let (x2, _) := idc_args0 in x2) =? 1
                          then Some (x1, (##0)%expr)%expr_pat
                          else None);
                   Some (Base x2)
               | None => None
               end
           | _ => None
           end;;
           match x1 with
           | @expr.Ident _ _ _ t0 idc0 =>
               args <- invert_bind_args idc0 Raw.ident.Literal;
               args0 <- invert_bind_args idc Raw.ident.Literal;
               match
                 pattern.type.unify_extracted_cps ((ℤ -> ℤ) -> ℤ)%ptype
                   (((projT1 args0) -> ℤ) -> (projT1 args))%ptype option
                   (fun x2 : option => x2)
               with
               | Some (_, _, _) =>
                   _ <- ident.unify pattern.ident.Literal ##(projT2 args0);
                   idc_args0 <- ident.unify pattern.ident.Literal
                                  ##(projT2 args);
                   x2 <- (if (let (x2, _) := idc_args0 in x2) =? 1
                          then Some (x0, (##0)%expr)%expr_pat
                          else None);
                   Some (Base x2)
               | None => None
               end
           | _ => None
           end;;
           match x0 with
           | @expr.Ident _ _ _ t0 idc0 =>
               args <- invert_bind_args idc0 Raw.ident.Literal;
               args0 <- invert_bind_args idc Raw.ident.Literal;
               match
                 pattern.type.unify_extracted_cps ((ℤ -> ℤ) -> ℤ)%ptype
                   (((projT1 args0) -> (projT1 args)) -> ℤ)%ptype option
                   (fun x2 : option => x2)
               with
               | Some (_, _, _) =>
                   _ <- ident.unify pattern.ident.Literal ##(projT2 args0);
                   idc_args0 <- ident.unify pattern.ident.Literal
                                  ##(projT2 args);
                   x2 <- (if (let (x2, _) := idc_args0 in x2) =? -1
                          then Some ((- x1)%expr, (##0)%expr)%expr_pat
                          else None);
                   Some (Base x2)
               | None => None
               end
           | _ => None
           end;;
           match x1 with
           | @expr.Ident _ _ _ t0 idc0 =>
               args <- invert_bind_args idc0 Raw.ident.Literal;
               args0 <- invert_bind_args idc Raw.ident.Literal;
               match
                 pattern.type.unify_extracted_cps ((ℤ -> ℤ) -> ℤ)%ptype
                   (((projT1 args0) -> ℤ) -> (projT1 args))%ptype option
                   (fun x2 : option => x2)
               with
               | Some (_, _, _) =>
                   _ <- ident.unify pattern.ident.Literal ##(projT2 args0);
                   idc_args0 <- ident.unify pattern.ident.Literal
                                  ##(projT2 args);
                   x2 <- (if (let (x2, _) := idc_args0 in x2) =? -1
                          then Some ((- x0)%expr, (##0)%expr)%expr_pat
                          else None);
                   Some (Base x2)
               | None => None
               end
           | _ => None
           end
       | _ => None
       end;;
       match
         pattern.type.unify_extracted_cps ((ℤ -> ℤ) -> ℤ)%ptype
           ((ℤ -> ℤ) -> ℤ)%ptype option (fun x2 : option => x2)
       with
       | Some (_, _, _) =>
           Some
             (UnderLet (#(Z_mul_split)%expr @ x @ x0 @ x1)%expr_pat
                (fun v : var (ℤ * ℤ)%etype =>
                 Base
                   (#(fst)%expr @ ($v)%expr, #(snd)%expr @ ($v)%expr)%expr_pat))
       | None => None
       end);;
      None);;;
     Base (#(Z_mul_split)%expr @ x @ x0 @ x1)%expr_pat)%option
| Z_add_get_carry =>
    fun x x0 x1 : expr ℤ =>
    (((match x0 with
       | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t idc) x2 =>
           _ <- invert_bind_args idc Raw.ident.Z_opp;
           match
             pattern.type.unify_extracted_cps ((ℤ -> ℤ) -> ℤ)%ptype
               ((ℤ -> s) -> ℤ)%ptype option (fun x3 : option => x3)
           with
           | Some (_, _, _) =>
               v <- type.try_make_transport_cps s ℤ;
               Some
                 (UnderLet
                    (#(Z_sub_get_borrow)%expr @ x @ x1 @
                     v (Compile.reflect x2))%expr_pat
                    (fun v0 : var (ℤ * ℤ)%etype =>
                     Base
                       (#(fst)%expr @ ($v0)%expr,
                       (- (#(snd)%expr @ $v0)%expr_pat)%expr)%expr_pat))
           | None => None
           end
       | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
         (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat _ |
         @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
       | _ => None
       end;;
       match x1 with
       | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t idc) x2 =>
           _ <- invert_bind_args idc Raw.ident.Z_opp;
           match
             pattern.type.unify_extracted_cps ((ℤ -> ℤ) -> ℤ)%ptype
               ((ℤ -> ℤ) -> s)%ptype option (fun x3 : option => x3)
           with
           | Some (_, _, _) =>
               v <- type.try_make_transport_cps s ℤ;
               Some
                 (UnderLet
                    (#(Z_sub_get_borrow)%expr @ x @ x0 @
                     v (Compile.reflect x2))%expr_pat
                    (fun v0 : var (ℤ * ℤ)%etype =>
                     Base
                       (#(fst)%expr @ ($v0)%expr,
                       (- (#(snd)%expr @ $v0)%expr_pat)%expr)%expr_pat))
           | None => None
           end
       | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
         (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat _ |
         @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
       | _ => None
       end;;
       match x0 with
       | @expr.Ident _ _ _ t idc =>
           args <- invert_bind_args idc Raw.ident.Literal;
           match
             pattern.type.unify_extracted_cps ((ℤ -> ℤ) -> ℤ)%ptype
               ((ℤ -> (projT1 args)) -> ℤ)%ptype option
               (fun x2 : option => x2)
           with
           | Some (_, _, _) =>
               idc_args <- ident.unify pattern.ident.Literal ##(projT2 args);
               fv <- (if (let (x2, _) := idc_args in x2) <? 0
                      then
                       Some
                         (UnderLet
                            (#(Z_sub_get_borrow)%expr @ x @ x1 @
                             (##(- (let (x2, _) := idc_args in x2))%Z)%expr)%expr_pat
                            (fun vc : var (ℤ * ℤ)%etype =>
                             Base
                               (#(fst)%expr @ ($vc)%expr,
                               (- (#(snd)%expr @ $vc)%expr_pat)%expr)%expr_pat))
                      else None);
               Some (fv0 <-- fv;
                     Base fv0)%under_lets
           | None => None
           end
       | _ => None
       end;;
       match x1 with
       | @expr.Ident _ _ _ t idc =>
           args <- invert_bind_args idc Raw.ident.Literal;
           match
             pattern.type.unify_extracted_cps ((ℤ -> ℤ) -> ℤ)%ptype
               ((ℤ -> ℤ) -> (projT1 args))%ptype option
               (fun x2 : option => x2)
           with
           | Some (_, _, _) =>
               idc_args <- ident.unify pattern.ident.Literal ##(projT2 args);
               fv <- (if (let (x2, _) := idc_args in x2) <? 0
                      then
                       Some
                         (UnderLet
                            (#(Z_sub_get_borrow)%expr @ x @ x0 @
                             (##(- (let (x2, _) := idc_args in x2))%Z)%expr)%expr_pat
                            (fun vc : var (ℤ * ℤ)%etype =>
                             Base
                               (#(fst)%expr @ ($vc)%expr,
                               (- (#(snd)%expr @ $vc)%expr_pat)%expr)%expr_pat))
                      else None);
               Some (fv0 <-- fv;
                     Base fv0)%under_lets
           | None => None
           end
       | _ => None
       end;;
       match x0 with
       | @expr.Ident _ _ _ t idc =>
           args <- invert_bind_args idc Raw.ident.Literal;
           match
             pattern.type.unify_extracted_cps ((ℤ -> ℤ) -> ℤ)%ptype
               ((ℤ -> (projT1 args)) -> ℤ)%ptype option
               (fun x2 : option => x2)
           with
           | Some (_, _, _) =>
               idc_args <- ident.unify pattern.ident.Literal ##(projT2 args);
               x2 <- (if (let (x2, _) := idc_args in x2) =? 0
                      then Some (x1, (##0)%expr)%expr_pat
                      else None);
               Some (Base x2)
           | None => None
           end
       | _ => None
       end;;
       match x1 with
       | @expr.Ident _ _ _ t idc =>
           args <- invert_bind_args idc Raw.ident.Literal;
           match
             pattern.type.unify_extracted_cps ((ℤ -> ℤ) -> ℤ)%ptype
               ((ℤ -> ℤ) -> (projT1 args))%ptype option
               (fun x2 : option => x2)
           with
           | Some (_, _, _) =>
               idc_args <- ident.unify pattern.ident.Literal ##(projT2 args);
               x2 <- (if (let (x2, _) := idc_args in x2) =? 0
                      then Some (x0, (##0)%expr)%expr_pat
                      else None);
               Some (Base x2)
           | None => None
           end
       | _ => None
       end;;
       match
         pattern.type.unify_extracted_cps ((ℤ -> ℤ) -> ℤ)%ptype
           ((ℤ -> ℤ) -> ℤ)%ptype option (fun x2 : option => x2)
       with
       | Some (_, _, _) =>
           Some
             (UnderLet (#(Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                (fun v : var (ℤ * ℤ)%etype =>
                 Base
                   (#(fst)%expr @ ($v)%expr, #(snd)%expr @ ($v)%expr)%expr_pat))
       | None => None
       end);;
      None);;;
     Base (#(Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat)%option
| Z_add_with_carry =>
    fun x x0 x1 : expr ℤ =>
    (((match x with
       | @expr.Ident _ _ _ t idc =>
           args <- invert_bind_args idc Raw.ident.Literal;
           match
             pattern.type.unify_extracted_cps ((ℤ -> ℤ) -> ℤ)%ptype
               (((projT1 args) -> ℤ) -> ℤ)%ptype option
               (fun x2 : option => x2)
           with
           | Some (_, _, _) =>
               idc_args <- ident.unify pattern.ident.Literal ##(projT2 args);
               x2 <- (if (let (x2, _) := idc_args in x2) =? 0
                      then Some (x0 + x1)%expr
                      else None);
               Some (Base x2)
           | None => None
           end
       | _ => None
       end;;
       match
         pattern.type.unify_extracted_cps ((ℤ -> ℤ) -> ℤ)%ptype
           ((ℤ -> ℤ) -> ℤ)%ptype option (fun x2 : option => x2)
       with
       | Some (_, _, _) =>
           Some
             (UnderLet (#(Z_add_with_carry)%expr @ x @ x0 @ x1)%expr_pat
                (fun v : var ℤ => Base ($v)%expr))
       | None => None
       end);;
      None);;;
     Base (#(Z_add_with_carry)%expr @ x @ x0 @ x1)%expr_pat)%option
| Z_add_with_get_carry =>
    fun x x0 x1 x2 : expr ℤ =>
    (((match x0 with
       | @expr.Ident _ _ _ t idc =>
           match x1 with
           | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t0 idc0) x3 =>
               (_ <- invert_bind_args idc0 Raw.ident.Z_opp;
                args0 <- invert_bind_args idc Raw.ident.Literal;
                match
                  pattern.type.unify_extracted_cps
                    (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
                    (((ℤ -> (projT1 args0)) -> s) -> ℤ)%ptype option
                    (fun x4 : option => x4)
                with
                | Some (_, _, _, _) =>
                    idc_args <- ident.unify pattern.ident.Literal
                                  ##(projT2 args0);
                    v <- type.try_make_transport_cps s ℤ;
                    fv <- (if (let (x4, _) := idc_args in x4) =? 0
                           then
                            Some
                              (UnderLet
                                 (#(Z_sub_get_borrow)%expr @ x @ x2 @
                                  v (Compile.reflect x3))%expr_pat
                                 (fun vc : var (ℤ * ℤ)%etype =>
                                  Base
                                    (#(fst)%expr @ ($vc)%expr,
                                    (- (#(snd)%expr @ $vc)%expr_pat)%expr)%expr_pat))
                           else None);
                    Some (fv0 <-- fv;
                          Base fv0)%under_lets
                | None => None
                end);;
               _ <- invert_bind_args idc0 Raw.ident.Z_opp;
               args0 <- invert_bind_args idc Raw.ident.Literal;
               match
                 pattern.type.unify_extracted_cps
                   (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
                   (((ℤ -> (projT1 args0)) -> s) -> ℤ)%ptype option
                   (fun x4 : option => x4)
               with
               | Some (_, _, _, _) =>
                   idc_args <- ident.unify pattern.ident.Literal
                                 ##(projT2 args0);
                   v <- type.try_make_transport_cps s ℤ;
                   fv <- (if (let (x4, _) := idc_args in x4) <? 0
                          then
                           Some
                             (UnderLet
                                (#(Z_sub_with_get_borrow)%expr @ x @
                                 (##(- (let (x4, _) := idc_args in x4))%Z)%expr @
                                 x2 @ v (Compile.reflect x3))%expr_pat
                                (fun vc : var (ℤ * ℤ)%etype =>
                                 Base
                                   (#(fst)%expr @ ($vc)%expr,
                                   (- (#(snd)%expr @ $vc)%expr_pat)%expr)%expr_pat))
                          else None);
                   Some (fv0 <-- fv;
                         Base fv0)%under_lets
               | None => None
               end
           | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
             (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat
             _ | @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
           | _ => None
           end;;
           match x2 with
           | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t0 idc0) x3 =>
               (_ <- invert_bind_args idc0 Raw.ident.Z_opp;
                args0 <- invert_bind_args idc Raw.ident.Literal;
                match
                  pattern.type.unify_extracted_cps
                    (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
                    (((ℤ -> (projT1 args0)) -> ℤ) -> s)%ptype option
                    (fun x4 : option => x4)
                with
                | Some (_, _, _, _) =>
                    idc_args <- ident.unify pattern.ident.Literal
                                  ##(projT2 args0);
                    v <- type.try_make_transport_cps s ℤ;
                    fv <- (if (let (x4, _) := idc_args in x4) =? 0
                           then
                            Some
                              (UnderLet
                                 (#(Z_sub_get_borrow)%expr @ x @ x1 @
                                  v (Compile.reflect x3))%expr_pat
                                 (fun vc : var (ℤ * ℤ)%etype =>
                                  Base
                                    (#(fst)%expr @ ($vc)%expr,
                                    (- (#(snd)%expr @ $vc)%expr_pat)%expr)%expr_pat))
                           else None);
                    Some (fv0 <-- fv;
                          Base fv0)%under_lets
                | None => None
                end);;
               _ <- invert_bind_args idc0 Raw.ident.Z_opp;
               args0 <- invert_bind_args idc Raw.ident.Literal;
               match
                 pattern.type.unify_extracted_cps
                   (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
                   (((ℤ -> (projT1 args0)) -> ℤ) -> s)%ptype option
                   (fun x4 : option => x4)
               with
               | Some (_, _, _, _) =>
                   idc_args <- ident.unify pattern.ident.Literal
                                 ##(projT2 args0);
                   v <- type.try_make_transport_cps s ℤ;
                   fv <- (if (let (x4, _) := idc_args in x4) <? 0
                          then
                           Some
                             (UnderLet
                                (#(Z_sub_with_get_borrow)%expr @ x @
                                 (##(- (let (x4, _) := idc_args in x4))%Z)%expr @
                                 x1 @ v (Compile.reflect x3))%expr_pat
                                (fun vc : var (ℤ * ℤ)%etype =>
                                 Base
                                   (#(fst)%expr @ ($vc)%expr,
                                   (- (#(snd)%expr @ $vc)%expr_pat)%expr)%expr_pat))
                          else None);
                   Some (fv0 <-- fv;
                         Base fv0)%under_lets
               | None => None
               end
           | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
             (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat
             _ | @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
           | _ => None
           end;;
           match x1 with
           | @expr.Ident _ _ _ t0 idc0 =>
               args <- invert_bind_args idc0 Raw.ident.Literal;
               args0 <- invert_bind_args idc Raw.ident.Literal;
               match
                 pattern.type.unify_extracted_cps
                   (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
                   (((ℤ -> (projT1 args0)) -> (projT1 args)) -> ℤ)%ptype
                   option (fun x3 : option => x3)
               with
               | Some (_, _, _, _) =>
                   idc_args <- ident.unify pattern.ident.Literal
                                 ##(projT2 args0);
                   idc_args0 <- ident.unify pattern.ident.Literal
                                  ##(projT2 args);
                   fv <- (if
                           ((let (x3, _) := idc_args0 in x3) <=? 0) &&
                           ((let (x3, _) := idc_args in x3) <=? 0) &&
                           ((let (x3, _) := idc_args0 in x3) +
                            (let (x3, _) := idc_args in x3) <? 0)
                          then
                           Some
                             (UnderLet
                                (#(Z_sub_with_get_borrow)%expr @ x @
                                 (##(- (let (x3, _) := idc_args in x3))%Z)%expr @
                                 x2 @
                                 (##(- (let (x3, _) := idc_args0 in x3))%Z)%expr)%expr_pat
                                (fun vc : var (ℤ * ℤ)%etype =>
                                 Base
                                   (#(fst)%expr @ ($vc)%expr,
                                   (- (#(snd)%expr @ $vc)%expr_pat)%expr)%expr_pat))
                          else None);
                   Some (fv0 <-- fv;
                         Base fv0)%under_lets
               | None => None
               end
           | _ => None
           end;;
           match x2 with
           | @expr.Ident _ _ _ t0 idc0 =>
               args <- invert_bind_args idc0 Raw.ident.Literal;
               args0 <- invert_bind_args idc Raw.ident.Literal;
               match
                 pattern.type.unify_extracted_cps
                   (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
                   (((ℤ -> (projT1 args0)) -> ℤ) -> (projT1 args))%ptype
                   option (fun x3 : option => x3)
               with
               | Some (_, _, _, _) =>
                   idc_args <- ident.unify pattern.ident.Literal
                                 ##(projT2 args0);
                   idc_args0 <- ident.unify pattern.ident.Literal
                                  ##(projT2 args);
                   fv <- (if
                           ((let (x3, _) := idc_args0 in x3) <=? 0) &&
                           ((let (x3, _) := idc_args in x3) <=? 0) &&
                           ((let (x3, _) := idc_args0 in x3) +
                            (let (x3, _) := idc_args in x3) <? 0)
                          then
                           Some
                             (UnderLet
                                (#(Z_sub_with_get_borrow)%expr @ x @
                                 (##(- (let (x3, _) := idc_args in x3))%Z)%expr @
                                 x1 @
                                 (##(- (let (x3, _) := idc_args0 in x3))%Z)%expr)%expr_pat
                                (fun vc : var (ℤ * ℤ)%etype =>
                                 Base
                                   (#(fst)%expr @ ($vc)%expr,
                                   (- (#(snd)%expr @ $vc)%expr_pat)%expr)%expr_pat))
                          else None);
                   Some (fv0 <-- fv;
                         Base fv0)%under_lets
               | None => None
               end
           | _ => None
           end;;
           match x with
           | @expr.Ident _ _ _ t0 idc0 =>
               match x1 with
               | @expr.Ident _ _ _ t1 idc1 =>
                   args <- invert_bind_args idc1 Raw.ident.Literal;
                   args0 <- invert_bind_args idc0 Raw.ident.Literal;
                   args1 <- invert_bind_args idc Raw.ident.Literal;
                   match
                     pattern.type.unify_extracted_cps
                       (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
                       ((((projT1 args0) -> (projT1 args1)) -> (projT1 args)) ->
                        ℤ)%ptype option (fun x3 : option => x3)
                   with
                   | Some (_, _, _, _) =>
                       _ <- ident.unify pattern.ident.Literal
                              ##(projT2 args0);
                       idc_args0 <- ident.unify pattern.ident.Literal
                                      ##(projT2 args1);
                       idc_args1 <- ident.unify pattern.ident.Literal
                                      ##(projT2 args);
                       x3 <- (if
                               ((let (x3, _) := idc_args0 in x3) =? 0) &&
                               ((let (x3, _) := idc_args1 in x3) =? 0)
                              then Some (x2, (##0)%expr)%expr_pat
                              else None);
                       Some (Base x3)
                   | None => None
                   end
               | _ => None
               end;;
               match x2 with
               | @expr.Ident _ _ _ t1 idc1 =>
                   args <- invert_bind_args idc1 Raw.ident.Literal;
                   args0 <- invert_bind_args idc0 Raw.ident.Literal;
                   args1 <- invert_bind_args idc Raw.ident.Literal;
                   match
                     pattern.type.unify_extracted_cps
                       (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
                       ((((projT1 args0) -> (projT1 args1)) -> ℤ) ->
                        (projT1 args))%ptype option (fun x3 : option => x3)
                   with
                   | Some (_, _, _, _) =>
                       _ <- ident.unify pattern.ident.Literal
                              ##(projT2 args0);
                       idc_args0 <- ident.unify pattern.ident.Literal
                                      ##(projT2 args1);
                       idc_args1 <- ident.unify pattern.ident.Literal
                                      ##(projT2 args);
                       x3 <- (if
                               ((let (x3, _) := idc_args0 in x3) =? 0) &&
                               ((let (x3, _) := idc_args1 in x3) =? 0)
                              then Some (x1, (##0)%expr)%expr_pat
                              else None);
                       Some (Base x3)
                   | None => None
                   end
               | _ => None
               end
           | _ => None
           end;;
           args <- invert_bind_args idc Raw.ident.Literal;
           match
             pattern.type.unify_extracted_cps (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
               (((ℤ -> (projT1 args)) -> ℤ) -> ℤ)%ptype option
               (fun x3 : option => x3)
           with
           | Some (_, _, _, _) =>
               idc_args <- ident.unify pattern.ident.Literal ##(projT2 args);
               fv <- (if (let (x3, _) := idc_args in x3) =? 0
                      then
                       Some
                         (UnderLet
                            (#(Z_add_get_carry)%expr @ x @ x1 @ x2)%expr_pat
                            (fun vc : var (ℤ * ℤ)%etype =>
                             Base
                               (#(fst)%expr @ ($vc)%expr,
                               #(snd)%expr @ ($vc)%expr)%expr_pat))
                      else None);
               Some (fv0 <-- fv;
                     Base fv0)%under_lets
           | None => None
           end
       | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t idc) x3 =>
           match x1 with
           | @expr.App _ _ _ s0 _ (@expr.Ident _ _ _ t0 idc0) x4 =>
               _ <- invert_bind_args idc0 Raw.ident.Z_opp;
               _ <- invert_bind_args idc Raw.ident.Z_opp;
               match
                 pattern.type.unify_extracted_cps
                   (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype (((ℤ -> s) -> s0) -> ℤ)%ptype
                   option (fun x5 : option => x5)
               with
               | Some (_, _, _, _) =>
                   v <- type.try_make_transport_cps s ℤ;
                   v0 <- type.try_make_transport_cps s0 ℤ;
                   Some
                     (UnderLet
                        (#(Z_sub_with_get_borrow)%expr @ x @
                         v (Compile.reflect x3) @ x2 @
                         v0 (Compile.reflect x4))%expr_pat
                        (fun v1 : var (ℤ * ℤ)%etype =>
                         Base
                           (#(fst)%expr @ ($v1)%expr,
                           (- (#(snd)%expr @ $v1)%expr_pat)%expr)%expr_pat))
               | None => None
               end
           | @expr.App _ _ _ s0 _ ($_)%expr _ | @expr.App _ _ _ s0 _
             (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0 _
             (_ @ _)%expr_pat _ | @expr.App _ _ _ s0 _
             (@expr.LetIn _ _ _ _ _ _ _) _ => None
           | _ => None
           end;;
           match x2 with
           | @expr.App _ _ _ s0 _ (@expr.Ident _ _ _ t0 idc0) x4 =>
               _ <- invert_bind_args idc0 Raw.ident.Z_opp;
               _ <- invert_bind_args idc Raw.ident.Z_opp;
               match
                 pattern.type.unify_extracted_cps
                   (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype (((ℤ -> s) -> ℤ) -> s0)%ptype
                   option (fun x5 : option => x5)
               with
               | Some (_, _, _, _) =>
                   v <- type.try_make_transport_cps s ℤ;
                   v0 <- type.try_make_transport_cps s0 ℤ;
                   Some
                     (UnderLet
                        (#(Z_sub_with_get_borrow)%expr @ x @
                         v (Compile.reflect x3) @ x1 @
                         v0 (Compile.reflect x4))%expr_pat
                        (fun v1 : var (ℤ * ℤ)%etype =>
                         Base
                           (#(fst)%expr @ ($v1)%expr,
                           (- (#(snd)%expr @ $v1)%expr_pat)%expr)%expr_pat))
               | None => None
               end
           | @expr.App _ _ _ s0 _ ($_)%expr _ | @expr.App _ _ _ s0 _
             (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0 _
             (_ @ _)%expr_pat _ | @expr.App _ _ _ s0 _
             (@expr.LetIn _ _ _ _ _ _ _) _ => None
           | _ => None
           end;;
           match x1 with
           | @expr.Ident _ _ _ t0 idc0 =>
               args <- invert_bind_args idc0 Raw.ident.Literal;
               _ <- invert_bind_args idc Raw.ident.Z_opp;
               match
                 pattern.type.unify_extracted_cps
                   (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
                   (((ℤ -> s) -> (projT1 args)) -> ℤ)%ptype option
                   (fun x4 : option => x4)
               with
               | Some (_, _, _, _) =>
                   v <- type.try_make_transport_cps s ℤ;
                   idc_args <- ident.unify pattern.ident.Literal
                                 ##(projT2 args);
                   fv <- (if (let (x4, _) := idc_args in x4) <=? 0
                          then
                           Some
                             (UnderLet
                                (#(Z_sub_with_get_borrow)%expr @ x @
                                 v (Compile.reflect x3) @ x2 @
                                 (##(- (let (x4, _) := idc_args in x4))%Z)%expr)%expr_pat
                                (fun vc : var (ℤ * ℤ)%etype =>
                                 Base
                                   (#(fst)%expr @ ($vc)%expr,
                                   (- (#(snd)%expr @ $vc)%expr_pat)%expr)%expr_pat))
                          else None);
                   Some (fv0 <-- fv;
                         Base fv0)%under_lets
               | None => None
               end
           | _ => None
           end;;
           match x2 with
           | @expr.Ident _ _ _ t0 idc0 =>
               args <- invert_bind_args idc0 Raw.ident.Literal;
               _ <- invert_bind_args idc Raw.ident.Z_opp;
               match
                 pattern.type.unify_extracted_cps
                   (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
                   (((ℤ -> s) -> ℤ) -> (projT1 args))%ptype option
                   (fun x4 : option => x4)
               with
               | Some (_, _, _, _) =>
                   v <- type.try_make_transport_cps s ℤ;
                   idc_args <- ident.unify pattern.ident.Literal
                                 ##(projT2 args);
                   fv <- (if (let (x4, _) := idc_args in x4) <=? 0
                          then
                           Some
                             (UnderLet
                                (#(Z_sub_with_get_borrow)%expr @ x @
                                 v (Compile.reflect x3) @ x1 @
                                 (##(- (let (x4, _) := idc_args in x4))%Z)%expr)%expr_pat
                                (fun vc : var (ℤ * ℤ)%etype =>
                                 Base
                                   (#(fst)%expr @ ($vc)%expr,
                                   (- (#(snd)%expr @ $vc)%expr_pat)%expr)%expr_pat))
                          else None);
                   Some (fv0 <-- fv;
                         Base fv0)%under_lets
               | None => None
               end
           | _ => None
           end
       | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
         (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat _ |
         @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
       | _ => None
       end;;
       match x1 with
       | @expr.Ident _ _ _ t idc =>
           match x2 with
           | @expr.Ident _ _ _ t0 idc0 =>
               args <- invert_bind_args idc0 Raw.ident.Literal;
               args0 <- invert_bind_args idc Raw.ident.Literal;
               match
                 pattern.type.unify_extracted_cps
                   (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
                   (((ℤ -> ℤ) -> (projT1 args0)) -> (projT1 args))%ptype
                   option (fun x3 : option => x3)
               with
               | Some (_, _, _, _) =>
                   idc_args <- ident.unify pattern.ident.Literal
                                 ##(projT2 args0);
                   idc_args0 <- ident.unify pattern.ident.Literal
                                  ##(projT2 args);
                   fv <- (if
                           ((let (x3, _) := idc_args in x3) =? 0) &&
                           ((let (x3, _) := idc_args0 in x3) =? 0)
                          then
                           Some
                             (UnderLet
                                (#(Z_add_with_get_carry)%expr @ x @ x0 @
                                 (##(let (x3, _) := idc_args in x3))%expr @
                                 (##(let (x3, _) := idc_args0 in x3))%expr)%expr_pat
                                (fun vc : var (ℤ * ℤ)%etype =>
                                 Base
                                   (#(fst)%expr @ ($vc)%expr, (##0)%expr)%expr_pat))
                          else None);
                   Some (fv0 <-- fv;
                         Base fv0)%under_lets
               | None => None
               end
           | _ => None
           end
       | _ => None
       end;;
       match
         pattern.type.unify_extracted_cps (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
           (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype option (fun x3 : option => x3)
       with
       | Some (_, _, _, _) =>
           Some
             (UnderLet
                (#(Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                (fun v : var (ℤ * ℤ)%etype =>
                 Base
                   (#(fst)%expr @ ($v)%expr, #(snd)%expr @ ($v)%expr)%expr_pat))
       | None => None
       end);;
      None);;;
     Base (#(Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat)%option
| Z_sub_get_borrow =>
    fun x x0 x1 : expr ℤ =>
    (match
       pattern.type.unify_extracted_cps ((ℤ -> ℤ) -> ℤ)%ptype
         ((ℤ -> ℤ) -> ℤ)%ptype option (fun x2 : option => x2)
     with
     | Some (_, _, _) =>
         Some
           (UnderLet (#(Z_sub_get_borrow)%expr @ x @ x0 @ x1)%expr_pat
              (fun v : var (ℤ * ℤ)%etype =>
               Base
                 (#(fst)%expr @ ($v)%expr, #(snd)%expr @ ($v)%expr)%expr_pat))
     | None => None
     end;;;
     Base (#(Z_sub_get_borrow)%expr @ x @ x0 @ x1)%expr_pat)%option
| Z_sub_with_get_borrow =>
    fun x x0 x1 x2 : expr ℤ =>
    (match
       pattern.type.unify_extracted_cps (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
         (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype option (fun x3 : option => x3)
     with
     | Some (_, _, _, _) =>
         Some
           (UnderLet
              (#(Z_sub_with_get_borrow)%expr @ x @ x0 @ x1 @ x2)%expr_pat
              (fun v : var (ℤ * ℤ)%etype =>
               Base
                 (#(fst)%expr @ ($v)%expr, #(snd)%expr @ ($v)%expr)%expr_pat))
     | None => None
     end;;;
     Base (#(Z_sub_with_get_borrow)%expr @ x @ x0 @ x1 @ x2)%expr_pat)%option
| Z_zselect =>
    fun x x0 x1 : expr ℤ => Base (#(Z_zselect)%expr @ x @ x0 @ x1)%expr_pat
| Z_add_modulo =>
    fun x x0 x1 : expr ℤ =>
    Base (#(Z_add_modulo)%expr @ x @ x0 @ x1)%expr_pat
| Z_rshi =>
    fun x x0 x1 x2 : expr ℤ =>
    Base (#(Z_rshi)%expr @ x @ x0 @ x1 @ x2)%expr_pat
| Z_cc_m => fun x x0 : expr ℤ => Base (#(Z_cc_m)%expr @ x @ x0)%expr_pat
| Z_cast range => fun x : expr ℤ => Base (#(Z_cast range)%expr @ x)%expr_pat
| Z_cast2 range =>
    fun x : expr (ℤ * ℤ)%etype =>
    (match x with
     | @expr.App _ _ _ s _
       (@expr.App _ _ _ s0 _ (@expr.Ident _ _ _ t idc) x1) x0 =>
         args <- invert_bind_args idc Raw.ident.pair;
         match
           pattern.type.unify_extracted_cps
             (((ℤ -> ℤ -> (ℤ * ℤ)%pbtype) -> ℤ) -> ℤ)%ptype
             ((((let (x2, _) := args in x2) ->
                (let (_, y) := args in y) ->
                ((let (x2, _) := args in x2) * (let (_, y) := args in y))%etype) ->
               s0) -> s)%ptype option (fun x2 : option => x2)
         with
         | Some (_, (_, (_, _)), _, _) =>
             _ <- ident.unify pattern.ident.pair pair;
             v <- type.try_make_transport_cps s0 ℤ;
             v0 <- type.try_make_transport_cps s ℤ;
             Some
               (fv <-- do_again (ℤ * ℤ)
                         (#(Z_cast (Datatypes.fst range))%expr @
                          ($(v (Compile.reflect x1)))%expr,
                         #(Z_cast (Datatypes.snd range))%expr @
                         ($(v0 (Compile.reflect x0)))%expr)%expr_pat;
                Base fv)%under_lets
         | None => None
         end
     | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ ($_)%expr _) _ | @expr.App _
       _ _ s _ (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _) _ | @expr.App
       _ _ _ s _ (@expr.App _ _ _ s0 _ (_ @ _)%expr_pat _) _ | @expr.App _ _
       _ s _ (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _) _ => None
     | @expr.App _ _ _ s _ #(_)%expr_pat _ | @expr.App _ _ _ s _ ($_)%expr
       _ | @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s
       _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
     | _ => None
     end;;;
     Base (#(Z_cast2 range)%expr @ x)%expr_pat)%option
| fancy_add log2wordmax imm =>
    fun x : expr (ℤ * ℤ)%etype =>
    Base (#(fancy_add log2wordmax imm)%expr @ x)%expr_pat
| fancy_addc log2wordmax imm =>
    fun x : expr (ℤ * ℤ * ℤ)%etype =>
    Base (#(fancy_addc log2wordmax imm)%expr @ x)%expr_pat
| fancy_sub log2wordmax imm =>
    fun x : expr (ℤ * ℤ)%etype =>
    Base (#(fancy_sub log2wordmax imm)%expr @ x)%expr_pat
| fancy_subb log2wordmax imm =>
    fun x : expr (ℤ * ℤ * ℤ)%etype =>
    Base (#(fancy_subb log2wordmax imm)%expr @ x)%expr_pat
| fancy_mulll log2wordmax =>
    fun x : expr (ℤ * ℤ)%etype =>
    Base (#(fancy_mulll log2wordmax)%expr @ x)%expr_pat
| fancy_mullh log2wordmax =>
    fun x : expr (ℤ * ℤ)%etype =>
    Base (#(fancy_mullh log2wordmax)%expr @ x)%expr_pat
| fancy_mulhl log2wordmax =>
    fun x : expr (ℤ * ℤ)%etype =>
    Base (#(fancy_mulhl log2wordmax)%expr @ x)%expr_pat
| fancy_mulhh log2wordmax =>
    fun x : expr (ℤ * ℤ)%etype =>
    Base (#(fancy_mulhh log2wordmax)%expr @ x)%expr_pat
| fancy_rshi log2wordmax x =>
    fun x0 : expr (ℤ * ℤ)%etype =>
    Base (#(fancy_rshi log2wordmax x)%expr @ x0)%expr_pat
| fancy_selc =>
    fun x : expr (ℤ * ℤ * ℤ)%etype => Base (#(fancy_selc)%expr @ x)%expr_pat
| fancy_selm log2wordmax =>
    fun x : expr (ℤ * ℤ * ℤ)%etype =>
    Base (#(fancy_selm log2wordmax)%expr @ x)%expr_pat
| fancy_sell =>
    fun x : expr (ℤ * ℤ * ℤ)%etype => Base (#(fancy_sell)%expr @ x)%expr_pat
| fancy_addm =>
    fun x : expr (ℤ * ℤ * ℤ)%etype => Base (#(fancy_addm)%expr @ x)%expr_pat
end
     : Compile.value' true t
