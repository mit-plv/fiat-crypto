fancy_rewrite_head = 
match idc in (ident t) return (Compile.value' true t) with
| @ident.Literal t v =>
    match
      t as t0
      return
        (base.base_interp t0 ->
         UnderLets.UnderLets base.type ident var
           (defaults.expr (type.base t0)))
    with
    | base.type.unit => fun v0 : unit => UnderLets.Base ##(v0)%expr
    | base.type.Z => fun v0 : Z => UnderLets.Base ##(v0)%expr
    | base.type.bool => fun v0 : bool => UnderLets.Base ##(v0)%expr
    | base.type.nat => fun v0 : nat => UnderLets.Base ##(v0)%expr
    end v
| ident.Nat_succ =>
    fun x : defaults.expr (type.base base.type.nat) =>
    UnderLets.Base (#(ident.Nat_succ)%expr @ x)%expr_pat
| ident.Nat_pred =>
    fun x : defaults.expr (type.base base.type.nat) =>
    UnderLets.Base (#(ident.Nat_pred)%expr @ x)%expr_pat
| ident.Nat_max =>
    fun x x0 : defaults.expr (type.base base.type.nat) =>
    UnderLets.Base (#(ident.Nat_max)%expr @ x @ x0)%expr_pat
| ident.Nat_mul =>
    fun x x0 : defaults.expr (type.base base.type.nat) =>
    UnderLets.Base (#(ident.Nat_mul)%expr @ x @ x0)%expr_pat
| ident.Nat_add =>
    fun x x0 : defaults.expr (type.base base.type.nat) =>
    UnderLets.Base (#(ident.Nat_add)%expr @ x @ x0)%expr_pat
| ident.Nat_sub =>
    fun x x0 : defaults.expr (type.base base.type.nat) =>
    UnderLets.Base (#(ident.Nat_sub)%expr @ x @ x0)%expr_pat
| @ident.nil t => UnderLets.Base []%expr_pat
| @ident.cons t =>
    fun (x : defaults.expr (type.base t))
      (x0 : defaults.expr (type.base (base.type.list t))) =>
    UnderLets.Base (x :: x0)%expr_pat
| @ident.pair A B =>
    fun (x : defaults.expr (type.base A)) (x0 : defaults.expr (type.base B))
    => UnderLets.Base (x, x0)%expr_pat
| @ident.fst A B =>
    fun x : defaults.expr (type.base (A * B)%etype) =>
    UnderLets.Base (#(ident.fst)%expr @ x)%expr_pat
| @ident.snd A B =>
    fun x : defaults.expr (type.base (A * B)%etype) =>
    UnderLets.Base (#(ident.snd)%expr @ x)%expr_pat
| @ident.prod_rect A B T =>
    fun
      (x : defaults.expr (type.base A) ->
           defaults.expr (type.base B) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base T)))
      (x0 : defaults.expr (type.base (A * B)%etype)) =>
    UnderLets.Base
      (#(ident.prod_rect)%expr @
       (λ (x1 : var (type.base A))(x2 : var (type.base B)),
        UnderLets.to_expr (x ($x1) ($x2)))%expr @ x0)%expr_pat
| @ident.bool_rect T =>
    fun
      (x
       x0 : defaults.expr (type.base base.type.unit) ->
            UnderLets.UnderLets base.type ident var
              (defaults.expr (type.base T)))
      (x1 : defaults.expr (type.base base.type.bool)) =>
    UnderLets.Base
      (#(ident.bool_rect)%expr @
       (λ x2 : var (type.base base.type.unit),
        UnderLets.to_expr (x ($x2)))%expr @
       (λ x2 : var (type.base base.type.unit),
        UnderLets.to_expr (x0 ($x2)))%expr @ x1)%expr_pat
| @ident.nat_rect P =>
    fun
      (x : defaults.expr (type.base base.type.unit) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base P)))
      (x0 : defaults.expr (type.base base.type.nat) ->
            defaults.expr (type.base P) ->
            UnderLets.UnderLets base.type ident var
              (defaults.expr (type.base P)))
      (x1 : defaults.expr (type.base base.type.nat)) =>
    UnderLets.Base
      (#(ident.nat_rect)%expr @
       (λ x2 : var (type.base base.type.unit),
        UnderLets.to_expr (x ($x2)))%expr @
       (λ (x2 : var (type.base base.type.nat))(x3 : var (type.base P)),
        UnderLets.to_expr (x0 ($x2) ($x3)))%expr @ x1)%expr_pat
| @ident.nat_rect_arrow P Q =>
    fun
      (x : defaults.expr (type.base P) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base Q)))
      (x0 : defaults.expr (type.base base.type.nat) ->
            (defaults.expr (type.base P) ->
             UnderLets.UnderLets base.type ident var
               (defaults.expr (type.base Q))) ->
            defaults.expr (type.base P) ->
            UnderLets.UnderLets base.type ident var
              (defaults.expr (type.base Q)))
      (x1 : defaults.expr (type.base base.type.nat))
      (x2 : defaults.expr (type.base P)) =>
    UnderLets.Base
      (#(ident.nat_rect_arrow)%expr @
       (λ x3 : var (type.base P),
        UnderLets.to_expr (x ($x3)))%expr @
       (λ (x3 : var (type.base base.type.nat))(x4 : var
                                                      (type.base P ->
                                                       type.base Q)%ptype)
        (x5 : var (type.base P)),
        UnderLets.to_expr
          (x0 ($x3)
             (fun x6 : defaults.expr (type.base P) =>
              UnderLets.Base ($x4 @ x6)%expr_pat) ($x5)))%expr @ x1 @ x2)%expr_pat
| @ident.list_rect A P =>
    fun
      (x : defaults.expr (type.base base.type.unit) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base P)))
      (x0 : defaults.expr (type.base A) ->
            defaults.expr (type.base (base.type.list A)) ->
            defaults.expr (type.base P) ->
            UnderLets.UnderLets base.type ident var
              (defaults.expr (type.base P)))
      (x1 : defaults.expr (type.base (base.type.list A))) =>
    UnderLets.Base
      (#(ident.list_rect)%expr @
       (λ x2 : var (type.base base.type.unit),
        UnderLets.to_expr (x ($x2)))%expr @
       (λ (x2 : var (type.base A))(x3 : var (type.base (base.type.list A)))
        (x4 : var (type.base P)),
        UnderLets.to_expr (x0 ($x2) ($x3) ($x4)))%expr @ x1)%expr_pat
| @ident.list_case A P =>
    fun
      (x : defaults.expr (type.base base.type.unit) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base P)))
      (x0 : defaults.expr (type.base A) ->
            defaults.expr (type.base (base.type.list A)) ->
            UnderLets.UnderLets base.type ident var
              (defaults.expr (type.base P)))
      (x1 : defaults.expr (type.base (base.type.list A))) =>
    UnderLets.Base
      (#(ident.list_case)%expr @
       (λ x2 : var (type.base base.type.unit),
        UnderLets.to_expr (x ($x2)))%expr @
       (λ (x2 : var (type.base A))(x3 : var (type.base (base.type.list A))),
        UnderLets.to_expr (x0 ($x2) ($x3)))%expr @ x1)%expr_pat
| @ident.List_length T =>
    fun x : defaults.expr (type.base (base.type.list T)) =>
    UnderLets.Base (#(ident.List_length)%expr @ x)%expr_pat
| ident.List_seq =>
    fun x x0 : defaults.expr (type.base base.type.nat) =>
    UnderLets.Base (#(ident.List_seq)%expr @ x @ x0)%expr_pat
| @ident.List_firstn A =>
    fun (x : defaults.expr (type.base base.type.nat))
      (x0 : defaults.expr (type.base (base.type.list A))) =>
    UnderLets.Base (#(ident.List_firstn)%expr @ x @ x0)%expr_pat
| @ident.List_skipn A =>
    fun (x : defaults.expr (type.base base.type.nat))
      (x0 : defaults.expr (type.base (base.type.list A))) =>
    UnderLets.Base (#(ident.List_skipn)%expr @ x @ x0)%expr_pat
| @ident.List_repeat A =>
    fun (x : defaults.expr (type.base A))
      (x0 : defaults.expr (type.base base.type.nat)) =>
    UnderLets.Base (#(ident.List_repeat)%expr @ x @ x0)%expr_pat
| @ident.List_combine A B =>
    fun (x : defaults.expr (type.base (base.type.list A)))
      (x0 : defaults.expr (type.base (base.type.list B))) =>
    UnderLets.Base (#(ident.List_combine)%expr @ x @ x0)%expr_pat
| @ident.List_map A B =>
    fun
      (x : defaults.expr (type.base A) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base B)))
      (x0 : defaults.expr (type.base (base.type.list A))) =>
    UnderLets.Base
      (#(ident.List_map)%expr @
       (λ x1 : var (type.base A),
        UnderLets.to_expr (x ($x1)))%expr @ x0)%expr_pat
| @ident.List_app A =>
    fun x x0 : defaults.expr (type.base (base.type.list A)) =>
    UnderLets.Base (x ++ x0)%expr
| @ident.List_rev A =>
    fun x : defaults.expr (type.base (base.type.list A)) =>
    UnderLets.Base (#(ident.List_rev)%expr @ x)%expr_pat
| @ident.List_flat_map A B =>
    fun
      (x : defaults.expr (type.base A) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base (base.type.list B))))
      (x0 : defaults.expr (type.base (base.type.list A))) =>
    UnderLets.Base
      (#(ident.List_flat_map)%expr @
       (λ x1 : var (type.base A),
        UnderLets.to_expr (x ($x1)))%expr @ x0)%expr_pat
| @ident.List_partition A =>
    fun
      (x : defaults.expr (type.base A) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base base.type.bool)))
      (x0 : defaults.expr (type.base (base.type.list A))) =>
    UnderLets.Base
      (#(ident.List_partition)%expr @
       (λ x1 : var (type.base A),
        UnderLets.to_expr (x ($x1)))%expr @ x0)%expr_pat
| @ident.List_fold_right A B =>
    fun
      (x : defaults.expr (type.base B) ->
           defaults.expr (type.base A) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base A)))
      (x0 : defaults.expr (type.base A))
      (x1 : defaults.expr (type.base (base.type.list B))) =>
    UnderLets.Base
      (#(ident.List_fold_right)%expr @
       (λ (x2 : var (type.base B))(x3 : var (type.base A)),
        UnderLets.to_expr (x ($x2) ($x3)))%expr @ x0 @ x1)%expr_pat
| @ident.List_update_nth T =>
    fun (x : defaults.expr (type.base base.type.nat))
      (x0 : defaults.expr (type.base T) ->
            UnderLets.UnderLets base.type ident var
              (defaults.expr (type.base T)))
      (x1 : defaults.expr (type.base (base.type.list T))) =>
    UnderLets.Base
      (#(ident.List_update_nth)%expr @ x @
       (λ x2 : var (type.base T),
        UnderLets.to_expr (x0 ($x2)))%expr @ x1)%expr_pat
| @ident.List_nth_default T =>
    fun (x : defaults.expr (type.base T))
      (x0 : defaults.expr (type.base (base.type.list T)))
      (x1 : defaults.expr (type.base base.type.nat)) =>
    UnderLets.Base (#(ident.List_nth_default)%expr @ x @ x0 @ x1)%expr_pat
| ident.Z_add =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (x + x0)%expr
| ident.Z_mul =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            match x0 with
            | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ #(idc0)%expr_pat x2)
              x1 =>
                match
                  match idc0 with
                  | ident.Z_land => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match x1 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args1 =>
                            match
                              s0 as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (defaults.expr (type.base base.type.Z)))
                            with
                            | type.base t2 =>
                                fun v : defaults.expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t3 : base.type =>
                                   defaults.expr (type.base t3)) t2
                                  base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (defaults.expr (type.base base.type.Z)))
                                  (fun
                                     a : option
                                           (defaults.expr (type.base t2) ->
                                            defaults.expr
                                              (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       if
                                        args1 =?
                                        2 ^ (2 * Z.log2_up args1 / 2) - 1
                                       then
                                        match
                                          invert_low (2 * Z.log2_up args1)
                                            args
                                        with
                                        | Some x3 =>
                                            UnderLets.Base
                                              (#(ident.fancy_mulll
                                                   (2 * Z.log2_up args1))%expr @
                                               (##(x3)%expr, x' v))%expr_pat
                                        | None =>
                                            match x2 with
                                            | #(idc2)%expr_pat =>
                                                match
                                                  match idc2 with
                                                  | @ident.Literal t4 v0 =>
                                                      match
                                                        t4 as t5
                                                        return
                                                          (base.base_interp
                                                             t5 -> option Z)
                                                      with
                                                      | base.type.unit =>
                                                          fun _ : unit =>
                                                          None
                                                      | base.type.Z =>
                                                          fun v1 : Z =>
                                                          Some v1
                                                      | base.type.bool =>
                                                          fun _ : bool =>
                                                          None
                                                      | base.type.nat =>
                                                          fun _ : nat => None
                                                      end v0
                                                  | _ => None
                                                  end
                                                with
                                                | Some args2 =>
                                                    match
                                                      s as t4
                                                      return
                                                        (Compile.value' false
                                                           t4 ->
                                                         UnderLets.UnderLets
                                                           base.type ident
                                                           var
                                                           (defaults.expr
                                                              (type.base
                                                                 base.type.Z)))
                                                    with
                                                    | type.base t4 =>
                                                        fun
                                                          v0 : defaults.expr
                                                                 (type.base
                                                                    t4) =>
                                                        base.try_make_transport_cps
                                                          (fun t5 : base.type
                                                           =>
                                                           defaults.expr
                                                             (type.base t5))
                                                          t4 base.type.Z
                                                          (UnderLets.UnderLets
                                                             base.type ident
                                                             var
                                                             (defaults.expr
                                                                (type.base
                                                                   base.type.Z)))
                                                          (fun
                                                             a0 : option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t4) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                           =>
                                                           match a0 with
                                                           | Some x'0 =>
                                                               if
                                                                args2 =?
                                                                2
                                                                ^ (2 *
                                                                   Z.log2_up
                                                                    args2 / 2) -
                                                                1
                                                               then
                                                                match
                                                                  invert_low
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2)
                                                                    args
                                                                with
                                                                | Some x3 =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2))%expr @
                                                                    (##
                                                                    (x3)%expr,
                                                                    x'0 v0))%expr_pat
                                                                | None =>
                                                                    match
                                                                    s as t5
                                                                    return
                                                                    (Compile.value'
                                                                    false t5 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t5 =>
                                                                    fun
                                                                    v1 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t5) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t6 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t6)) t5
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a1 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t5) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a1
                                                                    with
                                                                    | Some
                                                                    x'1 =>
                                                                    if
                                                                    args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2 / 2) -
                                                                    1
                                                                    then
                                                                    match
                                                                    invert_high
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2)
                                                                    args
                                                                    with
                                                                    | Some
                                                                    x3 =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulhl
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2))%expr @
                                                                    (##
                                                                    (x3)%expr,
                                                                    x'1 v1))%expr_pat
                                                                    | None =>
                                                                    match
                                                                    s0 as t6
                                                                    return
                                                                    (Compile.value'
                                                                    false t6 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t6 =>
                                                                    fun
                                                                    v2 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t6) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t7 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7)) t6
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a2 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t6) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a2
                                                                    with
                                                                    | Some
                                                                    x'2 =>
                                                                    if
                                                                    args1 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1 / 2) -
                                                                    1
                                                                    then
                                                                    match
                                                                    invert_high
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1)
                                                                    args
                                                                    with
                                                                    | Some
                                                                    x3 =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulhl
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1))%expr @
                                                                    (##
                                                                    (x3)%expr,
                                                                    x'2 v2))%expr_pat
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s1 ->
                                                                    d1)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s1 ->
                                                                    Compile.value'
                                                                    true d1
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x2)
                                                                    end
                                                                    else
                                                                    match
                                                                    s0 as t6
                                                                    return
                                                                    (Compile.value'
                                                                    false t6 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t6 =>
                                                                    fun
                                                                    v2 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t6) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t7 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7)) t6
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a2 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t6) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a2
                                                                    with
                                                                    | Some
                                                                    x'2 =>
                                                                    if
                                                                    args1 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1 / 2) -
                                                                    1
                                                                    then
                                                                    match
                                                                    invert_high
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1)
                                                                    args
                                                                    with
                                                                    | Some
                                                                    x3 =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulhl
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1))%expr @
                                                                    (##
                                                                    (x3)%expr,
                                                                    x'2 v2))%expr_pat
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s1 ->
                                                                    d1)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s1 ->
                                                                    Compile.value'
                                                                    true d1
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x2)
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s1 ->
                                                                    d1)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s1 ->
                                                                    Compile.value'
                                                                    true d1
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x1)
                                                                end
                                                               else
                                                                match
                                                                  s as t5
                                                                  return
                                                                    (Compile.value'
                                                                    false t5 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                with
                                                                | type.base
                                                                  t5 =>
                                                                    fun
                                                                    v1 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t5) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t6 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t6)) t5
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a1 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t5) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a1
                                                                    with
                                                                    | Some
                                                                    x'1 =>
                                                                    if
                                                                    args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2 / 2) -
                                                                    1
                                                                    then
                                                                    match
                                                                    invert_high
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2)
                                                                    args
                                                                    with
                                                                    | Some
                                                                    x3 =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulhl
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2))%expr @
                                                                    (##
                                                                    (x3)%expr,
                                                                    x'1 v1))%expr_pat
                                                                    | None =>
                                                                    match
                                                                    s0 as t6
                                                                    return
                                                                    (Compile.value'
                                                                    false t6 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t6 =>
                                                                    fun
                                                                    v2 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t6) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t7 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7)) t6
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a2 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t6) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a2
                                                                    with
                                                                    | Some
                                                                    x'2 =>
                                                                    if
                                                                    args1 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1 / 2) -
                                                                    1
                                                                    then
                                                                    match
                                                                    invert_high
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1)
                                                                    args
                                                                    with
                                                                    | Some
                                                                    x3 =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulhl
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1))%expr @
                                                                    (##
                                                                    (x3)%expr,
                                                                    x'2 v2))%expr_pat
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s1 ->
                                                                    d1)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s1 ->
                                                                    Compile.value'
                                                                    true d1
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x2)
                                                                    end
                                                                    else
                                                                    match
                                                                    s0 as t6
                                                                    return
                                                                    (Compile.value'
                                                                    false t6 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t6 =>
                                                                    fun
                                                                    v2 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t6) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t7 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7)) t6
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a2 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t6) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a2
                                                                    with
                                                                    | Some
                                                                    x'2 =>
                                                                    if
                                                                    args1 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1 / 2) -
                                                                    1
                                                                    then
                                                                    match
                                                                    invert_high
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1)
                                                                    args
                                                                    with
                                                                    | Some
                                                                    x3 =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulhl
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1))%expr @
                                                                    (##
                                                                    (x3)%expr,
                                                                    x'2 v2))%expr_pat
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s1 ->
                                                                    d1)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s1 ->
                                                                    Compile.value'
                                                                    true d1
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x2)
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                | (s1 -> d1)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s1 ->
                                                                    Compile.value'
                                                                    true d1
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                end
                                                                  (Compile.reflect
                                                                    x1)
                                                           | None =>
                                                               UnderLets.Base
                                                                 (x * x0)%expr
                                                           end)
                                                    | (s1 -> d1)%ptype =>
                                                        fun
                                                          _ : Compile.value'
                                                                false s1 ->
                                                              Compile.value'
                                                                true d1 =>
                                                        UnderLets.Base
                                                          (x * x0)%expr
                                                    end (Compile.reflect x1)
                                                | None =>
                                                    match
                                                      s0 as t4
                                                      return
                                                        (Compile.value' false
                                                           t4 ->
                                                         UnderLets.UnderLets
                                                           base.type ident
                                                           var
                                                           (defaults.expr
                                                              (type.base
                                                                 base.type.Z)))
                                                    with
                                                    | type.base t4 =>
                                                        fun
                                                          v0 : defaults.expr
                                                                 (type.base
                                                                    t4) =>
                                                        base.try_make_transport_cps
                                                          (fun t5 : base.type
                                                           =>
                                                           defaults.expr
                                                             (type.base t5))
                                                          t4 base.type.Z
                                                          (UnderLets.UnderLets
                                                             base.type ident
                                                             var
                                                             (defaults.expr
                                                                (type.base
                                                                   base.type.Z)))
                                                          (fun
                                                             a0 : option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t4) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                           =>
                                                           match a0 with
                                                           | Some x'0 =>
                                                               if
                                                                args1 =?
                                                                2
                                                                ^ (2 *
                                                                   Z.log2_up
                                                                    args1 / 2) -
                                                                1
                                                               then
                                                                match
                                                                  invert_high
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1)
                                                                    args
                                                                with
                                                                | Some x3 =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulhl
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1))%expr @
                                                                    (##
                                                                    (x3)%expr,
                                                                    x'0 v0))%expr_pat
                                                                | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                end
                                                               else
                                                                UnderLets.Base
                                                                  (x * x0)%expr
                                                           | None =>
                                                               UnderLets.Base
                                                                 (x * x0)%expr
                                                           end)
                                                    | (s1 -> d1)%ptype =>
                                                        fun
                                                          _ : Compile.value'
                                                                false s1 ->
                                                              Compile.value'
                                                                true d1 =>
                                                        UnderLets.Base
                                                          (x * x0)%expr
                                                    end (Compile.reflect x2)
                                                end
                                            | ($_)%expr =>
                                                match
                                                  s0 as t4
                                                  return
                                                    (Compile.value' false t4 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             base.type.Z)))
                                                with
                                                | type.base t4 =>
                                                    fun
                                                      v1 : defaults.expr
                                                             (type.base t4)
                                                    =>
                                                    base.try_make_transport_cps
                                                      (fun t5 : base.type =>
                                                       defaults.expr
                                                         (type.base t5)) t4
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               base.type.Z)))
                                                      (fun
                                                         a0 : option
                                                                (defaults.expr
                                                                   (type.base
                                                                    t4) ->
                                                                 defaults.expr
                                                                   (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a0 with
                                                       | Some x'0 =>
                                                           if
                                                            args1 =?
                                                            2
                                                            ^ (2 *
                                                               Z.log2_up
                                                                 args1 / 2) -
                                                            1
                                                           then
                                                            match
                                                              invert_high
                                                                (2 *
                                                                 Z.log2_up
                                                                   args1)
                                                                args
                                                            with
                                                            | Some x3 =>
                                                                UnderLets.Base
                                                                  (#(ident.fancy_mulhl
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1))%expr @
                                                                   (##
                                                                   (x3)%expr,
                                                                   x'0 v1))%expr_pat
                                                            | None =>
                                                                UnderLets.Base
                                                                  (x * x0)%expr
                                                            end
                                                           else
                                                            UnderLets.Base
                                                              (x * x0)%expr
                                                       | None =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end)
                                                | (s1 -> d1)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s1 ->
                                                          Compile.value' true
                                                            d1 =>
                                                    UnderLets.Base
                                                      (x * x0)%expr
                                                end (Compile.reflect x2)
                                            | @expr.Abs _ _ _ _ _ _ =>
                                                match
                                                  s0 as t3
                                                  return
                                                    (Compile.value' false t3 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             base.type.Z)))
                                                with
                                                | type.base t3 =>
                                                    fun
                                                      v0 : defaults.expr
                                                             (type.base t3)
                                                    =>
                                                    base.try_make_transport_cps
                                                      (fun t4 : base.type =>
                                                       defaults.expr
                                                         (type.base t4)) t3
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               base.type.Z)))
                                                      (fun
                                                         a0 : option
                                                                (defaults.expr
                                                                   (type.base
                                                                    t3) ->
                                                                 defaults.expr
                                                                   (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a0 with
                                                       | Some x'0 =>
                                                           if
                                                            args1 =?
                                                            2
                                                            ^ (2 *
                                                               Z.log2_up
                                                                 args1 / 2) -
                                                            1
                                                           then
                                                            match
                                                              invert_high
                                                                (2 *
                                                                 Z.log2_up
                                                                   args1)
                                                                args
                                                            with
                                                            | Some x3 =>
                                                                UnderLets.Base
                                                                  (#(ident.fancy_mulhl
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1))%expr @
                                                                   (##
                                                                   (x3)%expr,
                                                                   x'0 v0))%expr_pat
                                                            | None =>
                                                                UnderLets.Base
                                                                  (x * x0)%expr
                                                            end
                                                           else
                                                            UnderLets.Base
                                                              (x * x0)%expr
                                                       | None =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end)
                                                | (s2 -> d2)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s2 ->
                                                          Compile.value' true
                                                            d2 =>
                                                    UnderLets.Base
                                                      (x * x0)%expr
                                                end (Compile.reflect x2)
                                            | (_ @ _)%expr_pat =>
                                                match
                                                  s0 as t3
                                                  return
                                                    (Compile.value' false t3 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             base.type.Z)))
                                                with
                                                | type.base t3 =>
                                                    fun
                                                      v0 : defaults.expr
                                                             (type.base t3)
                                                    =>
                                                    base.try_make_transport_cps
                                                      (fun t4 : base.type =>
                                                       defaults.expr
                                                         (type.base t4)) t3
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               base.type.Z)))
                                                      (fun
                                                         a0 : option
                                                                (defaults.expr
                                                                   (type.base
                                                                    t3) ->
                                                                 defaults.expr
                                                                   (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a0 with
                                                       | Some x'0 =>
                                                           if
                                                            args1 =?
                                                            2
                                                            ^ (2 *
                                                               Z.log2_up
                                                                 args1 / 2) -
                                                            1
                                                           then
                                                            match
                                                              invert_high
                                                                (2 *
                                                                 Z.log2_up
                                                                   args1)
                                                                args
                                                            with
                                                            | Some x4 =>
                                                                UnderLets.Base
                                                                  (#(ident.fancy_mulhl
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1))%expr @
                                                                   (##
                                                                   (x4)%expr,
                                                                   x'0 v0))%expr_pat
                                                            | None =>
                                                                UnderLets.Base
                                                                  (x * x0)%expr
                                                            end
                                                           else
                                                            UnderLets.Base
                                                              (x * x0)%expr
                                                       | None =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end)
                                                | (s2 -> d2)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s2 ->
                                                          Compile.value' true
                                                            d2 =>
                                                    UnderLets.Base
                                                      (x * x0)%expr
                                                end (Compile.reflect x2)
                                            | @expr.LetIn _ _ _ _ _ _ _ =>
                                                match
                                                  s0 as t3
                                                  return
                                                    (Compile.value' false t3 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             base.type.Z)))
                                                with
                                                | type.base t3 =>
                                                    fun
                                                      v0 : defaults.expr
                                                             (type.base t3)
                                                    =>
                                                    base.try_make_transport_cps
                                                      (fun t4 : base.type =>
                                                       defaults.expr
                                                         (type.base t4)) t3
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               base.type.Z)))
                                                      (fun
                                                         a0 : option
                                                                (defaults.expr
                                                                   (type.base
                                                                    t3) ->
                                                                 defaults.expr
                                                                   (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a0 with
                                                       | Some x'0 =>
                                                           if
                                                            args1 =?
                                                            2
                                                            ^ (2 *
                                                               Z.log2_up
                                                                 args1 / 2) -
                                                            1
                                                           then
                                                            match
                                                              invert_high
                                                                (2 *
                                                                 Z.log2_up
                                                                   args1)
                                                                args
                                                            with
                                                            | Some x4 =>
                                                                UnderLets.Base
                                                                  (#(ident.fancy_mulhl
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1))%expr @
                                                                   (##
                                                                   (x4)%expr,
                                                                   x'0 v0))%expr_pat
                                                            | None =>
                                                                UnderLets.Base
                                                                  (x * x0)%expr
                                                            end
                                                           else
                                                            UnderLets.Base
                                                              (x * x0)%expr
                                                       | None =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end)
                                                | (s1 -> d1)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s1 ->
                                                          Compile.value' true
                                                            d1 =>
                                                    UnderLets.Base
                                                      (x * x0)%expr
                                                end (Compile.reflect x2)
                                            end
                                        end
                                       else
                                        match x2 with
                                        | #(idc2)%expr_pat =>
                                            match
                                              match idc2 with
                                              | @ident.Literal t4 v0 =>
                                                  match
                                                    t4 as t5
                                                    return
                                                      (base.base_interp t5 ->
                                                       option Z)
                                                  with
                                                  | base.type.unit =>
                                                      fun _ : unit => None
                                                  | base.type.Z =>
                                                      fun v1 : Z => Some v1
                                                  | base.type.bool =>
                                                      fun _ : bool => None
                                                  | base.type.nat =>
                                                      fun _ : nat => None
                                                  end v0
                                              | _ => None
                                              end
                                            with
                                            | Some args2 =>
                                                match
                                                  s as t4
                                                  return
                                                    (Compile.value' false t4 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             base.type.Z)))
                                                with
                                                | type.base t4 =>
                                                    fun
                                                      v0 : defaults.expr
                                                             (type.base t4)
                                                    =>
                                                    base.try_make_transport_cps
                                                      (fun t5 : base.type =>
                                                       defaults.expr
                                                         (type.base t5)) t4
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               base.type.Z)))
                                                      (fun
                                                         a0 : option
                                                                (defaults.expr
                                                                   (type.base
                                                                    t4) ->
                                                                 defaults.expr
                                                                   (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a0 with
                                                       | Some x'0 =>
                                                           if
                                                            args2 =?
                                                            2
                                                            ^ (2 *
                                                               Z.log2_up
                                                                 args2 / 2) -
                                                            1
                                                           then
                                                            match
                                                              invert_low
                                                                (2 *
                                                                 Z.log2_up
                                                                   args2)
                                                                args
                                                            with
                                                            | Some x3 =>
                                                                UnderLets.Base
                                                                  (#(ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2))%expr @
                                                                   (##
                                                                   (x3)%expr,
                                                                   x'0 v0))%expr_pat
                                                            | None =>
                                                                match
                                                                  s as t5
                                                                  return
                                                                    (Compile.value'
                                                                    false t5 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                with
                                                                | type.base
                                                                  t5 =>
                                                                    fun
                                                                    v1 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t5) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t6 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t6)) t5
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a1 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t5) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a1
                                                                    with
                                                                    | Some
                                                                    x'1 =>
                                                                    if
                                                                    args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2 / 2) -
                                                                    1
                                                                    then
                                                                    match
                                                                    invert_high
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2)
                                                                    args
                                                                    with
                                                                    | Some
                                                                    x3 =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulhl
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2))%expr @
                                                                    (##
                                                                    (x3)%expr,
                                                                    x'1 v1))%expr_pat
                                                                    | None =>
                                                                    match
                                                                    s0 as t6
                                                                    return
                                                                    (Compile.value'
                                                                    false t6 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t6 =>
                                                                    fun
                                                                    v2 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t6) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t7 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7)) t6
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a2 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t6) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a2
                                                                    with
                                                                    | Some
                                                                    x'2 =>
                                                                    if
                                                                    args1 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1 / 2) -
                                                                    1
                                                                    then
                                                                    match
                                                                    invert_high
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1)
                                                                    args
                                                                    with
                                                                    | Some
                                                                    x3 =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulhl
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1))%expr @
                                                                    (##
                                                                    (x3)%expr,
                                                                    x'2 v2))%expr_pat
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s1 ->
                                                                    d1)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s1 ->
                                                                    Compile.value'
                                                                    true d1
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x2)
                                                                    end
                                                                    else
                                                                    match
                                                                    s0 as t6
                                                                    return
                                                                    (Compile.value'
                                                                    false t6 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t6 =>
                                                                    fun
                                                                    v2 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t6) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t7 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7)) t6
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a2 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t6) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a2
                                                                    with
                                                                    | Some
                                                                    x'2 =>
                                                                    if
                                                                    args1 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1 / 2) -
                                                                    1
                                                                    then
                                                                    match
                                                                    invert_high
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1)
                                                                    args
                                                                    with
                                                                    | Some
                                                                    x3 =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulhl
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1))%expr @
                                                                    (##
                                                                    (x3)%expr,
                                                                    x'2 v2))%expr_pat
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s1 ->
                                                                    d1)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s1 ->
                                                                    Compile.value'
                                                                    true d1
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x2)
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                | (s1 -> d1)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s1 ->
                                                                    Compile.value'
                                                                    true d1
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                end
                                                                  (Compile.reflect
                                                                    x1)
                                                            end
                                                           else
                                                            match
                                                              s as t5
                                                              return
                                                                (Compile.value'
                                                                   false t5 ->
                                                                 UnderLets.UnderLets
                                                                   base.type
                                                                   ident var
                                                                   (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                            with
                                                            | type.base t5 =>
                                                                fun
                                                                  v1 : 
                                                                   defaults.expr
                                                                    (type.base
                                                                    t5) =>
                                                                base.try_make_transport_cps
                                                                  (fun
                                                                    t6 : base.type
                                                                   =>
                                                                   defaults.expr
                                                                    (type.base
                                                                    t6)) t5
                                                                  base.type.Z
                                                                  (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                  (fun
                                                                    a1 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t5) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                   =>
                                                                   match
                                                                    a1
                                                                   with
                                                                   | Some
                                                                    x'1 =>
                                                                    if
                                                                    args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2 / 2) -
                                                                    1
                                                                    then
                                                                    match
                                                                    invert_high
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2)
                                                                    args
                                                                    with
                                                                    | Some
                                                                    x3 =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulhl
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2))%expr @
                                                                    (##
                                                                    (x3)%expr,
                                                                    x'1 v1))%expr_pat
                                                                    | None =>
                                                                    match
                                                                    s0 as t6
                                                                    return
                                                                    (Compile.value'
                                                                    false t6 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t6 =>
                                                                    fun
                                                                    v2 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t6) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t7 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7)) t6
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a2 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t6) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a2
                                                                    with
                                                                    | Some
                                                                    x'2 =>
                                                                    if
                                                                    args1 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1 / 2) -
                                                                    1
                                                                    then
                                                                    match
                                                                    invert_high
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1)
                                                                    args
                                                                    with
                                                                    | Some
                                                                    x3 =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulhl
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1))%expr @
                                                                    (##
                                                                    (x3)%expr,
                                                                    x'2 v2))%expr_pat
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s1 ->
                                                                    d1)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s1 ->
                                                                    Compile.value'
                                                                    true d1
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x2)
                                                                    end
                                                                    else
                                                                    match
                                                                    s0 as t6
                                                                    return
                                                                    (Compile.value'
                                                                    false t6 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t6 =>
                                                                    fun
                                                                    v2 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t6) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t7 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7)) t6
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a2 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t6) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a2
                                                                    with
                                                                    | Some
                                                                    x'2 =>
                                                                    if
                                                                    args1 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1 / 2) -
                                                                    1
                                                                    then
                                                                    match
                                                                    invert_high
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1)
                                                                    args
                                                                    with
                                                                    | Some
                                                                    x3 =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulhl
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1))%expr @
                                                                    (##
                                                                    (x3)%expr,
                                                                    x'2 v2))%expr_pat
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s1 ->
                                                                    d1)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s1 ->
                                                                    Compile.value'
                                                                    true d1
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x2)
                                                                   | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                   end)
                                                            | (s1 -> d1)%ptype =>
                                                                fun
                                                                  _ : 
                                                                   Compile.value'
                                                                    false s1 ->
                                                                   Compile.value'
                                                                    true d1
                                                                =>
                                                                UnderLets.Base
                                                                  (x * x0)%expr
                                                            end
                                                              (Compile.reflect
                                                                 x1)
                                                       | None =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end)
                                                | (s1 -> d1)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s1 ->
                                                          Compile.value' true
                                                            d1 =>
                                                    UnderLets.Base
                                                      (x * x0)%expr
                                                end (Compile.reflect x1)
                                            | None =>
                                                match
                                                  s0 as t4
                                                  return
                                                    (Compile.value' false t4 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             base.type.Z)))
                                                with
                                                | type.base t4 =>
                                                    fun
                                                      v0 : defaults.expr
                                                             (type.base t4)
                                                    =>
                                                    base.try_make_transport_cps
                                                      (fun t5 : base.type =>
                                                       defaults.expr
                                                         (type.base t5)) t4
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               base.type.Z)))
                                                      (fun
                                                         a0 : option
                                                                (defaults.expr
                                                                   (type.base
                                                                    t4) ->
                                                                 defaults.expr
                                                                   (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a0 with
                                                       | Some x'0 =>
                                                           if
                                                            args1 =?
                                                            2
                                                            ^ (2 *
                                                               Z.log2_up
                                                                 args1 / 2) -
                                                            1
                                                           then
                                                            match
                                                              invert_high
                                                                (2 *
                                                                 Z.log2_up
                                                                   args1)
                                                                args
                                                            with
                                                            | Some x3 =>
                                                                UnderLets.Base
                                                                  (#(ident.fancy_mulhl
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1))%expr @
                                                                   (##
                                                                   (x3)%expr,
                                                                   x'0 v0))%expr_pat
                                                            | None =>
                                                                UnderLets.Base
                                                                  (x * x0)%expr
                                                            end
                                                           else
                                                            UnderLets.Base
                                                              (x * x0)%expr
                                                       | None =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end)
                                                | (s1 -> d1)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s1 ->
                                                          Compile.value' true
                                                            d1 =>
                                                    UnderLets.Base
                                                      (x * x0)%expr
                                                end (Compile.reflect x2)
                                            end
                                        | ($_)%expr =>
                                            match
                                              s0 as t4
                                              return
                                                (Compile.value' false t4 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base base.type.Z)))
                                            with
                                            | type.base t4 =>
                                                fun
                                                  v1 : defaults.expr
                                                         (type.base t4) =>
                                                base.try_make_transport_cps
                                                  (fun t5 : base.type =>
                                                   defaults.expr
                                                     (type.base t5)) t4
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           base.type.Z)))
                                                  (fun
                                                     a0 : option
                                                            (defaults.expr
                                                               (type.base t4) ->
                                                             defaults.expr
                                                               (type.base
                                                                  base.type.Z))
                                                   =>
                                                   match a0 with
                                                   | Some x'0 =>
                                                       if
                                                        args1 =?
                                                        2
                                                        ^ (2 *
                                                           Z.log2_up args1 /
                                                           2) - 1
                                                       then
                                                        match
                                                          invert_high
                                                            (2 *
                                                             Z.log2_up args1)
                                                            args
                                                        with
                                                        | Some x3 =>
                                                            UnderLets.Base
                                                              (#(ident.fancy_mulhl
                                                                   (2 *
                                                                    Z.log2_up
                                                                    args1))%expr @
                                                               (##(x3)%expr,
                                                               x'0 v1))%expr_pat
                                                        | None =>
                                                            UnderLets.Base
                                                              (x * x0)%expr
                                                        end
                                                       else
                                                        UnderLets.Base
                                                          (x * x0)%expr
                                                   | None =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end)
                                            | (s1 -> d1)%ptype =>
                                                fun
                                                  _ : Compile.value' false s1 ->
                                                      Compile.value' true d1
                                                =>
                                                UnderLets.Base (x * x0)%expr
                                            end (Compile.reflect x2)
                                        | @expr.Abs _ _ _ _ _ _ =>
                                            match
                                              s0 as t3
                                              return
                                                (Compile.value' false t3 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base base.type.Z)))
                                            with
                                            | type.base t3 =>
                                                fun
                                                  v0 : defaults.expr
                                                         (type.base t3) =>
                                                base.try_make_transport_cps
                                                  (fun t4 : base.type =>
                                                   defaults.expr
                                                     (type.base t4)) t3
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           base.type.Z)))
                                                  (fun
                                                     a0 : option
                                                            (defaults.expr
                                                               (type.base t3) ->
                                                             defaults.expr
                                                               (type.base
                                                                  base.type.Z))
                                                   =>
                                                   match a0 with
                                                   | Some x'0 =>
                                                       if
                                                        args1 =?
                                                        2
                                                        ^ (2 *
                                                           Z.log2_up args1 /
                                                           2) - 1
                                                       then
                                                        match
                                                          invert_high
                                                            (2 *
                                                             Z.log2_up args1)
                                                            args
                                                        with
                                                        | Some x3 =>
                                                            UnderLets.Base
                                                              (#(ident.fancy_mulhl
                                                                   (2 *
                                                                    Z.log2_up
                                                                    args1))%expr @
                                                               (##(x3)%expr,
                                                               x'0 v0))%expr_pat
                                                        | None =>
                                                            UnderLets.Base
                                                              (x * x0)%expr
                                                        end
                                                       else
                                                        UnderLets.Base
                                                          (x * x0)%expr
                                                   | None =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end)
                                            | (s2 -> d2)%ptype =>
                                                fun
                                                  _ : Compile.value' false s2 ->
                                                      Compile.value' true d2
                                                =>
                                                UnderLets.Base (x * x0)%expr
                                            end (Compile.reflect x2)
                                        | (_ @ _)%expr_pat =>
                                            match
                                              s0 as t3
                                              return
                                                (Compile.value' false t3 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base base.type.Z)))
                                            with
                                            | type.base t3 =>
                                                fun
                                                  v0 : defaults.expr
                                                         (type.base t3) =>
                                                base.try_make_transport_cps
                                                  (fun t4 : base.type =>
                                                   defaults.expr
                                                     (type.base t4)) t3
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           base.type.Z)))
                                                  (fun
                                                     a0 : option
                                                            (defaults.expr
                                                               (type.base t3) ->
                                                             defaults.expr
                                                               (type.base
                                                                  base.type.Z))
                                                   =>
                                                   match a0 with
                                                   | Some x'0 =>
                                                       if
                                                        args1 =?
                                                        2
                                                        ^ (2 *
                                                           Z.log2_up args1 /
                                                           2) - 1
                                                       then
                                                        match
                                                          invert_high
                                                            (2 *
                                                             Z.log2_up args1)
                                                            args
                                                        with
                                                        | Some x4 =>
                                                            UnderLets.Base
                                                              (#(ident.fancy_mulhl
                                                                   (2 *
                                                                    Z.log2_up
                                                                    args1))%expr @
                                                               (##(x4)%expr,
                                                               x'0 v0))%expr_pat
                                                        | None =>
                                                            UnderLets.Base
                                                              (x * x0)%expr
                                                        end
                                                       else
                                                        UnderLets.Base
                                                          (x * x0)%expr
                                                   | None =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end)
                                            | (s2 -> d2)%ptype =>
                                                fun
                                                  _ : Compile.value' false s2 ->
                                                      Compile.value' true d2
                                                =>
                                                UnderLets.Base (x * x0)%expr
                                            end (Compile.reflect x2)
                                        | @expr.LetIn _ _ _ _ _ _ _ =>
                                            match
                                              s0 as t3
                                              return
                                                (Compile.value' false t3 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base base.type.Z)))
                                            with
                                            | type.base t3 =>
                                                fun
                                                  v0 : defaults.expr
                                                         (type.base t3) =>
                                                base.try_make_transport_cps
                                                  (fun t4 : base.type =>
                                                   defaults.expr
                                                     (type.base t4)) t3
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           base.type.Z)))
                                                  (fun
                                                     a0 : option
                                                            (defaults.expr
                                                               (type.base t3) ->
                                                             defaults.expr
                                                               (type.base
                                                                  base.type.Z))
                                                   =>
                                                   match a0 with
                                                   | Some x'0 =>
                                                       if
                                                        args1 =?
                                                        2
                                                        ^ (2 *
                                                           Z.log2_up args1 /
                                                           2) - 1
                                                       then
                                                        match
                                                          invert_high
                                                            (2 *
                                                             Z.log2_up args1)
                                                            args
                                                        with
                                                        | Some x4 =>
                                                            UnderLets.Base
                                                              (#(ident.fancy_mulhl
                                                                   (2 *
                                                                    Z.log2_up
                                                                    args1))%expr @
                                                               (##(x4)%expr,
                                                               x'0 v0))%expr_pat
                                                        | None =>
                                                            UnderLets.Base
                                                              (x * x0)%expr
                                                        end
                                                       else
                                                        UnderLets.Base
                                                          (x * x0)%expr
                                                   | None =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end)
                                            | (s1 -> d1)%ptype =>
                                                fun
                                                  _ : Compile.value' false s1 ->
                                                      Compile.value' true d1
                                                =>
                                                UnderLets.Base (x * x0)%expr
                                            end (Compile.reflect x2)
                                        end
                                   | None => UnderLets.Base (x * x0)%expr
                                   end)
                            | (s1 -> d1)%ptype =>
                                fun
                                  _ : Compile.value' false s1 ->
                                      Compile.value' true d1 =>
                                UnderLets.Base (x * x0)%expr
                            end (Compile.reflect x2)
                        | None =>
                            match x2 with
                            | #(idc2)%expr_pat =>
                                match
                                  match idc2 with
                                  | @ident.Literal t3 v =>
                                      match
                                        t3 as t4
                                        return
                                          (base.base_interp t4 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s as t3
                                      return
                                        (Compile.value' false t3 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base base.type.Z)))
                                    with
                                    | type.base t3 =>
                                        fun v : defaults.expr (type.base t3)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t4 : base.type =>
                                           defaults.expr (type.base t4)) t3
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base base.type.Z)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t3) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if
                                                args1 =?
                                                2 ^ (2 * Z.log2_up args1 / 2) -
                                                1
                                               then
                                                match
                                                  invert_low
                                                    (2 * Z.log2_up args1)
                                                    args
                                                with
                                                | Some x3 =>
                                                    UnderLets.Base
                                                      (#(ident.fancy_mulll
                                                           (2 *
                                                            Z.log2_up args1))%expr @
                                                       (##(x3)%expr, x' v))%expr_pat
                                                | None =>
                                                    match
                                                      s as t4
                                                      return
                                                        (Compile.value' false
                                                           t4 ->
                                                         UnderLets.UnderLets
                                                           base.type ident
                                                           var
                                                           (defaults.expr
                                                              (type.base
                                                                 base.type.Z)))
                                                    with
                                                    | type.base t4 =>
                                                        fun
                                                          v0 : defaults.expr
                                                                 (type.base
                                                                    t4) =>
                                                        base.try_make_transport_cps
                                                          (fun t5 : base.type
                                                           =>
                                                           defaults.expr
                                                             (type.base t5))
                                                          t4 base.type.Z
                                                          (UnderLets.UnderLets
                                                             base.type ident
                                                             var
                                                             (defaults.expr
                                                                (type.base
                                                                   base.type.Z)))
                                                          (fun
                                                             a0 : option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t4) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                           =>
                                                           match a0 with
                                                           | Some x'0 =>
                                                               if
                                                                args1 =?
                                                                2
                                                                ^ (2 *
                                                                   Z.log2_up
                                                                    args1 / 2) -
                                                                1
                                                               then
                                                                match
                                                                  invert_high
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1)
                                                                    args
                                                                with
                                                                | Some x3 =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulhl
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1))%expr @
                                                                    (##
                                                                    (x3)%expr,
                                                                    x'0 v0))%expr_pat
                                                                | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                end
                                                               else
                                                                UnderLets.Base
                                                                  (x * x0)%expr
                                                           | None =>
                                                               UnderLets.Base
                                                                 (x * x0)%expr
                                                           end)
                                                    | (s1 -> d1)%ptype =>
                                                        fun
                                                          _ : Compile.value'
                                                                false s1 ->
                                                              Compile.value'
                                                                true d1 =>
                                                        UnderLets.Base
                                                          (x * x0)%expr
                                                    end (Compile.reflect x1)
                                                end
                                               else
                                                match
                                                  s as t4
                                                  return
                                                    (Compile.value' false t4 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             base.type.Z)))
                                                with
                                                | type.base t4 =>
                                                    fun
                                                      v0 : defaults.expr
                                                             (type.base t4)
                                                    =>
                                                    base.try_make_transport_cps
                                                      (fun t5 : base.type =>
                                                       defaults.expr
                                                         (type.base t5)) t4
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               base.type.Z)))
                                                      (fun
                                                         a0 : option
                                                                (defaults.expr
                                                                   (type.base
                                                                    t4) ->
                                                                 defaults.expr
                                                                   (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a0 with
                                                       | Some x'0 =>
                                                           if
                                                            args1 =?
                                                            2
                                                            ^ (2 *
                                                               Z.log2_up
                                                                 args1 / 2) -
                                                            1
                                                           then
                                                            match
                                                              invert_high
                                                                (2 *
                                                                 Z.log2_up
                                                                   args1)
                                                                args
                                                            with
                                                            | Some x3 =>
                                                                UnderLets.Base
                                                                  (#(ident.fancy_mulhl
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1))%expr @
                                                                   (##
                                                                   (x3)%expr,
                                                                   x'0 v0))%expr_pat
                                                            | None =>
                                                                UnderLets.Base
                                                                  (x * x0)%expr
                                                            end
                                                           else
                                                            UnderLets.Base
                                                              (x * x0)%expr
                                                       | None =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end)
                                                | (s1 -> d1)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s1 ->
                                                          Compile.value' true
                                                            d1 =>
                                                    UnderLets.Base
                                                      (x * x0)%expr
                                                end (Compile.reflect x1)
                                           | None =>
                                               UnderLets.Base (x * x0)%expr
                                           end)
                                    | (s1 -> d1)%ptype =>
                                        fun
                                          _ : Compile.value' false s1 ->
                                              Compile.value' true d1 =>
                                        UnderLets.Base (x * x0)%expr
                                    end (Compile.reflect x1)
                                | None => UnderLets.Base (x * x0)%expr
                                end
                            | _ => UnderLets.Base (x * x0)%expr
                            end
                        end
                    | ($_)%expr =>
                        match x2 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t3 v0 =>
                                  match
                                    t3 as t4
                                    return (base.base_interp t4 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v1 : Z => Some v1
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v0
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                match
                                  s as t3
                                  return
                                    (Compile.value' false t3 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr (type.base base.type.Z)))
                                with
                                | type.base t3 =>
                                    fun v0 : defaults.expr (type.base t3) =>
                                    base.try_make_transport_cps
                                      (fun t4 : base.type =>
                                       defaults.expr (type.base t4)) t3
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base base.type.Z)))
                                      (fun
                                         a : option
                                               (defaults.expr (type.base t3) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                       match a with
                                       | Some x' =>
                                           if
                                            args1 =?
                                            2 ^ (2 * Z.log2_up args1 / 2) - 1
                                           then
                                            match
                                              invert_low
                                                (2 * Z.log2_up args1) args
                                            with
                                            | Some x3 =>
                                                UnderLets.Base
                                                  (#(ident.fancy_mulll
                                                       (2 * Z.log2_up args1))%expr @
                                                   (##(x3)%expr, x' v0))%expr_pat
                                            | None =>
                                                match
                                                  s as t4
                                                  return
                                                    (Compile.value' false t4 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             base.type.Z)))
                                                with
                                                | type.base t4 =>
                                                    fun
                                                      v1 : defaults.expr
                                                             (type.base t4)
                                                    =>
                                                    base.try_make_transport_cps
                                                      (fun t5 : base.type =>
                                                       defaults.expr
                                                         (type.base t5)) t4
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               base.type.Z)))
                                                      (fun
                                                         a0 : option
                                                                (defaults.expr
                                                                   (type.base
                                                                    t4) ->
                                                                 defaults.expr
                                                                   (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a0 with
                                                       | Some x'0 =>
                                                           if
                                                            args1 =?
                                                            2
                                                            ^ (2 *
                                                               Z.log2_up
                                                                 args1 / 2) -
                                                            1
                                                           then
                                                            match
                                                              invert_high
                                                                (2 *
                                                                 Z.log2_up
                                                                   args1)
                                                                args
                                                            with
                                                            | Some x3 =>
                                                                UnderLets.Base
                                                                  (#(ident.fancy_mulhl
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1))%expr @
                                                                   (##
                                                                   (x3)%expr,
                                                                   x'0 v1))%expr_pat
                                                            | None =>
                                                                UnderLets.Base
                                                                  (x * x0)%expr
                                                            end
                                                           else
                                                            UnderLets.Base
                                                              (x * x0)%expr
                                                       | None =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end)
                                                | (s1 -> d1)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s1 ->
                                                          Compile.value' true
                                                            d1 =>
                                                    UnderLets.Base
                                                      (x * x0)%expr
                                                end (Compile.reflect x1)
                                            end
                                           else
                                            match
                                              s as t4
                                              return
                                                (Compile.value' false t4 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base base.type.Z)))
                                            with
                                            | type.base t4 =>
                                                fun
                                                  v1 : defaults.expr
                                                         (type.base t4) =>
                                                base.try_make_transport_cps
                                                  (fun t5 : base.type =>
                                                   defaults.expr
                                                     (type.base t5)) t4
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           base.type.Z)))
                                                  (fun
                                                     a0 : option
                                                            (defaults.expr
                                                               (type.base t4) ->
                                                             defaults.expr
                                                               (type.base
                                                                  base.type.Z))
                                                   =>
                                                   match a0 with
                                                   | Some x'0 =>
                                                       if
                                                        args1 =?
                                                        2
                                                        ^ (2 *
                                                           Z.log2_up args1 /
                                                           2) - 1
                                                       then
                                                        match
                                                          invert_high
                                                            (2 *
                                                             Z.log2_up args1)
                                                            args
                                                        with
                                                        | Some x3 =>
                                                            UnderLets.Base
                                                              (#(ident.fancy_mulhl
                                                                   (2 *
                                                                    Z.log2_up
                                                                    args1))%expr @
                                                               (##(x3)%expr,
                                                               x'0 v1))%expr_pat
                                                        | None =>
                                                            UnderLets.Base
                                                              (x * x0)%expr
                                                        end
                                                       else
                                                        UnderLets.Base
                                                          (x * x0)%expr
                                                   | None =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end)
                                            | (s1 -> d1)%ptype =>
                                                fun
                                                  _ : Compile.value' false s1 ->
                                                      Compile.value' true d1
                                                =>
                                                UnderLets.Base (x * x0)%expr
                                            end (Compile.reflect x1)
                                       | None => UnderLets.Base (x * x0)%expr
                                       end)
                                | (s1 -> d1)%ptype =>
                                    fun
                                      _ : Compile.value' false s1 ->
                                          Compile.value' true d1 =>
                                    UnderLets.Base (x * x0)%expr
                                end (Compile.reflect x1)
                            | None => UnderLets.Base (x * x0)%expr
                            end
                        | _ => UnderLets.Base (x * x0)%expr
                        end
                    | @expr.Abs _ _ _ _ _ _ =>
                        match x2 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t2 v =>
                                  match
                                    t2 as t3
                                    return (base.base_interp t3 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v0 : Z => Some v0
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                match
                                  s as t2
                                  return
                                    (Compile.value' false t2 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr (type.base base.type.Z)))
                                with
                                | type.base t2 =>
                                    fun v : defaults.expr (type.base t2) =>
                                    base.try_make_transport_cps
                                      (fun t3 : base.type =>
                                       defaults.expr (type.base t3)) t2
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base base.type.Z)))
                                      (fun
                                         a : option
                                               (defaults.expr (type.base t2) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                       match a with
                                       | Some x' =>
                                           if
                                            args1 =?
                                            2 ^ (2 * Z.log2_up args1 / 2) - 1
                                           then
                                            match
                                              invert_low
                                                (2 * Z.log2_up args1) args
                                            with
                                            | Some x3 =>
                                                UnderLets.Base
                                                  (#(ident.fancy_mulll
                                                       (2 * Z.log2_up args1))%expr @
                                                   (##(x3)%expr, x' v))%expr_pat
                                            | None =>
                                                match
                                                  s as t3
                                                  return
                                                    (Compile.value' false t3 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             base.type.Z)))
                                                with
                                                | type.base t3 =>
                                                    fun
                                                      v0 : defaults.expr
                                                             (type.base t3)
                                                    =>
                                                    base.try_make_transport_cps
                                                      (fun t4 : base.type =>
                                                       defaults.expr
                                                         (type.base t4)) t3
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               base.type.Z)))
                                                      (fun
                                                         a0 : option
                                                                (defaults.expr
                                                                   (type.base
                                                                    t3) ->
                                                                 defaults.expr
                                                                   (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a0 with
                                                       | Some x'0 =>
                                                           if
                                                            args1 =?
                                                            2
                                                            ^ (2 *
                                                               Z.log2_up
                                                                 args1 / 2) -
                                                            1
                                                           then
                                                            match
                                                              invert_high
                                                                (2 *
                                                                 Z.log2_up
                                                                   args1)
                                                                args
                                                            with
                                                            | Some x3 =>
                                                                UnderLets.Base
                                                                  (#(ident.fancy_mulhl
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1))%expr @
                                                                   (##
                                                                   (x3)%expr,
                                                                   x'0 v0))%expr_pat
                                                            | None =>
                                                                UnderLets.Base
                                                                  (x * x0)%expr
                                                            end
                                                           else
                                                            UnderLets.Base
                                                              (x * x0)%expr
                                                       | None =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end)
                                                | (s2 -> d2)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s2 ->
                                                          Compile.value' true
                                                            d2 =>
                                                    UnderLets.Base
                                                      (x * x0)%expr
                                                end (Compile.reflect x1)
                                            end
                                           else
                                            match
                                              s as t3
                                              return
                                                (Compile.value' false t3 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base base.type.Z)))
                                            with
                                            | type.base t3 =>
                                                fun
                                                  v0 : defaults.expr
                                                         (type.base t3) =>
                                                base.try_make_transport_cps
                                                  (fun t4 : base.type =>
                                                   defaults.expr
                                                     (type.base t4)) t3
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           base.type.Z)))
                                                  (fun
                                                     a0 : option
                                                            (defaults.expr
                                                               (type.base t3) ->
                                                             defaults.expr
                                                               (type.base
                                                                  base.type.Z))
                                                   =>
                                                   match a0 with
                                                   | Some x'0 =>
                                                       if
                                                        args1 =?
                                                        2
                                                        ^ (2 *
                                                           Z.log2_up args1 /
                                                           2) - 1
                                                       then
                                                        match
                                                          invert_high
                                                            (2 *
                                                             Z.log2_up args1)
                                                            args
                                                        with
                                                        | Some x3 =>
                                                            UnderLets.Base
                                                              (#(ident.fancy_mulhl
                                                                   (2 *
                                                                    Z.log2_up
                                                                    args1))%expr @
                                                               (##(x3)%expr,
                                                               x'0 v0))%expr_pat
                                                        | None =>
                                                            UnderLets.Base
                                                              (x * x0)%expr
                                                        end
                                                       else
                                                        UnderLets.Base
                                                          (x * x0)%expr
                                                   | None =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end)
                                            | (s2 -> d2)%ptype =>
                                                fun
                                                  _ : Compile.value' false s2 ->
                                                      Compile.value' true d2
                                                =>
                                                UnderLets.Base (x * x0)%expr
                                            end (Compile.reflect x1)
                                       | None => UnderLets.Base (x * x0)%expr
                                       end)
                                | (s2 -> d2)%ptype =>
                                    fun
                                      _ : Compile.value' false s2 ->
                                          Compile.value' true d2 =>
                                    UnderLets.Base (x * x0)%expr
                                end (Compile.reflect x1)
                            | None => UnderLets.Base (x * x0)%expr
                            end
                        | _ => UnderLets.Base (x * x0)%expr
                        end
                    | (_ @ _)%expr_pat =>
                        match x2 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t2 v =>
                                  match
                                    t2 as t3
                                    return (base.base_interp t3 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v0 : Z => Some v0
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                match
                                  s as t2
                                  return
                                    (Compile.value' false t2 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr (type.base base.type.Z)))
                                with
                                | type.base t2 =>
                                    fun v : defaults.expr (type.base t2) =>
                                    base.try_make_transport_cps
                                      (fun t3 : base.type =>
                                       defaults.expr (type.base t3)) t2
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base base.type.Z)))
                                      (fun
                                         a : option
                                               (defaults.expr (type.base t2) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                       match a with
                                       | Some x' =>
                                           if
                                            args1 =?
                                            2 ^ (2 * Z.log2_up args1 / 2) - 1
                                           then
                                            match
                                              invert_low
                                                (2 * Z.log2_up args1) args
                                            with
                                            | Some x4 =>
                                                UnderLets.Base
                                                  (#(ident.fancy_mulll
                                                       (2 * Z.log2_up args1))%expr @
                                                   (##(x4)%expr, x' v))%expr_pat
                                            | None =>
                                                match
                                                  s as t3
                                                  return
                                                    (Compile.value' false t3 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             base.type.Z)))
                                                with
                                                | type.base t3 =>
                                                    fun
                                                      v0 : defaults.expr
                                                             (type.base t3)
                                                    =>
                                                    base.try_make_transport_cps
                                                      (fun t4 : base.type =>
                                                       defaults.expr
                                                         (type.base t4)) t3
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               base.type.Z)))
                                                      (fun
                                                         a0 : option
                                                                (defaults.expr
                                                                   (type.base
                                                                    t3) ->
                                                                 defaults.expr
                                                                   (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a0 with
                                                       | Some x'0 =>
                                                           if
                                                            args1 =?
                                                            2
                                                            ^ (2 *
                                                               Z.log2_up
                                                                 args1 / 2) -
                                                            1
                                                           then
                                                            match
                                                              invert_high
                                                                (2 *
                                                                 Z.log2_up
                                                                   args1)
                                                                args
                                                            with
                                                            | Some x4 =>
                                                                UnderLets.Base
                                                                  (#(ident.fancy_mulhl
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1))%expr @
                                                                   (##
                                                                   (x4)%expr,
                                                                   x'0 v0))%expr_pat
                                                            | None =>
                                                                UnderLets.Base
                                                                  (x * x0)%expr
                                                            end
                                                           else
                                                            UnderLets.Base
                                                              (x * x0)%expr
                                                       | None =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end)
                                                | (s2 -> d2)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s2 ->
                                                          Compile.value' true
                                                            d2 =>
                                                    UnderLets.Base
                                                      (x * x0)%expr
                                                end (Compile.reflect x1)
                                            end
                                           else
                                            match
                                              s as t3
                                              return
                                                (Compile.value' false t3 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base base.type.Z)))
                                            with
                                            | type.base t3 =>
                                                fun
                                                  v0 : defaults.expr
                                                         (type.base t3) =>
                                                base.try_make_transport_cps
                                                  (fun t4 : base.type =>
                                                   defaults.expr
                                                     (type.base t4)) t3
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           base.type.Z)))
                                                  (fun
                                                     a0 : option
                                                            (defaults.expr
                                                               (type.base t3) ->
                                                             defaults.expr
                                                               (type.base
                                                                  base.type.Z))
                                                   =>
                                                   match a0 with
                                                   | Some x'0 =>
                                                       if
                                                        args1 =?
                                                        2
                                                        ^ (2 *
                                                           Z.log2_up args1 /
                                                           2) - 1
                                                       then
                                                        match
                                                          invert_high
                                                            (2 *
                                                             Z.log2_up args1)
                                                            args
                                                        with
                                                        | Some x4 =>
                                                            UnderLets.Base
                                                              (#(ident.fancy_mulhl
                                                                   (2 *
                                                                    Z.log2_up
                                                                    args1))%expr @
                                                               (##(x4)%expr,
                                                               x'0 v0))%expr_pat
                                                        | None =>
                                                            UnderLets.Base
                                                              (x * x0)%expr
                                                        end
                                                       else
                                                        UnderLets.Base
                                                          (x * x0)%expr
                                                   | None =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end)
                                            | (s2 -> d2)%ptype =>
                                                fun
                                                  _ : Compile.value' false s2 ->
                                                      Compile.value' true d2
                                                =>
                                                UnderLets.Base (x * x0)%expr
                                            end (Compile.reflect x1)
                                       | None => UnderLets.Base (x * x0)%expr
                                       end)
                                | (s2 -> d2)%ptype =>
                                    fun
                                      _ : Compile.value' false s2 ->
                                          Compile.value' true d2 =>
                                    UnderLets.Base (x * x0)%expr
                                end (Compile.reflect x1)
                            | None => UnderLets.Base (x * x0)%expr
                            end
                        | _ => UnderLets.Base (x * x0)%expr
                        end
                    | @expr.LetIn _ _ _ _ _ _ _ =>
                        match x2 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t2 v =>
                                  match
                                    t2 as t3
                                    return (base.base_interp t3 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v0 : Z => Some v0
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                match
                                  s as t2
                                  return
                                    (Compile.value' false t2 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr (type.base base.type.Z)))
                                with
                                | type.base t2 =>
                                    fun v : defaults.expr (type.base t2) =>
                                    base.try_make_transport_cps
                                      (fun t3 : base.type =>
                                       defaults.expr (type.base t3)) t2
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base base.type.Z)))
                                      (fun
                                         a : option
                                               (defaults.expr (type.base t2) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                       match a with
                                       | Some x' =>
                                           if
                                            args1 =?
                                            2 ^ (2 * Z.log2_up args1 / 2) - 1
                                           then
                                            match
                                              invert_low
                                                (2 * Z.log2_up args1) args
                                            with
                                            | Some x4 =>
                                                UnderLets.Base
                                                  (#(ident.fancy_mulll
                                                       (2 * Z.log2_up args1))%expr @
                                                   (##(x4)%expr, x' v))%expr_pat
                                            | None =>
                                                match
                                                  s as t3
                                                  return
                                                    (Compile.value' false t3 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             base.type.Z)))
                                                with
                                                | type.base t3 =>
                                                    fun
                                                      v0 : defaults.expr
                                                             (type.base t3)
                                                    =>
                                                    base.try_make_transport_cps
                                                      (fun t4 : base.type =>
                                                       defaults.expr
                                                         (type.base t4)) t3
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               base.type.Z)))
                                                      (fun
                                                         a0 : option
                                                                (defaults.expr
                                                                   (type.base
                                                                    t3) ->
                                                                 defaults.expr
                                                                   (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a0 with
                                                       | Some x'0 =>
                                                           if
                                                            args1 =?
                                                            2
                                                            ^ (2 *
                                                               Z.log2_up
                                                                 args1 / 2) -
                                                            1
                                                           then
                                                            match
                                                              invert_high
                                                                (2 *
                                                                 Z.log2_up
                                                                   args1)
                                                                args
                                                            with
                                                            | Some x4 =>
                                                                UnderLets.Base
                                                                  (#(ident.fancy_mulhl
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1))%expr @
                                                                   (##
                                                                   (x4)%expr,
                                                                   x'0 v0))%expr_pat
                                                            | None =>
                                                                UnderLets.Base
                                                                  (x * x0)%expr
                                                            end
                                                           else
                                                            UnderLets.Base
                                                              (x * x0)%expr
                                                       | None =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end)
                                                | (s1 -> d1)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s1 ->
                                                          Compile.value' true
                                                            d1 =>
                                                    UnderLets.Base
                                                      (x * x0)%expr
                                                end (Compile.reflect x1)
                                            end
                                           else
                                            match
                                              s as t3
                                              return
                                                (Compile.value' false t3 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base base.type.Z)))
                                            with
                                            | type.base t3 =>
                                                fun
                                                  v0 : defaults.expr
                                                         (type.base t3) =>
                                                base.try_make_transport_cps
                                                  (fun t4 : base.type =>
                                                   defaults.expr
                                                     (type.base t4)) t3
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           base.type.Z)))
                                                  (fun
                                                     a0 : option
                                                            (defaults.expr
                                                               (type.base t3) ->
                                                             defaults.expr
                                                               (type.base
                                                                  base.type.Z))
                                                   =>
                                                   match a0 with
                                                   | Some x'0 =>
                                                       if
                                                        args1 =?
                                                        2
                                                        ^ (2 *
                                                           Z.log2_up args1 /
                                                           2) - 1
                                                       then
                                                        match
                                                          invert_high
                                                            (2 *
                                                             Z.log2_up args1)
                                                            args
                                                        with
                                                        | Some x4 =>
                                                            UnderLets.Base
                                                              (#(ident.fancy_mulhl
                                                                   (2 *
                                                                    Z.log2_up
                                                                    args1))%expr @
                                                               (##(x4)%expr,
                                                               x'0 v0))%expr_pat
                                                        | None =>
                                                            UnderLets.Base
                                                              (x * x0)%expr
                                                        end
                                                       else
                                                        UnderLets.Base
                                                          (x * x0)%expr
                                                   | None =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end)
                                            | (s1 -> d1)%ptype =>
                                                fun
                                                  _ : Compile.value' false s1 ->
                                                      Compile.value' true d1
                                                =>
                                                UnderLets.Base (x * x0)%expr
                                            end (Compile.reflect x1)
                                       | None => UnderLets.Base (x * x0)%expr
                                       end)
                                | (s1 -> d1)%ptype =>
                                    fun
                                      _ : Compile.value' false s1 ->
                                          Compile.value' true d1 =>
                                    UnderLets.Base (x * x0)%expr
                                end (Compile.reflect x1)
                            | None => UnderLets.Base (x * x0)%expr
                            end
                        | _ => UnderLets.Base (x * x0)%expr
                        end
                    end
                | None =>
                    match
                      match idc0 with
                      | ident.Z_shiftr => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match x1 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t2 v =>
                                  match
                                    t2 as t3
                                    return (base.base_interp t3 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v0 : Z => Some v0
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                match
                                  s0 as t2
                                  return
                                    (Compile.value' false t2 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr (type.base base.type.Z)))
                                with
                                | type.base t2 =>
                                    fun v : defaults.expr (type.base t2) =>
                                    base.try_make_transport_cps
                                      (fun t3 : base.type =>
                                       defaults.expr (type.base t3)) t2
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base base.type.Z)))
                                      (fun
                                         a : option
                                               (defaults.expr (type.base t2) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                       match a with
                                       | Some x' =>
                                           match
                                             invert_low (2 * args1) args
                                           with
                                           | Some x3 =>
                                               UnderLets.Base
                                                 (#(ident.fancy_mullh
                                                      (2 * args1))%expr @
                                                  (##(x3)%expr, x' v))%expr_pat
                                           | None =>
                                               match
                                                 s0 as t3
                                                 return
                                                   (Compile.value' false t3 ->
                                                    UnderLets.UnderLets
                                                      base.type ident var
                                                      (defaults.expr
                                                         (type.base
                                                            base.type.Z)))
                                               with
                                               | type.base t3 =>
                                                   fun
                                                     v0 : defaults.expr
                                                            (type.base t3) =>
                                                   base.try_make_transport_cps
                                                     (fun t4 : base.type =>
                                                      defaults.expr
                                                        (type.base t4)) t3
                                                     base.type.Z
                                                     (UnderLets.UnderLets
                                                        base.type ident var
                                                        (defaults.expr
                                                           (type.base
                                                              base.type.Z)))
                                                     (fun
                                                        a0 : option
                                                               (defaults.expr
                                                                  (type.base
                                                                    t3) ->
                                                                defaults.expr
                                                                  (type.base
                                                                    base.type.Z))
                                                      =>
                                                      match a0 with
                                                      | Some x'0 =>
                                                          match
                                                            invert_high
                                                              (2 * args1)
                                                              args
                                                          with
                                                          | Some x3 =>
                                                              UnderLets.Base
                                                                (#(ident.fancy_mulhh
                                                                    (2 *
                                                                    args1))%expr @
                                                                 (##(x3)%expr,
                                                                 x'0 v0))%expr_pat
                                                          | None =>
                                                              UnderLets.Base
                                                                (x * x0)%expr
                                                          end
                                                      | None =>
                                                          UnderLets.Base
                                                            (x * x0)%expr
                                                      end)
                                               | (s1 -> d1)%ptype =>
                                                   fun
                                                     _ : Compile.value' false
                                                           s1 ->
                                                         Compile.value' true
                                                           d1 =>
                                                   UnderLets.Base
                                                     (x * x0)%expr
                                               end (Compile.reflect x2)
                                           end
                                       | None => UnderLets.Base (x * x0)%expr
                                       end)
                                | (s1 -> d1)%ptype =>
                                    fun
                                      _ : Compile.value' false s1 ->
                                          Compile.value' true d1 =>
                                    UnderLets.Base (x * x0)%expr
                                end (Compile.reflect x2)
                            | None => UnderLets.Base (x * x0)%expr
                            end
                        | _ => UnderLets.Base (x * x0)%expr
                        end
                    | None => UnderLets.Base (x * x0)%expr
                    end
                end
            | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ ($_)%expr _) _ |
              @expr.App _ _ _ s _
              (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _) _ | @expr.App
              _ _ _ s _ (@expr.App _ _ _ s0 _ (_ @ _)%expr_pat _) _ |
              @expr.App _ _ _ s _
              (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _) _ =>
                UnderLets.Base (x * x0)%expr
            | @expr.App _ _ _ s _ #(_)%expr_pat _ | @expr.App _ _ _ s _
              ($_)%expr _ | @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ |
              @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
                UnderLets.Base (x * x0)%expr
            | _ => UnderLets.Base (x * x0)%expr
            end
        | None => UnderLets.Base (x * x0)%expr
        end
    | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ #(idc)%expr_pat x2) x1 =>
        match match idc with
              | ident.Z_land => Some tt
              | _ => None
              end with
        | Some _ =>
            match x2 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 =>
                    match x0 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args1 =>
                            match
                              s as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (defaults.expr (type.base base.type.Z)))
                            with
                            | type.base t2 =>
                                fun v : defaults.expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t3 : base.type =>
                                   defaults.expr (type.base t3)) t2
                                  base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (defaults.expr (type.base base.type.Z)))
                                  (fun
                                     a : option
                                           (defaults.expr (type.base t2) ->
                                            defaults.expr
                                              (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       if
                                        args0 =?
                                        2 ^ (2 * Z.log2_up args0 / 2) - 1
                                       then
                                        match
                                          invert_low (2 * Z.log2_up args0)
                                            args1
                                        with
                                        | Some y =>
                                            UnderLets.Base
                                              (#(ident.fancy_mulll
                                                   (2 * Z.log2_up args0))%expr @
                                               (x' v, ##(y)%expr))%expr_pat
                                        | None =>
                                            match x1 with
                                            | #(idc2)%expr_pat =>
                                                match
                                                  match idc2 with
                                                  | @ident.Literal t4 v0 =>
                                                      match
                                                        t4 as t5
                                                        return
                                                          (base.base_interp
                                                             t5 -> option Z)
                                                      with
                                                      | base.type.unit =>
                                                          fun _ : unit =>
                                                          None
                                                      | base.type.Z =>
                                                          fun v1 : Z =>
                                                          Some v1
                                                      | base.type.bool =>
                                                          fun _ : bool =>
                                                          None
                                                      | base.type.nat =>
                                                          fun _ : nat => None
                                                      end v0
                                                  | _ => None
                                                  end
                                                with
                                                | Some args2 =>
                                                    match
                                                      s0 as t4
                                                      return
                                                        (Compile.value' false
                                                           t4 ->
                                                         UnderLets.UnderLets
                                                           base.type ident
                                                           var
                                                           (defaults.expr
                                                              (type.base
                                                                 base.type.Z)))
                                                    with
                                                    | type.base t4 =>
                                                        fun
                                                          v0 : defaults.expr
                                                                 (type.base
                                                                    t4) =>
                                                        base.try_make_transport_cps
                                                          (fun t5 : base.type
                                                           =>
                                                           defaults.expr
                                                             (type.base t5))
                                                          t4 base.type.Z
                                                          (UnderLets.UnderLets
                                                             base.type ident
                                                             var
                                                             (defaults.expr
                                                                (type.base
                                                                   base.type.Z)))
                                                          (fun
                                                             a0 : option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t4) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                           =>
                                                           match a0 with
                                                           | Some x'0 =>
                                                               if
                                                                args2 =?
                                                                2
                                                                ^ (2 *
                                                                   Z.log2_up
                                                                    args2 / 2) -
                                                                1
                                                               then
                                                                match
                                                                  invert_low
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2)
                                                                    args1
                                                                with
                                                                | Some y =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2))%expr @
                                                                    (
                                                                    x'0 v0,
                                                                    ##
                                                                    (y)%expr))%expr_pat
                                                                | None =>
                                                                    match
                                                                    s as t5
                                                                    return
                                                                    (Compile.value'
                                                                    false t5 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t5 =>
                                                                    fun
                                                                    v1 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t5) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t6 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t6)) t5
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a1 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t5) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a1
                                                                    with
                                                                    | Some
                                                                    x'1 =>
                                                                    if
                                                                    args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1
                                                                    then
                                                                    match
                                                                    invert_high
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0)
                                                                    args1
                                                                    with
                                                                    | Some
                                                                    y =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mullh
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x'1 v1,
                                                                    ##
                                                                    (y)%expr))%expr_pat
                                                                    | None =>
                                                                    match
                                                                    s0 as t6
                                                                    return
                                                                    (Compile.value'
                                                                    false t6 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t6 =>
                                                                    fun
                                                                    v2 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t6) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t7 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7)) t6
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a2 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t6) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a2
                                                                    with
                                                                    | Some
                                                                    x'2 =>
                                                                    if
                                                                    args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2 / 2) -
                                                                    1
                                                                    then
                                                                    match
                                                                    invert_high
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2)
                                                                    args1
                                                                    with
                                                                    | Some
                                                                    y =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mullh
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2))%expr @
                                                                    (
                                                                    x'2 v2,
                                                                    ##
                                                                    (y)%expr))%expr_pat
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s1 ->
                                                                    d1)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s1 ->
                                                                    Compile.value'
                                                                    true d1
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x2)
                                                                    end
                                                                    else
                                                                    match
                                                                    s0 as t6
                                                                    return
                                                                    (Compile.value'
                                                                    false t6 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t6 =>
                                                                    fun
                                                                    v2 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t6) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t7 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7)) t6
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a2 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t6) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a2
                                                                    with
                                                                    | Some
                                                                    x'2 =>
                                                                    if
                                                                    args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2 / 2) -
                                                                    1
                                                                    then
                                                                    match
                                                                    invert_high
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2)
                                                                    args1
                                                                    with
                                                                    | Some
                                                                    y =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mullh
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2))%expr @
                                                                    (
                                                                    x'2 v2,
                                                                    ##
                                                                    (y)%expr))%expr_pat
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s1 ->
                                                                    d1)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s1 ->
                                                                    Compile.value'
                                                                    true d1
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x2)
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s1 ->
                                                                    d1)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s1 ->
                                                                    Compile.value'
                                                                    true d1
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x1)
                                                                end
                                                               else
                                                                match
                                                                  s as t5
                                                                  return
                                                                    (Compile.value'
                                                                    false t5 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                with
                                                                | type.base
                                                                  t5 =>
                                                                    fun
                                                                    v1 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t5) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t6 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t6)) t5
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a1 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t5) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a1
                                                                    with
                                                                    | Some
                                                                    x'1 =>
                                                                    if
                                                                    args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1
                                                                    then
                                                                    match
                                                                    invert_high
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0)
                                                                    args1
                                                                    with
                                                                    | Some
                                                                    y =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mullh
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x'1 v1,
                                                                    ##
                                                                    (y)%expr))%expr_pat
                                                                    | None =>
                                                                    match
                                                                    s0 as t6
                                                                    return
                                                                    (Compile.value'
                                                                    false t6 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t6 =>
                                                                    fun
                                                                    v2 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t6) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t7 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7)) t6
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a2 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t6) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a2
                                                                    with
                                                                    | Some
                                                                    x'2 =>
                                                                    if
                                                                    args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2 / 2) -
                                                                    1
                                                                    then
                                                                    match
                                                                    invert_high
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2)
                                                                    args1
                                                                    with
                                                                    | Some
                                                                    y =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mullh
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2))%expr @
                                                                    (
                                                                    x'2 v2,
                                                                    ##
                                                                    (y)%expr))%expr_pat
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s1 ->
                                                                    d1)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s1 ->
                                                                    Compile.value'
                                                                    true d1
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x2)
                                                                    end
                                                                    else
                                                                    match
                                                                    s0 as t6
                                                                    return
                                                                    (Compile.value'
                                                                    false t6 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t6 =>
                                                                    fun
                                                                    v2 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t6) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t7 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7)) t6
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a2 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t6) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a2
                                                                    with
                                                                    | Some
                                                                    x'2 =>
                                                                    if
                                                                    args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2 / 2) -
                                                                    1
                                                                    then
                                                                    match
                                                                    invert_high
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2)
                                                                    args1
                                                                    with
                                                                    | Some
                                                                    y =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mullh
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2))%expr @
                                                                    (
                                                                    x'2 v2,
                                                                    ##
                                                                    (y)%expr))%expr_pat
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s1 ->
                                                                    d1)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s1 ->
                                                                    Compile.value'
                                                                    true d1
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x2)
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                | (s1 -> d1)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s1 ->
                                                                    Compile.value'
                                                                    true d1
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                end
                                                                  (Compile.reflect
                                                                    x1)
                                                           | None =>
                                                               UnderLets.Base
                                                                 (x * x0)%expr
                                                           end)
                                                    | (s1 -> d1)%ptype =>
                                                        fun
                                                          _ : Compile.value'
                                                                false s1 ->
                                                              Compile.value'
                                                                true d1 =>
                                                        UnderLets.Base
                                                          (x * x0)%expr
                                                    end (Compile.reflect x2)
                                                | None =>
                                                    match
                                                      s as t4
                                                      return
                                                        (Compile.value' false
                                                           t4 ->
                                                         UnderLets.UnderLets
                                                           base.type ident
                                                           var
                                                           (defaults.expr
                                                              (type.base
                                                                 base.type.Z)))
                                                    with
                                                    | type.base t4 =>
                                                        fun
                                                          v0 : defaults.expr
                                                                 (type.base
                                                                    t4) =>
                                                        base.try_make_transport_cps
                                                          (fun t5 : base.type
                                                           =>
                                                           defaults.expr
                                                             (type.base t5))
                                                          t4 base.type.Z
                                                          (UnderLets.UnderLets
                                                             base.type ident
                                                             var
                                                             (defaults.expr
                                                                (type.base
                                                                   base.type.Z)))
                                                          (fun
                                                             a0 : option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t4) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                           =>
                                                           match a0 with
                                                           | Some x'0 =>
                                                               if
                                                                args0 =?
                                                                2
                                                                ^ (2 *
                                                                   Z.log2_up
                                                                    args0 / 2) -
                                                                1
                                                               then
                                                                match
                                                                  invert_high
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0)
                                                                    args1
                                                                with
                                                                | Some y =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mullh
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x'0 v0,
                                                                    ##
                                                                    (y)%expr))%expr_pat
                                                                | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                end
                                                               else
                                                                UnderLets.Base
                                                                  (x * x0)%expr
                                                           | None =>
                                                               UnderLets.Base
                                                                 (x * x0)%expr
                                                           end)
                                                    | (s1 -> d1)%ptype =>
                                                        fun
                                                          _ : Compile.value'
                                                                false s1 ->
                                                              Compile.value'
                                                                true d1 =>
                                                        UnderLets.Base
                                                          (x * x0)%expr
                                                    end (Compile.reflect x1)
                                                end
                                            | ($_)%expr =>
                                                match
                                                  s as t4
                                                  return
                                                    (Compile.value' false t4 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             base.type.Z)))
                                                with
                                                | type.base t4 =>
                                                    fun
                                                      v1 : defaults.expr
                                                             (type.base t4)
                                                    =>
                                                    base.try_make_transport_cps
                                                      (fun t5 : base.type =>
                                                       defaults.expr
                                                         (type.base t5)) t4
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               base.type.Z)))
                                                      (fun
                                                         a0 : option
                                                                (defaults.expr
                                                                   (type.base
                                                                    t4) ->
                                                                 defaults.expr
                                                                   (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a0 with
                                                       | Some x'0 =>
                                                           if
                                                            args0 =?
                                                            2
                                                            ^ (2 *
                                                               Z.log2_up
                                                                 args0 / 2) -
                                                            1
                                                           then
                                                            match
                                                              invert_high
                                                                (2 *
                                                                 Z.log2_up
                                                                   args0)
                                                                args1
                                                            with
                                                            | Some y =>
                                                                UnderLets.Base
                                                                  (#(ident.fancy_mullh
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                   (x'0 v1,
                                                                   ##
                                                                   (y)%expr))%expr_pat
                                                            | None =>
                                                                UnderLets.Base
                                                                  (x * x0)%expr
                                                            end
                                                           else
                                                            UnderLets.Base
                                                              (x * x0)%expr
                                                       | None =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end)
                                                | (s1 -> d1)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s1 ->
                                                          Compile.value' true
                                                            d1 =>
                                                    UnderLets.Base
                                                      (x * x0)%expr
                                                end (Compile.reflect x1)
                                            | @expr.LetIn _ _ _ _ _ _ _ =>
                                                match
                                                  s as t3
                                                  return
                                                    (Compile.value' false t3 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             base.type.Z)))
                                                with
                                                | type.base t3 =>
                                                    fun
                                                      v0 : defaults.expr
                                                             (type.base t3)
                                                    =>
                                                    base.try_make_transport_cps
                                                      (fun t4 : base.type =>
                                                       defaults.expr
                                                         (type.base t4)) t3
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               base.type.Z)))
                                                      (fun
                                                         a0 : option
                                                                (defaults.expr
                                                                   (type.base
                                                                    t3) ->
                                                                 defaults.expr
                                                                   (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a0 with
                                                       | Some x'0 =>
                                                           if
                                                            args0 =?
                                                            2
                                                            ^ (2 *
                                                               Z.log2_up
                                                                 args0 / 2) -
                                                            1
                                                           then
                                                            match
                                                              invert_high
                                                                (2 *
                                                                 Z.log2_up
                                                                   args0)
                                                                args1
                                                            with
                                                            | Some y =>
                                                                UnderLets.Base
                                                                  (#(ident.fancy_mullh
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                   (x'0 v0,
                                                                   ##
                                                                   (y)%expr))%expr_pat
                                                            | None =>
                                                                UnderLets.Base
                                                                  (x * x0)%expr
                                                            end
                                                           else
                                                            UnderLets.Base
                                                              (x * x0)%expr
                                                       | None =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end)
                                                | (s1 -> d1)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s1 ->
                                                          Compile.value' true
                                                            d1 =>
                                                    UnderLets.Base
                                                      (x * x0)%expr
                                                end (Compile.reflect x1)
                                            | _ =>
                                                match
                                                  s as t3
                                                  return
                                                    (Compile.value' false t3 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             base.type.Z)))
                                                with
                                                | type.base t3 =>
                                                    fun
                                                      v0 : defaults.expr
                                                             (type.base t3)
                                                    =>
                                                    base.try_make_transport_cps
                                                      (fun t4 : base.type =>
                                                       defaults.expr
                                                         (type.base t4)) t3
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               base.type.Z)))
                                                      (fun
                                                         a0 : option
                                                                (defaults.expr
                                                                   (type.base
                                                                    t3) ->
                                                                 defaults.expr
                                                                   (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a0 with
                                                       | Some x'0 =>
                                                           if
                                                            args0 =?
                                                            2
                                                            ^ (2 *
                                                               Z.log2_up
                                                                 args0 / 2) -
                                                            1
                                                           then
                                                            match
                                                              invert_high
                                                                (2 *
                                                                 Z.log2_up
                                                                   args0)
                                                                args1
                                                            with
                                                            | Some y =>
                                                                UnderLets.Base
                                                                  (#(ident.fancy_mullh
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                   (x'0 v0,
                                                                   ##
                                                                   (y)%expr))%expr_pat
                                                            | None =>
                                                                UnderLets.Base
                                                                  (x * x0)%expr
                                                            end
                                                           else
                                                            UnderLets.Base
                                                              (x * x0)%expr
                                                       | None =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end)
                                                | (s2 -> d2)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s2 ->
                                                          Compile.value' true
                                                            d2 =>
                                                    UnderLets.Base
                                                      (x * x0)%expr
                                                end (Compile.reflect x1)
                                            end
                                        end
                                       else
                                        match x1 with
                                        | #(idc2)%expr_pat =>
                                            match
                                              match idc2 with
                                              | @ident.Literal t4 v0 =>
                                                  match
                                                    t4 as t5
                                                    return
                                                      (base.base_interp t5 ->
                                                       option Z)
                                                  with
                                                  | base.type.unit =>
                                                      fun _ : unit => None
                                                  | base.type.Z =>
                                                      fun v1 : Z => Some v1
                                                  | base.type.bool =>
                                                      fun _ : bool => None
                                                  | base.type.nat =>
                                                      fun _ : nat => None
                                                  end v0
                                              | _ => None
                                              end
                                            with
                                            | Some args2 =>
                                                match
                                                  s0 as t4
                                                  return
                                                    (Compile.value' false t4 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             base.type.Z)))
                                                with
                                                | type.base t4 =>
                                                    fun
                                                      v0 : defaults.expr
                                                             (type.base t4)
                                                    =>
                                                    base.try_make_transport_cps
                                                      (fun t5 : base.type =>
                                                       defaults.expr
                                                         (type.base t5)) t4
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               base.type.Z)))
                                                      (fun
                                                         a0 : option
                                                                (defaults.expr
                                                                   (type.base
                                                                    t4) ->
                                                                 defaults.expr
                                                                   (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a0 with
                                                       | Some x'0 =>
                                                           if
                                                            args2 =?
                                                            2
                                                            ^ (2 *
                                                               Z.log2_up
                                                                 args2 / 2) -
                                                            1
                                                           then
                                                            match
                                                              invert_low
                                                                (2 *
                                                                 Z.log2_up
                                                                   args2)
                                                                args1
                                                            with
                                                            | Some y =>
                                                                UnderLets.Base
                                                                  (#(ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2))%expr @
                                                                   (x'0 v0,
                                                                   ##
                                                                   (y)%expr))%expr_pat
                                                            | None =>
                                                                match
                                                                  s as t5
                                                                  return
                                                                    (Compile.value'
                                                                    false t5 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                with
                                                                | type.base
                                                                  t5 =>
                                                                    fun
                                                                    v1 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t5) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t6 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t6)) t5
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a1 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t5) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a1
                                                                    with
                                                                    | Some
                                                                    x'1 =>
                                                                    if
                                                                    args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1
                                                                    then
                                                                    match
                                                                    invert_high
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0)
                                                                    args1
                                                                    with
                                                                    | Some
                                                                    y =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mullh
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x'1 v1,
                                                                    ##
                                                                    (y)%expr))%expr_pat
                                                                    | None =>
                                                                    match
                                                                    s0 as t6
                                                                    return
                                                                    (Compile.value'
                                                                    false t6 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t6 =>
                                                                    fun
                                                                    v2 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t6) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t7 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7)) t6
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a2 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t6) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a2
                                                                    with
                                                                    | Some
                                                                    x'2 =>
                                                                    if
                                                                    args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2 / 2) -
                                                                    1
                                                                    then
                                                                    match
                                                                    invert_high
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2)
                                                                    args1
                                                                    with
                                                                    | Some
                                                                    y =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mullh
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2))%expr @
                                                                    (
                                                                    x'2 v2,
                                                                    ##
                                                                    (y)%expr))%expr_pat
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s1 ->
                                                                    d1)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s1 ->
                                                                    Compile.value'
                                                                    true d1
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x2)
                                                                    end
                                                                    else
                                                                    match
                                                                    s0 as t6
                                                                    return
                                                                    (Compile.value'
                                                                    false t6 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t6 =>
                                                                    fun
                                                                    v2 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t6) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t7 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7)) t6
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a2 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t6) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a2
                                                                    with
                                                                    | Some
                                                                    x'2 =>
                                                                    if
                                                                    args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2 / 2) -
                                                                    1
                                                                    then
                                                                    match
                                                                    invert_high
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2)
                                                                    args1
                                                                    with
                                                                    | Some
                                                                    y =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mullh
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2))%expr @
                                                                    (
                                                                    x'2 v2,
                                                                    ##
                                                                    (y)%expr))%expr_pat
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s1 ->
                                                                    d1)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s1 ->
                                                                    Compile.value'
                                                                    true d1
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x2)
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                | (s1 -> d1)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s1 ->
                                                                    Compile.value'
                                                                    true d1
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                end
                                                                  (Compile.reflect
                                                                    x1)
                                                            end
                                                           else
                                                            match
                                                              s as t5
                                                              return
                                                                (Compile.value'
                                                                   false t5 ->
                                                                 UnderLets.UnderLets
                                                                   base.type
                                                                   ident var
                                                                   (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                            with
                                                            | type.base t5 =>
                                                                fun
                                                                  v1 : 
                                                                   defaults.expr
                                                                    (type.base
                                                                    t5) =>
                                                                base.try_make_transport_cps
                                                                  (fun
                                                                    t6 : base.type
                                                                   =>
                                                                   defaults.expr
                                                                    (type.base
                                                                    t6)) t5
                                                                  base.type.Z
                                                                  (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                  (fun
                                                                    a1 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t5) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                   =>
                                                                   match
                                                                    a1
                                                                   with
                                                                   | Some
                                                                    x'1 =>
                                                                    if
                                                                    args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1
                                                                    then
                                                                    match
                                                                    invert_high
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0)
                                                                    args1
                                                                    with
                                                                    | Some
                                                                    y =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mullh
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x'1 v1,
                                                                    ##
                                                                    (y)%expr))%expr_pat
                                                                    | None =>
                                                                    match
                                                                    s0 as t6
                                                                    return
                                                                    (Compile.value'
                                                                    false t6 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t6 =>
                                                                    fun
                                                                    v2 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t6) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t7 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7)) t6
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a2 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t6) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a2
                                                                    with
                                                                    | Some
                                                                    x'2 =>
                                                                    if
                                                                    args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2 / 2) -
                                                                    1
                                                                    then
                                                                    match
                                                                    invert_high
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2)
                                                                    args1
                                                                    with
                                                                    | Some
                                                                    y =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mullh
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2))%expr @
                                                                    (
                                                                    x'2 v2,
                                                                    ##
                                                                    (y)%expr))%expr_pat
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s1 ->
                                                                    d1)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s1 ->
                                                                    Compile.value'
                                                                    true d1
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x2)
                                                                    end
                                                                    else
                                                                    match
                                                                    s0 as t6
                                                                    return
                                                                    (Compile.value'
                                                                    false t6 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t6 =>
                                                                    fun
                                                                    v2 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t6) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t7 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7)) t6
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a2 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t6) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a2
                                                                    with
                                                                    | Some
                                                                    x'2 =>
                                                                    if
                                                                    args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2 / 2) -
                                                                    1
                                                                    then
                                                                    match
                                                                    invert_high
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2)
                                                                    args1
                                                                    with
                                                                    | Some
                                                                    y =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mullh
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args2))%expr @
                                                                    (
                                                                    x'2 v2,
                                                                    ##
                                                                    (y)%expr))%expr_pat
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s1 ->
                                                                    d1)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s1 ->
                                                                    Compile.value'
                                                                    true d1
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x2)
                                                                   | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                   end)
                                                            | (s1 -> d1)%ptype =>
                                                                fun
                                                                  _ : 
                                                                   Compile.value'
                                                                    false s1 ->
                                                                   Compile.value'
                                                                    true d1
                                                                =>
                                                                UnderLets.Base
                                                                  (x * x0)%expr
                                                            end
                                                              (Compile.reflect
                                                                 x1)
                                                       | None =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end)
                                                | (s1 -> d1)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s1 ->
                                                          Compile.value' true
                                                            d1 =>
                                                    UnderLets.Base
                                                      (x * x0)%expr
                                                end (Compile.reflect x2)
                                            | None =>
                                                match
                                                  s as t4
                                                  return
                                                    (Compile.value' false t4 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             base.type.Z)))
                                                with
                                                | type.base t4 =>
                                                    fun
                                                      v0 : defaults.expr
                                                             (type.base t4)
                                                    =>
                                                    base.try_make_transport_cps
                                                      (fun t5 : base.type =>
                                                       defaults.expr
                                                         (type.base t5)) t4
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               base.type.Z)))
                                                      (fun
                                                         a0 : option
                                                                (defaults.expr
                                                                   (type.base
                                                                    t4) ->
                                                                 defaults.expr
                                                                   (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a0 with
                                                       | Some x'0 =>
                                                           if
                                                            args0 =?
                                                            2
                                                            ^ (2 *
                                                               Z.log2_up
                                                                 args0 / 2) -
                                                            1
                                                           then
                                                            match
                                                              invert_high
                                                                (2 *
                                                                 Z.log2_up
                                                                   args0)
                                                                args1
                                                            with
                                                            | Some y =>
                                                                UnderLets.Base
                                                                  (#(ident.fancy_mullh
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                   (x'0 v0,
                                                                   ##
                                                                   (y)%expr))%expr_pat
                                                            | None =>
                                                                UnderLets.Base
                                                                  (x * x0)%expr
                                                            end
                                                           else
                                                            UnderLets.Base
                                                              (x * x0)%expr
                                                       | None =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end)
                                                | (s1 -> d1)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s1 ->
                                                          Compile.value' true
                                                            d1 =>
                                                    UnderLets.Base
                                                      (x * x0)%expr
                                                end (Compile.reflect x1)
                                            end
                                        | ($_)%expr =>
                                            match
                                              s as t4
                                              return
                                                (Compile.value' false t4 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base base.type.Z)))
                                            with
                                            | type.base t4 =>
                                                fun
                                                  v1 : defaults.expr
                                                         (type.base t4) =>
                                                base.try_make_transport_cps
                                                  (fun t5 : base.type =>
                                                   defaults.expr
                                                     (type.base t5)) t4
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           base.type.Z)))
                                                  (fun
                                                     a0 : option
                                                            (defaults.expr
                                                               (type.base t4) ->
                                                             defaults.expr
                                                               (type.base
                                                                  base.type.Z))
                                                   =>
                                                   match a0 with
                                                   | Some x'0 =>
                                                       if
                                                        args0 =?
                                                        2
                                                        ^ (2 *
                                                           Z.log2_up args0 /
                                                           2) - 1
                                                       then
                                                        match
                                                          invert_high
                                                            (2 *
                                                             Z.log2_up args0)
                                                            args1
                                                        with
                                                        | Some y =>
                                                            UnderLets.Base
                                                              (#(ident.fancy_mullh
                                                                   (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                               (x'0 v1,
                                                               ##(y)%expr))%expr_pat
                                                        | None =>
                                                            UnderLets.Base
                                                              (x * x0)%expr
                                                        end
                                                       else
                                                        UnderLets.Base
                                                          (x * x0)%expr
                                                   | None =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end)
                                            | (s1 -> d1)%ptype =>
                                                fun
                                                  _ : Compile.value' false s1 ->
                                                      Compile.value' true d1
                                                =>
                                                UnderLets.Base (x * x0)%expr
                                            end (Compile.reflect x1)
                                        | @expr.LetIn _ _ _ _ _ _ _ =>
                                            match
                                              s as t3
                                              return
                                                (Compile.value' false t3 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base base.type.Z)))
                                            with
                                            | type.base t3 =>
                                                fun
                                                  v0 : defaults.expr
                                                         (type.base t3) =>
                                                base.try_make_transport_cps
                                                  (fun t4 : base.type =>
                                                   defaults.expr
                                                     (type.base t4)) t3
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           base.type.Z)))
                                                  (fun
                                                     a0 : option
                                                            (defaults.expr
                                                               (type.base t3) ->
                                                             defaults.expr
                                                               (type.base
                                                                  base.type.Z))
                                                   =>
                                                   match a0 with
                                                   | Some x'0 =>
                                                       if
                                                        args0 =?
                                                        2
                                                        ^ (2 *
                                                           Z.log2_up args0 /
                                                           2) - 1
                                                       then
                                                        match
                                                          invert_high
                                                            (2 *
                                                             Z.log2_up args0)
                                                            args1
                                                        with
                                                        | Some y =>
                                                            UnderLets.Base
                                                              (#(ident.fancy_mullh
                                                                   (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                               (x'0 v0,
                                                               ##(y)%expr))%expr_pat
                                                        | None =>
                                                            UnderLets.Base
                                                              (x * x0)%expr
                                                        end
                                                       else
                                                        UnderLets.Base
                                                          (x * x0)%expr
                                                   | None =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end)
                                            | (s1 -> d1)%ptype =>
                                                fun
                                                  _ : Compile.value' false s1 ->
                                                      Compile.value' true d1
                                                =>
                                                UnderLets.Base (x * x0)%expr
                                            end (Compile.reflect x1)
                                        | _ =>
                                            match
                                              s as t3
                                              return
                                                (Compile.value' false t3 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base base.type.Z)))
                                            with
                                            | type.base t3 =>
                                                fun
                                                  v0 : defaults.expr
                                                         (type.base t3) =>
                                                base.try_make_transport_cps
                                                  (fun t4 : base.type =>
                                                   defaults.expr
                                                     (type.base t4)) t3
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           base.type.Z)))
                                                  (fun
                                                     a0 : option
                                                            (defaults.expr
                                                               (type.base t3) ->
                                                             defaults.expr
                                                               (type.base
                                                                  base.type.Z))
                                                   =>
                                                   match a0 with
                                                   | Some x'0 =>
                                                       if
                                                        args0 =?
                                                        2
                                                        ^ (2 *
                                                           Z.log2_up args0 /
                                                           2) - 1
                                                       then
                                                        match
                                                          invert_high
                                                            (2 *
                                                             Z.log2_up args0)
                                                            args1
                                                        with
                                                        | Some y =>
                                                            UnderLets.Base
                                                              (#(ident.fancy_mullh
                                                                   (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                               (x'0 v0,
                                                               ##(y)%expr))%expr_pat
                                                        | None =>
                                                            UnderLets.Base
                                                              (x * x0)%expr
                                                        end
                                                       else
                                                        UnderLets.Base
                                                          (x * x0)%expr
                                                   | None =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end)
                                            | (s2 -> d2)%ptype =>
                                                fun
                                                  _ : Compile.value' false s2 ->
                                                      Compile.value' true d2
                                                =>
                                                UnderLets.Base (x * x0)%expr
                                            end (Compile.reflect x1)
                                        end
                                   | None => UnderLets.Base (x * x0)%expr
                                   end)
                            | (s1 -> d1)%ptype =>
                                fun
                                  _ : Compile.value' false s1 ->
                                      Compile.value' true d1 =>
                                UnderLets.Base (x * x0)%expr
                            end (Compile.reflect x1)
                        | None => UnderLets.Base (x * x0)%expr
                        end
                    | @expr.App _ _ _ s1 _
                      (@expr.App _ _ _ s2 _ #(idc1)%expr_pat x4) x3 =>
                        match
                          match idc1 with
                          | ident.Z_land => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match x4 with
                            | #(idc2)%expr_pat =>
                                match
                                  match idc2 with
                                  | @ident.Literal t3 v =>
                                      match
                                        t3 as t4
                                        return
                                          (base.base_interp t4 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args2 =>
                                    match
                                      s as t3
                                      return
                                        (Compile.value' false t3 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base base.type.Z)))
                                    with
                                    | type.base t3 =>
                                        fun v : defaults.expr (type.base t3)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t4 : base.type =>
                                           defaults.expr (type.base t4)) t3
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base base.type.Z)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t3) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               match
                                                 s1 as t4
                                                 return
                                                   (Compile.value' false t4 ->
                                                    UnderLets.UnderLets
                                                      base.type ident var
                                                      (defaults.expr
                                                         (type.base
                                                            base.type.Z)))
                                               with
                                               | type.base t4 =>
                                                   fun
                                                     v0 : defaults.expr
                                                            (type.base t4) =>
                                                   base.try_make_transport_cps
                                                     (fun t5 : base.type =>
                                                      defaults.expr
                                                        (type.base t5)) t4
                                                     base.type.Z
                                                     (UnderLets.UnderLets
                                                        base.type ident var
                                                        (defaults.expr
                                                           (type.base
                                                              base.type.Z)))
                                                     (fun
                                                        a0 : option
                                                               (defaults.expr
                                                                  (type.base
                                                                    t4) ->
                                                                defaults.expr
                                                                  (type.base
                                                                    base.type.Z))
                                                      =>
                                                      match a0 with
                                                      | Some x'0 =>
                                                          if
                                                           (args0 =?
                                                            2
                                                            ^ (2 *
                                                               Z.log2_up
                                                                 args0 / 2) -
                                                            1) &&
                                                           (args2 =?
                                                            2
                                                            ^ (2 *
                                                               Z.log2_up
                                                                 args0 / 2) -
                                                            1)
                                                          then
                                                           UnderLets.Base
                                                             (#(ident.fancy_mulll
                                                                  (2 *
                                                                   Z.log2_up
                                                                    args0))%expr @
                                                              (x' v, x'0 v0))%expr_pat
                                                          else
                                                           match x1 with
                                                           | #(idc3)%expr_pat =>
                                                               match
                                                                 match
                                                                   idc3
                                                                 with
                                                                 | @ident.Literal
                                                                   t6 v1 =>
                                                                    match
                                                                    t6 as t7
                                                                    return
                                                                    (base.base_interp
                                                                    t7 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v2 : Z =>
                                                                    Some v2
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v1
                                                                 | _ => None
                                                                 end
                                                               with
                                                               | Some
                                                                 args3 =>
                                                                   match
                                                                    s0 as t6
                                                                    return
                                                                    (Compile.value'
                                                                    false t6 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                   with
                                                                   | type.base
                                                                    t6 =>
                                                                    fun
                                                                    v1 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t6) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t7 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7)) t6
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a1 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t6) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a1
                                                                    with
                                                                    | Some
                                                                    x'1 =>
                                                                    match
                                                                    s1 as t7
                                                                    return
                                                                    (Compile.value'
                                                                    false t7 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t7 =>
                                                                    fun
                                                                    v2 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t8 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t8)) t7
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a2 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t7) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a2
                                                                    with
                                                                    | Some
                                                                    x'2 =>
                                                                    if
                                                                    (args3 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args3 / 2) -
                                                                    1) &&
                                                                    (args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args3 / 2) -
                                                                    1)
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args3))%expr @
                                                                    (
                                                                    x'1 v1,
                                                                    x'2 v2))%expr_pat
                                                                    else
                                                                    match
                                                                    x3
                                                                    with
                                                                    | #
                                                                    (idc4)%expr_pat =>
                                                                    match
                                                                    match
                                                                    idc4
                                                                    with
                                                                    | @ident.Literal
                                                                    t9 v3 =>
                                                                    match
                                                                    t9 as t10
                                                                    return
                                                                    (base.base_interp
                                                                    t10 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v4 : Z =>
                                                                    Some v4
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v3
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                    with
                                                                    | Some
                                                                    args4 =>
                                                                    match
                                                                    s as t9
                                                                    return
                                                                    (Compile.value'
                                                                    false t9 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t9 =>
                                                                    fun
                                                                    v3 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t9) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t10 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t10)) t9
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a3 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t9) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a3
                                                                    with
                                                                    | Some
                                                                    x'3 =>
                                                                    match
                                                                    s2 as t10
                                                                    return
                                                                    (Compile.value'
                                                                    false t10 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t10 =>
                                                                    fun
                                                                    v4 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t10) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t11 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t11)) t10
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a4 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t10) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a4
                                                                    with
                                                                    | Some
                                                                    x'4 =>
                                                                    if
                                                                    (args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1) &&
                                                                    (args4 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1)
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x'3 v3,
                                                                    x'4 v4))%expr_pat
                                                                    else
                                                                    match
                                                                    s0 as t11
                                                                    return
                                                                    (Compile.value'
                                                                    false t11 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t11 =>
                                                                    fun
                                                                    v5 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t11) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t12 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t12)) t11
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a5 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t11) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a5
                                                                    with
                                                                    | Some
                                                                    x'5 =>
                                                                    match
                                                                    s2 as t12
                                                                    return
                                                                    (Compile.value'
                                                                    false t12 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t12 =>
                                                                    fun
                                                                    v6 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t12) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t13 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t13)) t12
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a6 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t12) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a6
                                                                    with
                                                                    | Some
                                                                    x'6 =>
                                                                    if
                                                                    (args3 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args3 / 2) -
                                                                    1) &&
                                                                    (args4 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args3 / 2) -
                                                                    1)
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args3))%expr @
                                                                    (
                                                                    x'5 v5,
                                                                    x'6 v6))%expr_pat
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s3 ->
                                                                    d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x4)
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s3 ->
                                                                    d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x2)
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s3 ->
                                                                    d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x4)
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s3 ->
                                                                    d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x1)
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    | _ =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s3 ->
                                                                    d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x3)
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                   | (s3 ->
                                                                    d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                   end
                                                                    (Compile.reflect
                                                                    x2)
                                                               | None =>
                                                                   match
                                                                    x3
                                                                   with
                                                                   | #
                                                                    (idc4)%expr_pat =>
                                                                    match
                                                                    match
                                                                    idc4
                                                                    with
                                                                    | @ident.Literal
                                                                    t7 v1 =>
                                                                    match
                                                                    t7 as t8
                                                                    return
                                                                    (base.base_interp
                                                                    t8 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v2 : Z =>
                                                                    Some v2
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v1
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                    with
                                                                    | Some
                                                                    args3 =>
                                                                    match
                                                                    s as t7
                                                                    return
                                                                    (Compile.value'
                                                                    false t7 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t7 =>
                                                                    fun
                                                                    v1 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t8 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t8)) t7
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a1 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t7) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a1
                                                                    with
                                                                    | Some
                                                                    x'1 =>
                                                                    match
                                                                    s2 as t8
                                                                    return
                                                                    (Compile.value'
                                                                    false t8 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t8 =>
                                                                    fun
                                                                    v2 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t8) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t9 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t9)) t8
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a2 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t8) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a2
                                                                    with
                                                                    | Some
                                                                    x'2 =>
                                                                    if
                                                                    (args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1) &&
                                                                    (args3 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1)
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x'1 v1,
                                                                    x'2 v2))%expr_pat
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s3 ->
                                                                    d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x4)
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s3 ->
                                                                    d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x1)
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                   | _ =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                   end
                                                               end
                                                           | ($_)%expr =>
                                                               match x3 with
                                                               | #(idc3)%expr_pat =>
                                                                   match
                                                                    match
                                                                    idc3
                                                                    with
                                                                    | @ident.Literal
                                                                    t7 v2 =>
                                                                    match
                                                                    t7 as t8
                                                                    return
                                                                    (base.base_interp
                                                                    t8 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v3 : Z =>
                                                                    Some v3
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v2
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                   with
                                                                   | Some
                                                                    args3 =>
                                                                    match
                                                                    s as t7
                                                                    return
                                                                    (Compile.value'
                                                                    false t7 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t7 =>
                                                                    fun
                                                                    v2 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t8 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t8)) t7
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a1 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t7) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a1
                                                                    with
                                                                    | Some
                                                                    x'1 =>
                                                                    match
                                                                    s2 as t8
                                                                    return
                                                                    (Compile.value'
                                                                    false t8 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t8 =>
                                                                    fun
                                                                    v3 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t8) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t9 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t9)) t8
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a2 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t8) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a2
                                                                    with
                                                                    | Some
                                                                    x'2 =>
                                                                    if
                                                                    (args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1) &&
                                                                    (args3 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1)
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x'1 v2,
                                                                    x'2 v3))%expr_pat
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s3 ->
                                                                    d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x4)
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s3 ->
                                                                    d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x1)
                                                                   | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                   end
                                                               | _ =>
                                                                   UnderLets.Base
                                                                    (x * x0)%expr
                                                               end
                                                           | @expr.LetIn _ _
                                                             _ _ _ _ _ =>
                                                               match x3 with
                                                               | #(idc3)%expr_pat =>
                                                                   match
                                                                    match
                                                                    idc3
                                                                    with
                                                                    | @ident.Literal
                                                                    t6 v1 =>
                                                                    match
                                                                    t6 as t7
                                                                    return
                                                                    (base.base_interp
                                                                    t7 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v2 : Z =>
                                                                    Some v2
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v1
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                   with
                                                                   | Some
                                                                    args3 =>
                                                                    match
                                                                    s as t6
                                                                    return
                                                                    (Compile.value'
                                                                    false t6 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t6 =>
                                                                    fun
                                                                    v1 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t6) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t7 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7)) t6
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a1 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t6) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a1
                                                                    with
                                                                    | Some
                                                                    x'1 =>
                                                                    match
                                                                    s2 as t7
                                                                    return
                                                                    (Compile.value'
                                                                    false t7 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t7 =>
                                                                    fun
                                                                    v2 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t8 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t8)) t7
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a2 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t7) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a2
                                                                    with
                                                                    | Some
                                                                    x'2 =>
                                                                    if
                                                                    (args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1) &&
                                                                    (args3 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1)
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x'1 v1,
                                                                    x'2 v2))%expr_pat
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s3 ->
                                                                    d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x4)
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s3 ->
                                                                    d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x1)
                                                                   | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                   end
                                                               | _ =>
                                                                   UnderLets.Base
                                                                    (x * x0)%expr
                                                               end
                                                           | _ =>
                                                               match x3 with
                                                               | #(idc3)%expr_pat =>
                                                                   match
                                                                    match
                                                                    idc3
                                                                    with
                                                                    | @ident.Literal
                                                                    t6 v1 =>
                                                                    match
                                                                    t6 as t7
                                                                    return
                                                                    (base.base_interp
                                                                    t7 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v2 : Z =>
                                                                    Some v2
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v1
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                   with
                                                                   | Some
                                                                    args3 =>
                                                                    match
                                                                    s as t6
                                                                    return
                                                                    (Compile.value'
                                                                    false t6 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t6 =>
                                                                    fun
                                                                    v1 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t6) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t7 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7)) t6
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a1 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t6) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a1
                                                                    with
                                                                    | Some
                                                                    x'1 =>
                                                                    match
                                                                    s2 as t7
                                                                    return
                                                                    (Compile.value'
                                                                    false t7 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t7 =>
                                                                    fun
                                                                    v2 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t8 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t8)) t7
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a2 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t7) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a2
                                                                    with
                                                                    | Some
                                                                    x'2 =>
                                                                    if
                                                                    (args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1) &&
                                                                    (args3 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1)
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x'1 v1,
                                                                    x'2 v2))%expr_pat
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s4 ->
                                                                    d4)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s4 ->
                                                                    Compile.value'
                                                                    true d4
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x4)
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s4 ->
                                                                    d4)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s4 ->
                                                                    Compile.value'
                                                                    true d4
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x1)
                                                                   | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                   end
                                                               | _ =>
                                                                   UnderLets.Base
                                                                    (x * x0)%expr
                                                               end
                                                           end
                                                      | None =>
                                                          UnderLets.Base
                                                            (x * x0)%expr
                                                      end)
                                               | (s3 -> d3)%ptype =>
                                                   fun
                                                     _ : Compile.value' false
                                                           s3 ->
                                                         Compile.value' true
                                                           d3 =>
                                                   UnderLets.Base
                                                     (x * x0)%expr
                                               end (Compile.reflect x3)
                                           | None =>
                                               UnderLets.Base (x * x0)%expr
                                           end)
                                    | (s3 -> d3)%ptype =>
                                        fun
                                          _ : Compile.value' false s3 ->
                                              Compile.value' true d3 =>
                                        UnderLets.Base (x * x0)%expr
                                    end (Compile.reflect x1)
                                | None =>
                                    match x3 with
                                    | #(idc3)%expr_pat =>
                                        match
                                          match idc3 with
                                          | @ident.Literal t4 v =>
                                              match
                                                t4 as t5
                                                return
                                                  (base.base_interp t5 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v0 : Z => Some v0
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v
                                          | _ => None
                                          end
                                        with
                                        | Some args2 =>
                                            match
                                              s as t4
                                              return
                                                (Compile.value' false t4 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base base.type.Z)))
                                            with
                                            | type.base t4 =>
                                                fun
                                                  v : defaults.expr
                                                        (type.base t4) =>
                                                base.try_make_transport_cps
                                                  (fun t5 : base.type =>
                                                   defaults.expr
                                                     (type.base t5)) t4
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           base.type.Z)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t4) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       match
                                                         s2 as t5
                                                         return
                                                           (Compile.value'
                                                              false t5 ->
                                                            UnderLets.UnderLets
                                                              base.type ident
                                                              var
                                                              (defaults.expr
                                                                 (type.base
                                                                    base.type.Z)))
                                                       with
                                                       | type.base t5 =>
                                                           fun
                                                             v0 : defaults.expr
                                                                    (type.base
                                                                    t5) =>
                                                           base.try_make_transport_cps
                                                             (fun
                                                                t6 : base.type
                                                              =>
                                                              defaults.expr
                                                                (type.base t6))
                                                             t5 base.type.Z
                                                             (UnderLets.UnderLets
                                                                base.type
                                                                ident var
                                                                (defaults.expr
                                                                   (type.base
                                                                    base.type.Z)))
                                                             (fun
                                                                a0 : 
                                                                 option
                                                                   (defaults.expr
                                                                    (type.base
                                                                    t5) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                              =>
                                                              match a0 with
                                                              | Some x'0 =>
                                                                  if
                                                                   (args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1) &&
                                                                   (args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1)
                                                                  then
                                                                   UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x' v,
                                                                    x'0 v0))%expr_pat
                                                                  else
                                                                   match
                                                                    x1
                                                                   with
                                                                   | #
                                                                    (idc4)%expr_pat =>
                                                                    match
                                                                    match
                                                                    idc4
                                                                    with
                                                                    | @ident.Literal
                                                                    t7 v1 =>
                                                                    match
                                                                    t7 as t8
                                                                    return
                                                                    (base.base_interp
                                                                    t8 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v2 : Z =>
                                                                    Some v2
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v1
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                    with
                                                                    | Some
                                                                    args3 =>
                                                                    match
                                                                    s0 as t7
                                                                    return
                                                                    (Compile.value'
                                                                    false t7 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t7 =>
                                                                    fun
                                                                    v1 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t8 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t8)) t7
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a1 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t7) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a1
                                                                    with
                                                                    | Some
                                                                    x'1 =>
                                                                    match
                                                                    s2 as t8
                                                                    return
                                                                    (Compile.value'
                                                                    false t8 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t8 =>
                                                                    fun
                                                                    v2 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t8) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t9 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t9)) t8
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a2 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t8) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a2
                                                                    with
                                                                    | Some
                                                                    x'2 =>
                                                                    if
                                                                    (args3 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args3 / 2) -
                                                                    1) &&
                                                                    (args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args3 / 2) -
                                                                    1)
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args3))%expr @
                                                                    (
                                                                    x'1 v1,
                                                                    x'2 v2))%expr_pat
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s3 ->
                                                                    d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x4)
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s3 ->
                                                                    d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x2)
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                   | _ =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                   end
                                                              | None =>
                                                                  UnderLets.Base
                                                                    (x * x0)%expr
                                                              end)
                                                       | (s3 -> d3)%ptype =>
                                                           fun
                                                             _ : Compile.value'
                                                                   false s3 ->
                                                                 Compile.value'
                                                                   true d3 =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end
                                                         (Compile.reflect x4)
                                                   | None =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end)
                                            | (s3 -> d3)%ptype =>
                                                fun
                                                  _ : Compile.value' false s3 ->
                                                      Compile.value' true d3
                                                =>
                                                UnderLets.Base (x * x0)%expr
                                            end (Compile.reflect x1)
                                        | None =>
                                            UnderLets.Base (x * x0)%expr
                                        end
                                    | _ => UnderLets.Base (x * x0)%expr
                                    end
                                end
                            | ($_)%expr =>
                                match x3 with
                                | #(idc2)%expr_pat =>
                                    match
                                      match idc2 with
                                      | @ident.Literal t4 v0 =>
                                          match
                                            t4 as t5
                                            return
                                              (base.base_interp t5 ->
                                               option Z)
                                          with
                                          | base.type.unit =>
                                              fun _ : unit => None
                                          | base.type.Z =>
                                              fun v1 : Z => Some v1
                                          | base.type.bool =>
                                              fun _ : bool => None
                                          | base.type.nat =>
                                              fun _ : nat => None
                                          end v0
                                      | _ => None
                                      end
                                    with
                                    | Some args2 =>
                                        match
                                          s as t4
                                          return
                                            (Compile.value' false t4 ->
                                             UnderLets.UnderLets base.type
                                               ident var
                                               (defaults.expr
                                                  (type.base base.type.Z)))
                                        with
                                        | type.base t4 =>
                                            fun
                                              v0 : defaults.expr
                                                     (type.base t4) =>
                                            base.try_make_transport_cps
                                              (fun t5 : base.type =>
                                               defaults.expr (type.base t5))
                                              t4 base.type.Z
                                              (UnderLets.UnderLets base.type
                                                 ident var
                                                 (defaults.expr
                                                    (type.base base.type.Z)))
                                              (fun
                                                 a : option
                                                       (defaults.expr
                                                          (type.base t4) ->
                                                        defaults.expr
                                                          (type.base
                                                             base.type.Z)) =>
                                               match a with
                                               | Some x' =>
                                                   match
                                                     s2 as t5
                                                     return
                                                       (Compile.value' false
                                                          t5 ->
                                                        UnderLets.UnderLets
                                                          base.type ident var
                                                          (defaults.expr
                                                             (type.base
                                                                base.type.Z)))
                                                   with
                                                   | type.base t5 =>
                                                       fun
                                                         v1 : defaults.expr
                                                                (type.base t5)
                                                       =>
                                                       base.try_make_transport_cps
                                                         (fun t6 : base.type
                                                          =>
                                                          defaults.expr
                                                            (type.base t6))
                                                         t5 base.type.Z
                                                         (UnderLets.UnderLets
                                                            base.type ident
                                                            var
                                                            (defaults.expr
                                                               (type.base
                                                                  base.type.Z)))
                                                         (fun
                                                            a0 : option
                                                                   (defaults.expr
                                                                    (type.base
                                                                    t5) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                          =>
                                                          match a0 with
                                                          | Some x'0 =>
                                                              if
                                                               (args0 =?
                                                                2
                                                                ^ (2 *
                                                                   Z.log2_up
                                                                    args0 / 2) -
                                                                1) &&
                                                               (args2 =?
                                                                2
                                                                ^ (2 *
                                                                   Z.log2_up
                                                                    args0 / 2) -
                                                                1)
                                                              then
                                                               UnderLets.Base
                                                                 (#(ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                  (x' v0,
                                                                  x'0 v1))%expr_pat
                                                              else
                                                               match x1 with
                                                               | #(idc3)%expr_pat =>
                                                                   match
                                                                    match
                                                                    idc3
                                                                    with
                                                                    | @ident.Literal
                                                                    t7 v2 =>
                                                                    match
                                                                    t7 as t8
                                                                    return
                                                                    (base.base_interp
                                                                    t8 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v3 : Z =>
                                                                    Some v3
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v2
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                   with
                                                                   | Some
                                                                    args3 =>
                                                                    match
                                                                    s0 as t7
                                                                    return
                                                                    (Compile.value'
                                                                    false t7 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t7 =>
                                                                    fun
                                                                    v2 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t8 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t8)) t7
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a1 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t7) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a1
                                                                    with
                                                                    | Some
                                                                    x'1 =>
                                                                    match
                                                                    s2 as t8
                                                                    return
                                                                    (Compile.value'
                                                                    false t8 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t8 =>
                                                                    fun
                                                                    v3 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t8) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t9 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t9)) t8
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a2 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t8) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a2
                                                                    with
                                                                    | Some
                                                                    x'2 =>
                                                                    if
                                                                    (args3 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args3 / 2) -
                                                                    1) &&
                                                                    (args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args3 / 2) -
                                                                    1)
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args3))%expr @
                                                                    (
                                                                    x'1 v2,
                                                                    x'2 v3))%expr_pat
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s3 ->
                                                                    d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x4)
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s3 ->
                                                                    d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x2)
                                                                   | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                   end
                                                               | _ =>
                                                                   UnderLets.Base
                                                                    (x * x0)%expr
                                                               end
                                                          | None =>
                                                              UnderLets.Base
                                                                (x * x0)%expr
                                                          end)
                                                   | (s3 -> d3)%ptype =>
                                                       fun
                                                         _ : Compile.value'
                                                               false s3 ->
                                                             Compile.value'
                                                               true d3 =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end (Compile.reflect x4)
                                               | None =>
                                                   UnderLets.Base
                                                     (x * x0)%expr
                                               end)
                                        | (s3 -> d3)%ptype =>
                                            fun
                                              _ : Compile.value' false s3 ->
                                                  Compile.value' true d3 =>
                                            UnderLets.Base (x * x0)%expr
                                        end (Compile.reflect x1)
                                    | None => UnderLets.Base (x * x0)%expr
                                    end
                                | _ => UnderLets.Base (x * x0)%expr
                                end
                            | @expr.LetIn _ _ _ _ _ _ _ =>
                                match x3 with
                                | #(idc2)%expr_pat =>
                                    match
                                      match idc2 with
                                      | @ident.Literal t3 v =>
                                          match
                                            t3 as t4
                                            return
                                              (base.base_interp t4 ->
                                               option Z)
                                          with
                                          | base.type.unit =>
                                              fun _ : unit => None
                                          | base.type.Z =>
                                              fun v0 : Z => Some v0
                                          | base.type.bool =>
                                              fun _ : bool => None
                                          | base.type.nat =>
                                              fun _ : nat => None
                                          end v
                                      | _ => None
                                      end
                                    with
                                    | Some args2 =>
                                        match
                                          s as t3
                                          return
                                            (Compile.value' false t3 ->
                                             UnderLets.UnderLets base.type
                                               ident var
                                               (defaults.expr
                                                  (type.base base.type.Z)))
                                        with
                                        | type.base t3 =>
                                            fun
                                              v : defaults.expr
                                                    (type.base t3) =>
                                            base.try_make_transport_cps
                                              (fun t4 : base.type =>
                                               defaults.expr (type.base t4))
                                              t3 base.type.Z
                                              (UnderLets.UnderLets base.type
                                                 ident var
                                                 (defaults.expr
                                                    (type.base base.type.Z)))
                                              (fun
                                                 a : option
                                                       (defaults.expr
                                                          (type.base t3) ->
                                                        defaults.expr
                                                          (type.base
                                                             base.type.Z)) =>
                                               match a with
                                               | Some x' =>
                                                   match
                                                     s2 as t4
                                                     return
                                                       (Compile.value' false
                                                          t4 ->
                                                        UnderLets.UnderLets
                                                          base.type ident var
                                                          (defaults.expr
                                                             (type.base
                                                                base.type.Z)))
                                                   with
                                                   | type.base t4 =>
                                                       fun
                                                         v0 : defaults.expr
                                                                (type.base t4)
                                                       =>
                                                       base.try_make_transport_cps
                                                         (fun t5 : base.type
                                                          =>
                                                          defaults.expr
                                                            (type.base t5))
                                                         t4 base.type.Z
                                                         (UnderLets.UnderLets
                                                            base.type ident
                                                            var
                                                            (defaults.expr
                                                               (type.base
                                                                  base.type.Z)))
                                                         (fun
                                                            a0 : option
                                                                   (defaults.expr
                                                                    (type.base
                                                                    t4) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                          =>
                                                          match a0 with
                                                          | Some x'0 =>
                                                              if
                                                               (args0 =?
                                                                2
                                                                ^ (2 *
                                                                   Z.log2_up
                                                                    args0 / 2) -
                                                                1) &&
                                                               (args2 =?
                                                                2
                                                                ^ (2 *
                                                                   Z.log2_up
                                                                    args0 / 2) -
                                                                1)
                                                              then
                                                               UnderLets.Base
                                                                 (#(ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                  (x' v,
                                                                  x'0 v0))%expr_pat
                                                              else
                                                               match x1 with
                                                               | #(idc3)%expr_pat =>
                                                                   match
                                                                    match
                                                                    idc3
                                                                    with
                                                                    | @ident.Literal
                                                                    t6 v1 =>
                                                                    match
                                                                    t6 as t7
                                                                    return
                                                                    (base.base_interp
                                                                    t7 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v2 : Z =>
                                                                    Some v2
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v1
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                   with
                                                                   | Some
                                                                    args3 =>
                                                                    match
                                                                    s0 as t6
                                                                    return
                                                                    (Compile.value'
                                                                    false t6 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t6 =>
                                                                    fun
                                                                    v1 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t6) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t7 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7)) t6
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a1 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t6) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a1
                                                                    with
                                                                    | Some
                                                                    x'1 =>
                                                                    match
                                                                    s2 as t7
                                                                    return
                                                                    (Compile.value'
                                                                    false t7 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t7 =>
                                                                    fun
                                                                    v2 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t8 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t8)) t7
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a2 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t7) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a2
                                                                    with
                                                                    | Some
                                                                    x'2 =>
                                                                    if
                                                                    (args3 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args3 / 2) -
                                                                    1) &&
                                                                    (args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args3 / 2) -
                                                                    1)
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args3))%expr @
                                                                    (
                                                                    x'1 v1,
                                                                    x'2 v2))%expr_pat
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s3 ->
                                                                    d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x4)
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s3 ->
                                                                    d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x2)
                                                                   | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                   end
                                                               | _ =>
                                                                   UnderLets.Base
                                                                    (x * x0)%expr
                                                               end
                                                          | None =>
                                                              UnderLets.Base
                                                                (x * x0)%expr
                                                          end)
                                                   | (s3 -> d3)%ptype =>
                                                       fun
                                                         _ : Compile.value'
                                                               false s3 ->
                                                             Compile.value'
                                                               true d3 =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end (Compile.reflect x4)
                                               | None =>
                                                   UnderLets.Base
                                                     (x * x0)%expr
                                               end)
                                        | (s3 -> d3)%ptype =>
                                            fun
                                              _ : Compile.value' false s3 ->
                                                  Compile.value' true d3 =>
                                            UnderLets.Base (x * x0)%expr
                                        end (Compile.reflect x1)
                                    | None => UnderLets.Base (x * x0)%expr
                                    end
                                | _ => UnderLets.Base (x * x0)%expr
                                end
                            | _ =>
                                match x3 with
                                | #(idc2)%expr_pat =>
                                    match
                                      match idc2 with
                                      | @ident.Literal t3 v =>
                                          match
                                            t3 as t4
                                            return
                                              (base.base_interp t4 ->
                                               option Z)
                                          with
                                          | base.type.unit =>
                                              fun _ : unit => None
                                          | base.type.Z =>
                                              fun v0 : Z => Some v0
                                          | base.type.bool =>
                                              fun _ : bool => None
                                          | base.type.nat =>
                                              fun _ : nat => None
                                          end v
                                      | _ => None
                                      end
                                    with
                                    | Some args2 =>
                                        match
                                          s as t3
                                          return
                                            (Compile.value' false t3 ->
                                             UnderLets.UnderLets base.type
                                               ident var
                                               (defaults.expr
                                                  (type.base base.type.Z)))
                                        with
                                        | type.base t3 =>
                                            fun
                                              v : defaults.expr
                                                    (type.base t3) =>
                                            base.try_make_transport_cps
                                              (fun t4 : base.type =>
                                               defaults.expr (type.base t4))
                                              t3 base.type.Z
                                              (UnderLets.UnderLets base.type
                                                 ident var
                                                 (defaults.expr
                                                    (type.base base.type.Z)))
                                              (fun
                                                 a : option
                                                       (defaults.expr
                                                          (type.base t3) ->
                                                        defaults.expr
                                                          (type.base
                                                             base.type.Z)) =>
                                               match a with
                                               | Some x' =>
                                                   match
                                                     s2 as t4
                                                     return
                                                       (Compile.value' false
                                                          t4 ->
                                                        UnderLets.UnderLets
                                                          base.type ident var
                                                          (defaults.expr
                                                             (type.base
                                                                base.type.Z)))
                                                   with
                                                   | type.base t4 =>
                                                       fun
                                                         v0 : defaults.expr
                                                                (type.base t4)
                                                       =>
                                                       base.try_make_transport_cps
                                                         (fun t5 : base.type
                                                          =>
                                                          defaults.expr
                                                            (type.base t5))
                                                         t4 base.type.Z
                                                         (UnderLets.UnderLets
                                                            base.type ident
                                                            var
                                                            (defaults.expr
                                                               (type.base
                                                                  base.type.Z)))
                                                         (fun
                                                            a0 : option
                                                                   (defaults.expr
                                                                    (type.base
                                                                    t4) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                          =>
                                                          match a0 with
                                                          | Some x'0 =>
                                                              if
                                                               (args0 =?
                                                                2
                                                                ^ (2 *
                                                                   Z.log2_up
                                                                    args0 / 2) -
                                                                1) &&
                                                               (args2 =?
                                                                2
                                                                ^ (2 *
                                                                   Z.log2_up
                                                                    args0 / 2) -
                                                                1)
                                                              then
                                                               UnderLets.Base
                                                                 (#(ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                  (x' v,
                                                                  x'0 v0))%expr_pat
                                                              else
                                                               match x1 with
                                                               | #(idc3)%expr_pat =>
                                                                   match
                                                                    match
                                                                    idc3
                                                                    with
                                                                    | @ident.Literal
                                                                    t6 v1 =>
                                                                    match
                                                                    t6 as t7
                                                                    return
                                                                    (base.base_interp
                                                                    t7 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v2 : Z =>
                                                                    Some v2
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v1
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                   with
                                                                   | Some
                                                                    args3 =>
                                                                    match
                                                                    s0 as t6
                                                                    return
                                                                    (Compile.value'
                                                                    false t6 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t6 =>
                                                                    fun
                                                                    v1 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t6) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t7 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7)) t6
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a1 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t6) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a1
                                                                    with
                                                                    | Some
                                                                    x'1 =>
                                                                    match
                                                                    s2 as t7
                                                                    return
                                                                    (Compile.value'
                                                                    false t7 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t7 =>
                                                                    fun
                                                                    v2 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t8 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t8)) t7
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a2 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t7) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a2
                                                                    with
                                                                    | Some
                                                                    x'2 =>
                                                                    if
                                                                    (args3 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args3 / 2) -
                                                                    1) &&
                                                                    (args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args3 / 2) -
                                                                    1)
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args3))%expr @
                                                                    (
                                                                    x'1 v1,
                                                                    x'2 v2))%expr_pat
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s4 ->
                                                                    d4)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s4 ->
                                                                    Compile.value'
                                                                    true d4
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x4)
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s4 ->
                                                                    d4)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s4 ->
                                                                    Compile.value'
                                                                    true d4
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x2)
                                                                   | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                   end
                                                               | _ =>
                                                                   UnderLets.Base
                                                                    (x * x0)%expr
                                                               end
                                                          | None =>
                                                              UnderLets.Base
                                                                (x * x0)%expr
                                                          end)
                                                   | (s4 -> d4)%ptype =>
                                                       fun
                                                         _ : Compile.value'
                                                               false s4 ->
                                                             Compile.value'
                                                               true d4 =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end (Compile.reflect x4)
                                               | None =>
                                                   UnderLets.Base
                                                     (x * x0)%expr
                                               end)
                                        | (s4 -> d4)%ptype =>
                                            fun
                                              _ : Compile.value' false s4 ->
                                                  Compile.value' true d4 =>
                                            UnderLets.Base (x * x0)%expr
                                        end (Compile.reflect x1)
                                    | None => UnderLets.Base (x * x0)%expr
                                    end
                                | _ => UnderLets.Base (x * x0)%expr
                                end
                            end
                        | None =>
                            match
                              match idc1 with
                              | ident.Z_shiftr => Some tt
                              | _ => None
                              end
                            with
                            | Some _ =>
                                match x3 with
                                | #(idc2)%expr_pat =>
                                    match
                                      match idc2 with
                                      | @ident.Literal t3 v =>
                                          match
                                            t3 as t4
                                            return
                                              (base.base_interp t4 ->
                                               option Z)
                                          with
                                          | base.type.unit =>
                                              fun _ : unit => None
                                          | base.type.Z =>
                                              fun v0 : Z => Some v0
                                          | base.type.bool =>
                                              fun _ : bool => None
                                          | base.type.nat =>
                                              fun _ : nat => None
                                          end v
                                      | _ => None
                                      end
                                    with
                                    | Some args2 =>
                                        match
                                          s as t3
                                          return
                                            (Compile.value' false t3 ->
                                             UnderLets.UnderLets base.type
                                               ident var
                                               (defaults.expr
                                                  (type.base base.type.Z)))
                                        with
                                        | type.base t3 =>
                                            fun
                                              v : defaults.expr
                                                    (type.base t3) =>
                                            base.try_make_transport_cps
                                              (fun t4 : base.type =>
                                               defaults.expr (type.base t4))
                                              t3 base.type.Z
                                              (UnderLets.UnderLets base.type
                                                 ident var
                                                 (defaults.expr
                                                    (type.base base.type.Z)))
                                              (fun
                                                 a : option
                                                       (defaults.expr
                                                          (type.base t3) ->
                                                        defaults.expr
                                                          (type.base
                                                             base.type.Z)) =>
                                               match a with
                                               | Some x' =>
                                                   match
                                                     s2 as t4
                                                     return
                                                       (Compile.value' false
                                                          t4 ->
                                                        UnderLets.UnderLets
                                                          base.type ident var
                                                          (defaults.expr
                                                             (type.base
                                                                base.type.Z)))
                                                   with
                                                   | type.base t4 =>
                                                       fun
                                                         v0 : defaults.expr
                                                                (type.base t4)
                                                       =>
                                                       base.try_make_transport_cps
                                                         (fun t5 : base.type
                                                          =>
                                                          defaults.expr
                                                            (type.base t5))
                                                         t4 base.type.Z
                                                         (UnderLets.UnderLets
                                                            base.type ident
                                                            var
                                                            (defaults.expr
                                                               (type.base
                                                                  base.type.Z)))
                                                         (fun
                                                            a0 : option
                                                                   (defaults.expr
                                                                    (type.base
                                                                    t4) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                          =>
                                                          match a0 with
                                                          | Some x'0 =>
                                                              if
                                                               args0 =?
                                                               2
                                                               ^ (2 * args2 /
                                                                  2) - 1
                                                              then
                                                               UnderLets.Base
                                                                 (#(ident.fancy_mullh
                                                                    (2 *
                                                                    args2))%expr @
                                                                  (x' v,
                                                                  x'0 v0))%expr_pat
                                                              else
                                                               match x1 with
                                                               | #(idc3)%expr_pat =>
                                                                   match
                                                                    match
                                                                    idc3
                                                                    with
                                                                    | @ident.Literal
                                                                    t6 v1 =>
                                                                    match
                                                                    t6 as t7
                                                                    return
                                                                    (base.base_interp
                                                                    t7 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v2 : Z =>
                                                                    Some v2
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v1
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                   with
                                                                   | Some
                                                                    args3 =>
                                                                    match
                                                                    s0 as t6
                                                                    return
                                                                    (Compile.value'
                                                                    false t6 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t6 =>
                                                                    fun
                                                                    v1 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t6) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t7 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7)) t6
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a1 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t6) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a1
                                                                    with
                                                                    | Some
                                                                    x'1 =>
                                                                    match
                                                                    s2 as t7
                                                                    return
                                                                    (Compile.value'
                                                                    false t7 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t7 =>
                                                                    fun
                                                                    v2 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t8 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t8)) t7
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a2 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t7) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a2
                                                                    with
                                                                    | Some
                                                                    x'2 =>
                                                                    if
                                                                    args3 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    args2 / 2) -
                                                                    1
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mullh
                                                                    (2 *
                                                                    args2))%expr @
                                                                    (
                                                                    x'1 v1,
                                                                    x'2 v2))%expr_pat
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s3 ->
                                                                    d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x4)
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s3 ->
                                                                    d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x2)
                                                                   | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                   end
                                                               | _ =>
                                                                   UnderLets.Base
                                                                    (x * x0)%expr
                                                               end
                                                          | None =>
                                                              UnderLets.Base
                                                                (x * x0)%expr
                                                          end)
                                                   | (s3 -> d3)%ptype =>
                                                       fun
                                                         _ : Compile.value'
                                                               false s3 ->
                                                             Compile.value'
                                                               true d3 =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end (Compile.reflect x4)
                                               | None =>
                                                   UnderLets.Base
                                                     (x * x0)%expr
                                               end)
                                        | (s3 -> d3)%ptype =>
                                            fun
                                              _ : Compile.value' false s3 ->
                                                  Compile.value' true d3 =>
                                            UnderLets.Base (x * x0)%expr
                                        end (Compile.reflect x1)
                                    | None => UnderLets.Base (x * x0)%expr
                                    end
                                | _ => UnderLets.Base (x * x0)%expr
                                end
                            | None => UnderLets.Base (x * x0)%expr
                            end
                        end
                    | @expr.App _ _ _ s1 _ (@expr.App _ _ _ s2 _ ($_)%expr _)
                      _ | @expr.App _ _ _ s1 _
                      (@expr.App _ _ _ s2 _ (@expr.Abs _ _ _ _ _ _) _) _ |
                      @expr.App _ _ _ s1 _
                      (@expr.App _ _ _ s2 _ (_ @ _)%expr_pat _) _ | @expr.App
                      _ _ _ s1 _
                      (@expr.App _ _ _ s2 _ (@expr.LetIn _ _ _ _ _ _ _) _)
                      _ => UnderLets.Base (x * x0)%expr
                    | @expr.App _ _ _ s1 _ #(_)%expr_pat _ | @expr.App _ _ _
                      s1 _ ($_)%expr _ | @expr.App _ _ _ s1 _
                      (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s1 _
                      (@expr.LetIn _ _ _ _ _ _ _) _ =>
                        UnderLets.Base (x * x0)%expr
                    | _ => UnderLets.Base (x * x0)%expr
                    end
                | None =>
                    match x1 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args0 =>
                            match x0 with
                            | #(idc2)%expr_pat =>
                                match
                                  match idc2 with
                                  | @ident.Literal t3 v =>
                                      match
                                        t3 as t4
                                        return
                                          (base.base_interp t4 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s0 as t3
                                      return
                                        (Compile.value' false t3 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base base.type.Z)))
                                    with
                                    | type.base t3 =>
                                        fun v : defaults.expr (type.base t3)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t4 : base.type =>
                                           defaults.expr (type.base t4)) t3
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base base.type.Z)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t3) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if
                                                args0 =?
                                                2 ^ (2 * Z.log2_up args0 / 2) -
                                                1
                                               then
                                                match
                                                  invert_low
                                                    (2 * Z.log2_up args0)
                                                    args1
                                                with
                                                | Some y =>
                                                    UnderLets.Base
                                                      (#(ident.fancy_mulll
                                                           (2 *
                                                            Z.log2_up args0))%expr @
                                                       (x' v, ##(y)%expr))%expr_pat
                                                | None =>
                                                    match
                                                      s0 as t4
                                                      return
                                                        (Compile.value' false
                                                           t4 ->
                                                         UnderLets.UnderLets
                                                           base.type ident
                                                           var
                                                           (defaults.expr
                                                              (type.base
                                                                 base.type.Z)))
                                                    with
                                                    | type.base t4 =>
                                                        fun
                                                          v0 : defaults.expr
                                                                 (type.base
                                                                    t4) =>
                                                        base.try_make_transport_cps
                                                          (fun t5 : base.type
                                                           =>
                                                           defaults.expr
                                                             (type.base t5))
                                                          t4 base.type.Z
                                                          (UnderLets.UnderLets
                                                             base.type ident
                                                             var
                                                             (defaults.expr
                                                                (type.base
                                                                   base.type.Z)))
                                                          (fun
                                                             a0 : option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t4) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                           =>
                                                           match a0 with
                                                           | Some x'0 =>
                                                               if
                                                                args0 =?
                                                                2
                                                                ^ (2 *
                                                                   Z.log2_up
                                                                    args0 / 2) -
                                                                1
                                                               then
                                                                match
                                                                  invert_high
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0)
                                                                    args1
                                                                with
                                                                | Some y =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mullh
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x'0 v0,
                                                                    ##
                                                                    (y)%expr))%expr_pat
                                                                | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                end
                                                               else
                                                                UnderLets.Base
                                                                  (x * x0)%expr
                                                           | None =>
                                                               UnderLets.Base
                                                                 (x * x0)%expr
                                                           end)
                                                    | (s1 -> d1)%ptype =>
                                                        fun
                                                          _ : Compile.value'
                                                                false s1 ->
                                                              Compile.value'
                                                                true d1 =>
                                                        UnderLets.Base
                                                          (x * x0)%expr
                                                    end (Compile.reflect x2)
                                                end
                                               else
                                                match
                                                  s0 as t4
                                                  return
                                                    (Compile.value' false t4 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             base.type.Z)))
                                                with
                                                | type.base t4 =>
                                                    fun
                                                      v0 : defaults.expr
                                                             (type.base t4)
                                                    =>
                                                    base.try_make_transport_cps
                                                      (fun t5 : base.type =>
                                                       defaults.expr
                                                         (type.base t5)) t4
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               base.type.Z)))
                                                      (fun
                                                         a0 : option
                                                                (defaults.expr
                                                                   (type.base
                                                                    t4) ->
                                                                 defaults.expr
                                                                   (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a0 with
                                                       | Some x'0 =>
                                                           if
                                                            args0 =?
                                                            2
                                                            ^ (2 *
                                                               Z.log2_up
                                                                 args0 / 2) -
                                                            1
                                                           then
                                                            match
                                                              invert_high
                                                                (2 *
                                                                 Z.log2_up
                                                                   args0)
                                                                args1
                                                            with
                                                            | Some y =>
                                                                UnderLets.Base
                                                                  (#(ident.fancy_mullh
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                   (x'0 v0,
                                                                   ##
                                                                   (y)%expr))%expr_pat
                                                            | None =>
                                                                UnderLets.Base
                                                                  (x * x0)%expr
                                                            end
                                                           else
                                                            UnderLets.Base
                                                              (x * x0)%expr
                                                       | None =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end)
                                                | (s1 -> d1)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s1 ->
                                                          Compile.value' true
                                                            d1 =>
                                                    UnderLets.Base
                                                      (x * x0)%expr
                                                end (Compile.reflect x2)
                                           | None =>
                                               UnderLets.Base (x * x0)%expr
                                           end)
                                    | (s1 -> d1)%ptype =>
                                        fun
                                          _ : Compile.value' false s1 ->
                                              Compile.value' true d1 =>
                                        UnderLets.Base (x * x0)%expr
                                    end (Compile.reflect x2)
                                | None => UnderLets.Base (x * x0)%expr
                                end
                            | @expr.App _ _ _ s1 _
                              (@expr.App _ _ _ s2 _ #(idc2)%expr_pat x4)
                              x3 =>
                                match
                                  match idc2 with
                                  | ident.Z_land => Some tt
                                  | _ => None
                                  end
                                with
                                | Some _ =>
                                    match x4 with
                                    | #(idc3)%expr_pat =>
                                        match
                                          match idc3 with
                                          | @ident.Literal t4 v =>
                                              match
                                                t4 as t5
                                                return
                                                  (base.base_interp t5 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v0 : Z => Some v0
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v
                                          | _ => None
                                          end
                                        with
                                        | Some args2 =>
                                            match
                                              s0 as t4
                                              return
                                                (Compile.value' false t4 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base base.type.Z)))
                                            with
                                            | type.base t4 =>
                                                fun
                                                  v : defaults.expr
                                                        (type.base t4) =>
                                                base.try_make_transport_cps
                                                  (fun t5 : base.type =>
                                                   defaults.expr
                                                     (type.base t5)) t4
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           base.type.Z)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t4) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       match
                                                         s1 as t5
                                                         return
                                                           (Compile.value'
                                                              false t5 ->
                                                            UnderLets.UnderLets
                                                              base.type ident
                                                              var
                                                              (defaults.expr
                                                                 (type.base
                                                                    base.type.Z)))
                                                       with
                                                       | type.base t5 =>
                                                           fun
                                                             v0 : defaults.expr
                                                                    (type.base
                                                                    t5) =>
                                                           base.try_make_transport_cps
                                                             (fun
                                                                t6 : base.type
                                                              =>
                                                              defaults.expr
                                                                (type.base t6))
                                                             t5 base.type.Z
                                                             (UnderLets.UnderLets
                                                                base.type
                                                                ident var
                                                                (defaults.expr
                                                                   (type.base
                                                                    base.type.Z)))
                                                             (fun
                                                                a0 : 
                                                                 option
                                                                   (defaults.expr
                                                                    (type.base
                                                                    t5) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                              =>
                                                              match a0 with
                                                              | Some x'0 =>
                                                                  if
                                                                   (args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1) &&
                                                                   (args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1)
                                                                  then
                                                                   UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x' v,
                                                                    x'0 v0))%expr_pat
                                                                  else
                                                                   match
                                                                    x3
                                                                   with
                                                                   | #
                                                                    (idc4)%expr_pat =>
                                                                    match
                                                                    match
                                                                    idc4
                                                                    with
                                                                    | @ident.Literal
                                                                    t7 v1 =>
                                                                    match
                                                                    t7 as t8
                                                                    return
                                                                    (base.base_interp
                                                                    t8 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v2 : Z =>
                                                                    Some v2
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v1
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                    with
                                                                    | Some
                                                                    args3 =>
                                                                    match
                                                                    s0 as t7
                                                                    return
                                                                    (Compile.value'
                                                                    false t7 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t7 =>
                                                                    fun
                                                                    v1 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t8 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t8)) t7
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a1 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t7) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a1
                                                                    with
                                                                    | Some
                                                                    x'1 =>
                                                                    match
                                                                    s2 as t8
                                                                    return
                                                                    (Compile.value'
                                                                    false t8 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t8 =>
                                                                    fun
                                                                    v2 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t8) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t9 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t9)) t8
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a2 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t8) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a2
                                                                    with
                                                                    | Some
                                                                    x'2 =>
                                                                    if
                                                                    (args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1) &&
                                                                    (args3 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1)
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x'1 v1,
                                                                    x'2 v2))%expr_pat
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s3 ->
                                                                    d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x4)
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s3 ->
                                                                    d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x2)
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                   | _ =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                   end
                                                              | None =>
                                                                  UnderLets.Base
                                                                    (x * x0)%expr
                                                              end)
                                                       | (s3 -> d3)%ptype =>
                                                           fun
                                                             _ : Compile.value'
                                                                   false s3 ->
                                                                 Compile.value'
                                                                   true d3 =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end
                                                         (Compile.reflect x3)
                                                   | None =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end)
                                            | (s3 -> d3)%ptype =>
                                                fun
                                                  _ : Compile.value' false s3 ->
                                                      Compile.value' true d3
                                                =>
                                                UnderLets.Base (x * x0)%expr
                                            end (Compile.reflect x2)
                                        | None =>
                                            match x3 with
                                            | #(idc4)%expr_pat =>
                                                match
                                                  match idc4 with
                                                  | @ident.Literal t5 v =>
                                                      match
                                                        t5 as t6
                                                        return
                                                          (base.base_interp
                                                             t6 -> option Z)
                                                      with
                                                      | base.type.unit =>
                                                          fun _ : unit =>
                                                          None
                                                      | base.type.Z =>
                                                          fun v0 : Z =>
                                                          Some v0
                                                      | base.type.bool =>
                                                          fun _ : bool =>
                                                          None
                                                      | base.type.nat =>
                                                          fun _ : nat => None
                                                      end v
                                                  | _ => None
                                                  end
                                                with
                                                | Some args2 =>
                                                    match
                                                      s0 as t5
                                                      return
                                                        (Compile.value' false
                                                           t5 ->
                                                         UnderLets.UnderLets
                                                           base.type ident
                                                           var
                                                           (defaults.expr
                                                              (type.base
                                                                 base.type.Z)))
                                                    with
                                                    | type.base t5 =>
                                                        fun
                                                          v : defaults.expr
                                                                (type.base t5)
                                                        =>
                                                        base.try_make_transport_cps
                                                          (fun t6 : base.type
                                                           =>
                                                           defaults.expr
                                                             (type.base t6))
                                                          t5 base.type.Z
                                                          (UnderLets.UnderLets
                                                             base.type ident
                                                             var
                                                             (defaults.expr
                                                                (type.base
                                                                   base.type.Z)))
                                                          (fun
                                                             a : option
                                                                   (defaults.expr
                                                                    (type.base
                                                                    t5) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                           =>
                                                           match a with
                                                           | Some x' =>
                                                               match
                                                                 s2 as t6
                                                                 return
                                                                   (Compile.value'
                                                                    false t6 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                               with
                                                               | type.base
                                                                 t6 =>
                                                                   fun
                                                                    v0 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t6) =>
                                                                   base.try_make_transport_cps
                                                                    (fun
                                                                    t7 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7)) t6
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a0 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t6) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a0
                                                                    with
                                                                    | Some
                                                                    x'0 =>
                                                                    if
                                                                    (args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1) &&
                                                                    (args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1)
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x' v,
                                                                    x'0 v0))%expr_pat
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                               | (s3 -> d3)%ptype =>
                                                                   fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                   =>
                                                                   UnderLets.Base
                                                                    (x * x0)%expr
                                                               end
                                                                 (Compile.reflect
                                                                    x4)
                                                           | None =>
                                                               UnderLets.Base
                                                                 (x * x0)%expr
                                                           end)
                                                    | (s3 -> d3)%ptype =>
                                                        fun
                                                          _ : Compile.value'
                                                                false s3 ->
                                                              Compile.value'
                                                                true d3 =>
                                                        UnderLets.Base
                                                          (x * x0)%expr
                                                    end (Compile.reflect x2)
                                                | None =>
                                                    UnderLets.Base
                                                      (x * x0)%expr
                                                end
                                            | _ =>
                                                UnderLets.Base (x * x0)%expr
                                            end
                                        end
                                    | ($_)%expr =>
                                        match x3 with
                                        | #(idc3)%expr_pat =>
                                            match
                                              match idc3 with
                                              | @ident.Literal t5 v0 =>
                                                  match
                                                    t5 as t6
                                                    return
                                                      (base.base_interp t6 ->
                                                       option Z)
                                                  with
                                                  | base.type.unit =>
                                                      fun _ : unit => None
                                                  | base.type.Z =>
                                                      fun v1 : Z => Some v1
                                                  | base.type.bool =>
                                                      fun _ : bool => None
                                                  | base.type.nat =>
                                                      fun _ : nat => None
                                                  end v0
                                              | _ => None
                                              end
                                            with
                                            | Some args2 =>
                                                match
                                                  s0 as t5
                                                  return
                                                    (Compile.value' false t5 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             base.type.Z)))
                                                with
                                                | type.base t5 =>
                                                    fun
                                                      v0 : defaults.expr
                                                             (type.base t5)
                                                    =>
                                                    base.try_make_transport_cps
                                                      (fun t6 : base.type =>
                                                       defaults.expr
                                                         (type.base t6)) t5
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               base.type.Z)))
                                                      (fun
                                                         a : option
                                                               (defaults.expr
                                                                  (type.base
                                                                    t5) ->
                                                                defaults.expr
                                                                  (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a with
                                                       | Some x' =>
                                                           match
                                                             s2 as t6
                                                             return
                                                               (Compile.value'
                                                                  false t6 ->
                                                                UnderLets.UnderLets
                                                                  base.type
                                                                  ident var
                                                                  (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                           with
                                                           | type.base t6 =>
                                                               fun
                                                                 v1 : 
                                                                  defaults.expr
                                                                    (type.base
                                                                    t6) =>
                                                               base.try_make_transport_cps
                                                                 (fun
                                                                    t7 : base.type
                                                                  =>
                                                                  defaults.expr
                                                                    (type.base
                                                                    t7)) t6
                                                                 base.type.Z
                                                                 (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                 (fun
                                                                    a0 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t6) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                  =>
                                                                  match
                                                                    a0
                                                                  with
                                                                  | Some
                                                                    x'0 =>
                                                                    if
                                                                    (args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1) &&
                                                                    (args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1)
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x' v0,
                                                                    x'0 v1))%expr_pat
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                  | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                  end)
                                                           | (s3 -> d3)%ptype =>
                                                               fun
                                                                 _ : 
                                                                  Compile.value'
                                                                    false s3 ->
                                                                  Compile.value'
                                                                    true d3
                                                               =>
                                                               UnderLets.Base
                                                                 (x * x0)%expr
                                                           end
                                                             (Compile.reflect
                                                                x4)
                                                       | None =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end)
                                                | (s3 -> d3)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s3 ->
                                                          Compile.value' true
                                                            d3 =>
                                                    UnderLets.Base
                                                      (x * x0)%expr
                                                end (Compile.reflect x2)
                                            | None =>
                                                UnderLets.Base (x * x0)%expr
                                            end
                                        | _ => UnderLets.Base (x * x0)%expr
                                        end
                                    | @expr.LetIn _ _ _ _ _ _ _ =>
                                        match x3 with
                                        | #(idc3)%expr_pat =>
                                            match
                                              match idc3 with
                                              | @ident.Literal t4 v =>
                                                  match
                                                    t4 as t5
                                                    return
                                                      (base.base_interp t5 ->
                                                       option Z)
                                                  with
                                                  | base.type.unit =>
                                                      fun _ : unit => None
                                                  | base.type.Z =>
                                                      fun v0 : Z => Some v0
                                                  | base.type.bool =>
                                                      fun _ : bool => None
                                                  | base.type.nat =>
                                                      fun _ : nat => None
                                                  end v
                                              | _ => None
                                              end
                                            with
                                            | Some args2 =>
                                                match
                                                  s0 as t4
                                                  return
                                                    (Compile.value' false t4 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             base.type.Z)))
                                                with
                                                | type.base t4 =>
                                                    fun
                                                      v : defaults.expr
                                                            (type.base t4) =>
                                                    base.try_make_transport_cps
                                                      (fun t5 : base.type =>
                                                       defaults.expr
                                                         (type.base t5)) t4
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               base.type.Z)))
                                                      (fun
                                                         a : option
                                                               (defaults.expr
                                                                  (type.base
                                                                    t4) ->
                                                                defaults.expr
                                                                  (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a with
                                                       | Some x' =>
                                                           match
                                                             s2 as t5
                                                             return
                                                               (Compile.value'
                                                                  false t5 ->
                                                                UnderLets.UnderLets
                                                                  base.type
                                                                  ident var
                                                                  (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                           with
                                                           | type.base t5 =>
                                                               fun
                                                                 v0 : 
                                                                  defaults.expr
                                                                    (type.base
                                                                    t5) =>
                                                               base.try_make_transport_cps
                                                                 (fun
                                                                    t6 : base.type
                                                                  =>
                                                                  defaults.expr
                                                                    (type.base
                                                                    t6)) t5
                                                                 base.type.Z
                                                                 (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                 (fun
                                                                    a0 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t5) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                  =>
                                                                  match
                                                                    a0
                                                                  with
                                                                  | Some
                                                                    x'0 =>
                                                                    if
                                                                    (args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1) &&
                                                                    (args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1)
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x' v,
                                                                    x'0 v0))%expr_pat
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                  | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                  end)
                                                           | (s3 -> d3)%ptype =>
                                                               fun
                                                                 _ : 
                                                                  Compile.value'
                                                                    false s3 ->
                                                                  Compile.value'
                                                                    true d3
                                                               =>
                                                               UnderLets.Base
                                                                 (x * x0)%expr
                                                           end
                                                             (Compile.reflect
                                                                x4)
                                                       | None =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end)
                                                | (s3 -> d3)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s3 ->
                                                          Compile.value' true
                                                            d3 =>
                                                    UnderLets.Base
                                                      (x * x0)%expr
                                                end (Compile.reflect x2)
                                            | None =>
                                                UnderLets.Base (x * x0)%expr
                                            end
                                        | _ => UnderLets.Base (x * x0)%expr
                                        end
                                    | _ =>
                                        match x3 with
                                        | #(idc3)%expr_pat =>
                                            match
                                              match idc3 with
                                              | @ident.Literal t4 v =>
                                                  match
                                                    t4 as t5
                                                    return
                                                      (base.base_interp t5 ->
                                                       option Z)
                                                  with
                                                  | base.type.unit =>
                                                      fun _ : unit => None
                                                  | base.type.Z =>
                                                      fun v0 : Z => Some v0
                                                  | base.type.bool =>
                                                      fun _ : bool => None
                                                  | base.type.nat =>
                                                      fun _ : nat => None
                                                  end v
                                              | _ => None
                                              end
                                            with
                                            | Some args2 =>
                                                match
                                                  s0 as t4
                                                  return
                                                    (Compile.value' false t4 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             base.type.Z)))
                                                with
                                                | type.base t4 =>
                                                    fun
                                                      v : defaults.expr
                                                            (type.base t4) =>
                                                    base.try_make_transport_cps
                                                      (fun t5 : base.type =>
                                                       defaults.expr
                                                         (type.base t5)) t4
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               base.type.Z)))
                                                      (fun
                                                         a : option
                                                               (defaults.expr
                                                                  (type.base
                                                                    t4) ->
                                                                defaults.expr
                                                                  (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a with
                                                       | Some x' =>
                                                           match
                                                             s2 as t5
                                                             return
                                                               (Compile.value'
                                                                  false t5 ->
                                                                UnderLets.UnderLets
                                                                  base.type
                                                                  ident var
                                                                  (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                           with
                                                           | type.base t5 =>
                                                               fun
                                                                 v0 : 
                                                                  defaults.expr
                                                                    (type.base
                                                                    t5) =>
                                                               base.try_make_transport_cps
                                                                 (fun
                                                                    t6 : base.type
                                                                  =>
                                                                  defaults.expr
                                                                    (type.base
                                                                    t6)) t5
                                                                 base.type.Z
                                                                 (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                 (fun
                                                                    a0 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t5) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                  =>
                                                                  match
                                                                    a0
                                                                  with
                                                                  | Some
                                                                    x'0 =>
                                                                    if
                                                                    (args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1) &&
                                                                    (args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1)
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x' v,
                                                                    x'0 v0))%expr_pat
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                  | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                  end)
                                                           | (s4 -> d4)%ptype =>
                                                               fun
                                                                 _ : 
                                                                  Compile.value'
                                                                    false s4 ->
                                                                  Compile.value'
                                                                    true d4
                                                               =>
                                                               UnderLets.Base
                                                                 (x * x0)%expr
                                                           end
                                                             (Compile.reflect
                                                                x4)
                                                       | None =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end)
                                                | (s4 -> d4)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s4 ->
                                                          Compile.value' true
                                                            d4 =>
                                                    UnderLets.Base
                                                      (x * x0)%expr
                                                end (Compile.reflect x2)
                                            | None =>
                                                UnderLets.Base (x * x0)%expr
                                            end
                                        | _ => UnderLets.Base (x * x0)%expr
                                        end
                                    end
                                | None =>
                                    match
                                      match idc2 with
                                      | ident.Z_shiftr => Some tt
                                      | _ => None
                                      end
                                    with
                                    | Some _ =>
                                        match x3 with
                                        | #(idc3)%expr_pat =>
                                            match
                                              match idc3 with
                                              | @ident.Literal t4 v =>
                                                  match
                                                    t4 as t5
                                                    return
                                                      (base.base_interp t5 ->
                                                       option Z)
                                                  with
                                                  | base.type.unit =>
                                                      fun _ : unit => None
                                                  | base.type.Z =>
                                                      fun v0 : Z => Some v0
                                                  | base.type.bool =>
                                                      fun _ : bool => None
                                                  | base.type.nat =>
                                                      fun _ : nat => None
                                                  end v
                                              | _ => None
                                              end
                                            with
                                            | Some args2 =>
                                                match
                                                  s0 as t4
                                                  return
                                                    (Compile.value' false t4 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             base.type.Z)))
                                                with
                                                | type.base t4 =>
                                                    fun
                                                      v : defaults.expr
                                                            (type.base t4) =>
                                                    base.try_make_transport_cps
                                                      (fun t5 : base.type =>
                                                       defaults.expr
                                                         (type.base t5)) t4
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               base.type.Z)))
                                                      (fun
                                                         a : option
                                                               (defaults.expr
                                                                  (type.base
                                                                    t4) ->
                                                                defaults.expr
                                                                  (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a with
                                                       | Some x' =>
                                                           match
                                                             s2 as t5
                                                             return
                                                               (Compile.value'
                                                                  false t5 ->
                                                                UnderLets.UnderLets
                                                                  base.type
                                                                  ident var
                                                                  (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                           with
                                                           | type.base t5 =>
                                                               fun
                                                                 v0 : 
                                                                  defaults.expr
                                                                    (type.base
                                                                    t5) =>
                                                               base.try_make_transport_cps
                                                                 (fun
                                                                    t6 : base.type
                                                                  =>
                                                                  defaults.expr
                                                                    (type.base
                                                                    t6)) t5
                                                                 base.type.Z
                                                                 (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                 (fun
                                                                    a0 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t5) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                  =>
                                                                  match
                                                                    a0
                                                                  with
                                                                  | Some
                                                                    x'0 =>
                                                                    if
                                                                    args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    args2 / 2) -
                                                                    1
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mullh
                                                                    (2 *
                                                                    args2))%expr @
                                                                    (
                                                                    x' v,
                                                                    x'0 v0))%expr_pat
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                  | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                  end)
                                                           | (s3 -> d3)%ptype =>
                                                               fun
                                                                 _ : 
                                                                  Compile.value'
                                                                    false s3 ->
                                                                  Compile.value'
                                                                    true d3
                                                               =>
                                                               UnderLets.Base
                                                                 (x * x0)%expr
                                                           end
                                                             (Compile.reflect
                                                                x4)
                                                       | None =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end)
                                                | (s3 -> d3)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s3 ->
                                                          Compile.value' true
                                                            d3 =>
                                                    UnderLets.Base
                                                      (x * x0)%expr
                                                end (Compile.reflect x2)
                                            | None =>
                                                UnderLets.Base (x * x0)%expr
                                            end
                                        | _ => UnderLets.Base (x * x0)%expr
                                        end
                                    | None => UnderLets.Base (x * x0)%expr
                                    end
                                end
                            | @expr.App _ _ _ s1 _
                              (@expr.App _ _ _ s2 _ ($_)%expr _) _ |
                              @expr.App _ _ _ s1 _
                              (@expr.App _ _ _ s2 _ (@expr.Abs _ _ _ _ _ _)
                               _) _ | @expr.App _ _ _ s1 _
                              (@expr.App _ _ _ s2 _ (_ @ _)%expr_pat _) _ |
                              @expr.App _ _ _ s1 _
                              (@expr.App _ _ _ s2 _
                               (@expr.LetIn _ _ _ _ _ _ _) _) _ =>
                                UnderLets.Base (x * x0)%expr
                            | @expr.App _ _ _ s1 _ #(_)%expr_pat _ |
                              @expr.App _ _ _ s1 _ ($_)%expr _ | @expr.App _
                              _ _ s1 _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App
                              _ _ _ s1 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
                                UnderLets.Base (x * x0)%expr
                            | _ => UnderLets.Base (x * x0)%expr
                            end
                        | None => UnderLets.Base (x * x0)%expr
                        end
                    | _ => UnderLets.Base (x * x0)%expr
                    end
                end
            | ($_)%expr =>
                match x1 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t2 v0 =>
                          match
                            t2 as t3 return (base.base_interp t3 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v1 : Z => Some v1
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v0
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        match x0 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t3 v0 =>
                                  match
                                    t3 as t4
                                    return (base.base_interp t4 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v1 : Z => Some v1
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v0
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                match
                                  s0 as t3
                                  return
                                    (Compile.value' false t3 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr (type.base base.type.Z)))
                                with
                                | type.base t3 =>
                                    fun v0 : defaults.expr (type.base t3) =>
                                    base.try_make_transport_cps
                                      (fun t4 : base.type =>
                                       defaults.expr (type.base t4)) t3
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base base.type.Z)))
                                      (fun
                                         a : option
                                               (defaults.expr (type.base t3) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                       match a with
                                       | Some x' =>
                                           if
                                            args0 =?
                                            2 ^ (2 * Z.log2_up args0 / 2) - 1
                                           then
                                            match
                                              invert_low
                                                (2 * Z.log2_up args0) args1
                                            with
                                            | Some y =>
                                                UnderLets.Base
                                                  (#(ident.fancy_mulll
                                                       (2 * Z.log2_up args0))%expr @
                                                   (x' v0, ##(y)%expr))%expr_pat
                                            | None =>
                                                match
                                                  s0 as t4
                                                  return
                                                    (Compile.value' false t4 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             base.type.Z)))
                                                with
                                                | type.base t4 =>
                                                    fun
                                                      v1 : defaults.expr
                                                             (type.base t4)
                                                    =>
                                                    base.try_make_transport_cps
                                                      (fun t5 : base.type =>
                                                       defaults.expr
                                                         (type.base t5)) t4
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               base.type.Z)))
                                                      (fun
                                                         a0 : option
                                                                (defaults.expr
                                                                   (type.base
                                                                    t4) ->
                                                                 defaults.expr
                                                                   (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a0 with
                                                       | Some x'0 =>
                                                           if
                                                            args0 =?
                                                            2
                                                            ^ (2 *
                                                               Z.log2_up
                                                                 args0 / 2) -
                                                            1
                                                           then
                                                            match
                                                              invert_high
                                                                (2 *
                                                                 Z.log2_up
                                                                   args0)
                                                                args1
                                                            with
                                                            | Some y =>
                                                                UnderLets.Base
                                                                  (#(ident.fancy_mullh
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                   (x'0 v1,
                                                                   ##
                                                                   (y)%expr))%expr_pat
                                                            | None =>
                                                                UnderLets.Base
                                                                  (x * x0)%expr
                                                            end
                                                           else
                                                            UnderLets.Base
                                                              (x * x0)%expr
                                                       | None =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end)
                                                | (s1 -> d1)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s1 ->
                                                          Compile.value' true
                                                            d1 =>
                                                    UnderLets.Base
                                                      (x * x0)%expr
                                                end (Compile.reflect x2)
                                            end
                                           else
                                            match
                                              s0 as t4
                                              return
                                                (Compile.value' false t4 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base base.type.Z)))
                                            with
                                            | type.base t4 =>
                                                fun
                                                  v1 : defaults.expr
                                                         (type.base t4) =>
                                                base.try_make_transport_cps
                                                  (fun t5 : base.type =>
                                                   defaults.expr
                                                     (type.base t5)) t4
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           base.type.Z)))
                                                  (fun
                                                     a0 : option
                                                            (defaults.expr
                                                               (type.base t4) ->
                                                             defaults.expr
                                                               (type.base
                                                                  base.type.Z))
                                                   =>
                                                   match a0 with
                                                   | Some x'0 =>
                                                       if
                                                        args0 =?
                                                        2
                                                        ^ (2 *
                                                           Z.log2_up args0 /
                                                           2) - 1
                                                       then
                                                        match
                                                          invert_high
                                                            (2 *
                                                             Z.log2_up args0)
                                                            args1
                                                        with
                                                        | Some y =>
                                                            UnderLets.Base
                                                              (#(ident.fancy_mullh
                                                                   (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                               (x'0 v1,
                                                               ##(y)%expr))%expr_pat
                                                        | None =>
                                                            UnderLets.Base
                                                              (x * x0)%expr
                                                        end
                                                       else
                                                        UnderLets.Base
                                                          (x * x0)%expr
                                                   | None =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end)
                                            | (s1 -> d1)%ptype =>
                                                fun
                                                  _ : Compile.value' false s1 ->
                                                      Compile.value' true d1
                                                =>
                                                UnderLets.Base (x * x0)%expr
                                            end (Compile.reflect x2)
                                       | None => UnderLets.Base (x * x0)%expr
                                       end)
                                | (s1 -> d1)%ptype =>
                                    fun
                                      _ : Compile.value' false s1 ->
                                          Compile.value' true d1 =>
                                    UnderLets.Base (x * x0)%expr
                                end (Compile.reflect x2)
                            | None => UnderLets.Base (x * x0)%expr
                            end
                        | @expr.App _ _ _ s1 _
                          (@expr.App _ _ _ s2 _ #(idc1)%expr_pat x4) x3 =>
                            match
                              match idc1 with
                              | ident.Z_land => Some tt
                              | _ => None
                              end
                            with
                            | Some _ =>
                                match x4 with
                                | #(idc2)%expr_pat =>
                                    match
                                      match idc2 with
                                      | @ident.Literal t4 v0 =>
                                          match
                                            t4 as t5
                                            return
                                              (base.base_interp t5 ->
                                               option Z)
                                          with
                                          | base.type.unit =>
                                              fun _ : unit => None
                                          | base.type.Z =>
                                              fun v1 : Z => Some v1
                                          | base.type.bool =>
                                              fun _ : bool => None
                                          | base.type.nat =>
                                              fun _ : nat => None
                                          end v0
                                      | _ => None
                                      end
                                    with
                                    | Some args2 =>
                                        match
                                          s0 as t4
                                          return
                                            (Compile.value' false t4 ->
                                             UnderLets.UnderLets base.type
                                               ident var
                                               (defaults.expr
                                                  (type.base base.type.Z)))
                                        with
                                        | type.base t4 =>
                                            fun
                                              v0 : defaults.expr
                                                     (type.base t4) =>
                                            base.try_make_transport_cps
                                              (fun t5 : base.type =>
                                               defaults.expr (type.base t5))
                                              t4 base.type.Z
                                              (UnderLets.UnderLets base.type
                                                 ident var
                                                 (defaults.expr
                                                    (type.base base.type.Z)))
                                              (fun
                                                 a : option
                                                       (defaults.expr
                                                          (type.base t4) ->
                                                        defaults.expr
                                                          (type.base
                                                             base.type.Z)) =>
                                               match a with
                                               | Some x' =>
                                                   match
                                                     s1 as t5
                                                     return
                                                       (Compile.value' false
                                                          t5 ->
                                                        UnderLets.UnderLets
                                                          base.type ident var
                                                          (defaults.expr
                                                             (type.base
                                                                base.type.Z)))
                                                   with
                                                   | type.base t5 =>
                                                       fun
                                                         v1 : defaults.expr
                                                                (type.base t5)
                                                       =>
                                                       base.try_make_transport_cps
                                                         (fun t6 : base.type
                                                          =>
                                                          defaults.expr
                                                            (type.base t6))
                                                         t5 base.type.Z
                                                         (UnderLets.UnderLets
                                                            base.type ident
                                                            var
                                                            (defaults.expr
                                                               (type.base
                                                                  base.type.Z)))
                                                         (fun
                                                            a0 : option
                                                                   (defaults.expr
                                                                    (type.base
                                                                    t5) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                          =>
                                                          match a0 with
                                                          | Some x'0 =>
                                                              if
                                                               (args0 =?
                                                                2
                                                                ^ (2 *
                                                                   Z.log2_up
                                                                    args0 / 2) -
                                                                1) &&
                                                               (args2 =?
                                                                2
                                                                ^ (2 *
                                                                   Z.log2_up
                                                                    args0 / 2) -
                                                                1)
                                                              then
                                                               UnderLets.Base
                                                                 (#(ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                  (x' v0,
                                                                  x'0 v1))%expr_pat
                                                              else
                                                               match x3 with
                                                               | #(idc3)%expr_pat =>
                                                                   match
                                                                    match
                                                                    idc3
                                                                    with
                                                                    | @ident.Literal
                                                                    t7 v2 =>
                                                                    match
                                                                    t7 as t8
                                                                    return
                                                                    (base.base_interp
                                                                    t8 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v3 : Z =>
                                                                    Some v3
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v2
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                   with
                                                                   | Some
                                                                    args3 =>
                                                                    match
                                                                    s0 as t7
                                                                    return
                                                                    (Compile.value'
                                                                    false t7 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t7 =>
                                                                    fun
                                                                    v2 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t8 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t8)) t7
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a1 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t7) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a1
                                                                    with
                                                                    | Some
                                                                    x'1 =>
                                                                    match
                                                                    s2 as t8
                                                                    return
                                                                    (Compile.value'
                                                                    false t8 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t8 =>
                                                                    fun
                                                                    v3 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t8) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t9 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t9)) t8
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a2 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t8) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a2
                                                                    with
                                                                    | Some
                                                                    x'2 =>
                                                                    if
                                                                    (args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1) &&
                                                                    (args3 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1)
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x'1 v2,
                                                                    x'2 v3))%expr_pat
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s3 ->
                                                                    d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x4)
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s3 ->
                                                                    d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x2)
                                                                   | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                   end
                                                               | _ =>
                                                                   UnderLets.Base
                                                                    (x * x0)%expr
                                                               end
                                                          | None =>
                                                              UnderLets.Base
                                                                (x * x0)%expr
                                                          end)
                                                   | (s3 -> d3)%ptype =>
                                                       fun
                                                         _ : Compile.value'
                                                               false s3 ->
                                                             Compile.value'
                                                               true d3 =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end (Compile.reflect x3)
                                               | None =>
                                                   UnderLets.Base
                                                     (x * x0)%expr
                                               end)
                                        | (s3 -> d3)%ptype =>
                                            fun
                                              _ : Compile.value' false s3 ->
                                                  Compile.value' true d3 =>
                                            UnderLets.Base (x * x0)%expr
                                        end (Compile.reflect x2)
                                    | None =>
                                        match x3 with
                                        | #(idc3)%expr_pat =>
                                            match
                                              match idc3 with
                                              | @ident.Literal t5 v0 =>
                                                  match
                                                    t5 as t6
                                                    return
                                                      (base.base_interp t6 ->
                                                       option Z)
                                                  with
                                                  | base.type.unit =>
                                                      fun _ : unit => None
                                                  | base.type.Z =>
                                                      fun v1 : Z => Some v1
                                                  | base.type.bool =>
                                                      fun _ : bool => None
                                                  | base.type.nat =>
                                                      fun _ : nat => None
                                                  end v0
                                              | _ => None
                                              end
                                            with
                                            | Some args2 =>
                                                match
                                                  s0 as t5
                                                  return
                                                    (Compile.value' false t5 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             base.type.Z)))
                                                with
                                                | type.base t5 =>
                                                    fun
                                                      v0 : defaults.expr
                                                             (type.base t5)
                                                    =>
                                                    base.try_make_transport_cps
                                                      (fun t6 : base.type =>
                                                       defaults.expr
                                                         (type.base t6)) t5
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               base.type.Z)))
                                                      (fun
                                                         a : option
                                                               (defaults.expr
                                                                  (type.base
                                                                    t5) ->
                                                                defaults.expr
                                                                  (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a with
                                                       | Some x' =>
                                                           match
                                                             s2 as t6
                                                             return
                                                               (Compile.value'
                                                                  false t6 ->
                                                                UnderLets.UnderLets
                                                                  base.type
                                                                  ident var
                                                                  (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                           with
                                                           | type.base t6 =>
                                                               fun
                                                                 v1 : 
                                                                  defaults.expr
                                                                    (type.base
                                                                    t6) =>
                                                               base.try_make_transport_cps
                                                                 (fun
                                                                    t7 : base.type
                                                                  =>
                                                                  defaults.expr
                                                                    (type.base
                                                                    t7)) t6
                                                                 base.type.Z
                                                                 (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                 (fun
                                                                    a0 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t6) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                  =>
                                                                  match
                                                                    a0
                                                                  with
                                                                  | Some
                                                                    x'0 =>
                                                                    if
                                                                    (args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1) &&
                                                                    (args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1)
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x' v0,
                                                                    x'0 v1))%expr_pat
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                  | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                  end)
                                                           | (s3 -> d3)%ptype =>
                                                               fun
                                                                 _ : 
                                                                  Compile.value'
                                                                    false s3 ->
                                                                  Compile.value'
                                                                    true d3
                                                               =>
                                                               UnderLets.Base
                                                                 (x * x0)%expr
                                                           end
                                                             (Compile.reflect
                                                                x4)
                                                       | None =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end)
                                                | (s3 -> d3)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s3 ->
                                                          Compile.value' true
                                                            d3 =>
                                                    UnderLets.Base
                                                      (x * x0)%expr
                                                end (Compile.reflect x2)
                                            | None =>
                                                UnderLets.Base (x * x0)%expr
                                            end
                                        | _ => UnderLets.Base (x * x0)%expr
                                        end
                                    end
                                | ($_)%expr =>
                                    match x3 with
                                    | #(idc2)%expr_pat =>
                                        match
                                          match idc2 with
                                          | @ident.Literal t5 v1 =>
                                              match
                                                t5 as t6
                                                return
                                                  (base.base_interp t6 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v2 : Z => Some v2
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v1
                                          | _ => None
                                          end
                                        with
                                        | Some args2 =>
                                            match
                                              s0 as t5
                                              return
                                                (Compile.value' false t5 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base base.type.Z)))
                                            with
                                            | type.base t5 =>
                                                fun
                                                  v1 : defaults.expr
                                                         (type.base t5) =>
                                                base.try_make_transport_cps
                                                  (fun t6 : base.type =>
                                                   defaults.expr
                                                     (type.base t6)) t5
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           base.type.Z)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t5) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       match
                                                         s2 as t6
                                                         return
                                                           (Compile.value'
                                                              false t6 ->
                                                            UnderLets.UnderLets
                                                              base.type ident
                                                              var
                                                              (defaults.expr
                                                                 (type.base
                                                                    base.type.Z)))
                                                       with
                                                       | type.base t6 =>
                                                           fun
                                                             v2 : defaults.expr
                                                                    (type.base
                                                                    t6) =>
                                                           base.try_make_transport_cps
                                                             (fun
                                                                t7 : base.type
                                                              =>
                                                              defaults.expr
                                                                (type.base t7))
                                                             t6 base.type.Z
                                                             (UnderLets.UnderLets
                                                                base.type
                                                                ident var
                                                                (defaults.expr
                                                                   (type.base
                                                                    base.type.Z)))
                                                             (fun
                                                                a0 : 
                                                                 option
                                                                   (defaults.expr
                                                                    (type.base
                                                                    t6) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                              =>
                                                              match a0 with
                                                              | Some x'0 =>
                                                                  if
                                                                   (args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1) &&
                                                                   (args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1)
                                                                  then
                                                                   UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x' v1,
                                                                    x'0 v2))%expr_pat
                                                                  else
                                                                   UnderLets.Base
                                                                    (x * x0)%expr
                                                              | None =>
                                                                  UnderLets.Base
                                                                    (x * x0)%expr
                                                              end)
                                                       | (s3 -> d3)%ptype =>
                                                           fun
                                                             _ : Compile.value'
                                                                   false s3 ->
                                                                 Compile.value'
                                                                   true d3 =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end
                                                         (Compile.reflect x4)
                                                   | None =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end)
                                            | (s3 -> d3)%ptype =>
                                                fun
                                                  _ : Compile.value' false s3 ->
                                                      Compile.value' true d3
                                                =>
                                                UnderLets.Base (x * x0)%expr
                                            end (Compile.reflect x2)
                                        | None =>
                                            UnderLets.Base (x * x0)%expr
                                        end
                                    | _ => UnderLets.Base (x * x0)%expr
                                    end
                                | @expr.LetIn _ _ _ _ _ _ _ =>
                                    match x3 with
                                    | #(idc2)%expr_pat =>
                                        match
                                          match idc2 with
                                          | @ident.Literal t4 v0 =>
                                              match
                                                t4 as t5
                                                return
                                                  (base.base_interp t5 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v1 : Z => Some v1
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v0
                                          | _ => None
                                          end
                                        with
                                        | Some args2 =>
                                            match
                                              s0 as t4
                                              return
                                                (Compile.value' false t4 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base base.type.Z)))
                                            with
                                            | type.base t4 =>
                                                fun
                                                  v0 : defaults.expr
                                                         (type.base t4) =>
                                                base.try_make_transport_cps
                                                  (fun t5 : base.type =>
                                                   defaults.expr
                                                     (type.base t5)) t4
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           base.type.Z)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t4) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       match
                                                         s2 as t5
                                                         return
                                                           (Compile.value'
                                                              false t5 ->
                                                            UnderLets.UnderLets
                                                              base.type ident
                                                              var
                                                              (defaults.expr
                                                                 (type.base
                                                                    base.type.Z)))
                                                       with
                                                       | type.base t5 =>
                                                           fun
                                                             v1 : defaults.expr
                                                                    (type.base
                                                                    t5) =>
                                                           base.try_make_transport_cps
                                                             (fun
                                                                t6 : base.type
                                                              =>
                                                              defaults.expr
                                                                (type.base t6))
                                                             t5 base.type.Z
                                                             (UnderLets.UnderLets
                                                                base.type
                                                                ident var
                                                                (defaults.expr
                                                                   (type.base
                                                                    base.type.Z)))
                                                             (fun
                                                                a0 : 
                                                                 option
                                                                   (defaults.expr
                                                                    (type.base
                                                                    t5) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                              =>
                                                              match a0 with
                                                              | Some x'0 =>
                                                                  if
                                                                   (args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1) &&
                                                                   (args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1)
                                                                  then
                                                                   UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x' v0,
                                                                    x'0 v1))%expr_pat
                                                                  else
                                                                   UnderLets.Base
                                                                    (x * x0)%expr
                                                              | None =>
                                                                  UnderLets.Base
                                                                    (x * x0)%expr
                                                              end)
                                                       | (s3 -> d3)%ptype =>
                                                           fun
                                                             _ : Compile.value'
                                                                   false s3 ->
                                                                 Compile.value'
                                                                   true d3 =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end
                                                         (Compile.reflect x4)
                                                   | None =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end)
                                            | (s3 -> d3)%ptype =>
                                                fun
                                                  _ : Compile.value' false s3 ->
                                                      Compile.value' true d3
                                                =>
                                                UnderLets.Base (x * x0)%expr
                                            end (Compile.reflect x2)
                                        | None =>
                                            UnderLets.Base (x * x0)%expr
                                        end
                                    | _ => UnderLets.Base (x * x0)%expr
                                    end
                                | _ =>
                                    match x3 with
                                    | #(idc2)%expr_pat =>
                                        match
                                          match idc2 with
                                          | @ident.Literal t4 v0 =>
                                              match
                                                t4 as t5
                                                return
                                                  (base.base_interp t5 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v1 : Z => Some v1
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v0
                                          | _ => None
                                          end
                                        with
                                        | Some args2 =>
                                            match
                                              s0 as t4
                                              return
                                                (Compile.value' false t4 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base base.type.Z)))
                                            with
                                            | type.base t4 =>
                                                fun
                                                  v0 : defaults.expr
                                                         (type.base t4) =>
                                                base.try_make_transport_cps
                                                  (fun t5 : base.type =>
                                                   defaults.expr
                                                     (type.base t5)) t4
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           base.type.Z)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t4) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       match
                                                         s2 as t5
                                                         return
                                                           (Compile.value'
                                                              false t5 ->
                                                            UnderLets.UnderLets
                                                              base.type ident
                                                              var
                                                              (defaults.expr
                                                                 (type.base
                                                                    base.type.Z)))
                                                       with
                                                       | type.base t5 =>
                                                           fun
                                                             v1 : defaults.expr
                                                                    (type.base
                                                                    t5) =>
                                                           base.try_make_transport_cps
                                                             (fun
                                                                t6 : base.type
                                                              =>
                                                              defaults.expr
                                                                (type.base t6))
                                                             t5 base.type.Z
                                                             (UnderLets.UnderLets
                                                                base.type
                                                                ident var
                                                                (defaults.expr
                                                                   (type.base
                                                                    base.type.Z)))
                                                             (fun
                                                                a0 : 
                                                                 option
                                                                   (defaults.expr
                                                                    (type.base
                                                                    t5) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                              =>
                                                              match a0 with
                                                              | Some x'0 =>
                                                                  if
                                                                   (args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1) &&
                                                                   (args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1)
                                                                  then
                                                                   UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x' v0,
                                                                    x'0 v1))%expr_pat
                                                                  else
                                                                   UnderLets.Base
                                                                    (x * x0)%expr
                                                              | None =>
                                                                  UnderLets.Base
                                                                    (x * x0)%expr
                                                              end)
                                                       | (s4 -> d4)%ptype =>
                                                           fun
                                                             _ : Compile.value'
                                                                   false s4 ->
                                                                 Compile.value'
                                                                   true d4 =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end
                                                         (Compile.reflect x4)
                                                   | None =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end)
                                            | (s4 -> d4)%ptype =>
                                                fun
                                                  _ : Compile.value' false s4 ->
                                                      Compile.value' true d4
                                                =>
                                                UnderLets.Base (x * x0)%expr
                                            end (Compile.reflect x2)
                                        | None =>
                                            UnderLets.Base (x * x0)%expr
                                        end
                                    | _ => UnderLets.Base (x * x0)%expr
                                    end
                                end
                            | None =>
                                match
                                  match idc1 with
                                  | ident.Z_shiftr => Some tt
                                  | _ => None
                                  end
                                with
                                | Some _ =>
                                    match x3 with
                                    | #(idc2)%expr_pat =>
                                        match
                                          match idc2 with
                                          | @ident.Literal t4 v0 =>
                                              match
                                                t4 as t5
                                                return
                                                  (base.base_interp t5 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v1 : Z => Some v1
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v0
                                          | _ => None
                                          end
                                        with
                                        | Some args2 =>
                                            match
                                              s0 as t4
                                              return
                                                (Compile.value' false t4 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base base.type.Z)))
                                            with
                                            | type.base t4 =>
                                                fun
                                                  v0 : defaults.expr
                                                         (type.base t4) =>
                                                base.try_make_transport_cps
                                                  (fun t5 : base.type =>
                                                   defaults.expr
                                                     (type.base t5)) t4
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           base.type.Z)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t4) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       match
                                                         s2 as t5
                                                         return
                                                           (Compile.value'
                                                              false t5 ->
                                                            UnderLets.UnderLets
                                                              base.type ident
                                                              var
                                                              (defaults.expr
                                                                 (type.base
                                                                    base.type.Z)))
                                                       with
                                                       | type.base t5 =>
                                                           fun
                                                             v1 : defaults.expr
                                                                    (type.base
                                                                    t5) =>
                                                           base.try_make_transport_cps
                                                             (fun
                                                                t6 : base.type
                                                              =>
                                                              defaults.expr
                                                                (type.base t6))
                                                             t5 base.type.Z
                                                             (UnderLets.UnderLets
                                                                base.type
                                                                ident var
                                                                (defaults.expr
                                                                   (type.base
                                                                    base.type.Z)))
                                                             (fun
                                                                a0 : 
                                                                 option
                                                                   (defaults.expr
                                                                    (type.base
                                                                    t5) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                              =>
                                                              match a0 with
                                                              | Some x'0 =>
                                                                  if
                                                                   args0 =?
                                                                   2
                                                                   ^ 
                                                                   (2 * args2 /
                                                                    2) - 1
                                                                  then
                                                                   UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mullh
                                                                    (2 *
                                                                    args2))%expr @
                                                                    (
                                                                    x' v0,
                                                                    x'0 v1))%expr_pat
                                                                  else
                                                                   UnderLets.Base
                                                                    (x * x0)%expr
                                                              | None =>
                                                                  UnderLets.Base
                                                                    (x * x0)%expr
                                                              end)
                                                       | (s3 -> d3)%ptype =>
                                                           fun
                                                             _ : Compile.value'
                                                                   false s3 ->
                                                                 Compile.value'
                                                                   true d3 =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end
                                                         (Compile.reflect x4)
                                                   | None =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end)
                                            | (s3 -> d3)%ptype =>
                                                fun
                                                  _ : Compile.value' false s3 ->
                                                      Compile.value' true d3
                                                =>
                                                UnderLets.Base (x * x0)%expr
                                            end (Compile.reflect x2)
                                        | None =>
                                            UnderLets.Base (x * x0)%expr
                                        end
                                    | _ => UnderLets.Base (x * x0)%expr
                                    end
                                | None => UnderLets.Base (x * x0)%expr
                                end
                            end
                        | @expr.App _ _ _ s1 _
                          (@expr.App _ _ _ s2 _ ($_)%expr _) _ | @expr.App _
                          _ _ s1 _
                          (@expr.App _ _ _ s2 _ (@expr.Abs _ _ _ _ _ _) _)
                          _ | @expr.App _ _ _ s1 _
                          (@expr.App _ _ _ s2 _ (_ @ _)%expr_pat _) _ |
                          @expr.App _ _ _ s1 _
                          (@expr.App _ _ _ s2 _ (@expr.LetIn _ _ _ _ _ _ _)
                           _) _ => UnderLets.Base (x * x0)%expr
                        | @expr.App _ _ _ s1 _ #(_)%expr_pat _ | @expr.App _
                          _ _ s1 _ ($_)%expr _ | @expr.App _ _ _ s1 _
                          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s1 _
                          (@expr.LetIn _ _ _ _ _ _ _) _ =>
                            UnderLets.Base (x * x0)%expr
                        | _ => UnderLets.Base (x * x0)%expr
                        end
                    | None => UnderLets.Base (x * x0)%expr
                    end
                | _ => UnderLets.Base (x * x0)%expr
                end
            | @expr.Abs _ _ _ _ _ _ =>
                match x1 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t1 v =>
                          match
                            t1 as t2 return (base.base_interp t2 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v0 : Z => Some v0
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        match x0 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t2 v =>
                                  match
                                    t2 as t3
                                    return (base.base_interp t3 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v0 : Z => Some v0
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                match
                                  s0 as t2
                                  return
                                    (Compile.value' false t2 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr (type.base base.type.Z)))
                                with
                                | type.base t2 =>
                                    fun v : defaults.expr (type.base t2) =>
                                    base.try_make_transport_cps
                                      (fun t3 : base.type =>
                                       defaults.expr (type.base t3)) t2
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base base.type.Z)))
                                      (fun
                                         a : option
                                               (defaults.expr (type.base t2) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                       match a with
                                       | Some x' =>
                                           if
                                            args0 =?
                                            2 ^ (2 * Z.log2_up args0 / 2) - 1
                                           then
                                            match
                                              invert_low
                                                (2 * Z.log2_up args0) args1
                                            with
                                            | Some y =>
                                                UnderLets.Base
                                                  (#(ident.fancy_mulll
                                                       (2 * Z.log2_up args0))%expr @
                                                   (x' v, ##(y)%expr))%expr_pat
                                            | None =>
                                                match
                                                  s0 as t3
                                                  return
                                                    (Compile.value' false t3 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             base.type.Z)))
                                                with
                                                | type.base t3 =>
                                                    fun
                                                      v0 : defaults.expr
                                                             (type.base t3)
                                                    =>
                                                    base.try_make_transport_cps
                                                      (fun t4 : base.type =>
                                                       defaults.expr
                                                         (type.base t4)) t3
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               base.type.Z)))
                                                      (fun
                                                         a0 : option
                                                                (defaults.expr
                                                                   (type.base
                                                                    t3) ->
                                                                 defaults.expr
                                                                   (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a0 with
                                                       | Some x'0 =>
                                                           if
                                                            args0 =?
                                                            2
                                                            ^ (2 *
                                                               Z.log2_up
                                                                 args0 / 2) -
                                                            1
                                                           then
                                                            match
                                                              invert_high
                                                                (2 *
                                                                 Z.log2_up
                                                                   args0)
                                                                args1
                                                            with
                                                            | Some y =>
                                                                UnderLets.Base
                                                                  (#(ident.fancy_mullh
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                   (x'0 v0,
                                                                   ##
                                                                   (y)%expr))%expr_pat
                                                            | None =>
                                                                UnderLets.Base
                                                                  (x * x0)%expr
                                                            end
                                                           else
                                                            UnderLets.Base
                                                              (x * x0)%expr
                                                       | None =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end)
                                                | (s2 -> d2)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s2 ->
                                                          Compile.value' true
                                                            d2 =>
                                                    UnderLets.Base
                                                      (x * x0)%expr
                                                end (Compile.reflect x2)
                                            end
                                           else
                                            match
                                              s0 as t3
                                              return
                                                (Compile.value' false t3 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base base.type.Z)))
                                            with
                                            | type.base t3 =>
                                                fun
                                                  v0 : defaults.expr
                                                         (type.base t3) =>
                                                base.try_make_transport_cps
                                                  (fun t4 : base.type =>
                                                   defaults.expr
                                                     (type.base t4)) t3
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           base.type.Z)))
                                                  (fun
                                                     a0 : option
                                                            (defaults.expr
                                                               (type.base t3) ->
                                                             defaults.expr
                                                               (type.base
                                                                  base.type.Z))
                                                   =>
                                                   match a0 with
                                                   | Some x'0 =>
                                                       if
                                                        args0 =?
                                                        2
                                                        ^ (2 *
                                                           Z.log2_up args0 /
                                                           2) - 1
                                                       then
                                                        match
                                                          invert_high
                                                            (2 *
                                                             Z.log2_up args0)
                                                            args1
                                                        with
                                                        | Some y =>
                                                            UnderLets.Base
                                                              (#(ident.fancy_mullh
                                                                   (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                               (x'0 v0,
                                                               ##(y)%expr))%expr_pat
                                                        | None =>
                                                            UnderLets.Base
                                                              (x * x0)%expr
                                                        end
                                                       else
                                                        UnderLets.Base
                                                          (x * x0)%expr
                                                   | None =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end)
                                            | (s2 -> d2)%ptype =>
                                                fun
                                                  _ : Compile.value' false s2 ->
                                                      Compile.value' true d2
                                                =>
                                                UnderLets.Base (x * x0)%expr
                                            end (Compile.reflect x2)
                                       | None => UnderLets.Base (x * x0)%expr
                                       end)
                                | (s2 -> d2)%ptype =>
                                    fun
                                      _ : Compile.value' false s2 ->
                                          Compile.value' true d2 =>
                                    UnderLets.Base (x * x0)%expr
                                end (Compile.reflect x2)
                            | None => UnderLets.Base (x * x0)%expr
                            end
                        | @expr.App _ _ _ s2 _
                          (@expr.App _ _ _ s3 _ #(idc1)%expr_pat x4) x3 =>
                            match
                              match idc1 with
                              | ident.Z_land => Some tt
                              | _ => None
                              end
                            with
                            | Some _ =>
                                match x4 with
                                | #(idc2)%expr_pat =>
                                    match
                                      match idc2 with
                                      | @ident.Literal t3 v =>
                                          match
                                            t3 as t4
                                            return
                                              (base.base_interp t4 ->
                                               option Z)
                                          with
                                          | base.type.unit =>
                                              fun _ : unit => None
                                          | base.type.Z =>
                                              fun v0 : Z => Some v0
                                          | base.type.bool =>
                                              fun _ : bool => None
                                          | base.type.nat =>
                                              fun _ : nat => None
                                          end v
                                      | _ => None
                                      end
                                    with
                                    | Some args2 =>
                                        match
                                          s0 as t3
                                          return
                                            (Compile.value' false t3 ->
                                             UnderLets.UnderLets base.type
                                               ident var
                                               (defaults.expr
                                                  (type.base base.type.Z)))
                                        with
                                        | type.base t3 =>
                                            fun
                                              v : defaults.expr
                                                    (type.base t3) =>
                                            base.try_make_transport_cps
                                              (fun t4 : base.type =>
                                               defaults.expr (type.base t4))
                                              t3 base.type.Z
                                              (UnderLets.UnderLets base.type
                                                 ident var
                                                 (defaults.expr
                                                    (type.base base.type.Z)))
                                              (fun
                                                 a : option
                                                       (defaults.expr
                                                          (type.base t3) ->
                                                        defaults.expr
                                                          (type.base
                                                             base.type.Z)) =>
                                               match a with
                                               | Some x' =>
                                                   match
                                                     s2 as t4
                                                     return
                                                       (Compile.value' false
                                                          t4 ->
                                                        UnderLets.UnderLets
                                                          base.type ident var
                                                          (defaults.expr
                                                             (type.base
                                                                base.type.Z)))
                                                   with
                                                   | type.base t4 =>
                                                       fun
                                                         v0 : defaults.expr
                                                                (type.base t4)
                                                       =>
                                                       base.try_make_transport_cps
                                                         (fun t5 : base.type
                                                          =>
                                                          defaults.expr
                                                            (type.base t5))
                                                         t4 base.type.Z
                                                         (UnderLets.UnderLets
                                                            base.type ident
                                                            var
                                                            (defaults.expr
                                                               (type.base
                                                                  base.type.Z)))
                                                         (fun
                                                            a0 : option
                                                                   (defaults.expr
                                                                    (type.base
                                                                    t4) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                          =>
                                                          match a0 with
                                                          | Some x'0 =>
                                                              if
                                                               (args0 =?
                                                                2
                                                                ^ (2 *
                                                                   Z.log2_up
                                                                    args0 / 2) -
                                                                1) &&
                                                               (args2 =?
                                                                2
                                                                ^ (2 *
                                                                   Z.log2_up
                                                                    args0 / 2) -
                                                                1)
                                                              then
                                                               UnderLets.Base
                                                                 (#(ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                  (x' v,
                                                                  x'0 v0))%expr_pat
                                                              else
                                                               match x3 with
                                                               | #(idc3)%expr_pat =>
                                                                   match
                                                                    match
                                                                    idc3
                                                                    with
                                                                    | @ident.Literal
                                                                    t6 v1 =>
                                                                    match
                                                                    t6 as t7
                                                                    return
                                                                    (base.base_interp
                                                                    t7 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v2 : Z =>
                                                                    Some v2
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v1
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                   with
                                                                   | Some
                                                                    args3 =>
                                                                    match
                                                                    s0 as t6
                                                                    return
                                                                    (Compile.value'
                                                                    false t6 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t6 =>
                                                                    fun
                                                                    v1 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t6) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t7 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7)) t6
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a1 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t6) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a1
                                                                    with
                                                                    | Some
                                                                    x'1 =>
                                                                    match
                                                                    s3 as t7
                                                                    return
                                                                    (Compile.value'
                                                                    false t7 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t7 =>
                                                                    fun
                                                                    v2 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t8 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t8)) t7
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a2 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t7) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a2
                                                                    with
                                                                    | Some
                                                                    x'2 =>
                                                                    if
                                                                    (args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1) &&
                                                                    (args3 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1)
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x'1 v1,
                                                                    x'2 v2))%expr_pat
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s4 ->
                                                                    d4)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s4 ->
                                                                    Compile.value'
                                                                    true d4
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x4)
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s4 ->
                                                                    d4)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s4 ->
                                                                    Compile.value'
                                                                    true d4
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x2)
                                                                   | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                   end
                                                               | _ =>
                                                                   UnderLets.Base
                                                                    (x * x0)%expr
                                                               end
                                                          | None =>
                                                              UnderLets.Base
                                                                (x * x0)%expr
                                                          end)
                                                   | (s4 -> d4)%ptype =>
                                                       fun
                                                         _ : Compile.value'
                                                               false s4 ->
                                                             Compile.value'
                                                               true d4 =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end (Compile.reflect x3)
                                               | None =>
                                                   UnderLets.Base
                                                     (x * x0)%expr
                                               end)
                                        | (s4 -> d4)%ptype =>
                                            fun
                                              _ : Compile.value' false s4 ->
                                                  Compile.value' true d4 =>
                                            UnderLets.Base (x * x0)%expr
                                        end (Compile.reflect x2)
                                    | None =>
                                        match x3 with
                                        | #(idc3)%expr_pat =>
                                            match
                                              match idc3 with
                                              | @ident.Literal t4 v =>
                                                  match
                                                    t4 as t5
                                                    return
                                                      (base.base_interp t5 ->
                                                       option Z)
                                                  with
                                                  | base.type.unit =>
                                                      fun _ : unit => None
                                                  | base.type.Z =>
                                                      fun v0 : Z => Some v0
                                                  | base.type.bool =>
                                                      fun _ : bool => None
                                                  | base.type.nat =>
                                                      fun _ : nat => None
                                                  end v
                                              | _ => None
                                              end
                                            with
                                            | Some args2 =>
                                                match
                                                  s0 as t4
                                                  return
                                                    (Compile.value' false t4 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             base.type.Z)))
                                                with
                                                | type.base t4 =>
                                                    fun
                                                      v : defaults.expr
                                                            (type.base t4) =>
                                                    base.try_make_transport_cps
                                                      (fun t5 : base.type =>
                                                       defaults.expr
                                                         (type.base t5)) t4
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               base.type.Z)))
                                                      (fun
                                                         a : option
                                                               (defaults.expr
                                                                  (type.base
                                                                    t4) ->
                                                                defaults.expr
                                                                  (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a with
                                                       | Some x' =>
                                                           match
                                                             s3 as t5
                                                             return
                                                               (Compile.value'
                                                                  false t5 ->
                                                                UnderLets.UnderLets
                                                                  base.type
                                                                  ident var
                                                                  (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                           with
                                                           | type.base t5 =>
                                                               fun
                                                                 v0 : 
                                                                  defaults.expr
                                                                    (type.base
                                                                    t5) =>
                                                               base.try_make_transport_cps
                                                                 (fun
                                                                    t6 : base.type
                                                                  =>
                                                                  defaults.expr
                                                                    (type.base
                                                                    t6)) t5
                                                                 base.type.Z
                                                                 (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                 (fun
                                                                    a0 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t5) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                  =>
                                                                  match
                                                                    a0
                                                                  with
                                                                  | Some
                                                                    x'0 =>
                                                                    if
                                                                    (args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1) &&
                                                                    (args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1)
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x' v,
                                                                    x'0 v0))%expr_pat
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                  | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                  end)
                                                           | (s4 -> d4)%ptype =>
                                                               fun
                                                                 _ : 
                                                                  Compile.value'
                                                                    false s4 ->
                                                                  Compile.value'
                                                                    true d4
                                                               =>
                                                               UnderLets.Base
                                                                 (x * x0)%expr
                                                           end
                                                             (Compile.reflect
                                                                x4)
                                                       | None =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end)
                                                | (s4 -> d4)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s4 ->
                                                          Compile.value' true
                                                            d4 =>
                                                    UnderLets.Base
                                                      (x * x0)%expr
                                                end (Compile.reflect x2)
                                            | None =>
                                                UnderLets.Base (x * x0)%expr
                                            end
                                        | _ => UnderLets.Base (x * x0)%expr
                                        end
                                    end
                                | ($_)%expr =>
                                    match x3 with
                                    | #(idc2)%expr_pat =>
                                        match
                                          match idc2 with
                                          | @ident.Literal t4 v0 =>
                                              match
                                                t4 as t5
                                                return
                                                  (base.base_interp t5 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v1 : Z => Some v1
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v0
                                          | _ => None
                                          end
                                        with
                                        | Some args2 =>
                                            match
                                              s0 as t4
                                              return
                                                (Compile.value' false t4 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base base.type.Z)))
                                            with
                                            | type.base t4 =>
                                                fun
                                                  v0 : defaults.expr
                                                         (type.base t4) =>
                                                base.try_make_transport_cps
                                                  (fun t5 : base.type =>
                                                   defaults.expr
                                                     (type.base t5)) t4
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           base.type.Z)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t4) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       match
                                                         s3 as t5
                                                         return
                                                           (Compile.value'
                                                              false t5 ->
                                                            UnderLets.UnderLets
                                                              base.type ident
                                                              var
                                                              (defaults.expr
                                                                 (type.base
                                                                    base.type.Z)))
                                                       with
                                                       | type.base t5 =>
                                                           fun
                                                             v1 : defaults.expr
                                                                    (type.base
                                                                    t5) =>
                                                           base.try_make_transport_cps
                                                             (fun
                                                                t6 : base.type
                                                              =>
                                                              defaults.expr
                                                                (type.base t6))
                                                             t5 base.type.Z
                                                             (UnderLets.UnderLets
                                                                base.type
                                                                ident var
                                                                (defaults.expr
                                                                   (type.base
                                                                    base.type.Z)))
                                                             (fun
                                                                a0 : 
                                                                 option
                                                                   (defaults.expr
                                                                    (type.base
                                                                    t5) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                              =>
                                                              match a0 with
                                                              | Some x'0 =>
                                                                  if
                                                                   (args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1) &&
                                                                   (args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1)
                                                                  then
                                                                   UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x' v0,
                                                                    x'0 v1))%expr_pat
                                                                  else
                                                                   UnderLets.Base
                                                                    (x * x0)%expr
                                                              | None =>
                                                                  UnderLets.Base
                                                                    (x * x0)%expr
                                                              end)
                                                       | (s4 -> d4)%ptype =>
                                                           fun
                                                             _ : Compile.value'
                                                                   false s4 ->
                                                                 Compile.value'
                                                                   true d4 =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end
                                                         (Compile.reflect x4)
                                                   | None =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end)
                                            | (s4 -> d4)%ptype =>
                                                fun
                                                  _ : Compile.value' false s4 ->
                                                      Compile.value' true d4
                                                =>
                                                UnderLets.Base (x * x0)%expr
                                            end (Compile.reflect x2)
                                        | None =>
                                            UnderLets.Base (x * x0)%expr
                                        end
                                    | _ => UnderLets.Base (x * x0)%expr
                                    end
                                | @expr.LetIn _ _ _ _ _ _ _ =>
                                    match x3 with
                                    | #(idc2)%expr_pat =>
                                        match
                                          match idc2 with
                                          | @ident.Literal t3 v =>
                                              match
                                                t3 as t4
                                                return
                                                  (base.base_interp t4 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v0 : Z => Some v0
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v
                                          | _ => None
                                          end
                                        with
                                        | Some args2 =>
                                            match
                                              s0 as t3
                                              return
                                                (Compile.value' false t3 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base base.type.Z)))
                                            with
                                            | type.base t3 =>
                                                fun
                                                  v : defaults.expr
                                                        (type.base t3) =>
                                                base.try_make_transport_cps
                                                  (fun t4 : base.type =>
                                                   defaults.expr
                                                     (type.base t4)) t3
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           base.type.Z)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t3) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       match
                                                         s3 as t4
                                                         return
                                                           (Compile.value'
                                                              false t4 ->
                                                            UnderLets.UnderLets
                                                              base.type ident
                                                              var
                                                              (defaults.expr
                                                                 (type.base
                                                                    base.type.Z)))
                                                       with
                                                       | type.base t4 =>
                                                           fun
                                                             v0 : defaults.expr
                                                                    (type.base
                                                                    t4) =>
                                                           base.try_make_transport_cps
                                                             (fun
                                                                t5 : base.type
                                                              =>
                                                              defaults.expr
                                                                (type.base t5))
                                                             t4 base.type.Z
                                                             (UnderLets.UnderLets
                                                                base.type
                                                                ident var
                                                                (defaults.expr
                                                                   (type.base
                                                                    base.type.Z)))
                                                             (fun
                                                                a0 : 
                                                                 option
                                                                   (defaults.expr
                                                                    (type.base
                                                                    t4) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                              =>
                                                              match a0 with
                                                              | Some x'0 =>
                                                                  if
                                                                   (args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1) &&
                                                                   (args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1)
                                                                  then
                                                                   UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x' v,
                                                                    x'0 v0))%expr_pat
                                                                  else
                                                                   UnderLets.Base
                                                                    (x * x0)%expr
                                                              | None =>
                                                                  UnderLets.Base
                                                                    (x * x0)%expr
                                                              end)
                                                       | (s4 -> d4)%ptype =>
                                                           fun
                                                             _ : Compile.value'
                                                                   false s4 ->
                                                                 Compile.value'
                                                                   true d4 =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end
                                                         (Compile.reflect x4)
                                                   | None =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end)
                                            | (s4 -> d4)%ptype =>
                                                fun
                                                  _ : Compile.value' false s4 ->
                                                      Compile.value' true d4
                                                =>
                                                UnderLets.Base (x * x0)%expr
                                            end (Compile.reflect x2)
                                        | None =>
                                            UnderLets.Base (x * x0)%expr
                                        end
                                    | _ => UnderLets.Base (x * x0)%expr
                                    end
                                | _ =>
                                    match x3 with
                                    | #(idc2)%expr_pat =>
                                        match
                                          match idc2 with
                                          | @ident.Literal t3 v =>
                                              match
                                                t3 as t4
                                                return
                                                  (base.base_interp t4 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v0 : Z => Some v0
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v
                                          | _ => None
                                          end
                                        with
                                        | Some args2 =>
                                            match
                                              s0 as t3
                                              return
                                                (Compile.value' false t3 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base base.type.Z)))
                                            with
                                            | type.base t3 =>
                                                fun
                                                  v : defaults.expr
                                                        (type.base t3) =>
                                                base.try_make_transport_cps
                                                  (fun t4 : base.type =>
                                                   defaults.expr
                                                     (type.base t4)) t3
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           base.type.Z)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t3) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       match
                                                         s3 as t4
                                                         return
                                                           (Compile.value'
                                                              false t4 ->
                                                            UnderLets.UnderLets
                                                              base.type ident
                                                              var
                                                              (defaults.expr
                                                                 (type.base
                                                                    base.type.Z)))
                                                       with
                                                       | type.base t4 =>
                                                           fun
                                                             v0 : defaults.expr
                                                                    (type.base
                                                                    t4) =>
                                                           base.try_make_transport_cps
                                                             (fun
                                                                t5 : base.type
                                                              =>
                                                              defaults.expr
                                                                (type.base t5))
                                                             t4 base.type.Z
                                                             (UnderLets.UnderLets
                                                                base.type
                                                                ident var
                                                                (defaults.expr
                                                                   (type.base
                                                                    base.type.Z)))
                                                             (fun
                                                                a0 : 
                                                                 option
                                                                   (defaults.expr
                                                                    (type.base
                                                                    t4) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                              =>
                                                              match a0 with
                                                              | Some x'0 =>
                                                                  if
                                                                   (args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1) &&
                                                                   (args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1)
                                                                  then
                                                                   UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x' v,
                                                                    x'0 v0))%expr_pat
                                                                  else
                                                                   UnderLets.Base
                                                                    (x * x0)%expr
                                                              | None =>
                                                                  UnderLets.Base
                                                                    (x * x0)%expr
                                                              end)
                                                       | (s5 -> d5)%ptype =>
                                                           fun
                                                             _ : Compile.value'
                                                                   false s5 ->
                                                                 Compile.value'
                                                                   true d5 =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end
                                                         (Compile.reflect x4)
                                                   | None =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end)
                                            | (s5 -> d5)%ptype =>
                                                fun
                                                  _ : Compile.value' false s5 ->
                                                      Compile.value' true d5
                                                =>
                                                UnderLets.Base (x * x0)%expr
                                            end (Compile.reflect x2)
                                        | None =>
                                            UnderLets.Base (x * x0)%expr
                                        end
                                    | _ => UnderLets.Base (x * x0)%expr
                                    end
                                end
                            | None =>
                                match
                                  match idc1 with
                                  | ident.Z_shiftr => Some tt
                                  | _ => None
                                  end
                                with
                                | Some _ =>
                                    match x3 with
                                    | #(idc2)%expr_pat =>
                                        match
                                          match idc2 with
                                          | @ident.Literal t3 v =>
                                              match
                                                t3 as t4
                                                return
                                                  (base.base_interp t4 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v0 : Z => Some v0
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v
                                          | _ => None
                                          end
                                        with
                                        | Some args2 =>
                                            match
                                              s0 as t3
                                              return
                                                (Compile.value' false t3 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base base.type.Z)))
                                            with
                                            | type.base t3 =>
                                                fun
                                                  v : defaults.expr
                                                        (type.base t3) =>
                                                base.try_make_transport_cps
                                                  (fun t4 : base.type =>
                                                   defaults.expr
                                                     (type.base t4)) t3
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           base.type.Z)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t3) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       match
                                                         s3 as t4
                                                         return
                                                           (Compile.value'
                                                              false t4 ->
                                                            UnderLets.UnderLets
                                                              base.type ident
                                                              var
                                                              (defaults.expr
                                                                 (type.base
                                                                    base.type.Z)))
                                                       with
                                                       | type.base t4 =>
                                                           fun
                                                             v0 : defaults.expr
                                                                    (type.base
                                                                    t4) =>
                                                           base.try_make_transport_cps
                                                             (fun
                                                                t5 : base.type
                                                              =>
                                                              defaults.expr
                                                                (type.base t5))
                                                             t4 base.type.Z
                                                             (UnderLets.UnderLets
                                                                base.type
                                                                ident var
                                                                (defaults.expr
                                                                   (type.base
                                                                    base.type.Z)))
                                                             (fun
                                                                a0 : 
                                                                 option
                                                                   (defaults.expr
                                                                    (type.base
                                                                    t4) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                              =>
                                                              match a0 with
                                                              | Some x'0 =>
                                                                  if
                                                                   args0 =?
                                                                   2
                                                                   ^ 
                                                                   (2 * args2 /
                                                                    2) - 1
                                                                  then
                                                                   UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mullh
                                                                    (2 *
                                                                    args2))%expr @
                                                                    (
                                                                    x' v,
                                                                    x'0 v0))%expr_pat
                                                                  else
                                                                   UnderLets.Base
                                                                    (x * x0)%expr
                                                              | None =>
                                                                  UnderLets.Base
                                                                    (x * x0)%expr
                                                              end)
                                                       | (s4 -> d4)%ptype =>
                                                           fun
                                                             _ : Compile.value'
                                                                   false s4 ->
                                                                 Compile.value'
                                                                   true d4 =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end
                                                         (Compile.reflect x4)
                                                   | None =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end)
                                            | (s4 -> d4)%ptype =>
                                                fun
                                                  _ : Compile.value' false s4 ->
                                                      Compile.value' true d4
                                                =>
                                                UnderLets.Base (x * x0)%expr
                                            end (Compile.reflect x2)
                                        | None =>
                                            UnderLets.Base (x * x0)%expr
                                        end
                                    | _ => UnderLets.Base (x * x0)%expr
                                    end
                                | None => UnderLets.Base (x * x0)%expr
                                end
                            end
                        | @expr.App _ _ _ s2 _
                          (@expr.App _ _ _ s3 _ ($_)%expr _) _ | @expr.App _
                          _ _ s2 _
                          (@expr.App _ _ _ s3 _ (@expr.Abs _ _ _ _ _ _) _)
                          _ | @expr.App _ _ _ s2 _
                          (@expr.App _ _ _ s3 _ (_ @ _)%expr_pat _) _ |
                          @expr.App _ _ _ s2 _
                          (@expr.App _ _ _ s3 _ (@expr.LetIn _ _ _ _ _ _ _)
                           _) _ => UnderLets.Base (x * x0)%expr
                        | @expr.App _ _ _ s2 _ #(_)%expr_pat _ | @expr.App _
                          _ _ s2 _ ($_)%expr _ | @expr.App _ _ _ s2 _
                          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s2 _
                          (@expr.LetIn _ _ _ _ _ _ _) _ =>
                            UnderLets.Base (x * x0)%expr
                        | _ => UnderLets.Base (x * x0)%expr
                        end
                    | None => UnderLets.Base (x * x0)%expr
                    end
                | _ => UnderLets.Base (x * x0)%expr
                end
            | (_ @ _)%expr_pat =>
                match x1 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t1 v =>
                          match
                            t1 as t2 return (base.base_interp t2 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v0 : Z => Some v0
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        match x0 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t2 v =>
                                  match
                                    t2 as t3
                                    return (base.base_interp t3 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v0 : Z => Some v0
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                match
                                  s0 as t2
                                  return
                                    (Compile.value' false t2 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr (type.base base.type.Z)))
                                with
                                | type.base t2 =>
                                    fun v : defaults.expr (type.base t2) =>
                                    base.try_make_transport_cps
                                      (fun t3 : base.type =>
                                       defaults.expr (type.base t3)) t2
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base base.type.Z)))
                                      (fun
                                         a : option
                                               (defaults.expr (type.base t2) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                       match a with
                                       | Some x' =>
                                           if
                                            args0 =?
                                            2 ^ (2 * Z.log2_up args0 / 2) - 1
                                           then
                                            match
                                              invert_low
                                                (2 * Z.log2_up args0) args1
                                            with
                                            | Some y =>
                                                UnderLets.Base
                                                  (#(ident.fancy_mulll
                                                       (2 * Z.log2_up args0))%expr @
                                                   (x' v, ##(y)%expr))%expr_pat
                                            | None =>
                                                match
                                                  s0 as t3
                                                  return
                                                    (Compile.value' false t3 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             base.type.Z)))
                                                with
                                                | type.base t3 =>
                                                    fun
                                                      v0 : defaults.expr
                                                             (type.base t3)
                                                    =>
                                                    base.try_make_transport_cps
                                                      (fun t4 : base.type =>
                                                       defaults.expr
                                                         (type.base t4)) t3
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               base.type.Z)))
                                                      (fun
                                                         a0 : option
                                                                (defaults.expr
                                                                   (type.base
                                                                    t3) ->
                                                                 defaults.expr
                                                                   (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a0 with
                                                       | Some x'0 =>
                                                           if
                                                            args0 =?
                                                            2
                                                            ^ (2 *
                                                               Z.log2_up
                                                                 args0 / 2) -
                                                            1
                                                           then
                                                            match
                                                              invert_high
                                                                (2 *
                                                                 Z.log2_up
                                                                   args0)
                                                                args1
                                                            with
                                                            | Some y =>
                                                                UnderLets.Base
                                                                  (#(ident.fancy_mullh
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                   (x'0 v0,
                                                                   ##
                                                                   (y)%expr))%expr_pat
                                                            | None =>
                                                                UnderLets.Base
                                                                  (x * x0)%expr
                                                            end
                                                           else
                                                            UnderLets.Base
                                                              (x * x0)%expr
                                                       | None =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end)
                                                | (s2 -> d2)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s2 ->
                                                          Compile.value' true
                                                            d2 =>
                                                    UnderLets.Base
                                                      (x * x0)%expr
                                                end (Compile.reflect x2)
                                            end
                                           else
                                            match
                                              s0 as t3
                                              return
                                                (Compile.value' false t3 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base base.type.Z)))
                                            with
                                            | type.base t3 =>
                                                fun
                                                  v0 : defaults.expr
                                                         (type.base t3) =>
                                                base.try_make_transport_cps
                                                  (fun t4 : base.type =>
                                                   defaults.expr
                                                     (type.base t4)) t3
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           base.type.Z)))
                                                  (fun
                                                     a0 : option
                                                            (defaults.expr
                                                               (type.base t3) ->
                                                             defaults.expr
                                                               (type.base
                                                                  base.type.Z))
                                                   =>
                                                   match a0 with
                                                   | Some x'0 =>
                                                       if
                                                        args0 =?
                                                        2
                                                        ^ (2 *
                                                           Z.log2_up args0 /
                                                           2) - 1
                                                       then
                                                        match
                                                          invert_high
                                                            (2 *
                                                             Z.log2_up args0)
                                                            args1
                                                        with
                                                        | Some y =>
                                                            UnderLets.Base
                                                              (#(ident.fancy_mullh
                                                                   (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                               (x'0 v0,
                                                               ##(y)%expr))%expr_pat
                                                        | None =>
                                                            UnderLets.Base
                                                              (x * x0)%expr
                                                        end
                                                       else
                                                        UnderLets.Base
                                                          (x * x0)%expr
                                                   | None =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end)
                                            | (s2 -> d2)%ptype =>
                                                fun
                                                  _ : Compile.value' false s2 ->
                                                      Compile.value' true d2
                                                =>
                                                UnderLets.Base (x * x0)%expr
                                            end (Compile.reflect x2)
                                       | None => UnderLets.Base (x * x0)%expr
                                       end)
                                | (s2 -> d2)%ptype =>
                                    fun
                                      _ : Compile.value' false s2 ->
                                          Compile.value' true d2 =>
                                    UnderLets.Base (x * x0)%expr
                                end (Compile.reflect x2)
                            | None => UnderLets.Base (x * x0)%expr
                            end
                        | @expr.App _ _ _ s2 _
                          (@expr.App _ _ _ s3 _ #(idc1)%expr_pat x5) x4 =>
                            match
                              match idc1 with
                              | ident.Z_land => Some tt
                              | _ => None
                              end
                            with
                            | Some _ =>
                                match x5 with
                                | #(idc2)%expr_pat =>
                                    match
                                      match idc2 with
                                      | @ident.Literal t3 v =>
                                          match
                                            t3 as t4
                                            return
                                              (base.base_interp t4 ->
                                               option Z)
                                          with
                                          | base.type.unit =>
                                              fun _ : unit => None
                                          | base.type.Z =>
                                              fun v0 : Z => Some v0
                                          | base.type.bool =>
                                              fun _ : bool => None
                                          | base.type.nat =>
                                              fun _ : nat => None
                                          end v
                                      | _ => None
                                      end
                                    with
                                    | Some args2 =>
                                        match
                                          s0 as t3
                                          return
                                            (Compile.value' false t3 ->
                                             UnderLets.UnderLets base.type
                                               ident var
                                               (defaults.expr
                                                  (type.base base.type.Z)))
                                        with
                                        | type.base t3 =>
                                            fun
                                              v : defaults.expr
                                                    (type.base t3) =>
                                            base.try_make_transport_cps
                                              (fun t4 : base.type =>
                                               defaults.expr (type.base t4))
                                              t3 base.type.Z
                                              (UnderLets.UnderLets base.type
                                                 ident var
                                                 (defaults.expr
                                                    (type.base base.type.Z)))
                                              (fun
                                                 a : option
                                                       (defaults.expr
                                                          (type.base t3) ->
                                                        defaults.expr
                                                          (type.base
                                                             base.type.Z)) =>
                                               match a with
                                               | Some x' =>
                                                   match
                                                     s2 as t4
                                                     return
                                                       (Compile.value' false
                                                          t4 ->
                                                        UnderLets.UnderLets
                                                          base.type ident var
                                                          (defaults.expr
                                                             (type.base
                                                                base.type.Z)))
                                                   with
                                                   | type.base t4 =>
                                                       fun
                                                         v0 : defaults.expr
                                                                (type.base t4)
                                                       =>
                                                       base.try_make_transport_cps
                                                         (fun t5 : base.type
                                                          =>
                                                          defaults.expr
                                                            (type.base t5))
                                                         t4 base.type.Z
                                                         (UnderLets.UnderLets
                                                            base.type ident
                                                            var
                                                            (defaults.expr
                                                               (type.base
                                                                  base.type.Z)))
                                                         (fun
                                                            a0 : option
                                                                   (defaults.expr
                                                                    (type.base
                                                                    t4) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                          =>
                                                          match a0 with
                                                          | Some x'0 =>
                                                              if
                                                               (args0 =?
                                                                2
                                                                ^ (2 *
                                                                   Z.log2_up
                                                                    args0 / 2) -
                                                                1) &&
                                                               (args2 =?
                                                                2
                                                                ^ (2 *
                                                                   Z.log2_up
                                                                    args0 / 2) -
                                                                1)
                                                              then
                                                               UnderLets.Base
                                                                 (#(ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                  (x' v,
                                                                  x'0 v0))%expr_pat
                                                              else
                                                               match x4 with
                                                               | #(idc3)%expr_pat =>
                                                                   match
                                                                    match
                                                                    idc3
                                                                    with
                                                                    | @ident.Literal
                                                                    t6 v1 =>
                                                                    match
                                                                    t6 as t7
                                                                    return
                                                                    (base.base_interp
                                                                    t7 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v2 : Z =>
                                                                    Some v2
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v1
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                   with
                                                                   | Some
                                                                    args3 =>
                                                                    match
                                                                    s0 as t6
                                                                    return
                                                                    (Compile.value'
                                                                    false t6 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t6 =>
                                                                    fun
                                                                    v1 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t6) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t7 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7)) t6
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a1 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t6) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a1
                                                                    with
                                                                    | Some
                                                                    x'1 =>
                                                                    match
                                                                    s3 as t7
                                                                    return
                                                                    (Compile.value'
                                                                    false t7 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t7 =>
                                                                    fun
                                                                    v2 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t8 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t8)) t7
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a2 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t7) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a2
                                                                    with
                                                                    | Some
                                                                    x'2 =>
                                                                    if
                                                                    (args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1) &&
                                                                    (args3 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1)
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x'1 v1,
                                                                    x'2 v2))%expr_pat
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s4 ->
                                                                    d4)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s4 ->
                                                                    Compile.value'
                                                                    true d4
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x5)
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s4 ->
                                                                    d4)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s4 ->
                                                                    Compile.value'
                                                                    true d4
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x2)
                                                                   | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                   end
                                                               | _ =>
                                                                   UnderLets.Base
                                                                    (x * x0)%expr
                                                               end
                                                          | None =>
                                                              UnderLets.Base
                                                                (x * x0)%expr
                                                          end)
                                                   | (s4 -> d4)%ptype =>
                                                       fun
                                                         _ : Compile.value'
                                                               false s4 ->
                                                             Compile.value'
                                                               true d4 =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end (Compile.reflect x4)
                                               | None =>
                                                   UnderLets.Base
                                                     (x * x0)%expr
                                               end)
                                        | (s4 -> d4)%ptype =>
                                            fun
                                              _ : Compile.value' false s4 ->
                                                  Compile.value' true d4 =>
                                            UnderLets.Base (x * x0)%expr
                                        end (Compile.reflect x2)
                                    | None =>
                                        match x4 with
                                        | #(idc3)%expr_pat =>
                                            match
                                              match idc3 with
                                              | @ident.Literal t4 v =>
                                                  match
                                                    t4 as t5
                                                    return
                                                      (base.base_interp t5 ->
                                                       option Z)
                                                  with
                                                  | base.type.unit =>
                                                      fun _ : unit => None
                                                  | base.type.Z =>
                                                      fun v0 : Z => Some v0
                                                  | base.type.bool =>
                                                      fun _ : bool => None
                                                  | base.type.nat =>
                                                      fun _ : nat => None
                                                  end v
                                              | _ => None
                                              end
                                            with
                                            | Some args2 =>
                                                match
                                                  s0 as t4
                                                  return
                                                    (Compile.value' false t4 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             base.type.Z)))
                                                with
                                                | type.base t4 =>
                                                    fun
                                                      v : defaults.expr
                                                            (type.base t4) =>
                                                    base.try_make_transport_cps
                                                      (fun t5 : base.type =>
                                                       defaults.expr
                                                         (type.base t5)) t4
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               base.type.Z)))
                                                      (fun
                                                         a : option
                                                               (defaults.expr
                                                                  (type.base
                                                                    t4) ->
                                                                defaults.expr
                                                                  (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a with
                                                       | Some x' =>
                                                           match
                                                             s3 as t5
                                                             return
                                                               (Compile.value'
                                                                  false t5 ->
                                                                UnderLets.UnderLets
                                                                  base.type
                                                                  ident var
                                                                  (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                           with
                                                           | type.base t5 =>
                                                               fun
                                                                 v0 : 
                                                                  defaults.expr
                                                                    (type.base
                                                                    t5) =>
                                                               base.try_make_transport_cps
                                                                 (fun
                                                                    t6 : base.type
                                                                  =>
                                                                  defaults.expr
                                                                    (type.base
                                                                    t6)) t5
                                                                 base.type.Z
                                                                 (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                 (fun
                                                                    a0 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t5) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                  =>
                                                                  match
                                                                    a0
                                                                  with
                                                                  | Some
                                                                    x'0 =>
                                                                    if
                                                                    (args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1) &&
                                                                    (args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1)
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x' v,
                                                                    x'0 v0))%expr_pat
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                  | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                  end)
                                                           | (s4 -> d4)%ptype =>
                                                               fun
                                                                 _ : 
                                                                  Compile.value'
                                                                    false s4 ->
                                                                  Compile.value'
                                                                    true d4
                                                               =>
                                                               UnderLets.Base
                                                                 (x * x0)%expr
                                                           end
                                                             (Compile.reflect
                                                                x5)
                                                       | None =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end)
                                                | (s4 -> d4)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s4 ->
                                                          Compile.value' true
                                                            d4 =>
                                                    UnderLets.Base
                                                      (x * x0)%expr
                                                end (Compile.reflect x2)
                                            | None =>
                                                UnderLets.Base (x * x0)%expr
                                            end
                                        | _ => UnderLets.Base (x * x0)%expr
                                        end
                                    end
                                | ($_)%expr =>
                                    match x4 with
                                    | #(idc2)%expr_pat =>
                                        match
                                          match idc2 with
                                          | @ident.Literal t4 v0 =>
                                              match
                                                t4 as t5
                                                return
                                                  (base.base_interp t5 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v1 : Z => Some v1
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v0
                                          | _ => None
                                          end
                                        with
                                        | Some args2 =>
                                            match
                                              s0 as t4
                                              return
                                                (Compile.value' false t4 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base base.type.Z)))
                                            with
                                            | type.base t4 =>
                                                fun
                                                  v0 : defaults.expr
                                                         (type.base t4) =>
                                                base.try_make_transport_cps
                                                  (fun t5 : base.type =>
                                                   defaults.expr
                                                     (type.base t5)) t4
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           base.type.Z)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t4) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       match
                                                         s3 as t5
                                                         return
                                                           (Compile.value'
                                                              false t5 ->
                                                            UnderLets.UnderLets
                                                              base.type ident
                                                              var
                                                              (defaults.expr
                                                                 (type.base
                                                                    base.type.Z)))
                                                       with
                                                       | type.base t5 =>
                                                           fun
                                                             v1 : defaults.expr
                                                                    (type.base
                                                                    t5) =>
                                                           base.try_make_transport_cps
                                                             (fun
                                                                t6 : base.type
                                                              =>
                                                              defaults.expr
                                                                (type.base t6))
                                                             t5 base.type.Z
                                                             (UnderLets.UnderLets
                                                                base.type
                                                                ident var
                                                                (defaults.expr
                                                                   (type.base
                                                                    base.type.Z)))
                                                             (fun
                                                                a0 : 
                                                                 option
                                                                   (defaults.expr
                                                                    (type.base
                                                                    t5) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                              =>
                                                              match a0 with
                                                              | Some x'0 =>
                                                                  if
                                                                   (args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1) &&
                                                                   (args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1)
                                                                  then
                                                                   UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x' v0,
                                                                    x'0 v1))%expr_pat
                                                                  else
                                                                   UnderLets.Base
                                                                    (x * x0)%expr
                                                              | None =>
                                                                  UnderLets.Base
                                                                    (x * x0)%expr
                                                              end)
                                                       | (s4 -> d4)%ptype =>
                                                           fun
                                                             _ : Compile.value'
                                                                   false s4 ->
                                                                 Compile.value'
                                                                   true d4 =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end
                                                         (Compile.reflect x5)
                                                   | None =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end)
                                            | (s4 -> d4)%ptype =>
                                                fun
                                                  _ : Compile.value' false s4 ->
                                                      Compile.value' true d4
                                                =>
                                                UnderLets.Base (x * x0)%expr
                                            end (Compile.reflect x2)
                                        | None =>
                                            UnderLets.Base (x * x0)%expr
                                        end
                                    | _ => UnderLets.Base (x * x0)%expr
                                    end
                                | @expr.LetIn _ _ _ _ _ _ _ =>
                                    match x4 with
                                    | #(idc2)%expr_pat =>
                                        match
                                          match idc2 with
                                          | @ident.Literal t3 v =>
                                              match
                                                t3 as t4
                                                return
                                                  (base.base_interp t4 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v0 : Z => Some v0
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v
                                          | _ => None
                                          end
                                        with
                                        | Some args2 =>
                                            match
                                              s0 as t3
                                              return
                                                (Compile.value' false t3 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base base.type.Z)))
                                            with
                                            | type.base t3 =>
                                                fun
                                                  v : defaults.expr
                                                        (type.base t3) =>
                                                base.try_make_transport_cps
                                                  (fun t4 : base.type =>
                                                   defaults.expr
                                                     (type.base t4)) t3
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           base.type.Z)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t3) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       match
                                                         s3 as t4
                                                         return
                                                           (Compile.value'
                                                              false t4 ->
                                                            UnderLets.UnderLets
                                                              base.type ident
                                                              var
                                                              (defaults.expr
                                                                 (type.base
                                                                    base.type.Z)))
                                                       with
                                                       | type.base t4 =>
                                                           fun
                                                             v0 : defaults.expr
                                                                    (type.base
                                                                    t4) =>
                                                           base.try_make_transport_cps
                                                             (fun
                                                                t5 : base.type
                                                              =>
                                                              defaults.expr
                                                                (type.base t5))
                                                             t4 base.type.Z
                                                             (UnderLets.UnderLets
                                                                base.type
                                                                ident var
                                                                (defaults.expr
                                                                   (type.base
                                                                    base.type.Z)))
                                                             (fun
                                                                a0 : 
                                                                 option
                                                                   (defaults.expr
                                                                    (type.base
                                                                    t4) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                              =>
                                                              match a0 with
                                                              | Some x'0 =>
                                                                  if
                                                                   (args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1) &&
                                                                   (args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1)
                                                                  then
                                                                   UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x' v,
                                                                    x'0 v0))%expr_pat
                                                                  else
                                                                   UnderLets.Base
                                                                    (x * x0)%expr
                                                              | None =>
                                                                  UnderLets.Base
                                                                    (x * x0)%expr
                                                              end)
                                                       | (s4 -> d4)%ptype =>
                                                           fun
                                                             _ : Compile.value'
                                                                   false s4 ->
                                                                 Compile.value'
                                                                   true d4 =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end
                                                         (Compile.reflect x5)
                                                   | None =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end)
                                            | (s4 -> d4)%ptype =>
                                                fun
                                                  _ : Compile.value' false s4 ->
                                                      Compile.value' true d4
                                                =>
                                                UnderLets.Base (x * x0)%expr
                                            end (Compile.reflect x2)
                                        | None =>
                                            UnderLets.Base (x * x0)%expr
                                        end
                                    | _ => UnderLets.Base (x * x0)%expr
                                    end
                                | _ =>
                                    match x4 with
                                    | #(idc2)%expr_pat =>
                                        match
                                          match idc2 with
                                          | @ident.Literal t3 v =>
                                              match
                                                t3 as t4
                                                return
                                                  (base.base_interp t4 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v0 : Z => Some v0
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v
                                          | _ => None
                                          end
                                        with
                                        | Some args2 =>
                                            match
                                              s0 as t3
                                              return
                                                (Compile.value' false t3 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base base.type.Z)))
                                            with
                                            | type.base t3 =>
                                                fun
                                                  v : defaults.expr
                                                        (type.base t3) =>
                                                base.try_make_transport_cps
                                                  (fun t4 : base.type =>
                                                   defaults.expr
                                                     (type.base t4)) t3
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           base.type.Z)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t3) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       match
                                                         s3 as t4
                                                         return
                                                           (Compile.value'
                                                              false t4 ->
                                                            UnderLets.UnderLets
                                                              base.type ident
                                                              var
                                                              (defaults.expr
                                                                 (type.base
                                                                    base.type.Z)))
                                                       with
                                                       | type.base t4 =>
                                                           fun
                                                             v0 : defaults.expr
                                                                    (type.base
                                                                    t4) =>
                                                           base.try_make_transport_cps
                                                             (fun
                                                                t5 : base.type
                                                              =>
                                                              defaults.expr
                                                                (type.base t5))
                                                             t4 base.type.Z
                                                             (UnderLets.UnderLets
                                                                base.type
                                                                ident var
                                                                (defaults.expr
                                                                   (type.base
                                                                    base.type.Z)))
                                                             (fun
                                                                a0 : 
                                                                 option
                                                                   (defaults.expr
                                                                    (type.base
                                                                    t4) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                              =>
                                                              match a0 with
                                                              | Some x'0 =>
                                                                  if
                                                                   (args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1) &&
                                                                   (args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1)
                                                                  then
                                                                   UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x' v,
                                                                    x'0 v0))%expr_pat
                                                                  else
                                                                   UnderLets.Base
                                                                    (x * x0)%expr
                                                              | None =>
                                                                  UnderLets.Base
                                                                    (x * x0)%expr
                                                              end)
                                                       | (s5 -> d5)%ptype =>
                                                           fun
                                                             _ : Compile.value'
                                                                   false s5 ->
                                                                 Compile.value'
                                                                   true d5 =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end
                                                         (Compile.reflect x5)
                                                   | None =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end)
                                            | (s5 -> d5)%ptype =>
                                                fun
                                                  _ : Compile.value' false s5 ->
                                                      Compile.value' true d5
                                                =>
                                                UnderLets.Base (x * x0)%expr
                                            end (Compile.reflect x2)
                                        | None =>
                                            UnderLets.Base (x * x0)%expr
                                        end
                                    | _ => UnderLets.Base (x * x0)%expr
                                    end
                                end
                            | None =>
                                match
                                  match idc1 with
                                  | ident.Z_shiftr => Some tt
                                  | _ => None
                                  end
                                with
                                | Some _ =>
                                    match x4 with
                                    | #(idc2)%expr_pat =>
                                        match
                                          match idc2 with
                                          | @ident.Literal t3 v =>
                                              match
                                                t3 as t4
                                                return
                                                  (base.base_interp t4 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v0 : Z => Some v0
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v
                                          | _ => None
                                          end
                                        with
                                        | Some args2 =>
                                            match
                                              s0 as t3
                                              return
                                                (Compile.value' false t3 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base base.type.Z)))
                                            with
                                            | type.base t3 =>
                                                fun
                                                  v : defaults.expr
                                                        (type.base t3) =>
                                                base.try_make_transport_cps
                                                  (fun t4 : base.type =>
                                                   defaults.expr
                                                     (type.base t4)) t3
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           base.type.Z)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t3) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       match
                                                         s3 as t4
                                                         return
                                                           (Compile.value'
                                                              false t4 ->
                                                            UnderLets.UnderLets
                                                              base.type ident
                                                              var
                                                              (defaults.expr
                                                                 (type.base
                                                                    base.type.Z)))
                                                       with
                                                       | type.base t4 =>
                                                           fun
                                                             v0 : defaults.expr
                                                                    (type.base
                                                                    t4) =>
                                                           base.try_make_transport_cps
                                                             (fun
                                                                t5 : base.type
                                                              =>
                                                              defaults.expr
                                                                (type.base t5))
                                                             t4 base.type.Z
                                                             (UnderLets.UnderLets
                                                                base.type
                                                                ident var
                                                                (defaults.expr
                                                                   (type.base
                                                                    base.type.Z)))
                                                             (fun
                                                                a0 : 
                                                                 option
                                                                   (defaults.expr
                                                                    (type.base
                                                                    t4) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                              =>
                                                              match a0 with
                                                              | Some x'0 =>
                                                                  if
                                                                   args0 =?
                                                                   2
                                                                   ^ 
                                                                   (2 * args2 /
                                                                    2) - 1
                                                                  then
                                                                   UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mullh
                                                                    (2 *
                                                                    args2))%expr @
                                                                    (
                                                                    x' v,
                                                                    x'0 v0))%expr_pat
                                                                  else
                                                                   UnderLets.Base
                                                                    (x * x0)%expr
                                                              | None =>
                                                                  UnderLets.Base
                                                                    (x * x0)%expr
                                                              end)
                                                       | (s4 -> d4)%ptype =>
                                                           fun
                                                             _ : Compile.value'
                                                                   false s4 ->
                                                                 Compile.value'
                                                                   true d4 =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end
                                                         (Compile.reflect x5)
                                                   | None =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end)
                                            | (s4 -> d4)%ptype =>
                                                fun
                                                  _ : Compile.value' false s4 ->
                                                      Compile.value' true d4
                                                =>
                                                UnderLets.Base (x * x0)%expr
                                            end (Compile.reflect x2)
                                        | None =>
                                            UnderLets.Base (x * x0)%expr
                                        end
                                    | _ => UnderLets.Base (x * x0)%expr
                                    end
                                | None => UnderLets.Base (x * x0)%expr
                                end
                            end
                        | @expr.App _ _ _ s2 _
                          (@expr.App _ _ _ s3 _ ($_)%expr _) _ | @expr.App _
                          _ _ s2 _
                          (@expr.App _ _ _ s3 _ (@expr.Abs _ _ _ _ _ _) _)
                          _ | @expr.App _ _ _ s2 _
                          (@expr.App _ _ _ s3 _ (_ @ _)%expr_pat _) _ |
                          @expr.App _ _ _ s2 _
                          (@expr.App _ _ _ s3 _ (@expr.LetIn _ _ _ _ _ _ _)
                           _) _ => UnderLets.Base (x * x0)%expr
                        | @expr.App _ _ _ s2 _ #(_)%expr_pat _ | @expr.App _
                          _ _ s2 _ ($_)%expr _ | @expr.App _ _ _ s2 _
                          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s2 _
                          (@expr.LetIn _ _ _ _ _ _ _) _ =>
                            UnderLets.Base (x * x0)%expr
                        | _ => UnderLets.Base (x * x0)%expr
                        end
                    | None => UnderLets.Base (x * x0)%expr
                    end
                | _ => UnderLets.Base (x * x0)%expr
                end
            | @expr.LetIn _ _ _ _ _ _ _ =>
                match x1 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t1 v =>
                          match
                            t1 as t2 return (base.base_interp t2 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v0 : Z => Some v0
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        match x0 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t2 v =>
                                  match
                                    t2 as t3
                                    return (base.base_interp t3 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v0 : Z => Some v0
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                match
                                  s0 as t2
                                  return
                                    (Compile.value' false t2 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr (type.base base.type.Z)))
                                with
                                | type.base t2 =>
                                    fun v : defaults.expr (type.base t2) =>
                                    base.try_make_transport_cps
                                      (fun t3 : base.type =>
                                       defaults.expr (type.base t3)) t2
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base base.type.Z)))
                                      (fun
                                         a : option
                                               (defaults.expr (type.base t2) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                       match a with
                                       | Some x' =>
                                           if
                                            args0 =?
                                            2 ^ (2 * Z.log2_up args0 / 2) - 1
                                           then
                                            match
                                              invert_low
                                                (2 * Z.log2_up args0) args1
                                            with
                                            | Some y =>
                                                UnderLets.Base
                                                  (#(ident.fancy_mulll
                                                       (2 * Z.log2_up args0))%expr @
                                                   (x' v, ##(y)%expr))%expr_pat
                                            | None =>
                                                match
                                                  s0 as t3
                                                  return
                                                    (Compile.value' false t3 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             base.type.Z)))
                                                with
                                                | type.base t3 =>
                                                    fun
                                                      v0 : defaults.expr
                                                             (type.base t3)
                                                    =>
                                                    base.try_make_transport_cps
                                                      (fun t4 : base.type =>
                                                       defaults.expr
                                                         (type.base t4)) t3
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               base.type.Z)))
                                                      (fun
                                                         a0 : option
                                                                (defaults.expr
                                                                   (type.base
                                                                    t3) ->
                                                                 defaults.expr
                                                                   (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a0 with
                                                       | Some x'0 =>
                                                           if
                                                            args0 =?
                                                            2
                                                            ^ (2 *
                                                               Z.log2_up
                                                                 args0 / 2) -
                                                            1
                                                           then
                                                            match
                                                              invert_high
                                                                (2 *
                                                                 Z.log2_up
                                                                   args0)
                                                                args1
                                                            with
                                                            | Some y =>
                                                                UnderLets.Base
                                                                  (#(ident.fancy_mullh
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                   (x'0 v0,
                                                                   ##
                                                                   (y)%expr))%expr_pat
                                                            | None =>
                                                                UnderLets.Base
                                                                  (x * x0)%expr
                                                            end
                                                           else
                                                            UnderLets.Base
                                                              (x * x0)%expr
                                                       | None =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end)
                                                | (s1 -> d1)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s1 ->
                                                          Compile.value' true
                                                            d1 =>
                                                    UnderLets.Base
                                                      (x * x0)%expr
                                                end (Compile.reflect x2)
                                            end
                                           else
                                            match
                                              s0 as t3
                                              return
                                                (Compile.value' false t3 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base base.type.Z)))
                                            with
                                            | type.base t3 =>
                                                fun
                                                  v0 : defaults.expr
                                                         (type.base t3) =>
                                                base.try_make_transport_cps
                                                  (fun t4 : base.type =>
                                                   defaults.expr
                                                     (type.base t4)) t3
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           base.type.Z)))
                                                  (fun
                                                     a0 : option
                                                            (defaults.expr
                                                               (type.base t3) ->
                                                             defaults.expr
                                                               (type.base
                                                                  base.type.Z))
                                                   =>
                                                   match a0 with
                                                   | Some x'0 =>
                                                       if
                                                        args0 =?
                                                        2
                                                        ^ (2 *
                                                           Z.log2_up args0 /
                                                           2) - 1
                                                       then
                                                        match
                                                          invert_high
                                                            (2 *
                                                             Z.log2_up args0)
                                                            args1
                                                        with
                                                        | Some y =>
                                                            UnderLets.Base
                                                              (#(ident.fancy_mullh
                                                                   (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                               (x'0 v0,
                                                               ##(y)%expr))%expr_pat
                                                        | None =>
                                                            UnderLets.Base
                                                              (x * x0)%expr
                                                        end
                                                       else
                                                        UnderLets.Base
                                                          (x * x0)%expr
                                                   | None =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end)
                                            | (s1 -> d1)%ptype =>
                                                fun
                                                  _ : Compile.value' false s1 ->
                                                      Compile.value' true d1
                                                =>
                                                UnderLets.Base (x * x0)%expr
                                            end (Compile.reflect x2)
                                       | None => UnderLets.Base (x * x0)%expr
                                       end)
                                | (s1 -> d1)%ptype =>
                                    fun
                                      _ : Compile.value' false s1 ->
                                          Compile.value' true d1 =>
                                    UnderLets.Base (x * x0)%expr
                                end (Compile.reflect x2)
                            | None => UnderLets.Base (x * x0)%expr
                            end
                        | @expr.App _ _ _ s1 _
                          (@expr.App _ _ _ s2 _ #(idc1)%expr_pat x5) x4 =>
                            match
                              match idc1 with
                              | ident.Z_land => Some tt
                              | _ => None
                              end
                            with
                            | Some _ =>
                                match x5 with
                                | #(idc2)%expr_pat =>
                                    match
                                      match idc2 with
                                      | @ident.Literal t3 v =>
                                          match
                                            t3 as t4
                                            return
                                              (base.base_interp t4 ->
                                               option Z)
                                          with
                                          | base.type.unit =>
                                              fun _ : unit => None
                                          | base.type.Z =>
                                              fun v0 : Z => Some v0
                                          | base.type.bool =>
                                              fun _ : bool => None
                                          | base.type.nat =>
                                              fun _ : nat => None
                                          end v
                                      | _ => None
                                      end
                                    with
                                    | Some args2 =>
                                        match
                                          s0 as t3
                                          return
                                            (Compile.value' false t3 ->
                                             UnderLets.UnderLets base.type
                                               ident var
                                               (defaults.expr
                                                  (type.base base.type.Z)))
                                        with
                                        | type.base t3 =>
                                            fun
                                              v : defaults.expr
                                                    (type.base t3) =>
                                            base.try_make_transport_cps
                                              (fun t4 : base.type =>
                                               defaults.expr (type.base t4))
                                              t3 base.type.Z
                                              (UnderLets.UnderLets base.type
                                                 ident var
                                                 (defaults.expr
                                                    (type.base base.type.Z)))
                                              (fun
                                                 a : option
                                                       (defaults.expr
                                                          (type.base t3) ->
                                                        defaults.expr
                                                          (type.base
                                                             base.type.Z)) =>
                                               match a with
                                               | Some x' =>
                                                   match
                                                     s1 as t4
                                                     return
                                                       (Compile.value' false
                                                          t4 ->
                                                        UnderLets.UnderLets
                                                          base.type ident var
                                                          (defaults.expr
                                                             (type.base
                                                                base.type.Z)))
                                                   with
                                                   | type.base t4 =>
                                                       fun
                                                         v0 : defaults.expr
                                                                (type.base t4)
                                                       =>
                                                       base.try_make_transport_cps
                                                         (fun t5 : base.type
                                                          =>
                                                          defaults.expr
                                                            (type.base t5))
                                                         t4 base.type.Z
                                                         (UnderLets.UnderLets
                                                            base.type ident
                                                            var
                                                            (defaults.expr
                                                               (type.base
                                                                  base.type.Z)))
                                                         (fun
                                                            a0 : option
                                                                   (defaults.expr
                                                                    (type.base
                                                                    t4) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                          =>
                                                          match a0 with
                                                          | Some x'0 =>
                                                              if
                                                               (args0 =?
                                                                2
                                                                ^ (2 *
                                                                   Z.log2_up
                                                                    args0 / 2) -
                                                                1) &&
                                                               (args2 =?
                                                                2
                                                                ^ (2 *
                                                                   Z.log2_up
                                                                    args0 / 2) -
                                                                1)
                                                              then
                                                               UnderLets.Base
                                                                 (#(ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                  (x' v,
                                                                  x'0 v0))%expr_pat
                                                              else
                                                               match x4 with
                                                               | #(idc3)%expr_pat =>
                                                                   match
                                                                    match
                                                                    idc3
                                                                    with
                                                                    | @ident.Literal
                                                                    t6 v1 =>
                                                                    match
                                                                    t6 as t7
                                                                    return
                                                                    (base.base_interp
                                                                    t7 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v2 : Z =>
                                                                    Some v2
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v1
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                   with
                                                                   | Some
                                                                    args3 =>
                                                                    match
                                                                    s0 as t6
                                                                    return
                                                                    (Compile.value'
                                                                    false t6 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t6 =>
                                                                    fun
                                                                    v1 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t6) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t7 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7)) t6
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a1 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t6) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a1
                                                                    with
                                                                    | Some
                                                                    x'1 =>
                                                                    match
                                                                    s2 as t7
                                                                    return
                                                                    (Compile.value'
                                                                    false t7 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t7 =>
                                                                    fun
                                                                    v2 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t8 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t8)) t7
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a2 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t7) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a2
                                                                    with
                                                                    | Some
                                                                    x'2 =>
                                                                    if
                                                                    (args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1) &&
                                                                    (args3 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1)
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x'1 v1,
                                                                    x'2 v2))%expr_pat
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s3 ->
                                                                    d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x5)
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s3 ->
                                                                    d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x2)
                                                                   | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                   end
                                                               | _ =>
                                                                   UnderLets.Base
                                                                    (x * x0)%expr
                                                               end
                                                          | None =>
                                                              UnderLets.Base
                                                                (x * x0)%expr
                                                          end)
                                                   | (s3 -> d3)%ptype =>
                                                       fun
                                                         _ : Compile.value'
                                                               false s3 ->
                                                             Compile.value'
                                                               true d3 =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end (Compile.reflect x4)
                                               | None =>
                                                   UnderLets.Base
                                                     (x * x0)%expr
                                               end)
                                        | (s3 -> d3)%ptype =>
                                            fun
                                              _ : Compile.value' false s3 ->
                                                  Compile.value' true d3 =>
                                            UnderLets.Base (x * x0)%expr
                                        end (Compile.reflect x2)
                                    | None =>
                                        match x4 with
                                        | #(idc3)%expr_pat =>
                                            match
                                              match idc3 with
                                              | @ident.Literal t4 v =>
                                                  match
                                                    t4 as t5
                                                    return
                                                      (base.base_interp t5 ->
                                                       option Z)
                                                  with
                                                  | base.type.unit =>
                                                      fun _ : unit => None
                                                  | base.type.Z =>
                                                      fun v0 : Z => Some v0
                                                  | base.type.bool =>
                                                      fun _ : bool => None
                                                  | base.type.nat =>
                                                      fun _ : nat => None
                                                  end v
                                              | _ => None
                                              end
                                            with
                                            | Some args2 =>
                                                match
                                                  s0 as t4
                                                  return
                                                    (Compile.value' false t4 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             base.type.Z)))
                                                with
                                                | type.base t4 =>
                                                    fun
                                                      v : defaults.expr
                                                            (type.base t4) =>
                                                    base.try_make_transport_cps
                                                      (fun t5 : base.type =>
                                                       defaults.expr
                                                         (type.base t5)) t4
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               base.type.Z)))
                                                      (fun
                                                         a : option
                                                               (defaults.expr
                                                                  (type.base
                                                                    t4) ->
                                                                defaults.expr
                                                                  (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a with
                                                       | Some x' =>
                                                           match
                                                             s2 as t5
                                                             return
                                                               (Compile.value'
                                                                  false t5 ->
                                                                UnderLets.UnderLets
                                                                  base.type
                                                                  ident var
                                                                  (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                           with
                                                           | type.base t5 =>
                                                               fun
                                                                 v0 : 
                                                                  defaults.expr
                                                                    (type.base
                                                                    t5) =>
                                                               base.try_make_transport_cps
                                                                 (fun
                                                                    t6 : base.type
                                                                  =>
                                                                  defaults.expr
                                                                    (type.base
                                                                    t6)) t5
                                                                 base.type.Z
                                                                 (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                 (fun
                                                                    a0 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t5) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                  =>
                                                                  match
                                                                    a0
                                                                  with
                                                                  | Some
                                                                    x'0 =>
                                                                    if
                                                                    (args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1) &&
                                                                    (args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1)
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x' v,
                                                                    x'0 v0))%expr_pat
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                  | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                  end)
                                                           | (s3 -> d3)%ptype =>
                                                               fun
                                                                 _ : 
                                                                  Compile.value'
                                                                    false s3 ->
                                                                  Compile.value'
                                                                    true d3
                                                               =>
                                                               UnderLets.Base
                                                                 (x * x0)%expr
                                                           end
                                                             (Compile.reflect
                                                                x5)
                                                       | None =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end)
                                                | (s3 -> d3)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s3 ->
                                                          Compile.value' true
                                                            d3 =>
                                                    UnderLets.Base
                                                      (x * x0)%expr
                                                end (Compile.reflect x2)
                                            | None =>
                                                UnderLets.Base (x * x0)%expr
                                            end
                                        | _ => UnderLets.Base (x * x0)%expr
                                        end
                                    end
                                | ($_)%expr =>
                                    match x4 with
                                    | #(idc2)%expr_pat =>
                                        match
                                          match idc2 with
                                          | @ident.Literal t4 v0 =>
                                              match
                                                t4 as t5
                                                return
                                                  (base.base_interp t5 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v1 : Z => Some v1
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v0
                                          | _ => None
                                          end
                                        with
                                        | Some args2 =>
                                            match
                                              s0 as t4
                                              return
                                                (Compile.value' false t4 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base base.type.Z)))
                                            with
                                            | type.base t4 =>
                                                fun
                                                  v0 : defaults.expr
                                                         (type.base t4) =>
                                                base.try_make_transport_cps
                                                  (fun t5 : base.type =>
                                                   defaults.expr
                                                     (type.base t5)) t4
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           base.type.Z)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t4) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       match
                                                         s2 as t5
                                                         return
                                                           (Compile.value'
                                                              false t5 ->
                                                            UnderLets.UnderLets
                                                              base.type ident
                                                              var
                                                              (defaults.expr
                                                                 (type.base
                                                                    base.type.Z)))
                                                       with
                                                       | type.base t5 =>
                                                           fun
                                                             v1 : defaults.expr
                                                                    (type.base
                                                                    t5) =>
                                                           base.try_make_transport_cps
                                                             (fun
                                                                t6 : base.type
                                                              =>
                                                              defaults.expr
                                                                (type.base t6))
                                                             t5 base.type.Z
                                                             (UnderLets.UnderLets
                                                                base.type
                                                                ident var
                                                                (defaults.expr
                                                                   (type.base
                                                                    base.type.Z)))
                                                             (fun
                                                                a0 : 
                                                                 option
                                                                   (defaults.expr
                                                                    (type.base
                                                                    t5) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                              =>
                                                              match a0 with
                                                              | Some x'0 =>
                                                                  if
                                                                   (args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1) &&
                                                                   (args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1)
                                                                  then
                                                                   UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x' v0,
                                                                    x'0 v1))%expr_pat
                                                                  else
                                                                   UnderLets.Base
                                                                    (x * x0)%expr
                                                              | None =>
                                                                  UnderLets.Base
                                                                    (x * x0)%expr
                                                              end)
                                                       | (s3 -> d3)%ptype =>
                                                           fun
                                                             _ : Compile.value'
                                                                   false s3 ->
                                                                 Compile.value'
                                                                   true d3 =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end
                                                         (Compile.reflect x5)
                                                   | None =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end)
                                            | (s3 -> d3)%ptype =>
                                                fun
                                                  _ : Compile.value' false s3 ->
                                                      Compile.value' true d3
                                                =>
                                                UnderLets.Base (x * x0)%expr
                                            end (Compile.reflect x2)
                                        | None =>
                                            UnderLets.Base (x * x0)%expr
                                        end
                                    | _ => UnderLets.Base (x * x0)%expr
                                    end
                                | @expr.LetIn _ _ _ _ _ _ _ =>
                                    match x4 with
                                    | #(idc2)%expr_pat =>
                                        match
                                          match idc2 with
                                          | @ident.Literal t3 v =>
                                              match
                                                t3 as t4
                                                return
                                                  (base.base_interp t4 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v0 : Z => Some v0
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v
                                          | _ => None
                                          end
                                        with
                                        | Some args2 =>
                                            match
                                              s0 as t3
                                              return
                                                (Compile.value' false t3 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base base.type.Z)))
                                            with
                                            | type.base t3 =>
                                                fun
                                                  v : defaults.expr
                                                        (type.base t3) =>
                                                base.try_make_transport_cps
                                                  (fun t4 : base.type =>
                                                   defaults.expr
                                                     (type.base t4)) t3
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           base.type.Z)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t3) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       match
                                                         s2 as t4
                                                         return
                                                           (Compile.value'
                                                              false t4 ->
                                                            UnderLets.UnderLets
                                                              base.type ident
                                                              var
                                                              (defaults.expr
                                                                 (type.base
                                                                    base.type.Z)))
                                                       with
                                                       | type.base t4 =>
                                                           fun
                                                             v0 : defaults.expr
                                                                    (type.base
                                                                    t4) =>
                                                           base.try_make_transport_cps
                                                             (fun
                                                                t5 : base.type
                                                              =>
                                                              defaults.expr
                                                                (type.base t5))
                                                             t4 base.type.Z
                                                             (UnderLets.UnderLets
                                                                base.type
                                                                ident var
                                                                (defaults.expr
                                                                   (type.base
                                                                    base.type.Z)))
                                                             (fun
                                                                a0 : 
                                                                 option
                                                                   (defaults.expr
                                                                    (type.base
                                                                    t4) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                              =>
                                                              match a0 with
                                                              | Some x'0 =>
                                                                  if
                                                                   (args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1) &&
                                                                   (args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1)
                                                                  then
                                                                   UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x' v,
                                                                    x'0 v0))%expr_pat
                                                                  else
                                                                   UnderLets.Base
                                                                    (x * x0)%expr
                                                              | None =>
                                                                  UnderLets.Base
                                                                    (x * x0)%expr
                                                              end)
                                                       | (s3 -> d3)%ptype =>
                                                           fun
                                                             _ : Compile.value'
                                                                   false s3 ->
                                                                 Compile.value'
                                                                   true d3 =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end
                                                         (Compile.reflect x5)
                                                   | None =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end)
                                            | (s3 -> d3)%ptype =>
                                                fun
                                                  _ : Compile.value' false s3 ->
                                                      Compile.value' true d3
                                                =>
                                                UnderLets.Base (x * x0)%expr
                                            end (Compile.reflect x2)
                                        | None =>
                                            UnderLets.Base (x * x0)%expr
                                        end
                                    | _ => UnderLets.Base (x * x0)%expr
                                    end
                                | _ =>
                                    match x4 with
                                    | #(idc2)%expr_pat =>
                                        match
                                          match idc2 with
                                          | @ident.Literal t3 v =>
                                              match
                                                t3 as t4
                                                return
                                                  (base.base_interp t4 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v0 : Z => Some v0
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v
                                          | _ => None
                                          end
                                        with
                                        | Some args2 =>
                                            match
                                              s0 as t3
                                              return
                                                (Compile.value' false t3 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base base.type.Z)))
                                            with
                                            | type.base t3 =>
                                                fun
                                                  v : defaults.expr
                                                        (type.base t3) =>
                                                base.try_make_transport_cps
                                                  (fun t4 : base.type =>
                                                   defaults.expr
                                                     (type.base t4)) t3
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           base.type.Z)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t3) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       match
                                                         s2 as t4
                                                         return
                                                           (Compile.value'
                                                              false t4 ->
                                                            UnderLets.UnderLets
                                                              base.type ident
                                                              var
                                                              (defaults.expr
                                                                 (type.base
                                                                    base.type.Z)))
                                                       with
                                                       | type.base t4 =>
                                                           fun
                                                             v0 : defaults.expr
                                                                    (type.base
                                                                    t4) =>
                                                           base.try_make_transport_cps
                                                             (fun
                                                                t5 : base.type
                                                              =>
                                                              defaults.expr
                                                                (type.base t5))
                                                             t4 base.type.Z
                                                             (UnderLets.UnderLets
                                                                base.type
                                                                ident var
                                                                (defaults.expr
                                                                   (type.base
                                                                    base.type.Z)))
                                                             (fun
                                                                a0 : 
                                                                 option
                                                                   (defaults.expr
                                                                    (type.base
                                                                    t4) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                              =>
                                                              match a0 with
                                                              | Some x'0 =>
                                                                  if
                                                                   (args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1) &&
                                                                   (args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1)
                                                                  then
                                                                   UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x' v,
                                                                    x'0 v0))%expr_pat
                                                                  else
                                                                   UnderLets.Base
                                                                    (x * x0)%expr
                                                              | None =>
                                                                  UnderLets.Base
                                                                    (x * x0)%expr
                                                              end)
                                                       | (s4 -> d4)%ptype =>
                                                           fun
                                                             _ : Compile.value'
                                                                   false s4 ->
                                                                 Compile.value'
                                                                   true d4 =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end
                                                         (Compile.reflect x5)
                                                   | None =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end)
                                            | (s4 -> d4)%ptype =>
                                                fun
                                                  _ : Compile.value' false s4 ->
                                                      Compile.value' true d4
                                                =>
                                                UnderLets.Base (x * x0)%expr
                                            end (Compile.reflect x2)
                                        | None =>
                                            UnderLets.Base (x * x0)%expr
                                        end
                                    | _ => UnderLets.Base (x * x0)%expr
                                    end
                                end
                            | None =>
                                match
                                  match idc1 with
                                  | ident.Z_shiftr => Some tt
                                  | _ => None
                                  end
                                with
                                | Some _ =>
                                    match x4 with
                                    | #(idc2)%expr_pat =>
                                        match
                                          match idc2 with
                                          | @ident.Literal t3 v =>
                                              match
                                                t3 as t4
                                                return
                                                  (base.base_interp t4 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v0 : Z => Some v0
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v
                                          | _ => None
                                          end
                                        with
                                        | Some args2 =>
                                            match
                                              s0 as t3
                                              return
                                                (Compile.value' false t3 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base base.type.Z)))
                                            with
                                            | type.base t3 =>
                                                fun
                                                  v : defaults.expr
                                                        (type.base t3) =>
                                                base.try_make_transport_cps
                                                  (fun t4 : base.type =>
                                                   defaults.expr
                                                     (type.base t4)) t3
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           base.type.Z)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t3) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       match
                                                         s2 as t4
                                                         return
                                                           (Compile.value'
                                                              false t4 ->
                                                            UnderLets.UnderLets
                                                              base.type ident
                                                              var
                                                              (defaults.expr
                                                                 (type.base
                                                                    base.type.Z)))
                                                       with
                                                       | type.base t4 =>
                                                           fun
                                                             v0 : defaults.expr
                                                                    (type.base
                                                                    t4) =>
                                                           base.try_make_transport_cps
                                                             (fun
                                                                t5 : base.type
                                                              =>
                                                              defaults.expr
                                                                (type.base t5))
                                                             t4 base.type.Z
                                                             (UnderLets.UnderLets
                                                                base.type
                                                                ident var
                                                                (defaults.expr
                                                                   (type.base
                                                                    base.type.Z)))
                                                             (fun
                                                                a0 : 
                                                                 option
                                                                   (defaults.expr
                                                                    (type.base
                                                                    t4) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                              =>
                                                              match a0 with
                                                              | Some x'0 =>
                                                                  if
                                                                   args0 =?
                                                                   2
                                                                   ^ 
                                                                   (2 * args2 /
                                                                    2) - 1
                                                                  then
                                                                   UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mullh
                                                                    (2 *
                                                                    args2))%expr @
                                                                    (
                                                                    x' v,
                                                                    x'0 v0))%expr_pat
                                                                  else
                                                                   UnderLets.Base
                                                                    (x * x0)%expr
                                                              | None =>
                                                                  UnderLets.Base
                                                                    (x * x0)%expr
                                                              end)
                                                       | (s3 -> d3)%ptype =>
                                                           fun
                                                             _ : Compile.value'
                                                                   false s3 ->
                                                                 Compile.value'
                                                                   true d3 =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end
                                                         (Compile.reflect x5)
                                                   | None =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end)
                                            | (s3 -> d3)%ptype =>
                                                fun
                                                  _ : Compile.value' false s3 ->
                                                      Compile.value' true d3
                                                =>
                                                UnderLets.Base (x * x0)%expr
                                            end (Compile.reflect x2)
                                        | None =>
                                            UnderLets.Base (x * x0)%expr
                                        end
                                    | _ => UnderLets.Base (x * x0)%expr
                                    end
                                | None => UnderLets.Base (x * x0)%expr
                                end
                            end
                        | @expr.App _ _ _ s1 _
                          (@expr.App _ _ _ s2 _ ($_)%expr _) _ | @expr.App _
                          _ _ s1 _
                          (@expr.App _ _ _ s2 _ (@expr.Abs _ _ _ _ _ _) _)
                          _ | @expr.App _ _ _ s1 _
                          (@expr.App _ _ _ s2 _ (_ @ _)%expr_pat _) _ |
                          @expr.App _ _ _ s1 _
                          (@expr.App _ _ _ s2 _ (@expr.LetIn _ _ _ _ _ _ _)
                           _) _ => UnderLets.Base (x * x0)%expr
                        | @expr.App _ _ _ s1 _ #(_)%expr_pat _ | @expr.App _
                          _ _ s1 _ ($_)%expr _ | @expr.App _ _ _ s1 _
                          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s1 _
                          (@expr.LetIn _ _ _ _ _ _ _) _ =>
                            UnderLets.Base (x * x0)%expr
                        | _ => UnderLets.Base (x * x0)%expr
                        end
                    | None => UnderLets.Base (x * x0)%expr
                    end
                | _ => UnderLets.Base (x * x0)%expr
                end
            end
        | None =>
            match
              match idc with
              | ident.Z_shiftr => Some tt
              | _ => None
              end
            with
            | Some _ =>
                match x1 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t1 v =>
                          match
                            t1 as t2 return (base.base_interp t2 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v0 : Z => Some v0
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        match x0 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t2 v =>
                                  match
                                    t2 as t3
                                    return (base.base_interp t3 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v0 : Z => Some v0
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                match
                                  s0 as t2
                                  return
                                    (Compile.value' false t2 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr (type.base base.type.Z)))
                                with
                                | type.base t2 =>
                                    fun v : defaults.expr (type.base t2) =>
                                    base.try_make_transport_cps
                                      (fun t3 : base.type =>
                                       defaults.expr (type.base t3)) t2
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base base.type.Z)))
                                      (fun
                                         a : option
                                               (defaults.expr (type.base t2) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                       match a with
                                       | Some x' =>
                                           match
                                             invert_low (2 * args0) args1
                                           with
                                           | Some y =>
                                               UnderLets.Base
                                                 (#(ident.fancy_mulhl
                                                      (2 * args0))%expr @
                                                  (x' v, ##(y)%expr))%expr_pat
                                           | None =>
                                               match
                                                 s0 as t3
                                                 return
                                                   (Compile.value' false t3 ->
                                                    UnderLets.UnderLets
                                                      base.type ident var
                                                      (defaults.expr
                                                         (type.base
                                                            base.type.Z)))
                                               with
                                               | type.base t3 =>
                                                   fun
                                                     v0 : defaults.expr
                                                            (type.base t3) =>
                                                   base.try_make_transport_cps
                                                     (fun t4 : base.type =>
                                                      defaults.expr
                                                        (type.base t4)) t3
                                                     base.type.Z
                                                     (UnderLets.UnderLets
                                                        base.type ident var
                                                        (defaults.expr
                                                           (type.base
                                                              base.type.Z)))
                                                     (fun
                                                        a0 : option
                                                               (defaults.expr
                                                                  (type.base
                                                                    t3) ->
                                                                defaults.expr
                                                                  (type.base
                                                                    base.type.Z))
                                                      =>
                                                      match a0 with
                                                      | Some x'0 =>
                                                          match
                                                            invert_high
                                                              (2 * args0)
                                                              args1
                                                          with
                                                          | Some y =>
                                                              UnderLets.Base
                                                                (#(ident.fancy_mulhh
                                                                    (2 *
                                                                    args0))%expr @
                                                                 (x'0 v0,
                                                                 ##(y)%expr))%expr_pat
                                                          | None =>
                                                              UnderLets.Base
                                                                (x * x0)%expr
                                                          end
                                                      | None =>
                                                          UnderLets.Base
                                                            (x * x0)%expr
                                                      end)
                                               | (s1 -> d1)%ptype =>
                                                   fun
                                                     _ : Compile.value' false
                                                           s1 ->
                                                         Compile.value' true
                                                           d1 =>
                                                   UnderLets.Base
                                                     (x * x0)%expr
                                               end (Compile.reflect x2)
                                           end
                                       | None => UnderLets.Base (x * x0)%expr
                                       end)
                                | (s1 -> d1)%ptype =>
                                    fun
                                      _ : Compile.value' false s1 ->
                                          Compile.value' true d1 =>
                                    UnderLets.Base (x * x0)%expr
                                end (Compile.reflect x2)
                            | None => UnderLets.Base (x * x0)%expr
                            end
                        | @expr.App _ _ _ s1 _
                          (@expr.App _ _ _ s2 _ #(idc1)%expr_pat x4) x3 =>
                            match
                              match idc1 with
                              | ident.Z_land => Some tt
                              | _ => None
                              end
                            with
                            | Some _ =>
                                match x4 with
                                | #(idc2)%expr_pat =>
                                    match
                                      match idc2 with
                                      | @ident.Literal t3 v =>
                                          match
                                            t3 as t4
                                            return
                                              (base.base_interp t4 ->
                                               option Z)
                                          with
                                          | base.type.unit =>
                                              fun _ : unit => None
                                          | base.type.Z =>
                                              fun v0 : Z => Some v0
                                          | base.type.bool =>
                                              fun _ : bool => None
                                          | base.type.nat =>
                                              fun _ : nat => None
                                          end v
                                      | _ => None
                                      end
                                    with
                                    | Some args2 =>
                                        match
                                          s0 as t3
                                          return
                                            (Compile.value' false t3 ->
                                             UnderLets.UnderLets base.type
                                               ident var
                                               (defaults.expr
                                                  (type.base base.type.Z)))
                                        with
                                        | type.base t3 =>
                                            fun
                                              v : defaults.expr
                                                    (type.base t3) =>
                                            base.try_make_transport_cps
                                              (fun t4 : base.type =>
                                               defaults.expr (type.base t4))
                                              t3 base.type.Z
                                              (UnderLets.UnderLets base.type
                                                 ident var
                                                 (defaults.expr
                                                    (type.base base.type.Z)))
                                              (fun
                                                 a : option
                                                       (defaults.expr
                                                          (type.base t3) ->
                                                        defaults.expr
                                                          (type.base
                                                             base.type.Z)) =>
                                               match a with
                                               | Some x' =>
                                                   match
                                                     s1 as t4
                                                     return
                                                       (Compile.value' false
                                                          t4 ->
                                                        UnderLets.UnderLets
                                                          base.type ident var
                                                          (defaults.expr
                                                             (type.base
                                                                base.type.Z)))
                                                   with
                                                   | type.base t4 =>
                                                       fun
                                                         v0 : defaults.expr
                                                                (type.base t4)
                                                       =>
                                                       base.try_make_transport_cps
                                                         (fun t5 : base.type
                                                          =>
                                                          defaults.expr
                                                            (type.base t5))
                                                         t4 base.type.Z
                                                         (UnderLets.UnderLets
                                                            base.type ident
                                                            var
                                                            (defaults.expr
                                                               (type.base
                                                                  base.type.Z)))
                                                         (fun
                                                            a0 : option
                                                                   (defaults.expr
                                                                    (type.base
                                                                    t4) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                          =>
                                                          match a0 with
                                                          | Some x'0 =>
                                                              if
                                                               args2 =?
                                                               2
                                                               ^ (2 * args0 /
                                                                  2) - 1
                                                              then
                                                               UnderLets.Base
                                                                 (#(ident.fancy_mulhl
                                                                    (2 *
                                                                    args0))%expr @
                                                                  (x' v,
                                                                  x'0 v0))%expr_pat
                                                              else
                                                               match x3 with
                                                               | #(idc3)%expr_pat =>
                                                                   match
                                                                    match
                                                                    idc3
                                                                    with
                                                                    | @ident.Literal
                                                                    t6 v1 =>
                                                                    match
                                                                    t6 as t7
                                                                    return
                                                                    (base.base_interp
                                                                    t7 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v2 : Z =>
                                                                    Some v2
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v1
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                   with
                                                                   | Some
                                                                    args3 =>
                                                                    match
                                                                    s0 as t6
                                                                    return
                                                                    (Compile.value'
                                                                    false t6 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t6 =>
                                                                    fun
                                                                    v1 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t6) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t7 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7)) t6
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a1 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t6) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a1
                                                                    with
                                                                    | Some
                                                                    x'1 =>
                                                                    match
                                                                    s2 as t7
                                                                    return
                                                                    (Compile.value'
                                                                    false t7 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t7 =>
                                                                    fun
                                                                    v2 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t7) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t8 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t8)) t7
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a2 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t7) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a2
                                                                    with
                                                                    | Some
                                                                    x'2 =>
                                                                    if
                                                                    args3 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    args0 / 2) -
                                                                    1
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulhl
                                                                    (2 *
                                                                    args0))%expr @
                                                                    (
                                                                    x'1 v1,
                                                                    x'2 v2))%expr_pat
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s3 ->
                                                                    d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x4)
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end)
                                                                    | (s3 ->
                                                                    d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                    end
                                                                    (Compile.reflect
                                                                    x2)
                                                                   | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                   end
                                                               | _ =>
                                                                   UnderLets.Base
                                                                    (x * x0)%expr
                                                               end
                                                          | None =>
                                                              UnderLets.Base
                                                                (x * x0)%expr
                                                          end)
                                                   | (s3 -> d3)%ptype =>
                                                       fun
                                                         _ : Compile.value'
                                                               false s3 ->
                                                             Compile.value'
                                                               true d3 =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end (Compile.reflect x3)
                                               | None =>
                                                   UnderLets.Base
                                                     (x * x0)%expr
                                               end)
                                        | (s3 -> d3)%ptype =>
                                            fun
                                              _ : Compile.value' false s3 ->
                                                  Compile.value' true d3 =>
                                            UnderLets.Base (x * x0)%expr
                                        end (Compile.reflect x2)
                                    | None =>
                                        match x3 with
                                        | #(idc3)%expr_pat =>
                                            match
                                              match idc3 with
                                              | @ident.Literal t4 v =>
                                                  match
                                                    t4 as t5
                                                    return
                                                      (base.base_interp t5 ->
                                                       option Z)
                                                  with
                                                  | base.type.unit =>
                                                      fun _ : unit => None
                                                  | base.type.Z =>
                                                      fun v0 : Z => Some v0
                                                  | base.type.bool =>
                                                      fun _ : bool => None
                                                  | base.type.nat =>
                                                      fun _ : nat => None
                                                  end v
                                              | _ => None
                                              end
                                            with
                                            | Some args2 =>
                                                match
                                                  s0 as t4
                                                  return
                                                    (Compile.value' false t4 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             base.type.Z)))
                                                with
                                                | type.base t4 =>
                                                    fun
                                                      v : defaults.expr
                                                            (type.base t4) =>
                                                    base.try_make_transport_cps
                                                      (fun t5 : base.type =>
                                                       defaults.expr
                                                         (type.base t5)) t4
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               base.type.Z)))
                                                      (fun
                                                         a : option
                                                               (defaults.expr
                                                                  (type.base
                                                                    t4) ->
                                                                defaults.expr
                                                                  (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a with
                                                       | Some x' =>
                                                           match
                                                             s2 as t5
                                                             return
                                                               (Compile.value'
                                                                  false t5 ->
                                                                UnderLets.UnderLets
                                                                  base.type
                                                                  ident var
                                                                  (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                           with
                                                           | type.base t5 =>
                                                               fun
                                                                 v0 : 
                                                                  defaults.expr
                                                                    (type.base
                                                                    t5) =>
                                                               base.try_make_transport_cps
                                                                 (fun
                                                                    t6 : base.type
                                                                  =>
                                                                  defaults.expr
                                                                    (type.base
                                                                    t6)) t5
                                                                 base.type.Z
                                                                 (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                 (fun
                                                                    a0 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t5) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                  =>
                                                                  match
                                                                    a0
                                                                  with
                                                                  | Some
                                                                    x'0 =>
                                                                    if
                                                                    args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    args0 / 2) -
                                                                    1
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulhl
                                                                    (2 *
                                                                    args0))%expr @
                                                                    (
                                                                    x' v,
                                                                    x'0 v0))%expr_pat
                                                                    else
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                  | None =>
                                                                    UnderLets.Base
                                                                    (x * x0)%expr
                                                                  end)
                                                           | (s3 -> d3)%ptype =>
                                                               fun
                                                                 _ : 
                                                                  Compile.value'
                                                                    false s3 ->
                                                                  Compile.value'
                                                                    true d3
                                                               =>
                                                               UnderLets.Base
                                                                 (x * x0)%expr
                                                           end
                                                             (Compile.reflect
                                                                x4)
                                                       | None =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end)
                                                | (s3 -> d3)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s3 ->
                                                          Compile.value' true
                                                            d3 =>
                                                    UnderLets.Base
                                                      (x * x0)%expr
                                                end (Compile.reflect x2)
                                            | None =>
                                                UnderLets.Base (x * x0)%expr
                                            end
                                        | _ => UnderLets.Base (x * x0)%expr
                                        end
                                    end
                                | ($_)%expr =>
                                    match x3 with
                                    | #(idc2)%expr_pat =>
                                        match
                                          match idc2 with
                                          | @ident.Literal t4 v0 =>
                                              match
                                                t4 as t5
                                                return
                                                  (base.base_interp t5 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v1 : Z => Some v1
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v0
                                          | _ => None
                                          end
                                        with
                                        | Some args2 =>
                                            match
                                              s0 as t4
                                              return
                                                (Compile.value' false t4 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base base.type.Z)))
                                            with
                                            | type.base t4 =>
                                                fun
                                                  v0 : defaults.expr
                                                         (type.base t4) =>
                                                base.try_make_transport_cps
                                                  (fun t5 : base.type =>
                                                   defaults.expr
                                                     (type.base t5)) t4
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           base.type.Z)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t4) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       match
                                                         s2 as t5
                                                         return
                                                           (Compile.value'
                                                              false t5 ->
                                                            UnderLets.UnderLets
                                                              base.type ident
                                                              var
                                                              (defaults.expr
                                                                 (type.base
                                                                    base.type.Z)))
                                                       with
                                                       | type.base t5 =>
                                                           fun
                                                             v1 : defaults.expr
                                                                    (type.base
                                                                    t5) =>
                                                           base.try_make_transport_cps
                                                             (fun
                                                                t6 : base.type
                                                              =>
                                                              defaults.expr
                                                                (type.base t6))
                                                             t5 base.type.Z
                                                             (UnderLets.UnderLets
                                                                base.type
                                                                ident var
                                                                (defaults.expr
                                                                   (type.base
                                                                    base.type.Z)))
                                                             (fun
                                                                a0 : 
                                                                 option
                                                                   (defaults.expr
                                                                    (type.base
                                                                    t5) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                              =>
                                                              match a0 with
                                                              | Some x'0 =>
                                                                  if
                                                                   args2 =?
                                                                   2
                                                                   ^ 
                                                                   (2 * args0 /
                                                                    2) - 1
                                                                  then
                                                                   UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulhl
                                                                    (2 *
                                                                    args0))%expr @
                                                                    (
                                                                    x' v0,
                                                                    x'0 v1))%expr_pat
                                                                  else
                                                                   UnderLets.Base
                                                                    (x * x0)%expr
                                                              | None =>
                                                                  UnderLets.Base
                                                                    (x * x0)%expr
                                                              end)
                                                       | (s3 -> d3)%ptype =>
                                                           fun
                                                             _ : Compile.value'
                                                                   false s3 ->
                                                                 Compile.value'
                                                                   true d3 =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end
                                                         (Compile.reflect x4)
                                                   | None =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end)
                                            | (s3 -> d3)%ptype =>
                                                fun
                                                  _ : Compile.value' false s3 ->
                                                      Compile.value' true d3
                                                =>
                                                UnderLets.Base (x * x0)%expr
                                            end (Compile.reflect x2)
                                        | None =>
                                            UnderLets.Base (x * x0)%expr
                                        end
                                    | _ => UnderLets.Base (x * x0)%expr
                                    end
                                | @expr.LetIn _ _ _ _ _ _ _ =>
                                    match x3 with
                                    | #(idc2)%expr_pat =>
                                        match
                                          match idc2 with
                                          | @ident.Literal t3 v =>
                                              match
                                                t3 as t4
                                                return
                                                  (base.base_interp t4 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v0 : Z => Some v0
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v
                                          | _ => None
                                          end
                                        with
                                        | Some args2 =>
                                            match
                                              s0 as t3
                                              return
                                                (Compile.value' false t3 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base base.type.Z)))
                                            with
                                            | type.base t3 =>
                                                fun
                                                  v : defaults.expr
                                                        (type.base t3) =>
                                                base.try_make_transport_cps
                                                  (fun t4 : base.type =>
                                                   defaults.expr
                                                     (type.base t4)) t3
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           base.type.Z)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t3) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       match
                                                         s2 as t4
                                                         return
                                                           (Compile.value'
                                                              false t4 ->
                                                            UnderLets.UnderLets
                                                              base.type ident
                                                              var
                                                              (defaults.expr
                                                                 (type.base
                                                                    base.type.Z)))
                                                       with
                                                       | type.base t4 =>
                                                           fun
                                                             v0 : defaults.expr
                                                                    (type.base
                                                                    t4) =>
                                                           base.try_make_transport_cps
                                                             (fun
                                                                t5 : base.type
                                                              =>
                                                              defaults.expr
                                                                (type.base t5))
                                                             t4 base.type.Z
                                                             (UnderLets.UnderLets
                                                                base.type
                                                                ident var
                                                                (defaults.expr
                                                                   (type.base
                                                                    base.type.Z)))
                                                             (fun
                                                                a0 : 
                                                                 option
                                                                   (defaults.expr
                                                                    (type.base
                                                                    t4) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                              =>
                                                              match a0 with
                                                              | Some x'0 =>
                                                                  if
                                                                   args2 =?
                                                                   2
                                                                   ^ 
                                                                   (2 * args0 /
                                                                    2) - 1
                                                                  then
                                                                   UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulhl
                                                                    (2 *
                                                                    args0))%expr @
                                                                    (
                                                                    x' v,
                                                                    x'0 v0))%expr_pat
                                                                  else
                                                                   UnderLets.Base
                                                                    (x * x0)%expr
                                                              | None =>
                                                                  UnderLets.Base
                                                                    (x * x0)%expr
                                                              end)
                                                       | (s3 -> d3)%ptype =>
                                                           fun
                                                             _ : Compile.value'
                                                                   false s3 ->
                                                                 Compile.value'
                                                                   true d3 =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end
                                                         (Compile.reflect x4)
                                                   | None =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end)
                                            | (s3 -> d3)%ptype =>
                                                fun
                                                  _ : Compile.value' false s3 ->
                                                      Compile.value' true d3
                                                =>
                                                UnderLets.Base (x * x0)%expr
                                            end (Compile.reflect x2)
                                        | None =>
                                            UnderLets.Base (x * x0)%expr
                                        end
                                    | _ => UnderLets.Base (x * x0)%expr
                                    end
                                | _ =>
                                    match x3 with
                                    | #(idc2)%expr_pat =>
                                        match
                                          match idc2 with
                                          | @ident.Literal t3 v =>
                                              match
                                                t3 as t4
                                                return
                                                  (base.base_interp t4 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v0 : Z => Some v0
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v
                                          | _ => None
                                          end
                                        with
                                        | Some args2 =>
                                            match
                                              s0 as t3
                                              return
                                                (Compile.value' false t3 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base base.type.Z)))
                                            with
                                            | type.base t3 =>
                                                fun
                                                  v : defaults.expr
                                                        (type.base t3) =>
                                                base.try_make_transport_cps
                                                  (fun t4 : base.type =>
                                                   defaults.expr
                                                     (type.base t4)) t3
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           base.type.Z)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t3) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       match
                                                         s2 as t4
                                                         return
                                                           (Compile.value'
                                                              false t4 ->
                                                            UnderLets.UnderLets
                                                              base.type ident
                                                              var
                                                              (defaults.expr
                                                                 (type.base
                                                                    base.type.Z)))
                                                       with
                                                       | type.base t4 =>
                                                           fun
                                                             v0 : defaults.expr
                                                                    (type.base
                                                                    t4) =>
                                                           base.try_make_transport_cps
                                                             (fun
                                                                t5 : base.type
                                                              =>
                                                              defaults.expr
                                                                (type.base t5))
                                                             t4 base.type.Z
                                                             (UnderLets.UnderLets
                                                                base.type
                                                                ident var
                                                                (defaults.expr
                                                                   (type.base
                                                                    base.type.Z)))
                                                             (fun
                                                                a0 : 
                                                                 option
                                                                   (defaults.expr
                                                                    (type.base
                                                                    t4) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                              =>
                                                              match a0 with
                                                              | Some x'0 =>
                                                                  if
                                                                   args2 =?
                                                                   2
                                                                   ^ 
                                                                   (2 * args0 /
                                                                    2) - 1
                                                                  then
                                                                   UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulhl
                                                                    (2 *
                                                                    args0))%expr @
                                                                    (
                                                                    x' v,
                                                                    x'0 v0))%expr_pat
                                                                  else
                                                                   UnderLets.Base
                                                                    (x * x0)%expr
                                                              | None =>
                                                                  UnderLets.Base
                                                                    (x * x0)%expr
                                                              end)
                                                       | (s4 -> d4)%ptype =>
                                                           fun
                                                             _ : Compile.value'
                                                                   false s4 ->
                                                                 Compile.value'
                                                                   true d4 =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end
                                                         (Compile.reflect x4)
                                                   | None =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end)
                                            | (s4 -> d4)%ptype =>
                                                fun
                                                  _ : Compile.value' false s4 ->
                                                      Compile.value' true d4
                                                =>
                                                UnderLets.Base (x * x0)%expr
                                            end (Compile.reflect x2)
                                        | None =>
                                            UnderLets.Base (x * x0)%expr
                                        end
                                    | _ => UnderLets.Base (x * x0)%expr
                                    end
                                end
                            | None =>
                                match
                                  match idc1 with
                                  | ident.Z_shiftr => Some tt
                                  | _ => None
                                  end
                                with
                                | Some _ =>
                                    match x3 with
                                    | #(idc2)%expr_pat =>
                                        match
                                          match idc2 with
                                          | @ident.Literal t3 v =>
                                              match
                                                t3 as t4
                                                return
                                                  (base.base_interp t4 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v0 : Z => Some v0
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v
                                          | _ => None
                                          end
                                        with
                                        | Some args2 =>
                                            match
                                              s0 as t3
                                              return
                                                (Compile.value' false t3 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base base.type.Z)))
                                            with
                                            | type.base t3 =>
                                                fun
                                                  v : defaults.expr
                                                        (type.base t3) =>
                                                base.try_make_transport_cps
                                                  (fun t4 : base.type =>
                                                   defaults.expr
                                                     (type.base t4)) t3
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           base.type.Z)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t3) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       match
                                                         s2 as t4
                                                         return
                                                           (Compile.value'
                                                              false t4 ->
                                                            UnderLets.UnderLets
                                                              base.type ident
                                                              var
                                                              (defaults.expr
                                                                 (type.base
                                                                    base.type.Z)))
                                                       with
                                                       | type.base t4 =>
                                                           fun
                                                             v0 : defaults.expr
                                                                    (type.base
                                                                    t4) =>
                                                           base.try_make_transport_cps
                                                             (fun
                                                                t5 : base.type
                                                              =>
                                                              defaults.expr
                                                                (type.base t5))
                                                             t4 base.type.Z
                                                             (UnderLets.UnderLets
                                                                base.type
                                                                ident var
                                                                (defaults.expr
                                                                   (type.base
                                                                    base.type.Z)))
                                                             (fun
                                                                a0 : 
                                                                 option
                                                                   (defaults.expr
                                                                    (type.base
                                                                    t4) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                              =>
                                                              match a0 with
                                                              | Some x'0 =>
                                                                  if
                                                                   args0 =?
                                                                   args2
                                                                  then
                                                                   UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulhh
                                                                    (2 *
                                                                    args0))%expr @
                                                                    (
                                                                    x' v,
                                                                    x'0 v0))%expr_pat
                                                                  else
                                                                   UnderLets.Base
                                                                    (x * x0)%expr
                                                              | None =>
                                                                  UnderLets.Base
                                                                    (x * x0)%expr
                                                              end)
                                                       | (s3 -> d3)%ptype =>
                                                           fun
                                                             _ : Compile.value'
                                                                   false s3 ->
                                                                 Compile.value'
                                                                   true d3 =>
                                                           UnderLets.Base
                                                             (x * x0)%expr
                                                       end
                                                         (Compile.reflect x4)
                                                   | None =>
                                                       UnderLets.Base
                                                         (x * x0)%expr
                                                   end)
                                            | (s3 -> d3)%ptype =>
                                                fun
                                                  _ : Compile.value' false s3 ->
                                                      Compile.value' true d3
                                                =>
                                                UnderLets.Base (x * x0)%expr
                                            end (Compile.reflect x2)
                                        | None =>
                                            UnderLets.Base (x * x0)%expr
                                        end
                                    | _ => UnderLets.Base (x * x0)%expr
                                    end
                                | None => UnderLets.Base (x * x0)%expr
                                end
                            end
                        | @expr.App _ _ _ s1 _
                          (@expr.App _ _ _ s2 _ ($_)%expr _) _ | @expr.App _
                          _ _ s1 _
                          (@expr.App _ _ _ s2 _ (@expr.Abs _ _ _ _ _ _) _)
                          _ | @expr.App _ _ _ s1 _
                          (@expr.App _ _ _ s2 _ (_ @ _)%expr_pat _) _ |
                          @expr.App _ _ _ s1 _
                          (@expr.App _ _ _ s2 _ (@expr.LetIn _ _ _ _ _ _ _)
                           _) _ => UnderLets.Base (x * x0)%expr
                        | @expr.App _ _ _ s1 _ #(_)%expr_pat _ | @expr.App _
                          _ _ s1 _ ($_)%expr _ | @expr.App _ _ _ s1 _
                          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s1 _
                          (@expr.LetIn _ _ _ _ _ _ _) _ =>
                            UnderLets.Base (x * x0)%expr
                        | _ => UnderLets.Base (x * x0)%expr
                        end
                    | None => UnderLets.Base (x * x0)%expr
                    end
                | _ => UnderLets.Base (x * x0)%expr
                end
            | None => UnderLets.Base (x * x0)%expr
            end
        end
    | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ ($_)%expr _) _ | @expr.App _
      _ _ s _ (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _) _ | @expr.App
      _ _ _ s _ (@expr.App _ _ _ s0 _ (_ @ _)%expr_pat _) _ | @expr.App _ _ _
      s _ (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _) _ =>
        UnderLets.Base (x * x0)%expr
    | @expr.App _ _ _ s _ #(_)%expr_pat _ | @expr.App _ _ _ s _ ($_)%expr _ |
      @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _
      (@expr.LetIn _ _ _ _ _ _ _) _ => UnderLets.Base (x * x0)%expr
    | _ => UnderLets.Base (x * x0)%expr
    end
| ident.Z_pow =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_pow)%expr @ x @ x0)%expr_pat
| ident.Z_sub =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (x - x0)%expr
| ident.Z_opp =>
    fun x : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (- x)%expr
| ident.Z_div =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (x / x0)%expr
| ident.Z_modulo =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (x mod x0)%expr
| ident.Z_log2 =>
    fun x : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_log2)%expr @ x)%expr_pat
| ident.Z_log2_up =>
    fun x : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_log2_up)%expr @ x)%expr_pat
| ident.Z_eqb =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_eqb)%expr @ x @ x0)%expr_pat
| ident.Z_leb =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_leb)%expr @ x @ x0)%expr_pat
| ident.Z_geb =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_geb)%expr @ x @ x0)%expr_pat
| ident.Z_of_nat =>
    fun x : defaults.expr (type.base base.type.nat) =>
    UnderLets.Base (#(ident.Z_of_nat)%expr @ x)%expr_pat
| ident.Z_to_nat =>
    fun x : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_to_nat)%expr @ x)%expr_pat
| ident.Z_shiftr =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (x >> x0)%expr
| ident.Z_shiftl =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (x << x0)%expr
| ident.Z_land =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (x &' x0)%expr
| ident.Z_lor =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (x || x0)%expr
| ident.Z_bneg =>
    fun x : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_bneg)%expr @ x)%expr_pat
| ident.Z_lnot_modulo =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_lnot_modulo)%expr @ x @ x0)%expr_pat
| ident.Z_mul_split =>
    fun x x0 x1 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_mul_split)%expr @ x @ x0 @ x1)%expr_pat
| ident.Z_add_get_carry =>
    fun x x0 x1 : defaults.expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            match x1 with
            | #(_)%expr_pat =>
                match x0 with
                | (@expr.App _ _ _ s0 _ #(idc1) x3 @ x2)%expr_pat =>
                    match
                      match idc1 with
                      | ident.Z_shiftl => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match x2 with
                        | #(idc2)%expr_pat =>
                            match
                              match idc2 with
                              | @ident.Literal t3 v =>
                                  match
                                    t3 as t4
                                    return (base.base_interp t4 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v0 : Z => Some v0
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                match
                                  s0 as t3
                                  return
                                    (Compile.value' false t3 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)))
                                with
                                | type.base t3 =>
                                    fun v : defaults.expr (type.base t3) =>
                                    base.try_make_transport_cps
                                      (fun t4 : base.type =>
                                       defaults.expr (type.base t4)) t3
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base
                                               (base.type.Z * base.type.Z)%etype)))
                                      (fun
                                         a : option
                                               (defaults.expr (type.base t3) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                       match a with
                                       | Some x' =>
                                           if args =? 2 ^ Z.log2 args
                                           then
                                            UnderLets.Base
                                              (#(ident.fancy_add
                                                   (Z.log2 args) args1)%expr @
                                               (x1, x' v))%expr_pat
                                           else
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_add
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_get_carry)%expr @
                                                x @ x0 @ x1)%expr_pat
                                       | None =>
                                           UnderLets.Base
                                             (#(ident.Z_add_get_carry)%expr @
                                              x @ x0 @ x1)%expr_pat
                                       end)
                                | (s1 -> d1)%ptype =>
                                    fun
                                      _ : Compile.value' false s1 ->
                                          Compile.value' true d1 =>
                                    UnderLets.Base
                                      (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                       x1)%expr_pat
                                end (Compile.reflect x3)
                            | None =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                    (x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                    x1)%expr_pat
                            end
                        | _ =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                (x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                        end
                    | None =>
                        match
                          match idc1 with
                          | ident.Z_shiftr => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match x2 with
                            | #(idc2)%expr_pat =>
                                match
                                  match idc2 with
                                  | @ident.Literal t3 v =>
                                      match
                                        t3 as t4
                                        return
                                          (base.base_interp t4 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s0 as t3
                                      return
                                        (Compile.value' false t3 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t3 =>
                                        fun v : defaults.expr (type.base t3)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t4 : base.type =>
                                           defaults.expr (type.base t4)) t3
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t3) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_add
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x1, x' v))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_add
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_get_carry)%expr @
                                                    x @ x0 @ x1)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_get_carry)%expr @
                                                  x @ x0 @ x1)%expr_pat
                                           end)
                                    | (s1 -> d1)%ptype =>
                                        fun
                                          _ : Compile.value' false s1 ->
                                              Compile.value' true d1 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_get_carry)%expr @ x @
                                           x0 @ x1)%expr_pat
                                    end (Compile.reflect x3)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                        (x0, x1))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_get_carry)%expr @ x @
                                        x0 @ x1)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                    (x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                    x1)%expr_pat
                            end
                        | None =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                (x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                        end
                    end
                | (@expr.App _ _ _ s0 _ ($_)%expr _ @ _)%expr_pat |
                  (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s0 _ (_ @ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_add (Z.log2 args) 0)%expr @ (x0, x1))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                | _ =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_add (Z.log2 args) 0)%expr @ (x0, x1))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                end
            | ($_)%expr =>
                match x0 with
                | (@expr.App _ _ _ s0 _ #(idc0) x3 @ x2)%expr_pat =>
                    match
                      match idc0 with
                      | ident.Z_shiftl => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match x2 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t3 v0 =>
                                  match
                                    t3 as t4
                                    return (base.base_interp t4 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v1 : Z => Some v1
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v0
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                match
                                  s0 as t3
                                  return
                                    (Compile.value' false t3 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)))
                                with
                                | type.base t3 =>
                                    fun v0 : defaults.expr (type.base t3) =>
                                    base.try_make_transport_cps
                                      (fun t4 : base.type =>
                                       defaults.expr (type.base t4)) t3
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base
                                               (base.type.Z * base.type.Z)%etype)))
                                      (fun
                                         a : option
                                               (defaults.expr (type.base t3) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                       match a with
                                       | Some x' =>
                                           if args =? 2 ^ Z.log2 args
                                           then
                                            UnderLets.Base
                                              (#(ident.fancy_add
                                                   (Z.log2 args) args1)%expr @
                                               (x1, x' v0))%expr_pat
                                           else
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_add
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_get_carry)%expr @
                                                x @ x0 @ x1)%expr_pat
                                       | None =>
                                           UnderLets.Base
                                             (#(ident.Z_add_get_carry)%expr @
                                              x @ x0 @ x1)%expr_pat
                                       end)
                                | (s1 -> d1)%ptype =>
                                    fun
                                      _ : Compile.value' false s1 ->
                                          Compile.value' true d1 =>
                                    UnderLets.Base
                                      (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                       x1)%expr_pat
                                end (Compile.reflect x3)
                            | None =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                    (x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                    x1)%expr_pat
                            end
                        | _ =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                (x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                        end
                    | None =>
                        match
                          match idc0 with
                          | ident.Z_shiftr => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match x2 with
                            | #(idc1)%expr_pat =>
                                match
                                  match idc1 with
                                  | @ident.Literal t3 v0 =>
                                      match
                                        t3 as t4
                                        return
                                          (base.base_interp t4 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v1 : Z => Some v1
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v0
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s0 as t3
                                      return
                                        (Compile.value' false t3 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t3 =>
                                        fun v0 : defaults.expr (type.base t3)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t4 : base.type =>
                                           defaults.expr (type.base t4)) t3
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t3) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_add
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x1, x' v0))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_add
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_get_carry)%expr @
                                                    x @ x0 @ x1)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_get_carry)%expr @
                                                  x @ x0 @ x1)%expr_pat
                                           end)
                                    | (s1 -> d1)%ptype =>
                                        fun
                                          _ : Compile.value' false s1 ->
                                              Compile.value' true d1 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_get_carry)%expr @ x @
                                           x0 @ x1)%expr_pat
                                    end (Compile.reflect x3)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                        (x0, x1))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_get_carry)%expr @ x @
                                        x0 @ x1)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                    (x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                    x1)%expr_pat
                            end
                        | None =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                (x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                        end
                    end
                | (@expr.App _ _ _ s0 _ ($_)%expr _ @ _)%expr_pat |
                  (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s0 _ (_ @ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_add (Z.log2 args) 0)%expr @ (x0, x1))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                | _ =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_add (Z.log2 args) 0)%expr @ (x0, x1))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                end
            | @expr.Abs _ _ _ _ _ _ =>
                match x0 with
                | (@expr.App _ _ _ s1 _ #(idc0) x3 @ x2)%expr_pat =>
                    match
                      match idc0 with
                      | ident.Z_shiftl => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match x2 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t2 v =>
                                  match
                                    t2 as t3
                                    return (base.base_interp t3 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v0 : Z => Some v0
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                match
                                  s1 as t2
                                  return
                                    (Compile.value' false t2 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)))
                                with
                                | type.base t2 =>
                                    fun v : defaults.expr (type.base t2) =>
                                    base.try_make_transport_cps
                                      (fun t3 : base.type =>
                                       defaults.expr (type.base t3)) t2
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base
                                               (base.type.Z * base.type.Z)%etype)))
                                      (fun
                                         a : option
                                               (defaults.expr (type.base t2) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                       match a with
                                       | Some x' =>
                                           if args =? 2 ^ Z.log2 args
                                           then
                                            UnderLets.Base
                                              (#(ident.fancy_add
                                                   (Z.log2 args) args1)%expr @
                                               (x1, x' v))%expr_pat
                                           else
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_add
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_get_carry)%expr @
                                                x @ x0 @ x1)%expr_pat
                                       | None =>
                                           UnderLets.Base
                                             (#(ident.Z_add_get_carry)%expr @
                                              x @ x0 @ x1)%expr_pat
                                       end)
                                | (s2 -> d2)%ptype =>
                                    fun
                                      _ : Compile.value' false s2 ->
                                          Compile.value' true d2 =>
                                    UnderLets.Base
                                      (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                       x1)%expr_pat
                                end (Compile.reflect x3)
                            | None =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                    (x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                    x1)%expr_pat
                            end
                        | _ =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                (x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                        end
                    | None =>
                        match
                          match idc0 with
                          | ident.Z_shiftr => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match x2 with
                            | #(idc1)%expr_pat =>
                                match
                                  match idc1 with
                                  | @ident.Literal t2 v =>
                                      match
                                        t2 as t3
                                        return
                                          (base.base_interp t3 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s1 as t2
                                      return
                                        (Compile.value' false t2 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t2 =>
                                        fun v : defaults.expr (type.base t2)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t3 : base.type =>
                                           defaults.expr (type.base t3)) t2
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t2) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_add
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x1, x' v))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_add
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_get_carry)%expr @
                                                    x @ x0 @ x1)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_get_carry)%expr @
                                                  x @ x0 @ x1)%expr_pat
                                           end)
                                    | (s2 -> d2)%ptype =>
                                        fun
                                          _ : Compile.value' false s2 ->
                                              Compile.value' true d2 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_get_carry)%expr @ x @
                                           x0 @ x1)%expr_pat
                                    end (Compile.reflect x3)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                        (x0, x1))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_get_carry)%expr @ x @
                                        x0 @ x1)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                    (x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                    x1)%expr_pat
                            end
                        | None =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                (x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                        end
                    end
                | (@expr.App _ _ _ s1 _ ($_)%expr _ @ _)%expr_pat |
                  (@expr.App _ _ _ s1 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s1 _ (_ @ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s1 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_add (Z.log2 args) 0)%expr @ (x0, x1))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                | _ =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_add (Z.log2 args) 0)%expr @ (x0, x1))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                end
            | (#(_) @ _)%expr_pat =>
                match x0 with
                | (@expr.App _ _ _ s1 _ #(idc1) x4 @ x3)%expr_pat =>
                    match
                      match idc1 with
                      | ident.Z_shiftl => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match x3 with
                        | #(idc2)%expr_pat =>
                            match
                              match idc2 with
                              | @ident.Literal t3 v =>
                                  match
                                    t3 as t4
                                    return (base.base_interp t4 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v0 : Z => Some v0
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                match
                                  s1 as t3
                                  return
                                    (Compile.value' false t3 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)))
                                with
                                | type.base t3 =>
                                    fun v : defaults.expr (type.base t3) =>
                                    base.try_make_transport_cps
                                      (fun t4 : base.type =>
                                       defaults.expr (type.base t4)) t3
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base
                                               (base.type.Z * base.type.Z)%etype)))
                                      (fun
                                         a : option
                                               (defaults.expr (type.base t3) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                       match a with
                                       | Some x' =>
                                           if args =? 2 ^ Z.log2 args
                                           then
                                            UnderLets.Base
                                              (#(ident.fancy_add
                                                   (Z.log2 args) args1)%expr @
                                               (x1, x' v))%expr_pat
                                           else
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_add
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_get_carry)%expr @
                                                x @ x0 @ x1)%expr_pat
                                       | None =>
                                           UnderLets.Base
                                             (#(ident.Z_add_get_carry)%expr @
                                              x @ x0 @ x1)%expr_pat
                                       end)
                                | (s2 -> d2)%ptype =>
                                    fun
                                      _ : Compile.value' false s2 ->
                                          Compile.value' true d2 =>
                                    UnderLets.Base
                                      (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                       x1)%expr_pat
                                end (Compile.reflect x4)
                            | None =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                    (x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                    x1)%expr_pat
                            end
                        | _ =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                (x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                        end
                    | None =>
                        match
                          match idc1 with
                          | ident.Z_shiftr => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match x3 with
                            | #(idc2)%expr_pat =>
                                match
                                  match idc2 with
                                  | @ident.Literal t3 v =>
                                      match
                                        t3 as t4
                                        return
                                          (base.base_interp t4 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s1 as t3
                                      return
                                        (Compile.value' false t3 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t3 =>
                                        fun v : defaults.expr (type.base t3)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t4 : base.type =>
                                           defaults.expr (type.base t4)) t3
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t3) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_add
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x1, x' v))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_add
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_get_carry)%expr @
                                                    x @ x0 @ x1)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_get_carry)%expr @
                                                  x @ x0 @ x1)%expr_pat
                                           end)
                                    | (s2 -> d2)%ptype =>
                                        fun
                                          _ : Compile.value' false s2 ->
                                              Compile.value' true d2 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_get_carry)%expr @ x @
                                           x0 @ x1)%expr_pat
                                    end (Compile.reflect x4)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                        (x0, x1))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_get_carry)%expr @ x @
                                        x0 @ x1)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                    (x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                    x1)%expr_pat
                            end
                        | None =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                (x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                        end
                    end
                | (@expr.App _ _ _ s1 _ ($_)%expr _ @ _)%expr_pat |
                  (@expr.App _ _ _ s1 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s1 _ (_ @ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s1 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_add (Z.log2 args) 0)%expr @ (x0, x1))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                | _ =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_add (Z.log2 args) 0)%expr @ (x0, x1))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                end
            | (($_)%expr @ _)%expr_pat =>
                match x0 with
                | (@expr.App _ _ _ s1 _ #(idc0) x4 @ x3)%expr_pat =>
                    match
                      match idc0 with
                      | ident.Z_shiftl => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match x3 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t3 v0 =>
                                  match
                                    t3 as t4
                                    return (base.base_interp t4 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v1 : Z => Some v1
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v0
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                match
                                  s1 as t3
                                  return
                                    (Compile.value' false t3 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)))
                                with
                                | type.base t3 =>
                                    fun v0 : defaults.expr (type.base t3) =>
                                    base.try_make_transport_cps
                                      (fun t4 : base.type =>
                                       defaults.expr (type.base t4)) t3
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base
                                               (base.type.Z * base.type.Z)%etype)))
                                      (fun
                                         a : option
                                               (defaults.expr (type.base t3) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                       match a with
                                       | Some x' =>
                                           if args =? 2 ^ Z.log2 args
                                           then
                                            UnderLets.Base
                                              (#(ident.fancy_add
                                                   (Z.log2 args) args1)%expr @
                                               (x1, x' v0))%expr_pat
                                           else
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_add
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_get_carry)%expr @
                                                x @ x0 @ x1)%expr_pat
                                       | None =>
                                           UnderLets.Base
                                             (#(ident.Z_add_get_carry)%expr @
                                              x @ x0 @ x1)%expr_pat
                                       end)
                                | (s2 -> d2)%ptype =>
                                    fun
                                      _ : Compile.value' false s2 ->
                                          Compile.value' true d2 =>
                                    UnderLets.Base
                                      (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                       x1)%expr_pat
                                end (Compile.reflect x4)
                            | None =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                    (x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                    x1)%expr_pat
                            end
                        | _ =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                (x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                        end
                    | None =>
                        match
                          match idc0 with
                          | ident.Z_shiftr => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match x3 with
                            | #(idc1)%expr_pat =>
                                match
                                  match idc1 with
                                  | @ident.Literal t3 v0 =>
                                      match
                                        t3 as t4
                                        return
                                          (base.base_interp t4 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v1 : Z => Some v1
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v0
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s1 as t3
                                      return
                                        (Compile.value' false t3 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t3 =>
                                        fun v0 : defaults.expr (type.base t3)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t4 : base.type =>
                                           defaults.expr (type.base t4)) t3
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t3) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_add
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x1, x' v0))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_add
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_get_carry)%expr @
                                                    x @ x0 @ x1)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_get_carry)%expr @
                                                  x @ x0 @ x1)%expr_pat
                                           end)
                                    | (s2 -> d2)%ptype =>
                                        fun
                                          _ : Compile.value' false s2 ->
                                              Compile.value' true d2 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_get_carry)%expr @ x @
                                           x0 @ x1)%expr_pat
                                    end (Compile.reflect x4)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                        (x0, x1))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_get_carry)%expr @ x @
                                        x0 @ x1)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                    (x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                    x1)%expr_pat
                            end
                        | None =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                (x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                        end
                    end
                | (@expr.App _ _ _ s1 _ ($_)%expr _ @ _)%expr_pat |
                  (@expr.App _ _ _ s1 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s1 _ (_ @ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s1 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_add (Z.log2 args) 0)%expr @ (x0, x1))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                | _ =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_add (Z.log2 args) 0)%expr @ (x0, x1))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                end
            | (@expr.Abs _ _ _ _ _ _ @ _)%expr_pat =>
                match x0 with
                | (@expr.App _ _ _ s2 _ #(idc0) x4 @ x3)%expr_pat =>
                    match
                      match idc0 with
                      | ident.Z_shiftl => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match x3 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t2 v =>
                                  match
                                    t2 as t3
                                    return (base.base_interp t3 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v0 : Z => Some v0
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                match
                                  s2 as t2
                                  return
                                    (Compile.value' false t2 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)))
                                with
                                | type.base t2 =>
                                    fun v : defaults.expr (type.base t2) =>
                                    base.try_make_transport_cps
                                      (fun t3 : base.type =>
                                       defaults.expr (type.base t3)) t2
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base
                                               (base.type.Z * base.type.Z)%etype)))
                                      (fun
                                         a : option
                                               (defaults.expr (type.base t2) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                       match a with
                                       | Some x' =>
                                           if args =? 2 ^ Z.log2 args
                                           then
                                            UnderLets.Base
                                              (#(ident.fancy_add
                                                   (Z.log2 args) args1)%expr @
                                               (x1, x' v))%expr_pat
                                           else
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_add
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_get_carry)%expr @
                                                x @ x0 @ x1)%expr_pat
                                       | None =>
                                           UnderLets.Base
                                             (#(ident.Z_add_get_carry)%expr @
                                              x @ x0 @ x1)%expr_pat
                                       end)
                                | (s3 -> d3)%ptype =>
                                    fun
                                      _ : Compile.value' false s3 ->
                                          Compile.value' true d3 =>
                                    UnderLets.Base
                                      (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                       x1)%expr_pat
                                end (Compile.reflect x4)
                            | None =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                    (x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                    x1)%expr_pat
                            end
                        | _ =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                (x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                        end
                    | None =>
                        match
                          match idc0 with
                          | ident.Z_shiftr => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match x3 with
                            | #(idc1)%expr_pat =>
                                match
                                  match idc1 with
                                  | @ident.Literal t2 v =>
                                      match
                                        t2 as t3
                                        return
                                          (base.base_interp t3 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s2 as t2
                                      return
                                        (Compile.value' false t2 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t2 =>
                                        fun v : defaults.expr (type.base t2)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t3 : base.type =>
                                           defaults.expr (type.base t3)) t2
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t2) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_add
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x1, x' v))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_add
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_get_carry)%expr @
                                                    x @ x0 @ x1)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_get_carry)%expr @
                                                  x @ x0 @ x1)%expr_pat
                                           end)
                                    | (s3 -> d3)%ptype =>
                                        fun
                                          _ : Compile.value' false s3 ->
                                              Compile.value' true d3 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_get_carry)%expr @ x @
                                           x0 @ x1)%expr_pat
                                    end (Compile.reflect x4)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                        (x0, x1))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_get_carry)%expr @ x @
                                        x0 @ x1)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                    (x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                    x1)%expr_pat
                            end
                        | None =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                (x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                        end
                    end
                | (@expr.App _ _ _ s2 _ ($_)%expr _ @ _)%expr_pat |
                  (@expr.App _ _ _ s2 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s2 _ (_ @ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s2 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_add (Z.log2 args) 0)%expr @ (x0, x1))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                | _ =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_add (Z.log2 args) 0)%expr @ (x0, x1))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                end
            | (@expr.App _ _ _ s0 _ #(idc0) x3 @ x2)%expr_pat =>
                match
                  match idc0 with
                  | ident.Z_shiftl => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match x2 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args1 =>
                            match
                              s0 as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (defaults.expr
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)))
                            with
                            | type.base t2 =>
                                fun v : defaults.expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t3 : base.type =>
                                   defaults.expr (type.base t3)) t2
                                  base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (defaults.expr
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)))
                                  (fun
                                     a : option
                                           (defaults.expr (type.base t2) ->
                                            defaults.expr
                                              (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       if args =? 2 ^ Z.log2 args
                                       then
                                        UnderLets.Base
                                          (#(ident.fancy_add (Z.log2 args)
                                               args1)%expr @ (x0, x' v))%expr_pat
                                       else
                                        match x0 with
                                        | (@expr.App _ _ _ s2 _ #(idc2) x5 @
                                           x4)%expr_pat =>
                                            match
                                              match idc2 with
                                              | ident.Z_shiftl => Some tt
                                              | _ => None
                                              end
                                            with
                                            | Some _ =>
                                                match x4 with
                                                | #(idc3)%expr_pat =>
                                                    match
                                                      match idc3 with
                                                      | @ident.Literal t5
                                                        v0 =>
                                                          match
                                                            t5 as t6
                                                            return
                                                              (base.base_interp
                                                                 t6 ->
                                                               option Z)
                                                          with
                                                          | base.type.unit =>
                                                              fun _ : unit =>
                                                              None
                                                          | base.type.Z =>
                                                              fun v1 : Z =>
                                                              Some v1
                                                          | base.type.bool =>
                                                              fun _ : bool =>
                                                              None
                                                          | base.type.nat =>
                                                              fun _ : nat =>
                                                              None
                                                          end v0
                                                      | _ => None
                                                      end
                                                    with
                                                    | Some args3 =>
                                                        match
                                                          s2 as t5
                                                          return
                                                            (Compile.value'
                                                               false t5 ->
                                                             UnderLets.UnderLets
                                                               base.type
                                                               ident var
                                                               (defaults.expr
                                                                  (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)))
                                                        with
                                                        | type.base t5 =>
                                                            fun
                                                              v0 : defaults.expr
                                                                    (type.base
                                                                    t5) =>
                                                            base.try_make_transport_cps
                                                              (fun
                                                                 t6 : base.type
                                                               =>
                                                               defaults.expr
                                                                 (type.base
                                                                    t6)) t5
                                                              base.type.Z
                                                              (UnderLets.UnderLets
                                                                 base.type
                                                                 ident var
                                                                 (defaults.expr
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)))
                                                              (fun
                                                                 a0 : 
                                                                  option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t5) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                               =>
                                                               match a0 with
                                                               | Some x'0 =>
                                                                   if
                                                                    args =?
                                                                    2
                                                                    ^ 
                                                                    Z.log2
                                                                    args
                                                                   then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_add
                                                                    (Z.log2
                                                                    args)
                                                                    args3)%expr @
                                                                    (x1,
                                                                    x'0 v0))%expr_pat
                                                                   else
                                                                    if
                                                                    args =?
                                                                    2
                                                                    ^ 
                                                                    Z.log2
                                                                    args
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_add
                                                                    (Z.log2
                                                                    args) 0)%expr @
                                                                    (x0, x1))%expr_pat
                                                                    else
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.Z_add_get_carry)%expr @
                                                                    x @ x0 @
                                                                    x1)%expr_pat
                                                               | None =>
                                                                   UnderLets.Base
                                                                    (#
                                                                    (ident.Z_add_get_carry)%expr @
                                                                    x @ x0 @
                                                                    x1)%expr_pat
                                                               end)
                                                        | (s3 -> d3)%ptype =>
                                                            fun
                                                              _ : Compile.value'
                                                                    false s3 ->
                                                                  Compile.value'
                                                                    true d3
                                                            =>
                                                            UnderLets.Base
                                                              (#(ident.Z_add_get_carry)%expr @
                                                               x @ x0 @ x1)%expr_pat
                                                        end
                                                          (Compile.reflect x5)
                                                    | None =>
                                                        if
                                                         args =?
                                                         2 ^ Z.log2 args
                                                        then
                                                         UnderLets.Base
                                                           (#(ident.fancy_add
                                                                (Z.log2 args)
                                                                0)%expr @
                                                            (x0, x1))%expr_pat
                                                        else
                                                         UnderLets.Base
                                                           (#(ident.Z_add_get_carry)%expr @
                                                            x @ x0 @ x1)%expr_pat
                                                    end
                                                | _ =>
                                                    if
                                                     args =? 2 ^ Z.log2 args
                                                    then
                                                     UnderLets.Base
                                                       (#(ident.fancy_add
                                                            (Z.log2 args) 0)%expr @
                                                        (x0, x1))%expr_pat
                                                    else
                                                     UnderLets.Base
                                                       (#(ident.Z_add_get_carry)%expr @
                                                        x @ x0 @ x1)%expr_pat
                                                end
                                            | None =>
                                                match
                                                  match idc2 with
                                                  | ident.Z_shiftr => Some tt
                                                  | _ => None
                                                  end
                                                with
                                                | Some _ =>
                                                    match x4 with
                                                    | #(idc3)%expr_pat =>
                                                        match
                                                          match idc3 with
                                                          | @ident.Literal t5
                                                            v0 =>
                                                              match
                                                                t5 as t6
                                                                return
                                                                  (base.base_interp
                                                                    t6 ->
                                                                   option Z)
                                                              with
                                                              | base.type.unit =>
                                                                  fun
                                                                    _ : unit
                                                                  => None
                                                              | base.type.Z =>
                                                                  fun v1 : Z
                                                                  => 
                                                                  Some v1
                                                              | base.type.bool =>
                                                                  fun
                                                                    _ : bool
                                                                  => None
                                                              | base.type.nat =>
                                                                  fun _ : nat
                                                                  => None
                                                              end v0
                                                          | _ => None
                                                          end
                                                        with
                                                        | Some args3 =>
                                                            match
                                                              s2 as t5
                                                              return
                                                                (Compile.value'
                                                                   false t5 ->
                                                                 UnderLets.UnderLets
                                                                   base.type
                                                                   ident var
                                                                   (defaults.expr
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)))
                                                            with
                                                            | type.base t5 =>
                                                                fun
                                                                  v0 : 
                                                                   defaults.expr
                                                                    (type.base
                                                                    t5) =>
                                                                base.try_make_transport_cps
                                                                  (fun
                                                                    t6 : base.type
                                                                   =>
                                                                   defaults.expr
                                                                    (type.base
                                                                    t6)) t5
                                                                  base.type.Z
                                                                  (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)))
                                                                  (fun
                                                                    a0 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t5) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                   =>
                                                                   match
                                                                    a0
                                                                   with
                                                                   | Some
                                                                    x'0 =>
                                                                    if
                                                                    args =?
                                                                    2
                                                                    ^ 
                                                                    Z.log2
                                                                    args
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_add
                                                                    (Z.log2
                                                                    args)
                                                                    (- args3))%expr @
                                                                    (x1,
                                                                    x'0 v0))%expr_pat
                                                                    else
                                                                    if
                                                                    args =?
                                                                    2
                                                                    ^ 
                                                                    Z.log2
                                                                    args
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_add
                                                                    (Z.log2
                                                                    args) 0)%expr @
                                                                    (x0, x1))%expr_pat
                                                                    else
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.Z_add_get_carry)%expr @
                                                                    x @ x0 @
                                                                    x1)%expr_pat
                                                                   | None =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.Z_add_get_carry)%expr @
                                                                    x @ x0 @
                                                                    x1)%expr_pat
                                                                   end)
                                                            | (s3 -> d3)%ptype =>
                                                                fun
                                                                  _ : 
                                                                   Compile.value'
                                                                    false s3 ->
                                                                   Compile.value'
                                                                    true d3
                                                                =>
                                                                UnderLets.Base
                                                                  (#(ident.Z_add_get_carry)%expr @
                                                                   x @ x0 @
                                                                   x1)%expr_pat
                                                            end
                                                              (Compile.reflect
                                                                 x5)
                                                        | None =>
                                                            if
                                                             args =?
                                                             2 ^ Z.log2 args
                                                            then
                                                             UnderLets.Base
                                                               (#(ident.fancy_add
                                                                    (Z.log2
                                                                    args) 0)%expr @
                                                                (x0, x1))%expr_pat
                                                            else
                                                             UnderLets.Base
                                                               (#(ident.Z_add_get_carry)%expr @
                                                                x @ x0 @ x1)%expr_pat
                                                        end
                                                    | _ =>
                                                        if
                                                         args =?
                                                         2 ^ Z.log2 args
                                                        then
                                                         UnderLets.Base
                                                           (#(ident.fancy_add
                                                                (Z.log2 args)
                                                                0)%expr @
                                                            (x0, x1))%expr_pat
                                                        else
                                                         UnderLets.Base
                                                           (#(ident.Z_add_get_carry)%expr @
                                                            x @ x0 @ x1)%expr_pat
                                                    end
                                                | None =>
                                                    if
                                                     args =? 2 ^ Z.log2 args
                                                    then
                                                     UnderLets.Base
                                                       (#(ident.fancy_add
                                                            (Z.log2 args) 0)%expr @
                                                        (x0, x1))%expr_pat
                                                    else
                                                     UnderLets.Base
                                                       (#(ident.Z_add_get_carry)%expr @
                                                        x @ x0 @ x1)%expr_pat
                                                end
                                            end
                                        | (@expr.App _ _ _ s2 _ ($_)%expr _ @
                                           _)%expr_pat |
                                          (@expr.App _ _ _ s2 _
                                           (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                                          (@expr.App _ _ _ s2 _ (_ @ _) _ @ _)%expr_pat |
                                          (@expr.App _ _ _ s2 _
                                           (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_add
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_get_carry)%expr @
                                                x @ x0 @ x1)%expr_pat
                                        | _ =>
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_add
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_get_carry)%expr @
                                                x @ x0 @ x1)%expr_pat
                                        end
                                   | None =>
                                       UnderLets.Base
                                         (#(ident.Z_add_get_carry)%expr @ x @
                                          x0 @ x1)%expr_pat
                                   end)
                            | (s1 -> d1)%ptype =>
                                fun
                                  _ : Compile.value' false s1 ->
                                      Compile.value' true d1 =>
                                UnderLets.Base
                                  (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                   x1)%expr_pat
                            end (Compile.reflect x3)
                        | None =>
                            match x0 with
                            | (@expr.App _ _ _ s2 _ #(idc2) x5 @ x4)%expr_pat =>
                                match
                                  match idc2 with
                                  | ident.Z_shiftl => Some tt
                                  | _ => None
                                  end
                                with
                                | Some _ =>
                                    match x4 with
                                    | #(idc3)%expr_pat =>
                                        match
                                          match idc3 with
                                          | @ident.Literal t4 v =>
                                              match
                                                t4 as t5
                                                return
                                                  (base.base_interp t5 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v0 : Z => Some v0
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v
                                          | _ => None
                                          end
                                        with
                                        | Some args2 =>
                                            match
                                              s2 as t4
                                              return
                                                (Compile.value' false t4 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base
                                                         (base.type.Z *
                                                          base.type.Z)%etype)))
                                            with
                                            | type.base t4 =>
                                                fun
                                                  v : defaults.expr
                                                        (type.base t4) =>
                                                base.try_make_transport_cps
                                                  (fun t5 : base.type =>
                                                   defaults.expr
                                                     (type.base t5)) t4
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           (base.type.Z *
                                                            base.type.Z)%etype)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t4) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       if
                                                        args =?
                                                        2 ^ Z.log2 args
                                                       then
                                                        UnderLets.Base
                                                          (#(ident.fancy_add
                                                               (Z.log2 args)
                                                               args2)%expr @
                                                           (x1, x' v))%expr_pat
                                                       else
                                                        if
                                                         args =?
                                                         2 ^ Z.log2 args
                                                        then
                                                         UnderLets.Base
                                                           (#(ident.fancy_add
                                                                (Z.log2 args)
                                                                0)%expr @
                                                            (x0, x1))%expr_pat
                                                        else
                                                         UnderLets.Base
                                                           (#(ident.Z_add_get_carry)%expr @
                                                            x @ x0 @ x1)%expr_pat
                                                   | None =>
                                                       UnderLets.Base
                                                         (#(ident.Z_add_get_carry)%expr @
                                                          x @ x0 @ x1)%expr_pat
                                                   end)
                                            | (s3 -> d3)%ptype =>
                                                fun
                                                  _ : Compile.value' false s3 ->
                                                      Compile.value' true d3
                                                =>
                                                UnderLets.Base
                                                  (#(ident.Z_add_get_carry)%expr @
                                                   x @ x0 @ x1)%expr_pat
                                            end (Compile.reflect x5)
                                        | None =>
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_add
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_get_carry)%expr @
                                                x @ x0 @ x1)%expr_pat
                                        end
                                    | _ =>
                                        if args =? 2 ^ Z.log2 args
                                        then
                                         UnderLets.Base
                                           (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                            (x0, x1))%expr_pat
                                        else
                                         UnderLets.Base
                                           (#(ident.Z_add_get_carry)%expr @ x @
                                            x0 @ x1)%expr_pat
                                    end
                                | None =>
                                    match
                                      match idc2 with
                                      | ident.Z_shiftr => Some tt
                                      | _ => None
                                      end
                                    with
                                    | Some _ =>
                                        match x4 with
                                        | #(idc3)%expr_pat =>
                                            match
                                              match idc3 with
                                              | @ident.Literal t4 v =>
                                                  match
                                                    t4 as t5
                                                    return
                                                      (base.base_interp t5 ->
                                                       option Z)
                                                  with
                                                  | base.type.unit =>
                                                      fun _ : unit => None
                                                  | base.type.Z =>
                                                      fun v0 : Z => Some v0
                                                  | base.type.bool =>
                                                      fun _ : bool => None
                                                  | base.type.nat =>
                                                      fun _ : nat => None
                                                  end v
                                              | _ => None
                                              end
                                            with
                                            | Some args2 =>
                                                match
                                                  s2 as t4
                                                  return
                                                    (Compile.value' false t4 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             (base.type.Z *
                                                              base.type.Z)%etype)))
                                                with
                                                | type.base t4 =>
                                                    fun
                                                      v : defaults.expr
                                                            (type.base t4) =>
                                                    base.try_make_transport_cps
                                                      (fun t5 : base.type =>
                                                       defaults.expr
                                                         (type.base t5)) t4
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               (base.type.Z *
                                                                base.type.Z)%etype)))
                                                      (fun
                                                         a : option
                                                               (defaults.expr
                                                                  (type.base
                                                                    t4) ->
                                                                defaults.expr
                                                                  (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a with
                                                       | Some x' =>
                                                           if
                                                            args =?
                                                            2 ^ Z.log2 args
                                                           then
                                                            UnderLets.Base
                                                              (#(ident.fancy_add
                                                                   (Z.log2
                                                                    args)
                                                                   (- args2))%expr @
                                                               (x1, x' v))%expr_pat
                                                           else
                                                            if
                                                             args =?
                                                             2 ^ Z.log2 args
                                                            then
                                                             UnderLets.Base
                                                               (#(ident.fancy_add
                                                                    (Z.log2
                                                                    args) 0)%expr @
                                                                (x0, x1))%expr_pat
                                                            else
                                                             UnderLets.Base
                                                               (#(ident.Z_add_get_carry)%expr @
                                                                x @ x0 @ x1)%expr_pat
                                                       | None =>
                                                           UnderLets.Base
                                                             (#(ident.Z_add_get_carry)%expr @
                                                              x @ x0 @ x1)%expr_pat
                                                       end)
                                                | (s3 -> d3)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s3 ->
                                                          Compile.value' true
                                                            d3 =>
                                                    UnderLets.Base
                                                      (#(ident.Z_add_get_carry)%expr @
                                                       x @ x0 @ x1)%expr_pat
                                                end (Compile.reflect x5)
                                            | None =>
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_add
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_get_carry)%expr @
                                                    x @ x0 @ x1)%expr_pat
                                            end
                                        | _ =>
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_add
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_get_carry)%expr @
                                                x @ x0 @ x1)%expr_pat
                                        end
                                    | None =>
                                        if args =? 2 ^ Z.log2 args
                                        then
                                         UnderLets.Base
                                           (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                            (x0, x1))%expr_pat
                                        else
                                         UnderLets.Base
                                           (#(ident.Z_add_get_carry)%expr @ x @
                                            x0 @ x1)%expr_pat
                                    end
                                end
                            | (@expr.App _ _ _ s2 _ ($_)%expr _ @ _)%expr_pat |
                              (@expr.App _ _ _ s2 _ (@expr.Abs _ _ _ _ _ _)
                               _ @ _)%expr_pat |
                              (@expr.App _ _ _ s2 _ (_ @ _) _ @ _)%expr_pat |
                              (@expr.App _ _ _ s2 _
                               (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                    (x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                    x1)%expr_pat
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                    (x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                    x1)%expr_pat
                            end
                        end
                    | ($_)%expr =>
                        match x0 with
                        | (@expr.App _ _ _ s2 _ #(idc1) x5 @ x4)%expr_pat =>
                            match
                              match idc1 with
                              | ident.Z_shiftl => Some tt
                              | _ => None
                              end
                            with
                            | Some _ =>
                                match x4 with
                                | #(idc2)%expr_pat =>
                                    match
                                      match idc2 with
                                      | @ident.Literal t4 v0 =>
                                          match
                                            t4 as t5
                                            return
                                              (base.base_interp t5 ->
                                               option Z)
                                          with
                                          | base.type.unit =>
                                              fun _ : unit => None
                                          | base.type.Z =>
                                              fun v1 : Z => Some v1
                                          | base.type.bool =>
                                              fun _ : bool => None
                                          | base.type.nat =>
                                              fun _ : nat => None
                                          end v0
                                      | _ => None
                                      end
                                    with
                                    | Some args2 =>
                                        match
                                          s2 as t4
                                          return
                                            (Compile.value' false t4 ->
                                             UnderLets.UnderLets base.type
                                               ident var
                                               (defaults.expr
                                                  (type.base
                                                     (base.type.Z *
                                                      base.type.Z)%etype)))
                                        with
                                        | type.base t4 =>
                                            fun
                                              v0 : defaults.expr
                                                     (type.base t4) =>
                                            base.try_make_transport_cps
                                              (fun t5 : base.type =>
                                               defaults.expr (type.base t5))
                                              t4 base.type.Z
                                              (UnderLets.UnderLets base.type
                                                 ident var
                                                 (defaults.expr
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)))
                                              (fun
                                                 a : option
                                                       (defaults.expr
                                                          (type.base t4) ->
                                                        defaults.expr
                                                          (type.base
                                                             base.type.Z)) =>
                                               match a with
                                               | Some x' =>
                                                   if args =? 2 ^ Z.log2 args
                                                   then
                                                    UnderLets.Base
                                                      (#(ident.fancy_add
                                                           (Z.log2 args)
                                                           args2)%expr @
                                                       (x1, x' v0))%expr_pat
                                                   else
                                                    if
                                                     args =? 2 ^ Z.log2 args
                                                    then
                                                     UnderLets.Base
                                                       (#(ident.fancy_add
                                                            (Z.log2 args) 0)%expr @
                                                        (x0, x1))%expr_pat
                                                    else
                                                     UnderLets.Base
                                                       (#(ident.Z_add_get_carry)%expr @
                                                        x @ x0 @ x1)%expr_pat
                                               | None =>
                                                   UnderLets.Base
                                                     (#(ident.Z_add_get_carry)%expr @
                                                      x @ x0 @ x1)%expr_pat
                                               end)
                                        | (s3 -> d3)%ptype =>
                                            fun
                                              _ : Compile.value' false s3 ->
                                                  Compile.value' true d3 =>
                                            UnderLets.Base
                                              (#(ident.Z_add_get_carry)%expr @
                                               x @ x0 @ x1)%expr_pat
                                        end (Compile.reflect x5)
                                    | None =>
                                        if args =? 2 ^ Z.log2 args
                                        then
                                         UnderLets.Base
                                           (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                            (x0, x1))%expr_pat
                                        else
                                         UnderLets.Base
                                           (#(ident.Z_add_get_carry)%expr @ x @
                                            x0 @ x1)%expr_pat
                                    end
                                | _ =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                        (x0, x1))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_get_carry)%expr @ x @
                                        x0 @ x1)%expr_pat
                                end
                            | None =>
                                match
                                  match idc1 with
                                  | ident.Z_shiftr => Some tt
                                  | _ => None
                                  end
                                with
                                | Some _ =>
                                    match x4 with
                                    | #(idc2)%expr_pat =>
                                        match
                                          match idc2 with
                                          | @ident.Literal t4 v0 =>
                                              match
                                                t4 as t5
                                                return
                                                  (base.base_interp t5 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v1 : Z => Some v1
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v0
                                          | _ => None
                                          end
                                        with
                                        | Some args2 =>
                                            match
                                              s2 as t4
                                              return
                                                (Compile.value' false t4 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base
                                                         (base.type.Z *
                                                          base.type.Z)%etype)))
                                            with
                                            | type.base t4 =>
                                                fun
                                                  v0 : defaults.expr
                                                         (type.base t4) =>
                                                base.try_make_transport_cps
                                                  (fun t5 : base.type =>
                                                   defaults.expr
                                                     (type.base t5)) t4
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           (base.type.Z *
                                                            base.type.Z)%etype)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t4) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       if
                                                        args =?
                                                        2 ^ Z.log2 args
                                                       then
                                                        UnderLets.Base
                                                          (#(ident.fancy_add
                                                               (Z.log2 args)
                                                               (- args2))%expr @
                                                           (x1, x' v0))%expr_pat
                                                       else
                                                        if
                                                         args =?
                                                         2 ^ Z.log2 args
                                                        then
                                                         UnderLets.Base
                                                           (#(ident.fancy_add
                                                                (Z.log2 args)
                                                                0)%expr @
                                                            (x0, x1))%expr_pat
                                                        else
                                                         UnderLets.Base
                                                           (#(ident.Z_add_get_carry)%expr @
                                                            x @ x0 @ x1)%expr_pat
                                                   | None =>
                                                       UnderLets.Base
                                                         (#(ident.Z_add_get_carry)%expr @
                                                          x @ x0 @ x1)%expr_pat
                                                   end)
                                            | (s3 -> d3)%ptype =>
                                                fun
                                                  _ : Compile.value' false s3 ->
                                                      Compile.value' true d3
                                                =>
                                                UnderLets.Base
                                                  (#(ident.Z_add_get_carry)%expr @
                                                   x @ x0 @ x1)%expr_pat
                                            end (Compile.reflect x5)
                                        | None =>
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_add
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_get_carry)%expr @
                                                x @ x0 @ x1)%expr_pat
                                        end
                                    | _ =>
                                        if args =? 2 ^ Z.log2 args
                                        then
                                         UnderLets.Base
                                           (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                            (x0, x1))%expr_pat
                                        else
                                         UnderLets.Base
                                           (#(ident.Z_add_get_carry)%expr @ x @
                                            x0 @ x1)%expr_pat
                                    end
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                        (x0, x1))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_get_carry)%expr @ x @
                                        x0 @ x1)%expr_pat
                                end
                            end
                        | (@expr.App _ _ _ s2 _ ($_)%expr _ @ _)%expr_pat |
                          (@expr.App _ _ _ s2 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                          (@expr.App _ _ _ s2 _ (_ @ _) _ @ _)%expr_pat |
                          (@expr.App _ _ _ s2 _ (@expr.LetIn _ _ _ _ _ _ _)
                           _ @ _)%expr_pat =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                (x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                        | _ =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                (x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                        end
                    | @expr.Abs _ _ _ _ _ _ =>
                        match x0 with
                        | (@expr.App _ _ _ s3 _ #(idc1) x5 @ x4)%expr_pat =>
                            match
                              match idc1 with
                              | ident.Z_shiftl => Some tt
                              | _ => None
                              end
                            with
                            | Some _ =>
                                match x4 with
                                | #(idc2)%expr_pat =>
                                    match
                                      match idc2 with
                                      | @ident.Literal t3 v =>
                                          match
                                            t3 as t4
                                            return
                                              (base.base_interp t4 ->
                                               option Z)
                                          with
                                          | base.type.unit =>
                                              fun _ : unit => None
                                          | base.type.Z =>
                                              fun v0 : Z => Some v0
                                          | base.type.bool =>
                                              fun _ : bool => None
                                          | base.type.nat =>
                                              fun _ : nat => None
                                          end v
                                      | _ => None
                                      end
                                    with
                                    | Some args2 =>
                                        match
                                          s3 as t3
                                          return
                                            (Compile.value' false t3 ->
                                             UnderLets.UnderLets base.type
                                               ident var
                                               (defaults.expr
                                                  (type.base
                                                     (base.type.Z *
                                                      base.type.Z)%etype)))
                                        with
                                        | type.base t3 =>
                                            fun
                                              v : defaults.expr
                                                    (type.base t3) =>
                                            base.try_make_transport_cps
                                              (fun t4 : base.type =>
                                               defaults.expr (type.base t4))
                                              t3 base.type.Z
                                              (UnderLets.UnderLets base.type
                                                 ident var
                                                 (defaults.expr
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)))
                                              (fun
                                                 a : option
                                                       (defaults.expr
                                                          (type.base t3) ->
                                                        defaults.expr
                                                          (type.base
                                                             base.type.Z)) =>
                                               match a with
                                               | Some x' =>
                                                   if args =? 2 ^ Z.log2 args
                                                   then
                                                    UnderLets.Base
                                                      (#(ident.fancy_add
                                                           (Z.log2 args)
                                                           args2)%expr @
                                                       (x1, x' v))%expr_pat
                                                   else
                                                    if
                                                     args =? 2 ^ Z.log2 args
                                                    then
                                                     UnderLets.Base
                                                       (#(ident.fancy_add
                                                            (Z.log2 args) 0)%expr @
                                                        (x0, x1))%expr_pat
                                                    else
                                                     UnderLets.Base
                                                       (#(ident.Z_add_get_carry)%expr @
                                                        x @ x0 @ x1)%expr_pat
                                               | None =>
                                                   UnderLets.Base
                                                     (#(ident.Z_add_get_carry)%expr @
                                                      x @ x0 @ x1)%expr_pat
                                               end)
                                        | (s4 -> d4)%ptype =>
                                            fun
                                              _ : Compile.value' false s4 ->
                                                  Compile.value' true d4 =>
                                            UnderLets.Base
                                              (#(ident.Z_add_get_carry)%expr @
                                               x @ x0 @ x1)%expr_pat
                                        end (Compile.reflect x5)
                                    | None =>
                                        if args =? 2 ^ Z.log2 args
                                        then
                                         UnderLets.Base
                                           (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                            (x0, x1))%expr_pat
                                        else
                                         UnderLets.Base
                                           (#(ident.Z_add_get_carry)%expr @ x @
                                            x0 @ x1)%expr_pat
                                    end
                                | _ =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                        (x0, x1))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_get_carry)%expr @ x @
                                        x0 @ x1)%expr_pat
                                end
                            | None =>
                                match
                                  match idc1 with
                                  | ident.Z_shiftr => Some tt
                                  | _ => None
                                  end
                                with
                                | Some _ =>
                                    match x4 with
                                    | #(idc2)%expr_pat =>
                                        match
                                          match idc2 with
                                          | @ident.Literal t3 v =>
                                              match
                                                t3 as t4
                                                return
                                                  (base.base_interp t4 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v0 : Z => Some v0
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v
                                          | _ => None
                                          end
                                        with
                                        | Some args2 =>
                                            match
                                              s3 as t3
                                              return
                                                (Compile.value' false t3 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base
                                                         (base.type.Z *
                                                          base.type.Z)%etype)))
                                            with
                                            | type.base t3 =>
                                                fun
                                                  v : defaults.expr
                                                        (type.base t3) =>
                                                base.try_make_transport_cps
                                                  (fun t4 : base.type =>
                                                   defaults.expr
                                                     (type.base t4)) t3
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           (base.type.Z *
                                                            base.type.Z)%etype)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t3) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       if
                                                        args =?
                                                        2 ^ Z.log2 args
                                                       then
                                                        UnderLets.Base
                                                          (#(ident.fancy_add
                                                               (Z.log2 args)
                                                               (- args2))%expr @
                                                           (x1, x' v))%expr_pat
                                                       else
                                                        if
                                                         args =?
                                                         2 ^ Z.log2 args
                                                        then
                                                         UnderLets.Base
                                                           (#(ident.fancy_add
                                                                (Z.log2 args)
                                                                0)%expr @
                                                            (x0, x1))%expr_pat
                                                        else
                                                         UnderLets.Base
                                                           (#(ident.Z_add_get_carry)%expr @
                                                            x @ x0 @ x1)%expr_pat
                                                   | None =>
                                                       UnderLets.Base
                                                         (#(ident.Z_add_get_carry)%expr @
                                                          x @ x0 @ x1)%expr_pat
                                                   end)
                                            | (s4 -> d4)%ptype =>
                                                fun
                                                  _ : Compile.value' false s4 ->
                                                      Compile.value' true d4
                                                =>
                                                UnderLets.Base
                                                  (#(ident.Z_add_get_carry)%expr @
                                                   x @ x0 @ x1)%expr_pat
                                            end (Compile.reflect x5)
                                        | None =>
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_add
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_get_carry)%expr @
                                                x @ x0 @ x1)%expr_pat
                                        end
                                    | _ =>
                                        if args =? 2 ^ Z.log2 args
                                        then
                                         UnderLets.Base
                                           (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                            (x0, x1))%expr_pat
                                        else
                                         UnderLets.Base
                                           (#(ident.Z_add_get_carry)%expr @ x @
                                            x0 @ x1)%expr_pat
                                    end
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                        (x0, x1))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_get_carry)%expr @ x @
                                        x0 @ x1)%expr_pat
                                end
                            end
                        | (@expr.App _ _ _ s3 _ ($_)%expr _ @ _)%expr_pat |
                          (@expr.App _ _ _ s3 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                          (@expr.App _ _ _ s3 _ (_ @ _) _ @ _)%expr_pat |
                          (@expr.App _ _ _ s3 _ (@expr.LetIn _ _ _ _ _ _ _)
                           _ @ _)%expr_pat =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                (x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                        | _ =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                (x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                        end
                    | (_ @ _)%expr_pat =>
                        match x0 with
                        | (@expr.App _ _ _ s3 _ #(idc1) x6 @ x5)%expr_pat =>
                            match
                              match idc1 with
                              | ident.Z_shiftl => Some tt
                              | _ => None
                              end
                            with
                            | Some _ =>
                                match x5 with
                                | #(idc2)%expr_pat =>
                                    match
                                      match idc2 with
                                      | @ident.Literal t3 v =>
                                          match
                                            t3 as t4
                                            return
                                              (base.base_interp t4 ->
                                               option Z)
                                          with
                                          | base.type.unit =>
                                              fun _ : unit => None
                                          | base.type.Z =>
                                              fun v0 : Z => Some v0
                                          | base.type.bool =>
                                              fun _ : bool => None
                                          | base.type.nat =>
                                              fun _ : nat => None
                                          end v
                                      | _ => None
                                      end
                                    with
                                    | Some args2 =>
                                        match
                                          s3 as t3
                                          return
                                            (Compile.value' false t3 ->
                                             UnderLets.UnderLets base.type
                                               ident var
                                               (defaults.expr
                                                  (type.base
                                                     (base.type.Z *
                                                      base.type.Z)%etype)))
                                        with
                                        | type.base t3 =>
                                            fun
                                              v : defaults.expr
                                                    (type.base t3) =>
                                            base.try_make_transport_cps
                                              (fun t4 : base.type =>
                                               defaults.expr (type.base t4))
                                              t3 base.type.Z
                                              (UnderLets.UnderLets base.type
                                                 ident var
                                                 (defaults.expr
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)))
                                              (fun
                                                 a : option
                                                       (defaults.expr
                                                          (type.base t3) ->
                                                        defaults.expr
                                                          (type.base
                                                             base.type.Z)) =>
                                               match a with
                                               | Some x' =>
                                                   if args =? 2 ^ Z.log2 args
                                                   then
                                                    UnderLets.Base
                                                      (#(ident.fancy_add
                                                           (Z.log2 args)
                                                           args2)%expr @
                                                       (x1, x' v))%expr_pat
                                                   else
                                                    if
                                                     args =? 2 ^ Z.log2 args
                                                    then
                                                     UnderLets.Base
                                                       (#(ident.fancy_add
                                                            (Z.log2 args) 0)%expr @
                                                        (x0, x1))%expr_pat
                                                    else
                                                     UnderLets.Base
                                                       (#(ident.Z_add_get_carry)%expr @
                                                        x @ x0 @ x1)%expr_pat
                                               | None =>
                                                   UnderLets.Base
                                                     (#(ident.Z_add_get_carry)%expr @
                                                      x @ x0 @ x1)%expr_pat
                                               end)
                                        | (s4 -> d4)%ptype =>
                                            fun
                                              _ : Compile.value' false s4 ->
                                                  Compile.value' true d4 =>
                                            UnderLets.Base
                                              (#(ident.Z_add_get_carry)%expr @
                                               x @ x0 @ x1)%expr_pat
                                        end (Compile.reflect x6)
                                    | None =>
                                        if args =? 2 ^ Z.log2 args
                                        then
                                         UnderLets.Base
                                           (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                            (x0, x1))%expr_pat
                                        else
                                         UnderLets.Base
                                           (#(ident.Z_add_get_carry)%expr @ x @
                                            x0 @ x1)%expr_pat
                                    end
                                | _ =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                        (x0, x1))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_get_carry)%expr @ x @
                                        x0 @ x1)%expr_pat
                                end
                            | None =>
                                match
                                  match idc1 with
                                  | ident.Z_shiftr => Some tt
                                  | _ => None
                                  end
                                with
                                | Some _ =>
                                    match x5 with
                                    | #(idc2)%expr_pat =>
                                        match
                                          match idc2 with
                                          | @ident.Literal t3 v =>
                                              match
                                                t3 as t4
                                                return
                                                  (base.base_interp t4 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v0 : Z => Some v0
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v
                                          | _ => None
                                          end
                                        with
                                        | Some args2 =>
                                            match
                                              s3 as t3
                                              return
                                                (Compile.value' false t3 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base
                                                         (base.type.Z *
                                                          base.type.Z)%etype)))
                                            with
                                            | type.base t3 =>
                                                fun
                                                  v : defaults.expr
                                                        (type.base t3) =>
                                                base.try_make_transport_cps
                                                  (fun t4 : base.type =>
                                                   defaults.expr
                                                     (type.base t4)) t3
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           (base.type.Z *
                                                            base.type.Z)%etype)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t3) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       if
                                                        args =?
                                                        2 ^ Z.log2 args
                                                       then
                                                        UnderLets.Base
                                                          (#(ident.fancy_add
                                                               (Z.log2 args)
                                                               (- args2))%expr @
                                                           (x1, x' v))%expr_pat
                                                       else
                                                        if
                                                         args =?
                                                         2 ^ Z.log2 args
                                                        then
                                                         UnderLets.Base
                                                           (#(ident.fancy_add
                                                                (Z.log2 args)
                                                                0)%expr @
                                                            (x0, x1))%expr_pat
                                                        else
                                                         UnderLets.Base
                                                           (#(ident.Z_add_get_carry)%expr @
                                                            x @ x0 @ x1)%expr_pat
                                                   | None =>
                                                       UnderLets.Base
                                                         (#(ident.Z_add_get_carry)%expr @
                                                          x @ x0 @ x1)%expr_pat
                                                   end)
                                            | (s4 -> d4)%ptype =>
                                                fun
                                                  _ : Compile.value' false s4 ->
                                                      Compile.value' true d4
                                                =>
                                                UnderLets.Base
                                                  (#(ident.Z_add_get_carry)%expr @
                                                   x @ x0 @ x1)%expr_pat
                                            end (Compile.reflect x6)
                                        | None =>
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_add
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_get_carry)%expr @
                                                x @ x0 @ x1)%expr_pat
                                        end
                                    | _ =>
                                        if args =? 2 ^ Z.log2 args
                                        then
                                         UnderLets.Base
                                           (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                            (x0, x1))%expr_pat
                                        else
                                         UnderLets.Base
                                           (#(ident.Z_add_get_carry)%expr @ x @
                                            x0 @ x1)%expr_pat
                                    end
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                        (x0, x1))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_get_carry)%expr @ x @
                                        x0 @ x1)%expr_pat
                                end
                            end
                        | (@expr.App _ _ _ s3 _ ($_)%expr _ @ _)%expr_pat |
                          (@expr.App _ _ _ s3 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                          (@expr.App _ _ _ s3 _ (_ @ _) _ @ _)%expr_pat |
                          (@expr.App _ _ _ s3 _ (@expr.LetIn _ _ _ _ _ _ _)
                           _ @ _)%expr_pat =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                (x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                        | _ =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                (x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                        end
                    | @expr.LetIn _ _ _ _ _ _ _ =>
                        match x0 with
                        | (@expr.App _ _ _ s2 _ #(idc1) x6 @ x5)%expr_pat =>
                            match
                              match idc1 with
                              | ident.Z_shiftl => Some tt
                              | _ => None
                              end
                            with
                            | Some _ =>
                                match x5 with
                                | #(idc2)%expr_pat =>
                                    match
                                      match idc2 with
                                      | @ident.Literal t3 v =>
                                          match
                                            t3 as t4
                                            return
                                              (base.base_interp t4 ->
                                               option Z)
                                          with
                                          | base.type.unit =>
                                              fun _ : unit => None
                                          | base.type.Z =>
                                              fun v0 : Z => Some v0
                                          | base.type.bool =>
                                              fun _ : bool => None
                                          | base.type.nat =>
                                              fun _ : nat => None
                                          end v
                                      | _ => None
                                      end
                                    with
                                    | Some args2 =>
                                        match
                                          s2 as t3
                                          return
                                            (Compile.value' false t3 ->
                                             UnderLets.UnderLets base.type
                                               ident var
                                               (defaults.expr
                                                  (type.base
                                                     (base.type.Z *
                                                      base.type.Z)%etype)))
                                        with
                                        | type.base t3 =>
                                            fun
                                              v : defaults.expr
                                                    (type.base t3) =>
                                            base.try_make_transport_cps
                                              (fun t4 : base.type =>
                                               defaults.expr (type.base t4))
                                              t3 base.type.Z
                                              (UnderLets.UnderLets base.type
                                                 ident var
                                                 (defaults.expr
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)))
                                              (fun
                                                 a : option
                                                       (defaults.expr
                                                          (type.base t3) ->
                                                        defaults.expr
                                                          (type.base
                                                             base.type.Z)) =>
                                               match a with
                                               | Some x' =>
                                                   if args =? 2 ^ Z.log2 args
                                                   then
                                                    UnderLets.Base
                                                      (#(ident.fancy_add
                                                           (Z.log2 args)
                                                           args2)%expr @
                                                       (x1, x' v))%expr_pat
                                                   else
                                                    if
                                                     args =? 2 ^ Z.log2 args
                                                    then
                                                     UnderLets.Base
                                                       (#(ident.fancy_add
                                                            (Z.log2 args) 0)%expr @
                                                        (x0, x1))%expr_pat
                                                    else
                                                     UnderLets.Base
                                                       (#(ident.Z_add_get_carry)%expr @
                                                        x @ x0 @ x1)%expr_pat
                                               | None =>
                                                   UnderLets.Base
                                                     (#(ident.Z_add_get_carry)%expr @
                                                      x @ x0 @ x1)%expr_pat
                                               end)
                                        | (s3 -> d3)%ptype =>
                                            fun
                                              _ : Compile.value' false s3 ->
                                                  Compile.value' true d3 =>
                                            UnderLets.Base
                                              (#(ident.Z_add_get_carry)%expr @
                                               x @ x0 @ x1)%expr_pat
                                        end (Compile.reflect x6)
                                    | None =>
                                        if args =? 2 ^ Z.log2 args
                                        then
                                         UnderLets.Base
                                           (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                            (x0, x1))%expr_pat
                                        else
                                         UnderLets.Base
                                           (#(ident.Z_add_get_carry)%expr @ x @
                                            x0 @ x1)%expr_pat
                                    end
                                | _ =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                        (x0, x1))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_get_carry)%expr @ x @
                                        x0 @ x1)%expr_pat
                                end
                            | None =>
                                match
                                  match idc1 with
                                  | ident.Z_shiftr => Some tt
                                  | _ => None
                                  end
                                with
                                | Some _ =>
                                    match x5 with
                                    | #(idc2)%expr_pat =>
                                        match
                                          match idc2 with
                                          | @ident.Literal t3 v =>
                                              match
                                                t3 as t4
                                                return
                                                  (base.base_interp t4 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v0 : Z => Some v0
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v
                                          | _ => None
                                          end
                                        with
                                        | Some args2 =>
                                            match
                                              s2 as t3
                                              return
                                                (Compile.value' false t3 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base
                                                         (base.type.Z *
                                                          base.type.Z)%etype)))
                                            with
                                            | type.base t3 =>
                                                fun
                                                  v : defaults.expr
                                                        (type.base t3) =>
                                                base.try_make_transport_cps
                                                  (fun t4 : base.type =>
                                                   defaults.expr
                                                     (type.base t4)) t3
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           (base.type.Z *
                                                            base.type.Z)%etype)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t3) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       if
                                                        args =?
                                                        2 ^ Z.log2 args
                                                       then
                                                        UnderLets.Base
                                                          (#(ident.fancy_add
                                                               (Z.log2 args)
                                                               (- args2))%expr @
                                                           (x1, x' v))%expr_pat
                                                       else
                                                        if
                                                         args =?
                                                         2 ^ Z.log2 args
                                                        then
                                                         UnderLets.Base
                                                           (#(ident.fancy_add
                                                                (Z.log2 args)
                                                                0)%expr @
                                                            (x0, x1))%expr_pat
                                                        else
                                                         UnderLets.Base
                                                           (#(ident.Z_add_get_carry)%expr @
                                                            x @ x0 @ x1)%expr_pat
                                                   | None =>
                                                       UnderLets.Base
                                                         (#(ident.Z_add_get_carry)%expr @
                                                          x @ x0 @ x1)%expr_pat
                                                   end)
                                            | (s3 -> d3)%ptype =>
                                                fun
                                                  _ : Compile.value' false s3 ->
                                                      Compile.value' true d3
                                                =>
                                                UnderLets.Base
                                                  (#(ident.Z_add_get_carry)%expr @
                                                   x @ x0 @ x1)%expr_pat
                                            end (Compile.reflect x6)
                                        | None =>
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_add
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_get_carry)%expr @
                                                x @ x0 @ x1)%expr_pat
                                        end
                                    | _ =>
                                        if args =? 2 ^ Z.log2 args
                                        then
                                         UnderLets.Base
                                           (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                            (x0, x1))%expr_pat
                                        else
                                         UnderLets.Base
                                           (#(ident.Z_add_get_carry)%expr @ x @
                                            x0 @ x1)%expr_pat
                                    end
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                        (x0, x1))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_get_carry)%expr @ x @
                                        x0 @ x1)%expr_pat
                                end
                            end
                        | (@expr.App _ _ _ s2 _ ($_)%expr _ @ _)%expr_pat |
                          (@expr.App _ _ _ s2 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                          (@expr.App _ _ _ s2 _ (_ @ _) _ @ _)%expr_pat |
                          (@expr.App _ _ _ s2 _ (@expr.LetIn _ _ _ _ _ _ _)
                           _ @ _)%expr_pat =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                (x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                        | _ =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                (x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                        end
                    end
                | None =>
                    match
                      match idc0 with
                      | ident.Z_shiftr => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match x0 with
                        | #(_)%expr_pat =>
                            match x2 with
                            | #(idc2)%expr_pat =>
                                match
                                  match idc2 with
                                  | @ident.Literal t3 v =>
                                      match
                                        t3 as t4
                                        return
                                          (base.base_interp t4 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s0 as t3
                                      return
                                        (Compile.value' false t3 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t3 =>
                                        fun v : defaults.expr (type.base t3)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t4 : base.type =>
                                           defaults.expr (type.base t4)) t3
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t3) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_add
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x0, x' v))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_add
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_get_carry)%expr @
                                                    x @ x0 @ x1)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_get_carry)%expr @
                                                  x @ x0 @ x1)%expr_pat
                                           end)
                                    | (s1 -> d1)%ptype =>
                                        fun
                                          _ : Compile.value' false s1 ->
                                              Compile.value' true d1 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_get_carry)%expr @ x @
                                           x0 @ x1)%expr_pat
                                    end (Compile.reflect x3)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                        (x0, x1))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_get_carry)%expr @ x @
                                        x0 @ x1)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                    (x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                    x1)%expr_pat
                            end
                        | ($_)%expr =>
                            match x2 with
                            | #(idc1)%expr_pat =>
                                match
                                  match idc1 with
                                  | @ident.Literal t3 v0 =>
                                      match
                                        t3 as t4
                                        return
                                          (base.base_interp t4 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v1 : Z => Some v1
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v0
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s0 as t3
                                      return
                                        (Compile.value' false t3 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t3 =>
                                        fun v0 : defaults.expr (type.base t3)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t4 : base.type =>
                                           defaults.expr (type.base t4)) t3
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t3) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_add
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x0, x' v0))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_add
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_get_carry)%expr @
                                                    x @ x0 @ x1)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_get_carry)%expr @
                                                  x @ x0 @ x1)%expr_pat
                                           end)
                                    | (s1 -> d1)%ptype =>
                                        fun
                                          _ : Compile.value' false s1 ->
                                              Compile.value' true d1 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_get_carry)%expr @ x @
                                           x0 @ x1)%expr_pat
                                    end (Compile.reflect x3)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                        (x0, x1))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_get_carry)%expr @ x @
                                        x0 @ x1)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                    (x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                    x1)%expr_pat
                            end
                        | (#(_) @ _)%expr_pat =>
                            match x2 with
                            | #(idc2)%expr_pat =>
                                match
                                  match idc2 with
                                  | @ident.Literal t3 v =>
                                      match
                                        t3 as t4
                                        return
                                          (base.base_interp t4 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s0 as t3
                                      return
                                        (Compile.value' false t3 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t3 =>
                                        fun v : defaults.expr (type.base t3)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t4 : base.type =>
                                           defaults.expr (type.base t4)) t3
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t3) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_add
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x0, x' v))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_add
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_get_carry)%expr @
                                                    x @ x0 @ x1)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_get_carry)%expr @
                                                  x @ x0 @ x1)%expr_pat
                                           end)
                                    | (s2 -> d2)%ptype =>
                                        fun
                                          _ : Compile.value' false s2 ->
                                              Compile.value' true d2 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_get_carry)%expr @ x @
                                           x0 @ x1)%expr_pat
                                    end (Compile.reflect x3)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                        (x0, x1))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_get_carry)%expr @ x @
                                        x0 @ x1)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                    (x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                    x1)%expr_pat
                            end
                        | (($_)%expr @ _)%expr_pat =>
                            match x2 with
                            | #(idc1)%expr_pat =>
                                match
                                  match idc1 with
                                  | @ident.Literal t3 v0 =>
                                      match
                                        t3 as t4
                                        return
                                          (base.base_interp t4 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v1 : Z => Some v1
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v0
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s0 as t3
                                      return
                                        (Compile.value' false t3 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t3 =>
                                        fun v0 : defaults.expr (type.base t3)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t4 : base.type =>
                                           defaults.expr (type.base t4)) t3
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t3) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_add
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x0, x' v0))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_add
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_get_carry)%expr @
                                                    x @ x0 @ x1)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_get_carry)%expr @
                                                  x @ x0 @ x1)%expr_pat
                                           end)
                                    | (s2 -> d2)%ptype =>
                                        fun
                                          _ : Compile.value' false s2 ->
                                              Compile.value' true d2 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_get_carry)%expr @ x @
                                           x0 @ x1)%expr_pat
                                    end (Compile.reflect x3)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                        (x0, x1))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_get_carry)%expr @ x @
                                        x0 @ x1)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                    (x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                    x1)%expr_pat
                            end
                        | (@expr.Abs _ _ _ _ _ _ @ _)%expr_pat =>
                            match x2 with
                            | #(idc1)%expr_pat =>
                                match
                                  match idc1 with
                                  | @ident.Literal t2 v =>
                                      match
                                        t2 as t3
                                        return
                                          (base.base_interp t3 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s0 as t2
                                      return
                                        (Compile.value' false t2 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t2 =>
                                        fun v : defaults.expr (type.base t2)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t3 : base.type =>
                                           defaults.expr (type.base t3)) t2
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t2) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_add
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x0, x' v))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_add
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_get_carry)%expr @
                                                    x @ x0 @ x1)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_get_carry)%expr @
                                                  x @ x0 @ x1)%expr_pat
                                           end)
                                    | (s3 -> d3)%ptype =>
                                        fun
                                          _ : Compile.value' false s3 ->
                                              Compile.value' true d3 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_get_carry)%expr @ x @
                                           x0 @ x1)%expr_pat
                                    end (Compile.reflect x3)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                        (x0, x1))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_get_carry)%expr @ x @
                                        x0 @ x1)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                    (x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                    x1)%expr_pat
                            end
                        | (@expr.App _ _ _ s2 _ #(idc1) x5 @ x4)%expr_pat =>
                            match
                              match idc1 with
                              | ident.Z_shiftl => Some tt
                              | _ => None
                              end
                            with
                            | Some _ =>
                                match x4 with
                                | #(idc2)%expr_pat =>
                                    match
                                      match idc2 with
                                      | @ident.Literal t3 v =>
                                          match
                                            t3 as t4
                                            return
                                              (base.base_interp t4 ->
                                               option Z)
                                          with
                                          | base.type.unit =>
                                              fun _ : unit => None
                                          | base.type.Z =>
                                              fun v0 : Z => Some v0
                                          | base.type.bool =>
                                              fun _ : bool => None
                                          | base.type.nat =>
                                              fun _ : nat => None
                                          end v
                                      | _ => None
                                      end
                                    with
                                    | Some args2 =>
                                        match
                                          s2 as t3
                                          return
                                            (Compile.value' false t3 ->
                                             UnderLets.UnderLets base.type
                                               ident var
                                               (defaults.expr
                                                  (type.base
                                                     (base.type.Z *
                                                      base.type.Z)%etype)))
                                        with
                                        | type.base t3 =>
                                            fun
                                              v : defaults.expr
                                                    (type.base t3) =>
                                            base.try_make_transport_cps
                                              (fun t4 : base.type =>
                                               defaults.expr (type.base t4))
                                              t3 base.type.Z
                                              (UnderLets.UnderLets base.type
                                                 ident var
                                                 (defaults.expr
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)))
                                              (fun
                                                 a : option
                                                       (defaults.expr
                                                          (type.base t3) ->
                                                        defaults.expr
                                                          (type.base
                                                             base.type.Z)) =>
                                               match a with
                                               | Some x' =>
                                                   if args =? 2 ^ Z.log2 args
                                                   then
                                                    UnderLets.Base
                                                      (#(ident.fancy_add
                                                           (Z.log2 args)
                                                           args2)%expr @
                                                       (x1, x' v))%expr_pat
                                                   else
                                                    match x2 with
                                                    | #(idc3)%expr_pat =>
                                                        match
                                                          match idc3 with
                                                          | @ident.Literal t5
                                                            v0 =>
                                                              match
                                                                t5 as t6
                                                                return
                                                                  (base.base_interp
                                                                    t6 ->
                                                                   option Z)
                                                              with
                                                              | base.type.unit =>
                                                                  fun
                                                                    _ : unit
                                                                  => None
                                                              | base.type.Z =>
                                                                  fun v1 : Z
                                                                  => 
                                                                  Some v1
                                                              | base.type.bool =>
                                                                  fun
                                                                    _ : bool
                                                                  => None
                                                              | base.type.nat =>
                                                                  fun _ : nat
                                                                  => None
                                                              end v0
                                                          | _ => None
                                                          end
                                                        with
                                                        | Some args3 =>
                                                            match
                                                              s0 as t5
                                                              return
                                                                (Compile.value'
                                                                   false t5 ->
                                                                 UnderLets.UnderLets
                                                                   base.type
                                                                   ident var
                                                                   (defaults.expr
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)))
                                                            with
                                                            | type.base t5 =>
                                                                fun
                                                                  v0 : 
                                                                   defaults.expr
                                                                    (type.base
                                                                    t5) =>
                                                                base.try_make_transport_cps
                                                                  (fun
                                                                    t6 : base.type
                                                                   =>
                                                                   defaults.expr
                                                                    (type.base
                                                                    t6)) t5
                                                                  base.type.Z
                                                                  (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)))
                                                                  (fun
                                                                    a0 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t5) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                   =>
                                                                   match
                                                                    a0
                                                                   with
                                                                   | Some
                                                                    x'0 =>
                                                                    if
                                                                    args =?
                                                                    2
                                                                    ^ 
                                                                    Z.log2
                                                                    args
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_add
                                                                    (Z.log2
                                                                    args)
                                                                    (- args3))%expr @
                                                                    (x0,
                                                                    x'0 v0))%expr_pat
                                                                    else
                                                                    if
                                                                    args =?
                                                                    2
                                                                    ^ 
                                                                    Z.log2
                                                                    args
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_add
                                                                    (Z.log2
                                                                    args) 0)%expr @
                                                                    (x0, x1))%expr_pat
                                                                    else
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.Z_add_get_carry)%expr @
                                                                    x @ x0 @
                                                                    x1)%expr_pat
                                                                   | None =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.Z_add_get_carry)%expr @
                                                                    x @ x0 @
                                                                    x1)%expr_pat
                                                                   end)
                                                            | (s3 -> d3)%ptype =>
                                                                fun
                                                                  _ : 
                                                                   Compile.value'
                                                                    false s3 ->
                                                                   Compile.value'
                                                                    true d3
                                                                =>
                                                                UnderLets.Base
                                                                  (#(ident.Z_add_get_carry)%expr @
                                                                   x @ x0 @
                                                                   x1)%expr_pat
                                                            end
                                                              (Compile.reflect
                                                                 x3)
                                                        | None =>
                                                            if
                                                             args =?
                                                             2 ^ Z.log2 args
                                                            then
                                                             UnderLets.Base
                                                               (#(ident.fancy_add
                                                                    (Z.log2
                                                                    args) 0)%expr @
                                                                (x0, x1))%expr_pat
                                                            else
                                                             UnderLets.Base
                                                               (#(ident.Z_add_get_carry)%expr @
                                                                x @ x0 @ x1)%expr_pat
                                                        end
                                                    | _ =>
                                                        if
                                                         args =?
                                                         2 ^ Z.log2 args
                                                        then
                                                         UnderLets.Base
                                                           (#(ident.fancy_add
                                                                (Z.log2 args)
                                                                0)%expr @
                                                            (x0, x1))%expr_pat
                                                        else
                                                         UnderLets.Base
                                                           (#(ident.Z_add_get_carry)%expr @
                                                            x @ x0 @ x1)%expr_pat
                                                    end
                                               | None =>
                                                   UnderLets.Base
                                                     (#(ident.Z_add_get_carry)%expr @
                                                      x @ x0 @ x1)%expr_pat
                                               end)
                                        | (s3 -> d3)%ptype =>
                                            fun
                                              _ : Compile.value' false s3 ->
                                                  Compile.value' true d3 =>
                                            UnderLets.Base
                                              (#(ident.Z_add_get_carry)%expr @
                                               x @ x0 @ x1)%expr_pat
                                        end (Compile.reflect x5)
                                    | None =>
                                        match x2 with
                                        | #(idc3)%expr_pat =>
                                            match
                                              match idc3 with
                                              | @ident.Literal t4 v =>
                                                  match
                                                    t4 as t5
                                                    return
                                                      (base.base_interp t5 ->
                                                       option Z)
                                                  with
                                                  | base.type.unit =>
                                                      fun _ : unit => None
                                                  | base.type.Z =>
                                                      fun v0 : Z => Some v0
                                                  | base.type.bool =>
                                                      fun _ : bool => None
                                                  | base.type.nat =>
                                                      fun _ : nat => None
                                                  end v
                                              | _ => None
                                              end
                                            with
                                            | Some args2 =>
                                                match
                                                  s0 as t4
                                                  return
                                                    (Compile.value' false t4 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             (base.type.Z *
                                                              base.type.Z)%etype)))
                                                with
                                                | type.base t4 =>
                                                    fun
                                                      v : defaults.expr
                                                            (type.base t4) =>
                                                    base.try_make_transport_cps
                                                      (fun t5 : base.type =>
                                                       defaults.expr
                                                         (type.base t5)) t4
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               (base.type.Z *
                                                                base.type.Z)%etype)))
                                                      (fun
                                                         a : option
                                                               (defaults.expr
                                                                  (type.base
                                                                    t4) ->
                                                                defaults.expr
                                                                  (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a with
                                                       | Some x' =>
                                                           if
                                                            args =?
                                                            2 ^ Z.log2 args
                                                           then
                                                            UnderLets.Base
                                                              (#(ident.fancy_add
                                                                   (Z.log2
                                                                    args)
                                                                   (- args2))%expr @
                                                               (x0, x' v))%expr_pat
                                                           else
                                                            if
                                                             args =?
                                                             2 ^ Z.log2 args
                                                            then
                                                             UnderLets.Base
                                                               (#(ident.fancy_add
                                                                    (Z.log2
                                                                    args) 0)%expr @
                                                                (x0, x1))%expr_pat
                                                            else
                                                             UnderLets.Base
                                                               (#(ident.Z_add_get_carry)%expr @
                                                                x @ x0 @ x1)%expr_pat
                                                       | None =>
                                                           UnderLets.Base
                                                             (#(ident.Z_add_get_carry)%expr @
                                                              x @ x0 @ x1)%expr_pat
                                                       end)
                                                | (s3 -> d3)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s3 ->
                                                          Compile.value' true
                                                            d3 =>
                                                    UnderLets.Base
                                                      (#(ident.Z_add_get_carry)%expr @
                                                       x @ x0 @ x1)%expr_pat
                                                end (Compile.reflect x3)
                                            | None =>
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_add
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_get_carry)%expr @
                                                    x @ x0 @ x1)%expr_pat
                                            end
                                        | _ =>
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_add
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_get_carry)%expr @
                                                x @ x0 @ x1)%expr_pat
                                        end
                                    end
                                | ($_)%expr =>
                                    match x2 with
                                    | #(idc2)%expr_pat =>
                                        match
                                          match idc2 with
                                          | @ident.Literal t4 v0 =>
                                              match
                                                t4 as t5
                                                return
                                                  (base.base_interp t5 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v1 : Z => Some v1
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v0
                                          | _ => None
                                          end
                                        with
                                        | Some args2 =>
                                            match
                                              s0 as t4
                                              return
                                                (Compile.value' false t4 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base
                                                         (base.type.Z *
                                                          base.type.Z)%etype)))
                                            with
                                            | type.base t4 =>
                                                fun
                                                  v0 : defaults.expr
                                                         (type.base t4) =>
                                                base.try_make_transport_cps
                                                  (fun t5 : base.type =>
                                                   defaults.expr
                                                     (type.base t5)) t4
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           (base.type.Z *
                                                            base.type.Z)%etype)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t4) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       if
                                                        args =?
                                                        2 ^ Z.log2 args
                                                       then
                                                        UnderLets.Base
                                                          (#(ident.fancy_add
                                                               (Z.log2 args)
                                                               (- args2))%expr @
                                                           (x0, x' v0))%expr_pat
                                                       else
                                                        if
                                                         args =?
                                                         2 ^ Z.log2 args
                                                        then
                                                         UnderLets.Base
                                                           (#(ident.fancy_add
                                                                (Z.log2 args)
                                                                0)%expr @
                                                            (x0, x1))%expr_pat
                                                        else
                                                         UnderLets.Base
                                                           (#(ident.Z_add_get_carry)%expr @
                                                            x @ x0 @ x1)%expr_pat
                                                   | None =>
                                                       UnderLets.Base
                                                         (#(ident.Z_add_get_carry)%expr @
                                                          x @ x0 @ x1)%expr_pat
                                                   end)
                                            | (s3 -> d3)%ptype =>
                                                fun
                                                  _ : Compile.value' false s3 ->
                                                      Compile.value' true d3
                                                =>
                                                UnderLets.Base
                                                  (#(ident.Z_add_get_carry)%expr @
                                                   x @ x0 @ x1)%expr_pat
                                            end (Compile.reflect x3)
                                        | None =>
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_add
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_get_carry)%expr @
                                                x @ x0 @ x1)%expr_pat
                                        end
                                    | _ =>
                                        if args =? 2 ^ Z.log2 args
                                        then
                                         UnderLets.Base
                                           (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                            (x0, x1))%expr_pat
                                        else
                                         UnderLets.Base
                                           (#(ident.Z_add_get_carry)%expr @ x @
                                            x0 @ x1)%expr_pat
                                    end
                                | @expr.LetIn _ _ _ _ _ _ _ =>
                                    match x2 with
                                    | #(idc2)%expr_pat =>
                                        match
                                          match idc2 with
                                          | @ident.Literal t3 v =>
                                              match
                                                t3 as t4
                                                return
                                                  (base.base_interp t4 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v0 : Z => Some v0
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v
                                          | _ => None
                                          end
                                        with
                                        | Some args2 =>
                                            match
                                              s0 as t3
                                              return
                                                (Compile.value' false t3 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base
                                                         (base.type.Z *
                                                          base.type.Z)%etype)))
                                            with
                                            | type.base t3 =>
                                                fun
                                                  v : defaults.expr
                                                        (type.base t3) =>
                                                base.try_make_transport_cps
                                                  (fun t4 : base.type =>
                                                   defaults.expr
                                                     (type.base t4)) t3
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           (base.type.Z *
                                                            base.type.Z)%etype)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t3) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       if
                                                        args =?
                                                        2 ^ Z.log2 args
                                                       then
                                                        UnderLets.Base
                                                          (#(ident.fancy_add
                                                               (Z.log2 args)
                                                               (- args2))%expr @
                                                           (x0, x' v))%expr_pat
                                                       else
                                                        if
                                                         args =?
                                                         2 ^ Z.log2 args
                                                        then
                                                         UnderLets.Base
                                                           (#(ident.fancy_add
                                                                (Z.log2 args)
                                                                0)%expr @
                                                            (x0, x1))%expr_pat
                                                        else
                                                         UnderLets.Base
                                                           (#(ident.Z_add_get_carry)%expr @
                                                            x @ x0 @ x1)%expr_pat
                                                   | None =>
                                                       UnderLets.Base
                                                         (#(ident.Z_add_get_carry)%expr @
                                                          x @ x0 @ x1)%expr_pat
                                                   end)
                                            | (s3 -> d3)%ptype =>
                                                fun
                                                  _ : Compile.value' false s3 ->
                                                      Compile.value' true d3
                                                =>
                                                UnderLets.Base
                                                  (#(ident.Z_add_get_carry)%expr @
                                                   x @ x0 @ x1)%expr_pat
                                            end (Compile.reflect x3)
                                        | None =>
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_add
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_get_carry)%expr @
                                                x @ x0 @ x1)%expr_pat
                                        end
                                    | _ =>
                                        if args =? 2 ^ Z.log2 args
                                        then
                                         UnderLets.Base
                                           (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                            (x0, x1))%expr_pat
                                        else
                                         UnderLets.Base
                                           (#(ident.Z_add_get_carry)%expr @ x @
                                            x0 @ x1)%expr_pat
                                    end
                                | _ =>
                                    match x2 with
                                    | #(idc2)%expr_pat =>
                                        match
                                          match idc2 with
                                          | @ident.Literal t3 v =>
                                              match
                                                t3 as t4
                                                return
                                                  (base.base_interp t4 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v0 : Z => Some v0
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v
                                          | _ => None
                                          end
                                        with
                                        | Some args2 =>
                                            match
                                              s0 as t3
                                              return
                                                (Compile.value' false t3 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base
                                                         (base.type.Z *
                                                          base.type.Z)%etype)))
                                            with
                                            | type.base t3 =>
                                                fun
                                                  v : defaults.expr
                                                        (type.base t3) =>
                                                base.try_make_transport_cps
                                                  (fun t4 : base.type =>
                                                   defaults.expr
                                                     (type.base t4)) t3
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           (base.type.Z *
                                                            base.type.Z)%etype)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t3) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       if
                                                        args =?
                                                        2 ^ Z.log2 args
                                                       then
                                                        UnderLets.Base
                                                          (#(ident.fancy_add
                                                               (Z.log2 args)
                                                               (- args2))%expr @
                                                           (x0, x' v))%expr_pat
                                                       else
                                                        if
                                                         args =?
                                                         2 ^ Z.log2 args
                                                        then
                                                         UnderLets.Base
                                                           (#(ident.fancy_add
                                                                (Z.log2 args)
                                                                0)%expr @
                                                            (x0, x1))%expr_pat
                                                        else
                                                         UnderLets.Base
                                                           (#(ident.Z_add_get_carry)%expr @
                                                            x @ x0 @ x1)%expr_pat
                                                   | None =>
                                                       UnderLets.Base
                                                         (#(ident.Z_add_get_carry)%expr @
                                                          x @ x0 @ x1)%expr_pat
                                                   end)
                                            | (s4 -> d4)%ptype =>
                                                fun
                                                  _ : Compile.value' false s4 ->
                                                      Compile.value' true d4
                                                =>
                                                UnderLets.Base
                                                  (#(ident.Z_add_get_carry)%expr @
                                                   x @ x0 @ x1)%expr_pat
                                            end (Compile.reflect x3)
                                        | None =>
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_add
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_get_carry)%expr @
                                                x @ x0 @ x1)%expr_pat
                                        end
                                    | _ =>
                                        if args =? 2 ^ Z.log2 args
                                        then
                                         UnderLets.Base
                                           (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                            (x0, x1))%expr_pat
                                        else
                                         UnderLets.Base
                                           (#(ident.Z_add_get_carry)%expr @ x @
                                            x0 @ x1)%expr_pat
                                    end
                                end
                            | None =>
                                match
                                  match idc1 with
                                  | ident.Z_shiftr => Some tt
                                  | _ => None
                                  end
                                with
                                | Some _ =>
                                    match x2 with
                                    | #(idc2)%expr_pat =>
                                        match
                                          match idc2 with
                                          | @ident.Literal t3 v =>
                                              match
                                                t3 as t4
                                                return
                                                  (base.base_interp t4 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v0 : Z => Some v0
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v
                                          | _ => None
                                          end
                                        with
                                        | Some args2 =>
                                            match
                                              s0 as t3
                                              return
                                                (Compile.value' false t3 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base
                                                         (base.type.Z *
                                                          base.type.Z)%etype)))
                                            with
                                            | type.base t3 =>
                                                fun
                                                  v : defaults.expr
                                                        (type.base t3) =>
                                                base.try_make_transport_cps
                                                  (fun t4 : base.type =>
                                                   defaults.expr
                                                     (type.base t4)) t3
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           (base.type.Z *
                                                            base.type.Z)%etype)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t3) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       if
                                                        args =?
                                                        2 ^ Z.log2 args
                                                       then
                                                        UnderLets.Base
                                                          (#(ident.fancy_add
                                                               (Z.log2 args)
                                                               (- args2))%expr @
                                                           (x0, x' v))%expr_pat
                                                       else
                                                        match x4 with
                                                        | #(idc3)%expr_pat =>
                                                            match
                                                              match idc3 with
                                                              | @ident.Literal
                                                                t5 v0 =>
                                                                  match
                                                                    t5 as t6
                                                                    return
                                                                    (base.base_interp
                                                                    t6 ->
                                                                    option Z)
                                                                  with
                                                                  | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                  | base.type.Z =>
                                                                    fun
                                                                    v1 : Z =>
                                                                    Some v1
                                                                  | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                  | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                  end v0
                                                              | _ => None
                                                              end
                                                            with
                                                            | Some args3 =>
                                                                match
                                                                  s2 as t5
                                                                  return
                                                                    (Compile.value'
                                                                    false t5 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)))
                                                                with
                                                                | type.base
                                                                  t5 =>
                                                                    fun
                                                                    v0 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t5) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t6 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t6)) t5
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)))
                                                                    (fun
                                                                    a0 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t5) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a0
                                                                    with
                                                                    | Some
                                                                    x'0 =>
                                                                    if
                                                                    args =?
                                                                    2
                                                                    ^ 
                                                                    Z.log2
                                                                    args
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_add
                                                                    (Z.log2
                                                                    args)
                                                                    (- args3))%expr @
                                                                    (x1,
                                                                    x'0 v0))%expr_pat
                                                                    else
                                                                    if
                                                                    args =?
                                                                    2
                                                                    ^ 
                                                                    Z.log2
                                                                    args
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_add
                                                                    (Z.log2
                                                                    args) 0)%expr @
                                                                    (x0, x1))%expr_pat
                                                                    else
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.Z_add_get_carry)%expr @
                                                                    x @ x0 @
                                                                    x1)%expr_pat
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.Z_add_get_carry)%expr @
                                                                    x @ x0 @
                                                                    x1)%expr_pat
                                                                    end)
                                                                | (s3 -> d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.Z_add_get_carry)%expr @
                                                                    x @ x0 @
                                                                    x1)%expr_pat
                                                                end
                                                                  (Compile.reflect
                                                                    x5)
                                                            | None =>
                                                                if
                                                                 args =?
                                                                 2
                                                                 ^ Z.log2
                                                                    args
                                                                then
                                                                 UnderLets.Base
                                                                   (#
                                                                    (ident.fancy_add
                                                                    (Z.log2
                                                                    args) 0)%expr @
                                                                    (x0, x1))%expr_pat
                                                                else
                                                                 UnderLets.Base
                                                                   (#
                                                                    (ident.Z_add_get_carry)%expr @
                                                                    x @ x0 @
                                                                    x1)%expr_pat
                                                            end
                                                        | _ =>
                                                            if
                                                             args =?
                                                             2 ^ Z.log2 args
                                                            then
                                                             UnderLets.Base
                                                               (#(ident.fancy_add
                                                                    (Z.log2
                                                                    args) 0)%expr @
                                                                (x0, x1))%expr_pat
                                                            else
                                                             UnderLets.Base
                                                               (#(ident.Z_add_get_carry)%expr @
                                                                x @ x0 @ x1)%expr_pat
                                                        end
                                                   | None =>
                                                       UnderLets.Base
                                                         (#(ident.Z_add_get_carry)%expr @
                                                          x @ x0 @ x1)%expr_pat
                                                   end)
                                            | (s3 -> d3)%ptype =>
                                                fun
                                                  _ : Compile.value' false s3 ->
                                                      Compile.value' true d3
                                                =>
                                                UnderLets.Base
                                                  (#(ident.Z_add_get_carry)%expr @
                                                   x @ x0 @ x1)%expr_pat
                                            end (Compile.reflect x3)
                                        | None =>
                                            match x4 with
                                            | #(idc3)%expr_pat =>
                                                match
                                                  match idc3 with
                                                  | @ident.Literal t4 v =>
                                                      match
                                                        t4 as t5
                                                        return
                                                          (base.base_interp
                                                             t5 -> option Z)
                                                      with
                                                      | base.type.unit =>
                                                          fun _ : unit =>
                                                          None
                                                      | base.type.Z =>
                                                          fun v0 : Z =>
                                                          Some v0
                                                      | base.type.bool =>
                                                          fun _ : bool =>
                                                          None
                                                      | base.type.nat =>
                                                          fun _ : nat => None
                                                      end v
                                                  | _ => None
                                                  end
                                                with
                                                | Some args2 =>
                                                    match
                                                      s2 as t4
                                                      return
                                                        (Compile.value' false
                                                           t4 ->
                                                         UnderLets.UnderLets
                                                           base.type ident
                                                           var
                                                           (defaults.expr
                                                              (type.base
                                                                 (base.type.Z *
                                                                  base.type.Z)%etype)))
                                                    with
                                                    | type.base t4 =>
                                                        fun
                                                          v : defaults.expr
                                                                (type.base t4)
                                                        =>
                                                        base.try_make_transport_cps
                                                          (fun t5 : base.type
                                                           =>
                                                           defaults.expr
                                                             (type.base t5))
                                                          t4 base.type.Z
                                                          (UnderLets.UnderLets
                                                             base.type ident
                                                             var
                                                             (defaults.expr
                                                                (type.base
                                                                   (base.type.Z *
                                                                    base.type.Z)%etype)))
                                                          (fun
                                                             a : option
                                                                   (defaults.expr
                                                                    (type.base
                                                                    t4) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                           =>
                                                           match a with
                                                           | Some x' =>
                                                               if
                                                                args =?
                                                                2
                                                                ^ Z.log2 args
                                                               then
                                                                UnderLets.Base
                                                                  (#(ident.fancy_add
                                                                    (Z.log2
                                                                    args)
                                                                    (- args2))%expr @
                                                                   (x1, x' v))%expr_pat
                                                               else
                                                                if
                                                                 args =?
                                                                 2
                                                                 ^ Z.log2
                                                                    args
                                                                then
                                                                 UnderLets.Base
                                                                   (#
                                                                    (ident.fancy_add
                                                                    (Z.log2
                                                                    args) 0)%expr @
                                                                    (x0, x1))%expr_pat
                                                                else
                                                                 UnderLets.Base
                                                                   (#
                                                                    (ident.Z_add_get_carry)%expr @
                                                                    x @ x0 @
                                                                    x1)%expr_pat
                                                           | None =>
                                                               UnderLets.Base
                                                                 (#(ident.Z_add_get_carry)%expr @
                                                                  x @ x0 @ x1)%expr_pat
                                                           end)
                                                    | (s3 -> d3)%ptype =>
                                                        fun
                                                          _ : Compile.value'
                                                                false s3 ->
                                                              Compile.value'
                                                                true d3 =>
                                                        UnderLets.Base
                                                          (#(ident.Z_add_get_carry)%expr @
                                                           x @ x0 @ x1)%expr_pat
                                                    end (Compile.reflect x5)
                                                | None =>
                                                    if
                                                     args =? 2 ^ Z.log2 args
                                                    then
                                                     UnderLets.Base
                                                       (#(ident.fancy_add
                                                            (Z.log2 args) 0)%expr @
                                                        (x0, x1))%expr_pat
                                                    else
                                                     UnderLets.Base
                                                       (#(ident.Z_add_get_carry)%expr @
                                                        x @ x0 @ x1)%expr_pat
                                                end
                                            | _ =>
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_add
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_get_carry)%expr @
                                                    x @ x0 @ x1)%expr_pat
                                            end
                                        end
                                    | ($_)%expr =>
                                        match x4 with
                                        | #(idc2)%expr_pat =>
                                            match
                                              match idc2 with
                                              | @ident.Literal t4 v0 =>
                                                  match
                                                    t4 as t5
                                                    return
                                                      (base.base_interp t5 ->
                                                       option Z)
                                                  with
                                                  | base.type.unit =>
                                                      fun _ : unit => None
                                                  | base.type.Z =>
                                                      fun v1 : Z => Some v1
                                                  | base.type.bool =>
                                                      fun _ : bool => None
                                                  | base.type.nat =>
                                                      fun _ : nat => None
                                                  end v0
                                              | _ => None
                                              end
                                            with
                                            | Some args2 =>
                                                match
                                                  s2 as t4
                                                  return
                                                    (Compile.value' false t4 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             (base.type.Z *
                                                              base.type.Z)%etype)))
                                                with
                                                | type.base t4 =>
                                                    fun
                                                      v0 : defaults.expr
                                                             (type.base t4)
                                                    =>
                                                    base.try_make_transport_cps
                                                      (fun t5 : base.type =>
                                                       defaults.expr
                                                         (type.base t5)) t4
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               (base.type.Z *
                                                                base.type.Z)%etype)))
                                                      (fun
                                                         a : option
                                                               (defaults.expr
                                                                  (type.base
                                                                    t4) ->
                                                                defaults.expr
                                                                  (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a with
                                                       | Some x' =>
                                                           if
                                                            args =?
                                                            2 ^ Z.log2 args
                                                           then
                                                            UnderLets.Base
                                                              (#(ident.fancy_add
                                                                   (Z.log2
                                                                    args)
                                                                   (- args2))%expr @
                                                               (x1, x' v0))%expr_pat
                                                           else
                                                            if
                                                             args =?
                                                             2 ^ Z.log2 args
                                                            then
                                                             UnderLets.Base
                                                               (#(ident.fancy_add
                                                                    (Z.log2
                                                                    args) 0)%expr @
                                                                (x0, x1))%expr_pat
                                                            else
                                                             UnderLets.Base
                                                               (#(ident.Z_add_get_carry)%expr @
                                                                x @ x0 @ x1)%expr_pat
                                                       | None =>
                                                           UnderLets.Base
                                                             (#(ident.Z_add_get_carry)%expr @
                                                              x @ x0 @ x1)%expr_pat
                                                       end)
                                                | (s3 -> d3)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s3 ->
                                                          Compile.value' true
                                                            d3 =>
                                                    UnderLets.Base
                                                      (#(ident.Z_add_get_carry)%expr @
                                                       x @ x0 @ x1)%expr_pat
                                                end (Compile.reflect x5)
                                            | None =>
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_add
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_get_carry)%expr @
                                                    x @ x0 @ x1)%expr_pat
                                            end
                                        | _ =>
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_add
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_get_carry)%expr @
                                                x @ x0 @ x1)%expr_pat
                                        end
                                    | @expr.LetIn _ _ _ _ _ _ _ =>
                                        match x4 with
                                        | #(idc2)%expr_pat =>
                                            match
                                              match idc2 with
                                              | @ident.Literal t3 v =>
                                                  match
                                                    t3 as t4
                                                    return
                                                      (base.base_interp t4 ->
                                                       option Z)
                                                  with
                                                  | base.type.unit =>
                                                      fun _ : unit => None
                                                  | base.type.Z =>
                                                      fun v0 : Z => Some v0
                                                  | base.type.bool =>
                                                      fun _ : bool => None
                                                  | base.type.nat =>
                                                      fun _ : nat => None
                                                  end v
                                              | _ => None
                                              end
                                            with
                                            | Some args2 =>
                                                match
                                                  s2 as t3
                                                  return
                                                    (Compile.value' false t3 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             (base.type.Z *
                                                              base.type.Z)%etype)))
                                                with
                                                | type.base t3 =>
                                                    fun
                                                      v : defaults.expr
                                                            (type.base t3) =>
                                                    base.try_make_transport_cps
                                                      (fun t4 : base.type =>
                                                       defaults.expr
                                                         (type.base t4)) t3
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               (base.type.Z *
                                                                base.type.Z)%etype)))
                                                      (fun
                                                         a : option
                                                               (defaults.expr
                                                                  (type.base
                                                                    t3) ->
                                                                defaults.expr
                                                                  (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a with
                                                       | Some x' =>
                                                           if
                                                            args =?
                                                            2 ^ Z.log2 args
                                                           then
                                                            UnderLets.Base
                                                              (#(ident.fancy_add
                                                                   (Z.log2
                                                                    args)
                                                                   (- args2))%expr @
                                                               (x1, x' v))%expr_pat
                                                           else
                                                            if
                                                             args =?
                                                             2 ^ Z.log2 args
                                                            then
                                                             UnderLets.Base
                                                               (#(ident.fancy_add
                                                                    (Z.log2
                                                                    args) 0)%expr @
                                                                (x0, x1))%expr_pat
                                                            else
                                                             UnderLets.Base
                                                               (#(ident.Z_add_get_carry)%expr @
                                                                x @ x0 @ x1)%expr_pat
                                                       | None =>
                                                           UnderLets.Base
                                                             (#(ident.Z_add_get_carry)%expr @
                                                              x @ x0 @ x1)%expr_pat
                                                       end)
                                                | (s3 -> d3)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s3 ->
                                                          Compile.value' true
                                                            d3 =>
                                                    UnderLets.Base
                                                      (#(ident.Z_add_get_carry)%expr @
                                                       x @ x0 @ x1)%expr_pat
                                                end (Compile.reflect x5)
                                            | None =>
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_add
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_get_carry)%expr @
                                                    x @ x0 @ x1)%expr_pat
                                            end
                                        | _ =>
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_add
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_get_carry)%expr @
                                                x @ x0 @ x1)%expr_pat
                                        end
                                    | _ =>
                                        match x4 with
                                        | #(idc2)%expr_pat =>
                                            match
                                              match idc2 with
                                              | @ident.Literal t3 v =>
                                                  match
                                                    t3 as t4
                                                    return
                                                      (base.base_interp t4 ->
                                                       option Z)
                                                  with
                                                  | base.type.unit =>
                                                      fun _ : unit => None
                                                  | base.type.Z =>
                                                      fun v0 : Z => Some v0
                                                  | base.type.bool =>
                                                      fun _ : bool => None
                                                  | base.type.nat =>
                                                      fun _ : nat => None
                                                  end v
                                              | _ => None
                                              end
                                            with
                                            | Some args2 =>
                                                match
                                                  s2 as t3
                                                  return
                                                    (Compile.value' false t3 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             (base.type.Z *
                                                              base.type.Z)%etype)))
                                                with
                                                | type.base t3 =>
                                                    fun
                                                      v : defaults.expr
                                                            (type.base t3) =>
                                                    base.try_make_transport_cps
                                                      (fun t4 : base.type =>
                                                       defaults.expr
                                                         (type.base t4)) t3
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               (base.type.Z *
                                                                base.type.Z)%etype)))
                                                      (fun
                                                         a : option
                                                               (defaults.expr
                                                                  (type.base
                                                                    t3) ->
                                                                defaults.expr
                                                                  (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a with
                                                       | Some x' =>
                                                           if
                                                            args =?
                                                            2 ^ Z.log2 args
                                                           then
                                                            UnderLets.Base
                                                              (#(ident.fancy_add
                                                                   (Z.log2
                                                                    args)
                                                                   (- args2))%expr @
                                                               (x1, x' v))%expr_pat
                                                           else
                                                            if
                                                             args =?
                                                             2 ^ Z.log2 args
                                                            then
                                                             UnderLets.Base
                                                               (#(ident.fancy_add
                                                                    (Z.log2
                                                                    args) 0)%expr @
                                                                (x0, x1))%expr_pat
                                                            else
                                                             UnderLets.Base
                                                               (#(ident.Z_add_get_carry)%expr @
                                                                x @ x0 @ x1)%expr_pat
                                                       | None =>
                                                           UnderLets.Base
                                                             (#(ident.Z_add_get_carry)%expr @
                                                              x @ x0 @ x1)%expr_pat
                                                       end)
                                                | (s4 -> d4)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s4 ->
                                                          Compile.value' true
                                                            d4 =>
                                                    UnderLets.Base
                                                      (#(ident.Z_add_get_carry)%expr @
                                                       x @ x0 @ x1)%expr_pat
                                                end (Compile.reflect x5)
                                            | None =>
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_add
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_get_carry)%expr @
                                                    x @ x0 @ x1)%expr_pat
                                            end
                                        | _ =>
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_add
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_get_carry)%expr @
                                                x @ x0 @ x1)%expr_pat
                                        end
                                    end
                                | None =>
                                    match x2 with
                                    | #(idc2)%expr_pat =>
                                        match
                                          match idc2 with
                                          | @ident.Literal t3 v =>
                                              match
                                                t3 as t4
                                                return
                                                  (base.base_interp t4 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v0 : Z => Some v0
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v
                                          | _ => None
                                          end
                                        with
                                        | Some args1 =>
                                            match
                                              s0 as t3
                                              return
                                                (Compile.value' false t3 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base
                                                         (base.type.Z *
                                                          base.type.Z)%etype)))
                                            with
                                            | type.base t3 =>
                                                fun
                                                  v : defaults.expr
                                                        (type.base t3) =>
                                                base.try_make_transport_cps
                                                  (fun t4 : base.type =>
                                                   defaults.expr
                                                     (type.base t4)) t3
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           (base.type.Z *
                                                            base.type.Z)%etype)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t3) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       if
                                                        args =?
                                                        2 ^ Z.log2 args
                                                       then
                                                        UnderLets.Base
                                                          (#(ident.fancy_add
                                                               (Z.log2 args)
                                                               (- args1))%expr @
                                                           (x0, x' v))%expr_pat
                                                       else
                                                        if
                                                         args =?
                                                         2 ^ Z.log2 args
                                                        then
                                                         UnderLets.Base
                                                           (#(ident.fancy_add
                                                                (Z.log2 args)
                                                                0)%expr @
                                                            (x0, x1))%expr_pat
                                                        else
                                                         UnderLets.Base
                                                           (#(ident.Z_add_get_carry)%expr @
                                                            x @ x0 @ x1)%expr_pat
                                                   | None =>
                                                       UnderLets.Base
                                                         (#(ident.Z_add_get_carry)%expr @
                                                          x @ x0 @ x1)%expr_pat
                                                   end)
                                            | (s3 -> d3)%ptype =>
                                                fun
                                                  _ : Compile.value' false s3 ->
                                                      Compile.value' true d3
                                                =>
                                                UnderLets.Base
                                                  (#(ident.Z_add_get_carry)%expr @
                                                   x @ x0 @ x1)%expr_pat
                                            end (Compile.reflect x3)
                                        | None =>
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_add
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_get_carry)%expr @
                                                x @ x0 @ x1)%expr_pat
                                        end
                                    | _ =>
                                        if args =? 2 ^ Z.log2 args
                                        then
                                         UnderLets.Base
                                           (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                            (x0, x1))%expr_pat
                                        else
                                         UnderLets.Base
                                           (#(ident.Z_add_get_carry)%expr @ x @
                                            x0 @ x1)%expr_pat
                                    end
                                end
                            end
                        | (@expr.App _ _ _ s2 _ ($_)%expr _ @ _)%expr_pat =>
                            match x2 with
                            | #(idc1)%expr_pat =>
                                match
                                  match idc1 with
                                  | @ident.Literal t3 v0 =>
                                      match
                                        t3 as t4
                                        return
                                          (base.base_interp t4 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v1 : Z => Some v1
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v0
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s0 as t3
                                      return
                                        (Compile.value' false t3 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t3 =>
                                        fun v0 : defaults.expr (type.base t3)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t4 : base.type =>
                                           defaults.expr (type.base t4)) t3
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t3) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_add
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x0, x' v0))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_add
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_get_carry)%expr @
                                                    x @ x0 @ x1)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_get_carry)%expr @
                                                  x @ x0 @ x1)%expr_pat
                                           end)
                                    | (s3 -> d3)%ptype =>
                                        fun
                                          _ : Compile.value' false s3 ->
                                              Compile.value' true d3 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_get_carry)%expr @ x @
                                           x0 @ x1)%expr_pat
                                    end (Compile.reflect x3)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                        (x0, x1))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_get_carry)%expr @ x @
                                        x0 @ x1)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                    (x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                    x1)%expr_pat
                            end
                        | (@expr.App _ _ _ s2 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                          (@expr.App _ _ _ s2 _ (_ @ _) _ @ _)%expr_pat =>
                            match x2 with
                            | #(idc1)%expr_pat =>
                                match
                                  match idc1 with
                                  | @ident.Literal t2 v =>
                                      match
                                        t2 as t3
                                        return
                                          (base.base_interp t3 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s0 as t2
                                      return
                                        (Compile.value' false t2 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t2 =>
                                        fun v : defaults.expr (type.base t2)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t3 : base.type =>
                                           defaults.expr (type.base t3)) t2
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t2) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_add
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x0, x' v))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_add
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_get_carry)%expr @
                                                    x @ x0 @ x1)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_get_carry)%expr @
                                                  x @ x0 @ x1)%expr_pat
                                           end)
                                    | (s4 -> d4)%ptype =>
                                        fun
                                          _ : Compile.value' false s4 ->
                                              Compile.value' true d4 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_get_carry)%expr @ x @
                                           x0 @ x1)%expr_pat
                                    end (Compile.reflect x3)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                        (x0, x1))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_get_carry)%expr @ x @
                                        x0 @ x1)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                    (x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                    x1)%expr_pat
                            end
                        | (@expr.App _ _ _ s2 _ (@expr.LetIn _ _ _ _ _ _ _)
                           _ @ _)%expr_pat =>
                            match x2 with
                            | #(idc1)%expr_pat =>
                                match
                                  match idc1 with
                                  | @ident.Literal t2 v =>
                                      match
                                        t2 as t3
                                        return
                                          (base.base_interp t3 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s0 as t2
                                      return
                                        (Compile.value' false t2 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t2 =>
                                        fun v : defaults.expr (type.base t2)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t3 : base.type =>
                                           defaults.expr (type.base t3)) t2
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t2) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_add
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x0, x' v))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_add
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_get_carry)%expr @
                                                    x @ x0 @ x1)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_get_carry)%expr @
                                                  x @ x0 @ x1)%expr_pat
                                           end)
                                    | (s3 -> d3)%ptype =>
                                        fun
                                          _ : Compile.value' false s3 ->
                                              Compile.value' true d3 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_get_carry)%expr @ x @
                                           x0 @ x1)%expr_pat
                                    end (Compile.reflect x3)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                        (x0, x1))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_get_carry)%expr @ x @
                                        x0 @ x1)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                    (x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                    x1)%expr_pat
                            end
                        | @expr.LetIn _ _ _ _ _ _ _ =>
                            match x2 with
                            | #(idc1)%expr_pat =>
                                match
                                  match idc1 with
                                  | @ident.Literal t2 v =>
                                      match
                                        t2 as t3
                                        return
                                          (base.base_interp t3 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s0 as t2
                                      return
                                        (Compile.value' false t2 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t2 =>
                                        fun v : defaults.expr (type.base t2)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t3 : base.type =>
                                           defaults.expr (type.base t3)) t2
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t2) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_add
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x0, x' v))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_add
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_get_carry)%expr @
                                                    x @ x0 @ x1)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_get_carry)%expr @
                                                  x @ x0 @ x1)%expr_pat
                                           end)
                                    | (s1 -> d1)%ptype =>
                                        fun
                                          _ : Compile.value' false s1 ->
                                              Compile.value' true d1 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_get_carry)%expr @ x @
                                           x0 @ x1)%expr_pat
                                    end (Compile.reflect x3)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                        (x0, x1))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_get_carry)%expr @ x @
                                        x0 @ x1)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                    (x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                    x1)%expr_pat
                            end
                        | _ =>
                            match x2 with
                            | #(idc1)%expr_pat =>
                                match
                                  match idc1 with
                                  | @ident.Literal t2 v =>
                                      match
                                        t2 as t3
                                        return
                                          (base.base_interp t3 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s0 as t2
                                      return
                                        (Compile.value' false t2 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t2 =>
                                        fun v : defaults.expr (type.base t2)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t3 : base.type =>
                                           defaults.expr (type.base t3)) t2
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t2) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_add
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x0, x' v))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_add
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_get_carry)%expr @
                                                    x @ x0 @ x1)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_get_carry)%expr @
                                                  x @ x0 @ x1)%expr_pat
                                           end)
                                    | (s2 -> d2)%ptype =>
                                        fun
                                          _ : Compile.value' false s2 ->
                                              Compile.value' true d2 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_get_carry)%expr @ x @
                                           x0 @ x1)%expr_pat
                                    end (Compile.reflect x3)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                        (x0, x1))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_get_carry)%expr @ x @
                                        x0 @ x1)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                    (x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                    x1)%expr_pat
                            end
                        end
                    | None =>
                        match x0 with
                        | (@expr.App _ _ _ s2 _ #(idc1) x5 @ x4)%expr_pat =>
                            match
                              match idc1 with
                              | ident.Z_shiftl => Some tt
                              | _ => None
                              end
                            with
                            | Some _ =>
                                match x4 with
                                | #(idc2)%expr_pat =>
                                    match
                                      match idc2 with
                                      | @ident.Literal t3 v =>
                                          match
                                            t3 as t4
                                            return
                                              (base.base_interp t4 ->
                                               option Z)
                                          with
                                          | base.type.unit =>
                                              fun _ : unit => None
                                          | base.type.Z =>
                                              fun v0 : Z => Some v0
                                          | base.type.bool =>
                                              fun _ : bool => None
                                          | base.type.nat =>
                                              fun _ : nat => None
                                          end v
                                      | _ => None
                                      end
                                    with
                                    | Some args1 =>
                                        match
                                          s2 as t3
                                          return
                                            (Compile.value' false t3 ->
                                             UnderLets.UnderLets base.type
                                               ident var
                                               (defaults.expr
                                                  (type.base
                                                     (base.type.Z *
                                                      base.type.Z)%etype)))
                                        with
                                        | type.base t3 =>
                                            fun
                                              v : defaults.expr
                                                    (type.base t3) =>
                                            base.try_make_transport_cps
                                              (fun t4 : base.type =>
                                               defaults.expr (type.base t4))
                                              t3 base.type.Z
                                              (UnderLets.UnderLets base.type
                                                 ident var
                                                 (defaults.expr
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)))
                                              (fun
                                                 a : option
                                                       (defaults.expr
                                                          (type.base t3) ->
                                                        defaults.expr
                                                          (type.base
                                                             base.type.Z)) =>
                                               match a with
                                               | Some x' =>
                                                   if args =? 2 ^ Z.log2 args
                                                   then
                                                    UnderLets.Base
                                                      (#(ident.fancy_add
                                                           (Z.log2 args)
                                                           args1)%expr @
                                                       (x1, x' v))%expr_pat
                                                   else
                                                    if
                                                     args =? 2 ^ Z.log2 args
                                                    then
                                                     UnderLets.Base
                                                       (#(ident.fancy_add
                                                            (Z.log2 args) 0)%expr @
                                                        (x0, x1))%expr_pat
                                                    else
                                                     UnderLets.Base
                                                       (#(ident.Z_add_get_carry)%expr @
                                                        x @ x0 @ x1)%expr_pat
                                               | None =>
                                                   UnderLets.Base
                                                     (#(ident.Z_add_get_carry)%expr @
                                                      x @ x0 @ x1)%expr_pat
                                               end)
                                        | (s3 -> d3)%ptype =>
                                            fun
                                              _ : Compile.value' false s3 ->
                                                  Compile.value' true d3 =>
                                            UnderLets.Base
                                              (#(ident.Z_add_get_carry)%expr @
                                               x @ x0 @ x1)%expr_pat
                                        end (Compile.reflect x5)
                                    | None =>
                                        if args =? 2 ^ Z.log2 args
                                        then
                                         UnderLets.Base
                                           (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                            (x0, x1))%expr_pat
                                        else
                                         UnderLets.Base
                                           (#(ident.Z_add_get_carry)%expr @ x @
                                            x0 @ x1)%expr_pat
                                    end
                                | _ =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                        (x0, x1))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_get_carry)%expr @ x @
                                        x0 @ x1)%expr_pat
                                end
                            | None =>
                                match
                                  match idc1 with
                                  | ident.Z_shiftr => Some tt
                                  | _ => None
                                  end
                                with
                                | Some _ =>
                                    match x4 with
                                    | #(idc2)%expr_pat =>
                                        match
                                          match idc2 with
                                          | @ident.Literal t3 v =>
                                              match
                                                t3 as t4
                                                return
                                                  (base.base_interp t4 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v0 : Z => Some v0
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v
                                          | _ => None
                                          end
                                        with
                                        | Some args1 =>
                                            match
                                              s2 as t3
                                              return
                                                (Compile.value' false t3 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base
                                                         (base.type.Z *
                                                          base.type.Z)%etype)))
                                            with
                                            | type.base t3 =>
                                                fun
                                                  v : defaults.expr
                                                        (type.base t3) =>
                                                base.try_make_transport_cps
                                                  (fun t4 : base.type =>
                                                   defaults.expr
                                                     (type.base t4)) t3
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           (base.type.Z *
                                                            base.type.Z)%etype)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t3) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       if
                                                        args =?
                                                        2 ^ Z.log2 args
                                                       then
                                                        UnderLets.Base
                                                          (#(ident.fancy_add
                                                               (Z.log2 args)
                                                               (- args1))%expr @
                                                           (x1, x' v))%expr_pat
                                                       else
                                                        if
                                                         args =?
                                                         2 ^ Z.log2 args
                                                        then
                                                         UnderLets.Base
                                                           (#(ident.fancy_add
                                                                (Z.log2 args)
                                                                0)%expr @
                                                            (x0, x1))%expr_pat
                                                        else
                                                         UnderLets.Base
                                                           (#(ident.Z_add_get_carry)%expr @
                                                            x @ x0 @ x1)%expr_pat
                                                   | None =>
                                                       UnderLets.Base
                                                         (#(ident.Z_add_get_carry)%expr @
                                                          x @ x0 @ x1)%expr_pat
                                                   end)
                                            | (s3 -> d3)%ptype =>
                                                fun
                                                  _ : Compile.value' false s3 ->
                                                      Compile.value' true d3
                                                =>
                                                UnderLets.Base
                                                  (#(ident.Z_add_get_carry)%expr @
                                                   x @ x0 @ x1)%expr_pat
                                            end (Compile.reflect x5)
                                        | None =>
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_add
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_get_carry)%expr @
                                                x @ x0 @ x1)%expr_pat
                                        end
                                    | _ =>
                                        if args =? 2 ^ Z.log2 args
                                        then
                                         UnderLets.Base
                                           (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                            (x0, x1))%expr_pat
                                        else
                                         UnderLets.Base
                                           (#(ident.Z_add_get_carry)%expr @ x @
                                            x0 @ x1)%expr_pat
                                    end
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                        (x0, x1))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_get_carry)%expr @ x @
                                        x0 @ x1)%expr_pat
                                end
                            end
                        | (@expr.App _ _ _ s2 _ ($_)%expr _ @ _)%expr_pat |
                          (@expr.App _ _ _ s2 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                          (@expr.App _ _ _ s2 _ (_ @ _) _ @ _)%expr_pat |
                          (@expr.App _ _ _ s2 _ (@expr.LetIn _ _ _ _ _ _ _)
                           _ @ _)%expr_pat =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                (x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                        | _ =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                (x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                        end
                    end
                end
            | (@expr.App _ _ _ s0 _ ($_)%expr _ @ _)%expr_pat =>
                match x0 with
                | (@expr.App _ _ _ s2 _ #(idc0) x5 @ x4)%expr_pat =>
                    match
                      match idc0 with
                      | ident.Z_shiftl => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match x4 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t3 v0 =>
                                  match
                                    t3 as t4
                                    return (base.base_interp t4 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v1 : Z => Some v1
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v0
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                match
                                  s2 as t3
                                  return
                                    (Compile.value' false t3 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)))
                                with
                                | type.base t3 =>
                                    fun v0 : defaults.expr (type.base t3) =>
                                    base.try_make_transport_cps
                                      (fun t4 : base.type =>
                                       defaults.expr (type.base t4)) t3
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base
                                               (base.type.Z * base.type.Z)%etype)))
                                      (fun
                                         a : option
                                               (defaults.expr (type.base t3) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                       match a with
                                       | Some x' =>
                                           if args =? 2 ^ Z.log2 args
                                           then
                                            UnderLets.Base
                                              (#(ident.fancy_add
                                                   (Z.log2 args) args1)%expr @
                                               (x1, x' v0))%expr_pat
                                           else
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_add
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_get_carry)%expr @
                                                x @ x0 @ x1)%expr_pat
                                       | None =>
                                           UnderLets.Base
                                             (#(ident.Z_add_get_carry)%expr @
                                              x @ x0 @ x1)%expr_pat
                                       end)
                                | (s3 -> d3)%ptype =>
                                    fun
                                      _ : Compile.value' false s3 ->
                                          Compile.value' true d3 =>
                                    UnderLets.Base
                                      (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                       x1)%expr_pat
                                end (Compile.reflect x5)
                            | None =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                    (x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                    x1)%expr_pat
                            end
                        | _ =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                (x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                        end
                    | None =>
                        match
                          match idc0 with
                          | ident.Z_shiftr => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match x4 with
                            | #(idc1)%expr_pat =>
                                match
                                  match idc1 with
                                  | @ident.Literal t3 v0 =>
                                      match
                                        t3 as t4
                                        return
                                          (base.base_interp t4 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v1 : Z => Some v1
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v0
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s2 as t3
                                      return
                                        (Compile.value' false t3 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t3 =>
                                        fun v0 : defaults.expr (type.base t3)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t4 : base.type =>
                                           defaults.expr (type.base t4)) t3
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t3) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_add
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x1, x' v0))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_add
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_get_carry)%expr @
                                                    x @ x0 @ x1)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_get_carry)%expr @
                                                  x @ x0 @ x1)%expr_pat
                                           end)
                                    | (s3 -> d3)%ptype =>
                                        fun
                                          _ : Compile.value' false s3 ->
                                              Compile.value' true d3 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_get_carry)%expr @ x @
                                           x0 @ x1)%expr_pat
                                    end (Compile.reflect x5)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                        (x0, x1))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_get_carry)%expr @ x @
                                        x0 @ x1)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                    (x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                    x1)%expr_pat
                            end
                        | None =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                (x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                        end
                    end
                | (@expr.App _ _ _ s2 _ ($_)%expr _ @ _)%expr_pat |
                  (@expr.App _ _ _ s2 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s2 _ (_ @ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s2 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_add (Z.log2 args) 0)%expr @ (x0, x1))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                | _ =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_add (Z.log2 args) 0)%expr @ (x0, x1))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                end
            | (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat =>
                match x0 with
                | (@expr.App _ _ _ s3 _ #(idc0) x5 @ x4)%expr_pat =>
                    match
                      match idc0 with
                      | ident.Z_shiftl => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match x4 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t2 v =>
                                  match
                                    t2 as t3
                                    return (base.base_interp t3 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v0 : Z => Some v0
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                match
                                  s3 as t2
                                  return
                                    (Compile.value' false t2 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)))
                                with
                                | type.base t2 =>
                                    fun v : defaults.expr (type.base t2) =>
                                    base.try_make_transport_cps
                                      (fun t3 : base.type =>
                                       defaults.expr (type.base t3)) t2
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base
                                               (base.type.Z * base.type.Z)%etype)))
                                      (fun
                                         a : option
                                               (defaults.expr (type.base t2) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                       match a with
                                       | Some x' =>
                                           if args =? 2 ^ Z.log2 args
                                           then
                                            UnderLets.Base
                                              (#(ident.fancy_add
                                                   (Z.log2 args) args1)%expr @
                                               (x1, x' v))%expr_pat
                                           else
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_add
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_get_carry)%expr @
                                                x @ x0 @ x1)%expr_pat
                                       | None =>
                                           UnderLets.Base
                                             (#(ident.Z_add_get_carry)%expr @
                                              x @ x0 @ x1)%expr_pat
                                       end)
                                | (s4 -> d4)%ptype =>
                                    fun
                                      _ : Compile.value' false s4 ->
                                          Compile.value' true d4 =>
                                    UnderLets.Base
                                      (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                       x1)%expr_pat
                                end (Compile.reflect x5)
                            | None =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                    (x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                    x1)%expr_pat
                            end
                        | _ =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                (x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                        end
                    | None =>
                        match
                          match idc0 with
                          | ident.Z_shiftr => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match x4 with
                            | #(idc1)%expr_pat =>
                                match
                                  match idc1 with
                                  | @ident.Literal t2 v =>
                                      match
                                        t2 as t3
                                        return
                                          (base.base_interp t3 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s3 as t2
                                      return
                                        (Compile.value' false t2 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t2 =>
                                        fun v : defaults.expr (type.base t2)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t3 : base.type =>
                                           defaults.expr (type.base t3)) t2
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t2) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_add
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x1, x' v))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_add
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_get_carry)%expr @
                                                    x @ x0 @ x1)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_get_carry)%expr @
                                                  x @ x0 @ x1)%expr_pat
                                           end)
                                    | (s4 -> d4)%ptype =>
                                        fun
                                          _ : Compile.value' false s4 ->
                                              Compile.value' true d4 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_get_carry)%expr @ x @
                                           x0 @ x1)%expr_pat
                                    end (Compile.reflect x5)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                        (x0, x1))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_get_carry)%expr @ x @
                                        x0 @ x1)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                    (x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                    x1)%expr_pat
                            end
                        | None =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                (x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                        end
                    end
                | (@expr.App _ _ _ s3 _ ($_)%expr _ @ _)%expr_pat |
                  (@expr.App _ _ _ s3 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s3 _ (_ @ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s3 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_add (Z.log2 args) 0)%expr @ (x0, x1))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                | _ =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_add (Z.log2 args) 0)%expr @ (x0, x1))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                end
            | (@expr.App _ _ _ s0 _ (_ @ _) _ @ _)%expr_pat =>
                match x0 with
                | (@expr.App _ _ _ s3 _ #(idc0) x6 @ x5)%expr_pat =>
                    match
                      match idc0 with
                      | ident.Z_shiftl => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match x5 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t2 v =>
                                  match
                                    t2 as t3
                                    return (base.base_interp t3 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v0 : Z => Some v0
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                match
                                  s3 as t2
                                  return
                                    (Compile.value' false t2 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)))
                                with
                                | type.base t2 =>
                                    fun v : defaults.expr (type.base t2) =>
                                    base.try_make_transport_cps
                                      (fun t3 : base.type =>
                                       defaults.expr (type.base t3)) t2
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base
                                               (base.type.Z * base.type.Z)%etype)))
                                      (fun
                                         a : option
                                               (defaults.expr (type.base t2) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                       match a with
                                       | Some x' =>
                                           if args =? 2 ^ Z.log2 args
                                           then
                                            UnderLets.Base
                                              (#(ident.fancy_add
                                                   (Z.log2 args) args1)%expr @
                                               (x1, x' v))%expr_pat
                                           else
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_add
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_get_carry)%expr @
                                                x @ x0 @ x1)%expr_pat
                                       | None =>
                                           UnderLets.Base
                                             (#(ident.Z_add_get_carry)%expr @
                                              x @ x0 @ x1)%expr_pat
                                       end)
                                | (s4 -> d4)%ptype =>
                                    fun
                                      _ : Compile.value' false s4 ->
                                          Compile.value' true d4 =>
                                    UnderLets.Base
                                      (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                       x1)%expr_pat
                                end (Compile.reflect x6)
                            | None =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                    (x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                    x1)%expr_pat
                            end
                        | _ =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                (x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                        end
                    | None =>
                        match
                          match idc0 with
                          | ident.Z_shiftr => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match x5 with
                            | #(idc1)%expr_pat =>
                                match
                                  match idc1 with
                                  | @ident.Literal t2 v =>
                                      match
                                        t2 as t3
                                        return
                                          (base.base_interp t3 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s3 as t2
                                      return
                                        (Compile.value' false t2 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t2 =>
                                        fun v : defaults.expr (type.base t2)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t3 : base.type =>
                                           defaults.expr (type.base t3)) t2
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t2) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_add
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x1, x' v))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_add
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_get_carry)%expr @
                                                    x @ x0 @ x1)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_get_carry)%expr @
                                                  x @ x0 @ x1)%expr_pat
                                           end)
                                    | (s4 -> d4)%ptype =>
                                        fun
                                          _ : Compile.value' false s4 ->
                                              Compile.value' true d4 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_get_carry)%expr @ x @
                                           x0 @ x1)%expr_pat
                                    end (Compile.reflect x6)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                        (x0, x1))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_get_carry)%expr @ x @
                                        x0 @ x1)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                    (x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                    x1)%expr_pat
                            end
                        | None =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                (x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                        end
                    end
                | (@expr.App _ _ _ s3 _ ($_)%expr _ @ _)%expr_pat |
                  (@expr.App _ _ _ s3 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s3 _ (_ @ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s3 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_add (Z.log2 args) 0)%expr @ (x0, x1))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                | _ =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_add (Z.log2 args) 0)%expr @ (x0, x1))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                end
            | (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                match x0 with
                | (@expr.App _ _ _ s2 _ #(idc0) x6 @ x5)%expr_pat =>
                    match
                      match idc0 with
                      | ident.Z_shiftl => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match x5 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t2 v =>
                                  match
                                    t2 as t3
                                    return (base.base_interp t3 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v0 : Z => Some v0
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                match
                                  s2 as t2
                                  return
                                    (Compile.value' false t2 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)))
                                with
                                | type.base t2 =>
                                    fun v : defaults.expr (type.base t2) =>
                                    base.try_make_transport_cps
                                      (fun t3 : base.type =>
                                       defaults.expr (type.base t3)) t2
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base
                                               (base.type.Z * base.type.Z)%etype)))
                                      (fun
                                         a : option
                                               (defaults.expr (type.base t2) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                       match a with
                                       | Some x' =>
                                           if args =? 2 ^ Z.log2 args
                                           then
                                            UnderLets.Base
                                              (#(ident.fancy_add
                                                   (Z.log2 args) args1)%expr @
                                               (x1, x' v))%expr_pat
                                           else
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_add
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_get_carry)%expr @
                                                x @ x0 @ x1)%expr_pat
                                       | None =>
                                           UnderLets.Base
                                             (#(ident.Z_add_get_carry)%expr @
                                              x @ x0 @ x1)%expr_pat
                                       end)
                                | (s3 -> d3)%ptype =>
                                    fun
                                      _ : Compile.value' false s3 ->
                                          Compile.value' true d3 =>
                                    UnderLets.Base
                                      (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                       x1)%expr_pat
                                end (Compile.reflect x6)
                            | None =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                    (x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                    x1)%expr_pat
                            end
                        | _ =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                (x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                        end
                    | None =>
                        match
                          match idc0 with
                          | ident.Z_shiftr => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match x5 with
                            | #(idc1)%expr_pat =>
                                match
                                  match idc1 with
                                  | @ident.Literal t2 v =>
                                      match
                                        t2 as t3
                                        return
                                          (base.base_interp t3 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s2 as t2
                                      return
                                        (Compile.value' false t2 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t2 =>
                                        fun v : defaults.expr (type.base t2)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t3 : base.type =>
                                           defaults.expr (type.base t3)) t2
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t2) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_add
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x1, x' v))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_add
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_get_carry)%expr @
                                                    x @ x0 @ x1)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_get_carry)%expr @
                                                  x @ x0 @ x1)%expr_pat
                                           end)
                                    | (s3 -> d3)%ptype =>
                                        fun
                                          _ : Compile.value' false s3 ->
                                              Compile.value' true d3 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_get_carry)%expr @ x @
                                           x0 @ x1)%expr_pat
                                    end (Compile.reflect x6)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                        (x0, x1))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_get_carry)%expr @ x @
                                        x0 @ x1)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                    (x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                    x1)%expr_pat
                            end
                        | None =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                (x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                        end
                    end
                | (@expr.App _ _ _ s2 _ ($_)%expr _ @ _)%expr_pat |
                  (@expr.App _ _ _ s2 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s2 _ (_ @ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s2 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_add (Z.log2 args) 0)%expr @ (x0, x1))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                | _ =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_add (Z.log2 args) 0)%expr @ (x0, x1))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                end
            | (@expr.LetIn _ _ _ _ _ _ _ @ _)%expr_pat =>
                match x0 with
                | (@expr.App _ _ _ s1 _ #(idc0) x5 @ x4)%expr_pat =>
                    match
                      match idc0 with
                      | ident.Z_shiftl => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match x4 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t2 v =>
                                  match
                                    t2 as t3
                                    return (base.base_interp t3 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v0 : Z => Some v0
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                match
                                  s1 as t2
                                  return
                                    (Compile.value' false t2 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)))
                                with
                                | type.base t2 =>
                                    fun v : defaults.expr (type.base t2) =>
                                    base.try_make_transport_cps
                                      (fun t3 : base.type =>
                                       defaults.expr (type.base t3)) t2
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base
                                               (base.type.Z * base.type.Z)%etype)))
                                      (fun
                                         a : option
                                               (defaults.expr (type.base t2) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                       match a with
                                       | Some x' =>
                                           if args =? 2 ^ Z.log2 args
                                           then
                                            UnderLets.Base
                                              (#(ident.fancy_add
                                                   (Z.log2 args) args1)%expr @
                                               (x1, x' v))%expr_pat
                                           else
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_add
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_get_carry)%expr @
                                                x @ x0 @ x1)%expr_pat
                                       | None =>
                                           UnderLets.Base
                                             (#(ident.Z_add_get_carry)%expr @
                                              x @ x0 @ x1)%expr_pat
                                       end)
                                | (s2 -> d2)%ptype =>
                                    fun
                                      _ : Compile.value' false s2 ->
                                          Compile.value' true d2 =>
                                    UnderLets.Base
                                      (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                       x1)%expr_pat
                                end (Compile.reflect x5)
                            | None =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                    (x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                    x1)%expr_pat
                            end
                        | _ =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                (x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                        end
                    | None =>
                        match
                          match idc0 with
                          | ident.Z_shiftr => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match x4 with
                            | #(idc1)%expr_pat =>
                                match
                                  match idc1 with
                                  | @ident.Literal t2 v =>
                                      match
                                        t2 as t3
                                        return
                                          (base.base_interp t3 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s1 as t2
                                      return
                                        (Compile.value' false t2 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t2 =>
                                        fun v : defaults.expr (type.base t2)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t3 : base.type =>
                                           defaults.expr (type.base t3)) t2
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t2) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_add
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x1, x' v))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_add
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_get_carry)%expr @
                                                    x @ x0 @ x1)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_get_carry)%expr @
                                                  x @ x0 @ x1)%expr_pat
                                           end)
                                    | (s2 -> d2)%ptype =>
                                        fun
                                          _ : Compile.value' false s2 ->
                                              Compile.value' true d2 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_get_carry)%expr @ x @
                                           x0 @ x1)%expr_pat
                                    end (Compile.reflect x5)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                        (x0, x1))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_get_carry)%expr @ x @
                                        x0 @ x1)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                    (x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                    x1)%expr_pat
                            end
                        | None =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                (x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                        end
                    end
                | (@expr.App _ _ _ s1 _ ($_)%expr _ @ _)%expr_pat |
                  (@expr.App _ _ _ s1 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s1 _ (_ @ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s1 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_add (Z.log2 args) 0)%expr @ (x0, x1))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                | _ =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_add (Z.log2 args) 0)%expr @ (x0, x1))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                end
            | @expr.LetIn _ _ _ _ _ _ _ =>
                match x0 with
                | (@expr.App _ _ _ s0 _ #(idc0) x4 @ x3)%expr_pat =>
                    match
                      match idc0 with
                      | ident.Z_shiftl => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match x3 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t2 v =>
                                  match
                                    t2 as t3
                                    return (base.base_interp t3 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v0 : Z => Some v0
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                match
                                  s0 as t2
                                  return
                                    (Compile.value' false t2 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)))
                                with
                                | type.base t2 =>
                                    fun v : defaults.expr (type.base t2) =>
                                    base.try_make_transport_cps
                                      (fun t3 : base.type =>
                                       defaults.expr (type.base t3)) t2
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base
                                               (base.type.Z * base.type.Z)%etype)))
                                      (fun
                                         a : option
                                               (defaults.expr (type.base t2) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                       match a with
                                       | Some x' =>
                                           if args =? 2 ^ Z.log2 args
                                           then
                                            UnderLets.Base
                                              (#(ident.fancy_add
                                                   (Z.log2 args) args1)%expr @
                                               (x1, x' v))%expr_pat
                                           else
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_add
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_get_carry)%expr @
                                                x @ x0 @ x1)%expr_pat
                                       | None =>
                                           UnderLets.Base
                                             (#(ident.Z_add_get_carry)%expr @
                                              x @ x0 @ x1)%expr_pat
                                       end)
                                | (s1 -> d1)%ptype =>
                                    fun
                                      _ : Compile.value' false s1 ->
                                          Compile.value' true d1 =>
                                    UnderLets.Base
                                      (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                       x1)%expr_pat
                                end (Compile.reflect x4)
                            | None =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                    (x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                    x1)%expr_pat
                            end
                        | _ =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                (x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                        end
                    | None =>
                        match
                          match idc0 with
                          | ident.Z_shiftr => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match x3 with
                            | #(idc1)%expr_pat =>
                                match
                                  match idc1 with
                                  | @ident.Literal t2 v =>
                                      match
                                        t2 as t3
                                        return
                                          (base.base_interp t3 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s0 as t2
                                      return
                                        (Compile.value' false t2 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t2 =>
                                        fun v : defaults.expr (type.base t2)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t3 : base.type =>
                                           defaults.expr (type.base t3)) t2
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t2) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_add
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x1, x' v))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_add
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_get_carry)%expr @
                                                    x @ x0 @ x1)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_get_carry)%expr @
                                                  x @ x0 @ x1)%expr_pat
                                           end)
                                    | (s1 -> d1)%ptype =>
                                        fun
                                          _ : Compile.value' false s1 ->
                                              Compile.value' true d1 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_get_carry)%expr @ x @
                                           x0 @ x1)%expr_pat
                                    end (Compile.reflect x4)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                        (x0, x1))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_get_carry)%expr @ x @
                                        x0 @ x1)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                    (x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry)%expr @ x @ x0 @
                                    x1)%expr_pat
                            end
                        | None =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 args) 0)%expr @
                                (x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                        end
                    end
                | (@expr.App _ _ _ s0 _ ($_)%expr _ @ _)%expr_pat |
                  (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s0 _ (_ @ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_add (Z.log2 args) 0)%expr @ (x0, x1))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                | _ =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_add (Z.log2 args) 0)%expr @ (x0, x1))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
                end
            end
        | None =>
            UnderLets.Base
              (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
        end
    | _ =>
        UnderLets.Base (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
    end
| ident.Z_add_with_carry =>
    fun x x0 x1 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_add_with_carry)%expr @ x @ x0 @ x1)%expr_pat
| ident.Z_add_with_get_carry =>
    fun x x0 x1 x2 : defaults.expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            match x2 with
            | #(_)%expr_pat =>
                match x1 with
                | (@expr.App _ _ _ s0 _ #(idc1) x4 @ x3)%expr_pat =>
                    match
                      match idc1 with
                      | ident.Z_shiftl => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match x3 with
                        | #(idc2)%expr_pat =>
                            match
                              match idc2 with
                              | @ident.Literal t3 v =>
                                  match
                                    t3 as t4
                                    return (base.base_interp t4 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v0 : Z => Some v0
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                match
                                  s0 as t3
                                  return
                                    (Compile.value' false t3 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)))
                                with
                                | type.base t3 =>
                                    fun v : defaults.expr (type.base t3) =>
                                    base.try_make_transport_cps
                                      (fun t4 : base.type =>
                                       defaults.expr (type.base t4)) t3
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base
                                               (base.type.Z * base.type.Z)%etype)))
                                      (fun
                                         a : option
                                               (defaults.expr (type.base t3) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                       match a with
                                       | Some x' =>
                                           if args =? 2 ^ Z.log2 args
                                           then
                                            UnderLets.Base
                                              (#(ident.fancy_addc
                                                   (Z.log2 args) args1)%expr @
                                               (x0, x2, x' v))%expr_pat
                                           else
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_addc
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1, x2))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_with_get_carry)%expr @
                                                x @ x0 @ x1 @ x2)%expr_pat
                                       | None =>
                                           UnderLets.Base
                                             (#(ident.Z_add_with_get_carry)%expr @
                                              x @ x0 @ x1 @ x2)%expr_pat
                                       end)
                                | (s1 -> d1)%ptype =>
                                    fun
                                      _ : Compile.value' false s1 ->
                                          Compile.value' true d1 =>
                                    UnderLets.Base
                                      (#(ident.Z_add_with_get_carry)%expr @ x @
                                       x0 @ x1 @ x2)%expr_pat
                                end (Compile.reflect x4)
                            | None =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                    (x0, x1, x2))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry)%expr @ x @
                                    x0 @ x1 @ x2)%expr_pat
                            end
                        | _ =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                (x0, x1, x2))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                        end
                    | None =>
                        match
                          match idc1 with
                          | ident.Z_shiftr => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match x3 with
                            | #(idc2)%expr_pat =>
                                match
                                  match idc2 with
                                  | @ident.Literal t3 v =>
                                      match
                                        t3 as t4
                                        return
                                          (base.base_interp t4 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s0 as t3
                                      return
                                        (Compile.value' false t3 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t3 =>
                                        fun v : defaults.expr (type.base t3)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t4 : base.type =>
                                           defaults.expr (type.base t4)) t3
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t3) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_addc
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x0, x2, x' v))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_addc
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1, x2))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_with_get_carry)%expr @
                                                    x @ x0 @ x1 @ x2)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_with_get_carry)%expr @
                                                  x @ x0 @ x1 @ x2)%expr_pat
                                           end)
                                    | (s1 -> d1)%ptype =>
                                        fun
                                          _ : Compile.value' false s1 ->
                                              Compile.value' true d1 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ x1 @ x2)%expr_pat
                                    end (Compile.reflect x4)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                        (x0, x1, x2))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_with_get_carry)%expr @
                                        x @ x0 @ x1 @ x2)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                    (x0, x1, x2))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry)%expr @ x @
                                    x0 @ x1 @ x2)%expr_pat
                            end
                        | None =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                (x0, x1, x2))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                        end
                    end
                | (@expr.App _ _ _ s0 _ ($_)%expr _ @ _)%expr_pat |
                  (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s0 _ (_ @ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                        (x0, x1, x2))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                | _ =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                        (x0, x1, x2))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                end
            | ($_)%expr =>
                match x1 with
                | (@expr.App _ _ _ s0 _ #(idc0) x4 @ x3)%expr_pat =>
                    match
                      match idc0 with
                      | ident.Z_shiftl => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match x3 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t3 v0 =>
                                  match
                                    t3 as t4
                                    return (base.base_interp t4 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v1 : Z => Some v1
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v0
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                match
                                  s0 as t3
                                  return
                                    (Compile.value' false t3 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)))
                                with
                                | type.base t3 =>
                                    fun v0 : defaults.expr (type.base t3) =>
                                    base.try_make_transport_cps
                                      (fun t4 : base.type =>
                                       defaults.expr (type.base t4)) t3
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base
                                               (base.type.Z * base.type.Z)%etype)))
                                      (fun
                                         a : option
                                               (defaults.expr (type.base t3) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                       match a with
                                       | Some x' =>
                                           if args =? 2 ^ Z.log2 args
                                           then
                                            UnderLets.Base
                                              (#(ident.fancy_addc
                                                   (Z.log2 args) args1)%expr @
                                               (x0, x2, x' v0))%expr_pat
                                           else
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_addc
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1, x2))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_with_get_carry)%expr @
                                                x @ x0 @ x1 @ x2)%expr_pat
                                       | None =>
                                           UnderLets.Base
                                             (#(ident.Z_add_with_get_carry)%expr @
                                              x @ x0 @ x1 @ x2)%expr_pat
                                       end)
                                | (s1 -> d1)%ptype =>
                                    fun
                                      _ : Compile.value' false s1 ->
                                          Compile.value' true d1 =>
                                    UnderLets.Base
                                      (#(ident.Z_add_with_get_carry)%expr @ x @
                                       x0 @ x1 @ x2)%expr_pat
                                end (Compile.reflect x4)
                            | None =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                    (x0, x1, x2))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry)%expr @ x @
                                    x0 @ x1 @ x2)%expr_pat
                            end
                        | _ =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                (x0, x1, x2))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                        end
                    | None =>
                        match
                          match idc0 with
                          | ident.Z_shiftr => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match x3 with
                            | #(idc1)%expr_pat =>
                                match
                                  match idc1 with
                                  | @ident.Literal t3 v0 =>
                                      match
                                        t3 as t4
                                        return
                                          (base.base_interp t4 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v1 : Z => Some v1
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v0
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s0 as t3
                                      return
                                        (Compile.value' false t3 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t3 =>
                                        fun v0 : defaults.expr (type.base t3)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t4 : base.type =>
                                           defaults.expr (type.base t4)) t3
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t3) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_addc
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x0, x2, x' v0))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_addc
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1, x2))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_with_get_carry)%expr @
                                                    x @ x0 @ x1 @ x2)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_with_get_carry)%expr @
                                                  x @ x0 @ x1 @ x2)%expr_pat
                                           end)
                                    | (s1 -> d1)%ptype =>
                                        fun
                                          _ : Compile.value' false s1 ->
                                              Compile.value' true d1 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ x1 @ x2)%expr_pat
                                    end (Compile.reflect x4)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                        (x0, x1, x2))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_with_get_carry)%expr @
                                        x @ x0 @ x1 @ x2)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                    (x0, x1, x2))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry)%expr @ x @
                                    x0 @ x1 @ x2)%expr_pat
                            end
                        | None =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                (x0, x1, x2))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                        end
                    end
                | (@expr.App _ _ _ s0 _ ($_)%expr _ @ _)%expr_pat |
                  (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s0 _ (_ @ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                        (x0, x1, x2))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                | _ =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                        (x0, x1, x2))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                end
            | @expr.Abs _ _ _ _ _ _ =>
                match x1 with
                | (@expr.App _ _ _ s1 _ #(idc0) x4 @ x3)%expr_pat =>
                    match
                      match idc0 with
                      | ident.Z_shiftl => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match x3 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t2 v =>
                                  match
                                    t2 as t3
                                    return (base.base_interp t3 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v0 : Z => Some v0
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                match
                                  s1 as t2
                                  return
                                    (Compile.value' false t2 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)))
                                with
                                | type.base t2 =>
                                    fun v : defaults.expr (type.base t2) =>
                                    base.try_make_transport_cps
                                      (fun t3 : base.type =>
                                       defaults.expr (type.base t3)) t2
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base
                                               (base.type.Z * base.type.Z)%etype)))
                                      (fun
                                         a : option
                                               (defaults.expr (type.base t2) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                       match a with
                                       | Some x' =>
                                           if args =? 2 ^ Z.log2 args
                                           then
                                            UnderLets.Base
                                              (#(ident.fancy_addc
                                                   (Z.log2 args) args1)%expr @
                                               (x0, x2, x' v))%expr_pat
                                           else
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_addc
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1, x2))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_with_get_carry)%expr @
                                                x @ x0 @ x1 @ x2)%expr_pat
                                       | None =>
                                           UnderLets.Base
                                             (#(ident.Z_add_with_get_carry)%expr @
                                              x @ x0 @ x1 @ x2)%expr_pat
                                       end)
                                | (s2 -> d2)%ptype =>
                                    fun
                                      _ : Compile.value' false s2 ->
                                          Compile.value' true d2 =>
                                    UnderLets.Base
                                      (#(ident.Z_add_with_get_carry)%expr @ x @
                                       x0 @ x1 @ x2)%expr_pat
                                end (Compile.reflect x4)
                            | None =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                    (x0, x1, x2))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry)%expr @ x @
                                    x0 @ x1 @ x2)%expr_pat
                            end
                        | _ =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                (x0, x1, x2))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                        end
                    | None =>
                        match
                          match idc0 with
                          | ident.Z_shiftr => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match x3 with
                            | #(idc1)%expr_pat =>
                                match
                                  match idc1 with
                                  | @ident.Literal t2 v =>
                                      match
                                        t2 as t3
                                        return
                                          (base.base_interp t3 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s1 as t2
                                      return
                                        (Compile.value' false t2 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t2 =>
                                        fun v : defaults.expr (type.base t2)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t3 : base.type =>
                                           defaults.expr (type.base t3)) t2
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t2) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_addc
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x0, x2, x' v))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_addc
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1, x2))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_with_get_carry)%expr @
                                                    x @ x0 @ x1 @ x2)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_with_get_carry)%expr @
                                                  x @ x0 @ x1 @ x2)%expr_pat
                                           end)
                                    | (s2 -> d2)%ptype =>
                                        fun
                                          _ : Compile.value' false s2 ->
                                              Compile.value' true d2 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ x1 @ x2)%expr_pat
                                    end (Compile.reflect x4)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                        (x0, x1, x2))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_with_get_carry)%expr @
                                        x @ x0 @ x1 @ x2)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                    (x0, x1, x2))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry)%expr @ x @
                                    x0 @ x1 @ x2)%expr_pat
                            end
                        | None =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                (x0, x1, x2))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                        end
                    end
                | (@expr.App _ _ _ s1 _ ($_)%expr _ @ _)%expr_pat |
                  (@expr.App _ _ _ s1 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s1 _ (_ @ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s1 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                        (x0, x1, x2))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                | _ =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                        (x0, x1, x2))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                end
            | (#(_) @ _)%expr_pat =>
                match x1 with
                | (@expr.App _ _ _ s1 _ #(idc1) x5 @ x4)%expr_pat =>
                    match
                      match idc1 with
                      | ident.Z_shiftl => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match x4 with
                        | #(idc2)%expr_pat =>
                            match
                              match idc2 with
                              | @ident.Literal t3 v =>
                                  match
                                    t3 as t4
                                    return (base.base_interp t4 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v0 : Z => Some v0
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                match
                                  s1 as t3
                                  return
                                    (Compile.value' false t3 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)))
                                with
                                | type.base t3 =>
                                    fun v : defaults.expr (type.base t3) =>
                                    base.try_make_transport_cps
                                      (fun t4 : base.type =>
                                       defaults.expr (type.base t4)) t3
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base
                                               (base.type.Z * base.type.Z)%etype)))
                                      (fun
                                         a : option
                                               (defaults.expr (type.base t3) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                       match a with
                                       | Some x' =>
                                           if args =? 2 ^ Z.log2 args
                                           then
                                            UnderLets.Base
                                              (#(ident.fancy_addc
                                                   (Z.log2 args) args1)%expr @
                                               (x0, x2, x' v))%expr_pat
                                           else
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_addc
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1, x2))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_with_get_carry)%expr @
                                                x @ x0 @ x1 @ x2)%expr_pat
                                       | None =>
                                           UnderLets.Base
                                             (#(ident.Z_add_with_get_carry)%expr @
                                              x @ x0 @ x1 @ x2)%expr_pat
                                       end)
                                | (s2 -> d2)%ptype =>
                                    fun
                                      _ : Compile.value' false s2 ->
                                          Compile.value' true d2 =>
                                    UnderLets.Base
                                      (#(ident.Z_add_with_get_carry)%expr @ x @
                                       x0 @ x1 @ x2)%expr_pat
                                end (Compile.reflect x5)
                            | None =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                    (x0, x1, x2))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry)%expr @ x @
                                    x0 @ x1 @ x2)%expr_pat
                            end
                        | _ =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                (x0, x1, x2))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                        end
                    | None =>
                        match
                          match idc1 with
                          | ident.Z_shiftr => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match x4 with
                            | #(idc2)%expr_pat =>
                                match
                                  match idc2 with
                                  | @ident.Literal t3 v =>
                                      match
                                        t3 as t4
                                        return
                                          (base.base_interp t4 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s1 as t3
                                      return
                                        (Compile.value' false t3 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t3 =>
                                        fun v : defaults.expr (type.base t3)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t4 : base.type =>
                                           defaults.expr (type.base t4)) t3
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t3) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_addc
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x0, x2, x' v))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_addc
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1, x2))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_with_get_carry)%expr @
                                                    x @ x0 @ x1 @ x2)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_with_get_carry)%expr @
                                                  x @ x0 @ x1 @ x2)%expr_pat
                                           end)
                                    | (s2 -> d2)%ptype =>
                                        fun
                                          _ : Compile.value' false s2 ->
                                              Compile.value' true d2 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ x1 @ x2)%expr_pat
                                    end (Compile.reflect x5)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                        (x0, x1, x2))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_with_get_carry)%expr @
                                        x @ x0 @ x1 @ x2)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                    (x0, x1, x2))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry)%expr @ x @
                                    x0 @ x1 @ x2)%expr_pat
                            end
                        | None =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                (x0, x1, x2))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                        end
                    end
                | (@expr.App _ _ _ s1 _ ($_)%expr _ @ _)%expr_pat |
                  (@expr.App _ _ _ s1 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s1 _ (_ @ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s1 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                        (x0, x1, x2))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                | _ =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                        (x0, x1, x2))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                end
            | (($_)%expr @ _)%expr_pat =>
                match x1 with
                | (@expr.App _ _ _ s1 _ #(idc0) x5 @ x4)%expr_pat =>
                    match
                      match idc0 with
                      | ident.Z_shiftl => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match x4 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t3 v0 =>
                                  match
                                    t3 as t4
                                    return (base.base_interp t4 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v1 : Z => Some v1
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v0
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                match
                                  s1 as t3
                                  return
                                    (Compile.value' false t3 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)))
                                with
                                | type.base t3 =>
                                    fun v0 : defaults.expr (type.base t3) =>
                                    base.try_make_transport_cps
                                      (fun t4 : base.type =>
                                       defaults.expr (type.base t4)) t3
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base
                                               (base.type.Z * base.type.Z)%etype)))
                                      (fun
                                         a : option
                                               (defaults.expr (type.base t3) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                       match a with
                                       | Some x' =>
                                           if args =? 2 ^ Z.log2 args
                                           then
                                            UnderLets.Base
                                              (#(ident.fancy_addc
                                                   (Z.log2 args) args1)%expr @
                                               (x0, x2, x' v0))%expr_pat
                                           else
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_addc
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1, x2))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_with_get_carry)%expr @
                                                x @ x0 @ x1 @ x2)%expr_pat
                                       | None =>
                                           UnderLets.Base
                                             (#(ident.Z_add_with_get_carry)%expr @
                                              x @ x0 @ x1 @ x2)%expr_pat
                                       end)
                                | (s2 -> d2)%ptype =>
                                    fun
                                      _ : Compile.value' false s2 ->
                                          Compile.value' true d2 =>
                                    UnderLets.Base
                                      (#(ident.Z_add_with_get_carry)%expr @ x @
                                       x0 @ x1 @ x2)%expr_pat
                                end (Compile.reflect x5)
                            | None =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                    (x0, x1, x2))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry)%expr @ x @
                                    x0 @ x1 @ x2)%expr_pat
                            end
                        | _ =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                (x0, x1, x2))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                        end
                    | None =>
                        match
                          match idc0 with
                          | ident.Z_shiftr => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match x4 with
                            | #(idc1)%expr_pat =>
                                match
                                  match idc1 with
                                  | @ident.Literal t3 v0 =>
                                      match
                                        t3 as t4
                                        return
                                          (base.base_interp t4 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v1 : Z => Some v1
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v0
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s1 as t3
                                      return
                                        (Compile.value' false t3 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t3 =>
                                        fun v0 : defaults.expr (type.base t3)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t4 : base.type =>
                                           defaults.expr (type.base t4)) t3
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t3) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_addc
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x0, x2, x' v0))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_addc
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1, x2))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_with_get_carry)%expr @
                                                    x @ x0 @ x1 @ x2)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_with_get_carry)%expr @
                                                  x @ x0 @ x1 @ x2)%expr_pat
                                           end)
                                    | (s2 -> d2)%ptype =>
                                        fun
                                          _ : Compile.value' false s2 ->
                                              Compile.value' true d2 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ x1 @ x2)%expr_pat
                                    end (Compile.reflect x5)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                        (x0, x1, x2))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_with_get_carry)%expr @
                                        x @ x0 @ x1 @ x2)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                    (x0, x1, x2))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry)%expr @ x @
                                    x0 @ x1 @ x2)%expr_pat
                            end
                        | None =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                (x0, x1, x2))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                        end
                    end
                | (@expr.App _ _ _ s1 _ ($_)%expr _ @ _)%expr_pat |
                  (@expr.App _ _ _ s1 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s1 _ (_ @ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s1 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                        (x0, x1, x2))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                | _ =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                        (x0, x1, x2))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                end
            | (@expr.Abs _ _ _ _ _ _ @ _)%expr_pat =>
                match x1 with
                | (@expr.App _ _ _ s2 _ #(idc0) x5 @ x4)%expr_pat =>
                    match
                      match idc0 with
                      | ident.Z_shiftl => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match x4 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t2 v =>
                                  match
                                    t2 as t3
                                    return (base.base_interp t3 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v0 : Z => Some v0
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                match
                                  s2 as t2
                                  return
                                    (Compile.value' false t2 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)))
                                with
                                | type.base t2 =>
                                    fun v : defaults.expr (type.base t2) =>
                                    base.try_make_transport_cps
                                      (fun t3 : base.type =>
                                       defaults.expr (type.base t3)) t2
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base
                                               (base.type.Z * base.type.Z)%etype)))
                                      (fun
                                         a : option
                                               (defaults.expr (type.base t2) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                       match a with
                                       | Some x' =>
                                           if args =? 2 ^ Z.log2 args
                                           then
                                            UnderLets.Base
                                              (#(ident.fancy_addc
                                                   (Z.log2 args) args1)%expr @
                                               (x0, x2, x' v))%expr_pat
                                           else
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_addc
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1, x2))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_with_get_carry)%expr @
                                                x @ x0 @ x1 @ x2)%expr_pat
                                       | None =>
                                           UnderLets.Base
                                             (#(ident.Z_add_with_get_carry)%expr @
                                              x @ x0 @ x1 @ x2)%expr_pat
                                       end)
                                | (s3 -> d3)%ptype =>
                                    fun
                                      _ : Compile.value' false s3 ->
                                          Compile.value' true d3 =>
                                    UnderLets.Base
                                      (#(ident.Z_add_with_get_carry)%expr @ x @
                                       x0 @ x1 @ x2)%expr_pat
                                end (Compile.reflect x5)
                            | None =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                    (x0, x1, x2))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry)%expr @ x @
                                    x0 @ x1 @ x2)%expr_pat
                            end
                        | _ =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                (x0, x1, x2))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                        end
                    | None =>
                        match
                          match idc0 with
                          | ident.Z_shiftr => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match x4 with
                            | #(idc1)%expr_pat =>
                                match
                                  match idc1 with
                                  | @ident.Literal t2 v =>
                                      match
                                        t2 as t3
                                        return
                                          (base.base_interp t3 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s2 as t2
                                      return
                                        (Compile.value' false t2 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t2 =>
                                        fun v : defaults.expr (type.base t2)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t3 : base.type =>
                                           defaults.expr (type.base t3)) t2
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t2) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_addc
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x0, x2, x' v))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_addc
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1, x2))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_with_get_carry)%expr @
                                                    x @ x0 @ x1 @ x2)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_with_get_carry)%expr @
                                                  x @ x0 @ x1 @ x2)%expr_pat
                                           end)
                                    | (s3 -> d3)%ptype =>
                                        fun
                                          _ : Compile.value' false s3 ->
                                              Compile.value' true d3 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ x1 @ x2)%expr_pat
                                    end (Compile.reflect x5)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                        (x0, x1, x2))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_with_get_carry)%expr @
                                        x @ x0 @ x1 @ x2)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                    (x0, x1, x2))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry)%expr @ x @
                                    x0 @ x1 @ x2)%expr_pat
                            end
                        | None =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                (x0, x1, x2))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                        end
                    end
                | (@expr.App _ _ _ s2 _ ($_)%expr _ @ _)%expr_pat |
                  (@expr.App _ _ _ s2 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s2 _ (_ @ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s2 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                        (x0, x1, x2))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                | _ =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                        (x0, x1, x2))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                end
            | (@expr.App _ _ _ s0 _ #(idc0) x4 @ x3)%expr_pat =>
                match
                  match idc0 with
                  | ident.Z_shiftl => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match x3 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args1 =>
                            match
                              s0 as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (defaults.expr
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)))
                            with
                            | type.base t2 =>
                                fun v : defaults.expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t3 : base.type =>
                                   defaults.expr (type.base t3)) t2
                                  base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (defaults.expr
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)))
                                  (fun
                                     a : option
                                           (defaults.expr (type.base t2) ->
                                            defaults.expr
                                              (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       if args =? 2 ^ Z.log2 args
                                       then
                                        UnderLets.Base
                                          (#(ident.fancy_addc (Z.log2 args)
                                               args1)%expr @ (x0, x1, x' v))%expr_pat
                                       else
                                        match x1 with
                                        | (@expr.App _ _ _ s2 _ #(idc2) x6 @
                                           x5)%expr_pat =>
                                            match
                                              match idc2 with
                                              | ident.Z_shiftl => Some tt
                                              | _ => None
                                              end
                                            with
                                            | Some _ =>
                                                match x5 with
                                                | #(idc3)%expr_pat =>
                                                    match
                                                      match idc3 with
                                                      | @ident.Literal t5
                                                        v0 =>
                                                          match
                                                            t5 as t6
                                                            return
                                                              (base.base_interp
                                                                 t6 ->
                                                               option Z)
                                                          with
                                                          | base.type.unit =>
                                                              fun _ : unit =>
                                                              None
                                                          | base.type.Z =>
                                                              fun v1 : Z =>
                                                              Some v1
                                                          | base.type.bool =>
                                                              fun _ : bool =>
                                                              None
                                                          | base.type.nat =>
                                                              fun _ : nat =>
                                                              None
                                                          end v0
                                                      | _ => None
                                                      end
                                                    with
                                                    | Some args3 =>
                                                        match
                                                          s2 as t5
                                                          return
                                                            (Compile.value'
                                                               false t5 ->
                                                             UnderLets.UnderLets
                                                               base.type
                                                               ident var
                                                               (defaults.expr
                                                                  (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)))
                                                        with
                                                        | type.base t5 =>
                                                            fun
                                                              v0 : defaults.expr
                                                                    (type.base
                                                                    t5) =>
                                                            base.try_make_transport_cps
                                                              (fun
                                                                 t6 : base.type
                                                               =>
                                                               defaults.expr
                                                                 (type.base
                                                                    t6)) t5
                                                              base.type.Z
                                                              (UnderLets.UnderLets
                                                                 base.type
                                                                 ident var
                                                                 (defaults.expr
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)))
                                                              (fun
                                                                 a0 : 
                                                                  option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t5) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                               =>
                                                               match a0 with
                                                               | Some x'0 =>
                                                                   if
                                                                    args =?
                                                                    2
                                                                    ^ 
                                                                    Z.log2
                                                                    args
                                                                   then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_addc
                                                                    (Z.log2
                                                                    args)
                                                                    args3)%expr @
                                                                    (x0, x2,
                                                                    x'0 v0))%expr_pat
                                                                   else
                                                                    if
                                                                    args =?
                                                                    2
                                                                    ^ 
                                                                    Z.log2
                                                                    args
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_addc
                                                                    (Z.log2
                                                                    args) 0)%expr @
                                                                    (x0, x1,
                                                                    x2))%expr_pat
                                                                    else
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.Z_add_with_get_carry)%expr @
                                                                    x @ x0 @
                                                                    x1 @ x2)%expr_pat
                                                               | None =>
                                                                   UnderLets.Base
                                                                    (#
                                                                    (ident.Z_add_with_get_carry)%expr @
                                                                    x @ x0 @
                                                                    x1 @ x2)%expr_pat
                                                               end)
                                                        | (s3 -> d3)%ptype =>
                                                            fun
                                                              _ : Compile.value'
                                                                    false s3 ->
                                                                  Compile.value'
                                                                    true d3
                                                            =>
                                                            UnderLets.Base
                                                              (#(ident.Z_add_with_get_carry)%expr @
                                                               x @ x0 @ x1 @
                                                               x2)%expr_pat
                                                        end
                                                          (Compile.reflect x6)
                                                    | None =>
                                                        if
                                                         args =?
                                                         2 ^ Z.log2 args
                                                        then
                                                         UnderLets.Base
                                                           (#(ident.fancy_addc
                                                                (Z.log2 args)
                                                                0)%expr @
                                                            (x0, x1, x2))%expr_pat
                                                        else
                                                         UnderLets.Base
                                                           (#(ident.Z_add_with_get_carry)%expr @
                                                            x @ x0 @ x1 @ x2)%expr_pat
                                                    end
                                                | _ =>
                                                    if
                                                     args =? 2 ^ Z.log2 args
                                                    then
                                                     UnderLets.Base
                                                       (#(ident.fancy_addc
                                                            (Z.log2 args) 0)%expr @
                                                        (x0, x1, x2))%expr_pat
                                                    else
                                                     UnderLets.Base
                                                       (#(ident.Z_add_with_get_carry)%expr @
                                                        x @ x0 @ x1 @ x2)%expr_pat
                                                end
                                            | None =>
                                                match
                                                  match idc2 with
                                                  | ident.Z_shiftr => Some tt
                                                  | _ => None
                                                  end
                                                with
                                                | Some _ =>
                                                    match x5 with
                                                    | #(idc3)%expr_pat =>
                                                        match
                                                          match idc3 with
                                                          | @ident.Literal t5
                                                            v0 =>
                                                              match
                                                                t5 as t6
                                                                return
                                                                  (base.base_interp
                                                                    t6 ->
                                                                   option Z)
                                                              with
                                                              | base.type.unit =>
                                                                  fun
                                                                    _ : unit
                                                                  => None
                                                              | base.type.Z =>
                                                                  fun v1 : Z
                                                                  => 
                                                                  Some v1
                                                              | base.type.bool =>
                                                                  fun
                                                                    _ : bool
                                                                  => None
                                                              | base.type.nat =>
                                                                  fun _ : nat
                                                                  => None
                                                              end v0
                                                          | _ => None
                                                          end
                                                        with
                                                        | Some args3 =>
                                                            match
                                                              s2 as t5
                                                              return
                                                                (Compile.value'
                                                                   false t5 ->
                                                                 UnderLets.UnderLets
                                                                   base.type
                                                                   ident var
                                                                   (defaults.expr
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)))
                                                            with
                                                            | type.base t5 =>
                                                                fun
                                                                  v0 : 
                                                                   defaults.expr
                                                                    (type.base
                                                                    t5) =>
                                                                base.try_make_transport_cps
                                                                  (fun
                                                                    t6 : base.type
                                                                   =>
                                                                   defaults.expr
                                                                    (type.base
                                                                    t6)) t5
                                                                  base.type.Z
                                                                  (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)))
                                                                  (fun
                                                                    a0 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t5) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                   =>
                                                                   match
                                                                    a0
                                                                   with
                                                                   | Some
                                                                    x'0 =>
                                                                    if
                                                                    args =?
                                                                    2
                                                                    ^ 
                                                                    Z.log2
                                                                    args
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_addc
                                                                    (Z.log2
                                                                    args)
                                                                    (- args3))%expr @
                                                                    (x0, x2,
                                                                    x'0 v0))%expr_pat
                                                                    else
                                                                    if
                                                                    args =?
                                                                    2
                                                                    ^ 
                                                                    Z.log2
                                                                    args
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_addc
                                                                    (Z.log2
                                                                    args) 0)%expr @
                                                                    (x0, x1,
                                                                    x2))%expr_pat
                                                                    else
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.Z_add_with_get_carry)%expr @
                                                                    x @ x0 @
                                                                    x1 @ x2)%expr_pat
                                                                   | None =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.Z_add_with_get_carry)%expr @
                                                                    x @ x0 @
                                                                    x1 @ x2)%expr_pat
                                                                   end)
                                                            | (s3 -> d3)%ptype =>
                                                                fun
                                                                  _ : 
                                                                   Compile.value'
                                                                    false s3 ->
                                                                   Compile.value'
                                                                    true d3
                                                                =>
                                                                UnderLets.Base
                                                                  (#(ident.Z_add_with_get_carry)%expr @
                                                                   x @ x0 @
                                                                   x1 @ x2)%expr_pat
                                                            end
                                                              (Compile.reflect
                                                                 x6)
                                                        | None =>
                                                            if
                                                             args =?
                                                             2 ^ Z.log2 args
                                                            then
                                                             UnderLets.Base
                                                               (#(ident.fancy_addc
                                                                    (Z.log2
                                                                    args) 0)%expr @
                                                                (x0, x1, x2))%expr_pat
                                                            else
                                                             UnderLets.Base
                                                               (#(ident.Z_add_with_get_carry)%expr @
                                                                x @ x0 @ x1 @
                                                                x2)%expr_pat
                                                        end
                                                    | _ =>
                                                        if
                                                         args =?
                                                         2 ^ Z.log2 args
                                                        then
                                                         UnderLets.Base
                                                           (#(ident.fancy_addc
                                                                (Z.log2 args)
                                                                0)%expr @
                                                            (x0, x1, x2))%expr_pat
                                                        else
                                                         UnderLets.Base
                                                           (#(ident.Z_add_with_get_carry)%expr @
                                                            x @ x0 @ x1 @ x2)%expr_pat
                                                    end
                                                | None =>
                                                    if
                                                     args =? 2 ^ Z.log2 args
                                                    then
                                                     UnderLets.Base
                                                       (#(ident.fancy_addc
                                                            (Z.log2 args) 0)%expr @
                                                        (x0, x1, x2))%expr_pat
                                                    else
                                                     UnderLets.Base
                                                       (#(ident.Z_add_with_get_carry)%expr @
                                                        x @ x0 @ x1 @ x2)%expr_pat
                                                end
                                            end
                                        | (@expr.App _ _ _ s2 _ ($_)%expr _ @
                                           _)%expr_pat |
                                          (@expr.App _ _ _ s2 _
                                           (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                                          (@expr.App _ _ _ s2 _ (_ @ _) _ @ _)%expr_pat |
                                          (@expr.App _ _ _ s2 _
                                           (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_addc
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1, x2))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_with_get_carry)%expr @
                                                x @ x0 @ x1 @ x2)%expr_pat
                                        | _ =>
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_addc
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1, x2))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_with_get_carry)%expr @
                                                x @ x0 @ x1 @ x2)%expr_pat
                                        end
                                   | None =>
                                       UnderLets.Base
                                         (#(ident.Z_add_with_get_carry)%expr @
                                          x @ x0 @ x1 @ x2)%expr_pat
                                   end)
                            | (s1 -> d1)%ptype =>
                                fun
                                  _ : Compile.value' false s1 ->
                                      Compile.value' true d1 =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry)%expr @ x @
                                   x0 @ x1 @ x2)%expr_pat
                            end (Compile.reflect x4)
                        | None =>
                            match x1 with
                            | (@expr.App _ _ _ s2 _ #(idc2) x6 @ x5)%expr_pat =>
                                match
                                  match idc2 with
                                  | ident.Z_shiftl => Some tt
                                  | _ => None
                                  end
                                with
                                | Some _ =>
                                    match x5 with
                                    | #(idc3)%expr_pat =>
                                        match
                                          match idc3 with
                                          | @ident.Literal t4 v =>
                                              match
                                                t4 as t5
                                                return
                                                  (base.base_interp t5 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v0 : Z => Some v0
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v
                                          | _ => None
                                          end
                                        with
                                        | Some args2 =>
                                            match
                                              s2 as t4
                                              return
                                                (Compile.value' false t4 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base
                                                         (base.type.Z *
                                                          base.type.Z)%etype)))
                                            with
                                            | type.base t4 =>
                                                fun
                                                  v : defaults.expr
                                                        (type.base t4) =>
                                                base.try_make_transport_cps
                                                  (fun t5 : base.type =>
                                                   defaults.expr
                                                     (type.base t5)) t4
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           (base.type.Z *
                                                            base.type.Z)%etype)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t4) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       if
                                                        args =?
                                                        2 ^ Z.log2 args
                                                       then
                                                        UnderLets.Base
                                                          (#(ident.fancy_addc
                                                               (Z.log2 args)
                                                               args2)%expr @
                                                           (x0, x2, x' v))%expr_pat
                                                       else
                                                        if
                                                         args =?
                                                         2 ^ Z.log2 args
                                                        then
                                                         UnderLets.Base
                                                           (#(ident.fancy_addc
                                                                (Z.log2 args)
                                                                0)%expr @
                                                            (x0, x1, x2))%expr_pat
                                                        else
                                                         UnderLets.Base
                                                           (#(ident.Z_add_with_get_carry)%expr @
                                                            x @ x0 @ x1 @ x2)%expr_pat
                                                   | None =>
                                                       UnderLets.Base
                                                         (#(ident.Z_add_with_get_carry)%expr @
                                                          x @ x0 @ x1 @ x2)%expr_pat
                                                   end)
                                            | (s3 -> d3)%ptype =>
                                                fun
                                                  _ : Compile.value' false s3 ->
                                                      Compile.value' true d3
                                                =>
                                                UnderLets.Base
                                                  (#(ident.Z_add_with_get_carry)%expr @
                                                   x @ x0 @ x1 @ x2)%expr_pat
                                            end (Compile.reflect x6)
                                        | None =>
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_addc
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1, x2))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_with_get_carry)%expr @
                                                x @ x0 @ x1 @ x2)%expr_pat
                                        end
                                    | _ =>
                                        if args =? 2 ^ Z.log2 args
                                        then
                                         UnderLets.Base
                                           (#(ident.fancy_addc (Z.log2 args)
                                                0)%expr @ (x0, x1, x2))%expr_pat
                                        else
                                         UnderLets.Base
                                           (#(ident.Z_add_with_get_carry)%expr @
                                            x @ x0 @ x1 @ x2)%expr_pat
                                    end
                                | None =>
                                    match
                                      match idc2 with
                                      | ident.Z_shiftr => Some tt
                                      | _ => None
                                      end
                                    with
                                    | Some _ =>
                                        match x5 with
                                        | #(idc3)%expr_pat =>
                                            match
                                              match idc3 with
                                              | @ident.Literal t4 v =>
                                                  match
                                                    t4 as t5
                                                    return
                                                      (base.base_interp t5 ->
                                                       option Z)
                                                  with
                                                  | base.type.unit =>
                                                      fun _ : unit => None
                                                  | base.type.Z =>
                                                      fun v0 : Z => Some v0
                                                  | base.type.bool =>
                                                      fun _ : bool => None
                                                  | base.type.nat =>
                                                      fun _ : nat => None
                                                  end v
                                              | _ => None
                                              end
                                            with
                                            | Some args2 =>
                                                match
                                                  s2 as t4
                                                  return
                                                    (Compile.value' false t4 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             (base.type.Z *
                                                              base.type.Z)%etype)))
                                                with
                                                | type.base t4 =>
                                                    fun
                                                      v : defaults.expr
                                                            (type.base t4) =>
                                                    base.try_make_transport_cps
                                                      (fun t5 : base.type =>
                                                       defaults.expr
                                                         (type.base t5)) t4
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               (base.type.Z *
                                                                base.type.Z)%etype)))
                                                      (fun
                                                         a : option
                                                               (defaults.expr
                                                                  (type.base
                                                                    t4) ->
                                                                defaults.expr
                                                                  (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a with
                                                       | Some x' =>
                                                           if
                                                            args =?
                                                            2 ^ Z.log2 args
                                                           then
                                                            UnderLets.Base
                                                              (#(ident.fancy_addc
                                                                   (Z.log2
                                                                    args)
                                                                   (- args2))%expr @
                                                               (x0, x2, x' v))%expr_pat
                                                           else
                                                            if
                                                             args =?
                                                             2 ^ Z.log2 args
                                                            then
                                                             UnderLets.Base
                                                               (#(ident.fancy_addc
                                                                    (Z.log2
                                                                    args) 0)%expr @
                                                                (x0, x1, x2))%expr_pat
                                                            else
                                                             UnderLets.Base
                                                               (#(ident.Z_add_with_get_carry)%expr @
                                                                x @ x0 @ x1 @
                                                                x2)%expr_pat
                                                       | None =>
                                                           UnderLets.Base
                                                             (#(ident.Z_add_with_get_carry)%expr @
                                                              x @ x0 @ x1 @
                                                              x2)%expr_pat
                                                       end)
                                                | (s3 -> d3)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s3 ->
                                                          Compile.value' true
                                                            d3 =>
                                                    UnderLets.Base
                                                      (#(ident.Z_add_with_get_carry)%expr @
                                                       x @ x0 @ x1 @ x2)%expr_pat
                                                end (Compile.reflect x6)
                                            | None =>
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_addc
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1, x2))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_with_get_carry)%expr @
                                                    x @ x0 @ x1 @ x2)%expr_pat
                                            end
                                        | _ =>
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_addc
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1, x2))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_with_get_carry)%expr @
                                                x @ x0 @ x1 @ x2)%expr_pat
                                        end
                                    | None =>
                                        if args =? 2 ^ Z.log2 args
                                        then
                                         UnderLets.Base
                                           (#(ident.fancy_addc (Z.log2 args)
                                                0)%expr @ (x0, x1, x2))%expr_pat
                                        else
                                         UnderLets.Base
                                           (#(ident.Z_add_with_get_carry)%expr @
                                            x @ x0 @ x1 @ x2)%expr_pat
                                    end
                                end
                            | (@expr.App _ _ _ s2 _ ($_)%expr _ @ _)%expr_pat |
                              (@expr.App _ _ _ s2 _ (@expr.Abs _ _ _ _ _ _)
                               _ @ _)%expr_pat |
                              (@expr.App _ _ _ s2 _ (_ @ _) _ @ _)%expr_pat |
                              (@expr.App _ _ _ s2 _
                               (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                    (x0, x1, x2))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry)%expr @ x @
                                    x0 @ x1 @ x2)%expr_pat
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                    (x0, x1, x2))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry)%expr @ x @
                                    x0 @ x1 @ x2)%expr_pat
                            end
                        end
                    | ($_)%expr =>
                        match x1 with
                        | (@expr.App _ _ _ s2 _ #(idc1) x6 @ x5)%expr_pat =>
                            match
                              match idc1 with
                              | ident.Z_shiftl => Some tt
                              | _ => None
                              end
                            with
                            | Some _ =>
                                match x5 with
                                | #(idc2)%expr_pat =>
                                    match
                                      match idc2 with
                                      | @ident.Literal t4 v0 =>
                                          match
                                            t4 as t5
                                            return
                                              (base.base_interp t5 ->
                                               option Z)
                                          with
                                          | base.type.unit =>
                                              fun _ : unit => None
                                          | base.type.Z =>
                                              fun v1 : Z => Some v1
                                          | base.type.bool =>
                                              fun _ : bool => None
                                          | base.type.nat =>
                                              fun _ : nat => None
                                          end v0
                                      | _ => None
                                      end
                                    with
                                    | Some args2 =>
                                        match
                                          s2 as t4
                                          return
                                            (Compile.value' false t4 ->
                                             UnderLets.UnderLets base.type
                                               ident var
                                               (defaults.expr
                                                  (type.base
                                                     (base.type.Z *
                                                      base.type.Z)%etype)))
                                        with
                                        | type.base t4 =>
                                            fun
                                              v0 : defaults.expr
                                                     (type.base t4) =>
                                            base.try_make_transport_cps
                                              (fun t5 : base.type =>
                                               defaults.expr (type.base t5))
                                              t4 base.type.Z
                                              (UnderLets.UnderLets base.type
                                                 ident var
                                                 (defaults.expr
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)))
                                              (fun
                                                 a : option
                                                       (defaults.expr
                                                          (type.base t4) ->
                                                        defaults.expr
                                                          (type.base
                                                             base.type.Z)) =>
                                               match a with
                                               | Some x' =>
                                                   if args =? 2 ^ Z.log2 args
                                                   then
                                                    UnderLets.Base
                                                      (#(ident.fancy_addc
                                                           (Z.log2 args)
                                                           args2)%expr @
                                                       (x0, x2, x' v0))%expr_pat
                                                   else
                                                    if
                                                     args =? 2 ^ Z.log2 args
                                                    then
                                                     UnderLets.Base
                                                       (#(ident.fancy_addc
                                                            (Z.log2 args) 0)%expr @
                                                        (x0, x1, x2))%expr_pat
                                                    else
                                                     UnderLets.Base
                                                       (#(ident.Z_add_with_get_carry)%expr @
                                                        x @ x0 @ x1 @ x2)%expr_pat
                                               | None =>
                                                   UnderLets.Base
                                                     (#(ident.Z_add_with_get_carry)%expr @
                                                      x @ x0 @ x1 @ x2)%expr_pat
                                               end)
                                        | (s3 -> d3)%ptype =>
                                            fun
                                              _ : Compile.value' false s3 ->
                                                  Compile.value' true d3 =>
                                            UnderLets.Base
                                              (#(ident.Z_add_with_get_carry)%expr @
                                               x @ x0 @ x1 @ x2)%expr_pat
                                        end (Compile.reflect x6)
                                    | None =>
                                        if args =? 2 ^ Z.log2 args
                                        then
                                         UnderLets.Base
                                           (#(ident.fancy_addc (Z.log2 args)
                                                0)%expr @ (x0, x1, x2))%expr_pat
                                        else
                                         UnderLets.Base
                                           (#(ident.Z_add_with_get_carry)%expr @
                                            x @ x0 @ x1 @ x2)%expr_pat
                                    end
                                | _ =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                        (x0, x1, x2))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_with_get_carry)%expr @
                                        x @ x0 @ x1 @ x2)%expr_pat
                                end
                            | None =>
                                match
                                  match idc1 with
                                  | ident.Z_shiftr => Some tt
                                  | _ => None
                                  end
                                with
                                | Some _ =>
                                    match x5 with
                                    | #(idc2)%expr_pat =>
                                        match
                                          match idc2 with
                                          | @ident.Literal t4 v0 =>
                                              match
                                                t4 as t5
                                                return
                                                  (base.base_interp t5 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v1 : Z => Some v1
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v0
                                          | _ => None
                                          end
                                        with
                                        | Some args2 =>
                                            match
                                              s2 as t4
                                              return
                                                (Compile.value' false t4 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base
                                                         (base.type.Z *
                                                          base.type.Z)%etype)))
                                            with
                                            | type.base t4 =>
                                                fun
                                                  v0 : defaults.expr
                                                         (type.base t4) =>
                                                base.try_make_transport_cps
                                                  (fun t5 : base.type =>
                                                   defaults.expr
                                                     (type.base t5)) t4
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           (base.type.Z *
                                                            base.type.Z)%etype)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t4) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       if
                                                        args =?
                                                        2 ^ Z.log2 args
                                                       then
                                                        UnderLets.Base
                                                          (#(ident.fancy_addc
                                                               (Z.log2 args)
                                                               (- args2))%expr @
                                                           (x0, x2, x' v0))%expr_pat
                                                       else
                                                        if
                                                         args =?
                                                         2 ^ Z.log2 args
                                                        then
                                                         UnderLets.Base
                                                           (#(ident.fancy_addc
                                                                (Z.log2 args)
                                                                0)%expr @
                                                            (x0, x1, x2))%expr_pat
                                                        else
                                                         UnderLets.Base
                                                           (#(ident.Z_add_with_get_carry)%expr @
                                                            x @ x0 @ x1 @ x2)%expr_pat
                                                   | None =>
                                                       UnderLets.Base
                                                         (#(ident.Z_add_with_get_carry)%expr @
                                                          x @ x0 @ x1 @ x2)%expr_pat
                                                   end)
                                            | (s3 -> d3)%ptype =>
                                                fun
                                                  _ : Compile.value' false s3 ->
                                                      Compile.value' true d3
                                                =>
                                                UnderLets.Base
                                                  (#(ident.Z_add_with_get_carry)%expr @
                                                   x @ x0 @ x1 @ x2)%expr_pat
                                            end (Compile.reflect x6)
                                        | None =>
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_addc
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1, x2))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_with_get_carry)%expr @
                                                x @ x0 @ x1 @ x2)%expr_pat
                                        end
                                    | _ =>
                                        if args =? 2 ^ Z.log2 args
                                        then
                                         UnderLets.Base
                                           (#(ident.fancy_addc (Z.log2 args)
                                                0)%expr @ (x0, x1, x2))%expr_pat
                                        else
                                         UnderLets.Base
                                           (#(ident.Z_add_with_get_carry)%expr @
                                            x @ x0 @ x1 @ x2)%expr_pat
                                    end
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                        (x0, x1, x2))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_with_get_carry)%expr @
                                        x @ x0 @ x1 @ x2)%expr_pat
                                end
                            end
                        | (@expr.App _ _ _ s2 _ ($_)%expr _ @ _)%expr_pat |
                          (@expr.App _ _ _ s2 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                          (@expr.App _ _ _ s2 _ (_ @ _) _ @ _)%expr_pat |
                          (@expr.App _ _ _ s2 _ (@expr.LetIn _ _ _ _ _ _ _)
                           _ @ _)%expr_pat =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                (x0, x1, x2))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                        | _ =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                (x0, x1, x2))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                        end
                    | @expr.Abs _ _ _ _ _ _ =>
                        match x1 with
                        | (@expr.App _ _ _ s3 _ #(idc1) x6 @ x5)%expr_pat =>
                            match
                              match idc1 with
                              | ident.Z_shiftl => Some tt
                              | _ => None
                              end
                            with
                            | Some _ =>
                                match x5 with
                                | #(idc2)%expr_pat =>
                                    match
                                      match idc2 with
                                      | @ident.Literal t3 v =>
                                          match
                                            t3 as t4
                                            return
                                              (base.base_interp t4 ->
                                               option Z)
                                          with
                                          | base.type.unit =>
                                              fun _ : unit => None
                                          | base.type.Z =>
                                              fun v0 : Z => Some v0
                                          | base.type.bool =>
                                              fun _ : bool => None
                                          | base.type.nat =>
                                              fun _ : nat => None
                                          end v
                                      | _ => None
                                      end
                                    with
                                    | Some args2 =>
                                        match
                                          s3 as t3
                                          return
                                            (Compile.value' false t3 ->
                                             UnderLets.UnderLets base.type
                                               ident var
                                               (defaults.expr
                                                  (type.base
                                                     (base.type.Z *
                                                      base.type.Z)%etype)))
                                        with
                                        | type.base t3 =>
                                            fun
                                              v : defaults.expr
                                                    (type.base t3) =>
                                            base.try_make_transport_cps
                                              (fun t4 : base.type =>
                                               defaults.expr (type.base t4))
                                              t3 base.type.Z
                                              (UnderLets.UnderLets base.type
                                                 ident var
                                                 (defaults.expr
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)))
                                              (fun
                                                 a : option
                                                       (defaults.expr
                                                          (type.base t3) ->
                                                        defaults.expr
                                                          (type.base
                                                             base.type.Z)) =>
                                               match a with
                                               | Some x' =>
                                                   if args =? 2 ^ Z.log2 args
                                                   then
                                                    UnderLets.Base
                                                      (#(ident.fancy_addc
                                                           (Z.log2 args)
                                                           args2)%expr @
                                                       (x0, x2, x' v))%expr_pat
                                                   else
                                                    if
                                                     args =? 2 ^ Z.log2 args
                                                    then
                                                     UnderLets.Base
                                                       (#(ident.fancy_addc
                                                            (Z.log2 args) 0)%expr @
                                                        (x0, x1, x2))%expr_pat
                                                    else
                                                     UnderLets.Base
                                                       (#(ident.Z_add_with_get_carry)%expr @
                                                        x @ x0 @ x1 @ x2)%expr_pat
                                               | None =>
                                                   UnderLets.Base
                                                     (#(ident.Z_add_with_get_carry)%expr @
                                                      x @ x0 @ x1 @ x2)%expr_pat
                                               end)
                                        | (s4 -> d4)%ptype =>
                                            fun
                                              _ : Compile.value' false s4 ->
                                                  Compile.value' true d4 =>
                                            UnderLets.Base
                                              (#(ident.Z_add_with_get_carry)%expr @
                                               x @ x0 @ x1 @ x2)%expr_pat
                                        end (Compile.reflect x6)
                                    | None =>
                                        if args =? 2 ^ Z.log2 args
                                        then
                                         UnderLets.Base
                                           (#(ident.fancy_addc (Z.log2 args)
                                                0)%expr @ (x0, x1, x2))%expr_pat
                                        else
                                         UnderLets.Base
                                           (#(ident.Z_add_with_get_carry)%expr @
                                            x @ x0 @ x1 @ x2)%expr_pat
                                    end
                                | _ =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                        (x0, x1, x2))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_with_get_carry)%expr @
                                        x @ x0 @ x1 @ x2)%expr_pat
                                end
                            | None =>
                                match
                                  match idc1 with
                                  | ident.Z_shiftr => Some tt
                                  | _ => None
                                  end
                                with
                                | Some _ =>
                                    match x5 with
                                    | #(idc2)%expr_pat =>
                                        match
                                          match idc2 with
                                          | @ident.Literal t3 v =>
                                              match
                                                t3 as t4
                                                return
                                                  (base.base_interp t4 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v0 : Z => Some v0
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v
                                          | _ => None
                                          end
                                        with
                                        | Some args2 =>
                                            match
                                              s3 as t3
                                              return
                                                (Compile.value' false t3 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base
                                                         (base.type.Z *
                                                          base.type.Z)%etype)))
                                            with
                                            | type.base t3 =>
                                                fun
                                                  v : defaults.expr
                                                        (type.base t3) =>
                                                base.try_make_transport_cps
                                                  (fun t4 : base.type =>
                                                   defaults.expr
                                                     (type.base t4)) t3
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           (base.type.Z *
                                                            base.type.Z)%etype)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t3) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       if
                                                        args =?
                                                        2 ^ Z.log2 args
                                                       then
                                                        UnderLets.Base
                                                          (#(ident.fancy_addc
                                                               (Z.log2 args)
                                                               (- args2))%expr @
                                                           (x0, x2, x' v))%expr_pat
                                                       else
                                                        if
                                                         args =?
                                                         2 ^ Z.log2 args
                                                        then
                                                         UnderLets.Base
                                                           (#(ident.fancy_addc
                                                                (Z.log2 args)
                                                                0)%expr @
                                                            (x0, x1, x2))%expr_pat
                                                        else
                                                         UnderLets.Base
                                                           (#(ident.Z_add_with_get_carry)%expr @
                                                            x @ x0 @ x1 @ x2)%expr_pat
                                                   | None =>
                                                       UnderLets.Base
                                                         (#(ident.Z_add_with_get_carry)%expr @
                                                          x @ x0 @ x1 @ x2)%expr_pat
                                                   end)
                                            | (s4 -> d4)%ptype =>
                                                fun
                                                  _ : Compile.value' false s4 ->
                                                      Compile.value' true d4
                                                =>
                                                UnderLets.Base
                                                  (#(ident.Z_add_with_get_carry)%expr @
                                                   x @ x0 @ x1 @ x2)%expr_pat
                                            end (Compile.reflect x6)
                                        | None =>
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_addc
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1, x2))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_with_get_carry)%expr @
                                                x @ x0 @ x1 @ x2)%expr_pat
                                        end
                                    | _ =>
                                        if args =? 2 ^ Z.log2 args
                                        then
                                         UnderLets.Base
                                           (#(ident.fancy_addc (Z.log2 args)
                                                0)%expr @ (x0, x1, x2))%expr_pat
                                        else
                                         UnderLets.Base
                                           (#(ident.Z_add_with_get_carry)%expr @
                                            x @ x0 @ x1 @ x2)%expr_pat
                                    end
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                        (x0, x1, x2))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_with_get_carry)%expr @
                                        x @ x0 @ x1 @ x2)%expr_pat
                                end
                            end
                        | (@expr.App _ _ _ s3 _ ($_)%expr _ @ _)%expr_pat |
                          (@expr.App _ _ _ s3 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                          (@expr.App _ _ _ s3 _ (_ @ _) _ @ _)%expr_pat |
                          (@expr.App _ _ _ s3 _ (@expr.LetIn _ _ _ _ _ _ _)
                           _ @ _)%expr_pat =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                (x0, x1, x2))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                        | _ =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                (x0, x1, x2))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                        end
                    | (_ @ _)%expr_pat =>
                        match x1 with
                        | (@expr.App _ _ _ s3 _ #(idc1) x7 @ x6)%expr_pat =>
                            match
                              match idc1 with
                              | ident.Z_shiftl => Some tt
                              | _ => None
                              end
                            with
                            | Some _ =>
                                match x6 with
                                | #(idc2)%expr_pat =>
                                    match
                                      match idc2 with
                                      | @ident.Literal t3 v =>
                                          match
                                            t3 as t4
                                            return
                                              (base.base_interp t4 ->
                                               option Z)
                                          with
                                          | base.type.unit =>
                                              fun _ : unit => None
                                          | base.type.Z =>
                                              fun v0 : Z => Some v0
                                          | base.type.bool =>
                                              fun _ : bool => None
                                          | base.type.nat =>
                                              fun _ : nat => None
                                          end v
                                      | _ => None
                                      end
                                    with
                                    | Some args2 =>
                                        match
                                          s3 as t3
                                          return
                                            (Compile.value' false t3 ->
                                             UnderLets.UnderLets base.type
                                               ident var
                                               (defaults.expr
                                                  (type.base
                                                     (base.type.Z *
                                                      base.type.Z)%etype)))
                                        with
                                        | type.base t3 =>
                                            fun
                                              v : defaults.expr
                                                    (type.base t3) =>
                                            base.try_make_transport_cps
                                              (fun t4 : base.type =>
                                               defaults.expr (type.base t4))
                                              t3 base.type.Z
                                              (UnderLets.UnderLets base.type
                                                 ident var
                                                 (defaults.expr
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)))
                                              (fun
                                                 a : option
                                                       (defaults.expr
                                                          (type.base t3) ->
                                                        defaults.expr
                                                          (type.base
                                                             base.type.Z)) =>
                                               match a with
                                               | Some x' =>
                                                   if args =? 2 ^ Z.log2 args
                                                   then
                                                    UnderLets.Base
                                                      (#(ident.fancy_addc
                                                           (Z.log2 args)
                                                           args2)%expr @
                                                       (x0, x2, x' v))%expr_pat
                                                   else
                                                    if
                                                     args =? 2 ^ Z.log2 args
                                                    then
                                                     UnderLets.Base
                                                       (#(ident.fancy_addc
                                                            (Z.log2 args) 0)%expr @
                                                        (x0, x1, x2))%expr_pat
                                                    else
                                                     UnderLets.Base
                                                       (#(ident.Z_add_with_get_carry)%expr @
                                                        x @ x0 @ x1 @ x2)%expr_pat
                                               | None =>
                                                   UnderLets.Base
                                                     (#(ident.Z_add_with_get_carry)%expr @
                                                      x @ x0 @ x1 @ x2)%expr_pat
                                               end)
                                        | (s4 -> d4)%ptype =>
                                            fun
                                              _ : Compile.value' false s4 ->
                                                  Compile.value' true d4 =>
                                            UnderLets.Base
                                              (#(ident.Z_add_with_get_carry)%expr @
                                               x @ x0 @ x1 @ x2)%expr_pat
                                        end (Compile.reflect x7)
                                    | None =>
                                        if args =? 2 ^ Z.log2 args
                                        then
                                         UnderLets.Base
                                           (#(ident.fancy_addc (Z.log2 args)
                                                0)%expr @ (x0, x1, x2))%expr_pat
                                        else
                                         UnderLets.Base
                                           (#(ident.Z_add_with_get_carry)%expr @
                                            x @ x0 @ x1 @ x2)%expr_pat
                                    end
                                | _ =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                        (x0, x1, x2))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_with_get_carry)%expr @
                                        x @ x0 @ x1 @ x2)%expr_pat
                                end
                            | None =>
                                match
                                  match idc1 with
                                  | ident.Z_shiftr => Some tt
                                  | _ => None
                                  end
                                with
                                | Some _ =>
                                    match x6 with
                                    | #(idc2)%expr_pat =>
                                        match
                                          match idc2 with
                                          | @ident.Literal t3 v =>
                                              match
                                                t3 as t4
                                                return
                                                  (base.base_interp t4 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v0 : Z => Some v0
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v
                                          | _ => None
                                          end
                                        with
                                        | Some args2 =>
                                            match
                                              s3 as t3
                                              return
                                                (Compile.value' false t3 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base
                                                         (base.type.Z *
                                                          base.type.Z)%etype)))
                                            with
                                            | type.base t3 =>
                                                fun
                                                  v : defaults.expr
                                                        (type.base t3) =>
                                                base.try_make_transport_cps
                                                  (fun t4 : base.type =>
                                                   defaults.expr
                                                     (type.base t4)) t3
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           (base.type.Z *
                                                            base.type.Z)%etype)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t3) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       if
                                                        args =?
                                                        2 ^ Z.log2 args
                                                       then
                                                        UnderLets.Base
                                                          (#(ident.fancy_addc
                                                               (Z.log2 args)
                                                               (- args2))%expr @
                                                           (x0, x2, x' v))%expr_pat
                                                       else
                                                        if
                                                         args =?
                                                         2 ^ Z.log2 args
                                                        then
                                                         UnderLets.Base
                                                           (#(ident.fancy_addc
                                                                (Z.log2 args)
                                                                0)%expr @
                                                            (x0, x1, x2))%expr_pat
                                                        else
                                                         UnderLets.Base
                                                           (#(ident.Z_add_with_get_carry)%expr @
                                                            x @ x0 @ x1 @ x2)%expr_pat
                                                   | None =>
                                                       UnderLets.Base
                                                         (#(ident.Z_add_with_get_carry)%expr @
                                                          x @ x0 @ x1 @ x2)%expr_pat
                                                   end)
                                            | (s4 -> d4)%ptype =>
                                                fun
                                                  _ : Compile.value' false s4 ->
                                                      Compile.value' true d4
                                                =>
                                                UnderLets.Base
                                                  (#(ident.Z_add_with_get_carry)%expr @
                                                   x @ x0 @ x1 @ x2)%expr_pat
                                            end (Compile.reflect x7)
                                        | None =>
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_addc
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1, x2))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_with_get_carry)%expr @
                                                x @ x0 @ x1 @ x2)%expr_pat
                                        end
                                    | _ =>
                                        if args =? 2 ^ Z.log2 args
                                        then
                                         UnderLets.Base
                                           (#(ident.fancy_addc (Z.log2 args)
                                                0)%expr @ (x0, x1, x2))%expr_pat
                                        else
                                         UnderLets.Base
                                           (#(ident.Z_add_with_get_carry)%expr @
                                            x @ x0 @ x1 @ x2)%expr_pat
                                    end
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                        (x0, x1, x2))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_with_get_carry)%expr @
                                        x @ x0 @ x1 @ x2)%expr_pat
                                end
                            end
                        | (@expr.App _ _ _ s3 _ ($_)%expr _ @ _)%expr_pat |
                          (@expr.App _ _ _ s3 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                          (@expr.App _ _ _ s3 _ (_ @ _) _ @ _)%expr_pat |
                          (@expr.App _ _ _ s3 _ (@expr.LetIn _ _ _ _ _ _ _)
                           _ @ _)%expr_pat =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                (x0, x1, x2))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                        | _ =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                (x0, x1, x2))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                        end
                    | @expr.LetIn _ _ _ _ _ _ _ =>
                        match x1 with
                        | (@expr.App _ _ _ s2 _ #(idc1) x7 @ x6)%expr_pat =>
                            match
                              match idc1 with
                              | ident.Z_shiftl => Some tt
                              | _ => None
                              end
                            with
                            | Some _ =>
                                match x6 with
                                | #(idc2)%expr_pat =>
                                    match
                                      match idc2 with
                                      | @ident.Literal t3 v =>
                                          match
                                            t3 as t4
                                            return
                                              (base.base_interp t4 ->
                                               option Z)
                                          with
                                          | base.type.unit =>
                                              fun _ : unit => None
                                          | base.type.Z =>
                                              fun v0 : Z => Some v0
                                          | base.type.bool =>
                                              fun _ : bool => None
                                          | base.type.nat =>
                                              fun _ : nat => None
                                          end v
                                      | _ => None
                                      end
                                    with
                                    | Some args2 =>
                                        match
                                          s2 as t3
                                          return
                                            (Compile.value' false t3 ->
                                             UnderLets.UnderLets base.type
                                               ident var
                                               (defaults.expr
                                                  (type.base
                                                     (base.type.Z *
                                                      base.type.Z)%etype)))
                                        with
                                        | type.base t3 =>
                                            fun
                                              v : defaults.expr
                                                    (type.base t3) =>
                                            base.try_make_transport_cps
                                              (fun t4 : base.type =>
                                               defaults.expr (type.base t4))
                                              t3 base.type.Z
                                              (UnderLets.UnderLets base.type
                                                 ident var
                                                 (defaults.expr
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)))
                                              (fun
                                                 a : option
                                                       (defaults.expr
                                                          (type.base t3) ->
                                                        defaults.expr
                                                          (type.base
                                                             base.type.Z)) =>
                                               match a with
                                               | Some x' =>
                                                   if args =? 2 ^ Z.log2 args
                                                   then
                                                    UnderLets.Base
                                                      (#(ident.fancy_addc
                                                           (Z.log2 args)
                                                           args2)%expr @
                                                       (x0, x2, x' v))%expr_pat
                                                   else
                                                    if
                                                     args =? 2 ^ Z.log2 args
                                                    then
                                                     UnderLets.Base
                                                       (#(ident.fancy_addc
                                                            (Z.log2 args) 0)%expr @
                                                        (x0, x1, x2))%expr_pat
                                                    else
                                                     UnderLets.Base
                                                       (#(ident.Z_add_with_get_carry)%expr @
                                                        x @ x0 @ x1 @ x2)%expr_pat
                                               | None =>
                                                   UnderLets.Base
                                                     (#(ident.Z_add_with_get_carry)%expr @
                                                      x @ x0 @ x1 @ x2)%expr_pat
                                               end)
                                        | (s3 -> d3)%ptype =>
                                            fun
                                              _ : Compile.value' false s3 ->
                                                  Compile.value' true d3 =>
                                            UnderLets.Base
                                              (#(ident.Z_add_with_get_carry)%expr @
                                               x @ x0 @ x1 @ x2)%expr_pat
                                        end (Compile.reflect x7)
                                    | None =>
                                        if args =? 2 ^ Z.log2 args
                                        then
                                         UnderLets.Base
                                           (#(ident.fancy_addc (Z.log2 args)
                                                0)%expr @ (x0, x1, x2))%expr_pat
                                        else
                                         UnderLets.Base
                                           (#(ident.Z_add_with_get_carry)%expr @
                                            x @ x0 @ x1 @ x2)%expr_pat
                                    end
                                | _ =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                        (x0, x1, x2))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_with_get_carry)%expr @
                                        x @ x0 @ x1 @ x2)%expr_pat
                                end
                            | None =>
                                match
                                  match idc1 with
                                  | ident.Z_shiftr => Some tt
                                  | _ => None
                                  end
                                with
                                | Some _ =>
                                    match x6 with
                                    | #(idc2)%expr_pat =>
                                        match
                                          match idc2 with
                                          | @ident.Literal t3 v =>
                                              match
                                                t3 as t4
                                                return
                                                  (base.base_interp t4 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v0 : Z => Some v0
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v
                                          | _ => None
                                          end
                                        with
                                        | Some args2 =>
                                            match
                                              s2 as t3
                                              return
                                                (Compile.value' false t3 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base
                                                         (base.type.Z *
                                                          base.type.Z)%etype)))
                                            with
                                            | type.base t3 =>
                                                fun
                                                  v : defaults.expr
                                                        (type.base t3) =>
                                                base.try_make_transport_cps
                                                  (fun t4 : base.type =>
                                                   defaults.expr
                                                     (type.base t4)) t3
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           (base.type.Z *
                                                            base.type.Z)%etype)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t3) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       if
                                                        args =?
                                                        2 ^ Z.log2 args
                                                       then
                                                        UnderLets.Base
                                                          (#(ident.fancy_addc
                                                               (Z.log2 args)
                                                               (- args2))%expr @
                                                           (x0, x2, x' v))%expr_pat
                                                       else
                                                        if
                                                         args =?
                                                         2 ^ Z.log2 args
                                                        then
                                                         UnderLets.Base
                                                           (#(ident.fancy_addc
                                                                (Z.log2 args)
                                                                0)%expr @
                                                            (x0, x1, x2))%expr_pat
                                                        else
                                                         UnderLets.Base
                                                           (#(ident.Z_add_with_get_carry)%expr @
                                                            x @ x0 @ x1 @ x2)%expr_pat
                                                   | None =>
                                                       UnderLets.Base
                                                         (#(ident.Z_add_with_get_carry)%expr @
                                                          x @ x0 @ x1 @ x2)%expr_pat
                                                   end)
                                            | (s3 -> d3)%ptype =>
                                                fun
                                                  _ : Compile.value' false s3 ->
                                                      Compile.value' true d3
                                                =>
                                                UnderLets.Base
                                                  (#(ident.Z_add_with_get_carry)%expr @
                                                   x @ x0 @ x1 @ x2)%expr_pat
                                            end (Compile.reflect x7)
                                        | None =>
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_addc
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1, x2))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_with_get_carry)%expr @
                                                x @ x0 @ x1 @ x2)%expr_pat
                                        end
                                    | _ =>
                                        if args =? 2 ^ Z.log2 args
                                        then
                                         UnderLets.Base
                                           (#(ident.fancy_addc (Z.log2 args)
                                                0)%expr @ (x0, x1, x2))%expr_pat
                                        else
                                         UnderLets.Base
                                           (#(ident.Z_add_with_get_carry)%expr @
                                            x @ x0 @ x1 @ x2)%expr_pat
                                    end
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                        (x0, x1, x2))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_with_get_carry)%expr @
                                        x @ x0 @ x1 @ x2)%expr_pat
                                end
                            end
                        | (@expr.App _ _ _ s2 _ ($_)%expr _ @ _)%expr_pat |
                          (@expr.App _ _ _ s2 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                          (@expr.App _ _ _ s2 _ (_ @ _) _ @ _)%expr_pat |
                          (@expr.App _ _ _ s2 _ (@expr.LetIn _ _ _ _ _ _ _)
                           _ @ _)%expr_pat =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                (x0, x1, x2))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                        | _ =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                (x0, x1, x2))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                        end
                    end
                | None =>
                    match
                      match idc0 with
                      | ident.Z_shiftr => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match x1 with
                        | #(_)%expr_pat =>
                            match x3 with
                            | #(idc2)%expr_pat =>
                                match
                                  match idc2 with
                                  | @ident.Literal t3 v =>
                                      match
                                        t3 as t4
                                        return
                                          (base.base_interp t4 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s0 as t3
                                      return
                                        (Compile.value' false t3 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t3 =>
                                        fun v : defaults.expr (type.base t3)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t4 : base.type =>
                                           defaults.expr (type.base t4)) t3
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t3) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_addc
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x0, x1, x' v))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_addc
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1, x2))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_with_get_carry)%expr @
                                                    x @ x0 @ x1 @ x2)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_with_get_carry)%expr @
                                                  x @ x0 @ x1 @ x2)%expr_pat
                                           end)
                                    | (s1 -> d1)%ptype =>
                                        fun
                                          _ : Compile.value' false s1 ->
                                              Compile.value' true d1 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ x1 @ x2)%expr_pat
                                    end (Compile.reflect x4)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                        (x0, x1, x2))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_with_get_carry)%expr @
                                        x @ x0 @ x1 @ x2)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                    (x0, x1, x2))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry)%expr @ x @
                                    x0 @ x1 @ x2)%expr_pat
                            end
                        | ($_)%expr =>
                            match x3 with
                            | #(idc1)%expr_pat =>
                                match
                                  match idc1 with
                                  | @ident.Literal t3 v0 =>
                                      match
                                        t3 as t4
                                        return
                                          (base.base_interp t4 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v1 : Z => Some v1
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v0
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s0 as t3
                                      return
                                        (Compile.value' false t3 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t3 =>
                                        fun v0 : defaults.expr (type.base t3)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t4 : base.type =>
                                           defaults.expr (type.base t4)) t3
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t3) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_addc
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x0, x1, x' v0))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_addc
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1, x2))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_with_get_carry)%expr @
                                                    x @ x0 @ x1 @ x2)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_with_get_carry)%expr @
                                                  x @ x0 @ x1 @ x2)%expr_pat
                                           end)
                                    | (s1 -> d1)%ptype =>
                                        fun
                                          _ : Compile.value' false s1 ->
                                              Compile.value' true d1 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ x1 @ x2)%expr_pat
                                    end (Compile.reflect x4)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                        (x0, x1, x2))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_with_get_carry)%expr @
                                        x @ x0 @ x1 @ x2)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                    (x0, x1, x2))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry)%expr @ x @
                                    x0 @ x1 @ x2)%expr_pat
                            end
                        | (#(_) @ _)%expr_pat =>
                            match x3 with
                            | #(idc2)%expr_pat =>
                                match
                                  match idc2 with
                                  | @ident.Literal t3 v =>
                                      match
                                        t3 as t4
                                        return
                                          (base.base_interp t4 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s0 as t3
                                      return
                                        (Compile.value' false t3 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t3 =>
                                        fun v : defaults.expr (type.base t3)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t4 : base.type =>
                                           defaults.expr (type.base t4)) t3
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t3) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_addc
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x0, x1, x' v))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_addc
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1, x2))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_with_get_carry)%expr @
                                                    x @ x0 @ x1 @ x2)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_with_get_carry)%expr @
                                                  x @ x0 @ x1 @ x2)%expr_pat
                                           end)
                                    | (s2 -> d2)%ptype =>
                                        fun
                                          _ : Compile.value' false s2 ->
                                              Compile.value' true d2 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ x1 @ x2)%expr_pat
                                    end (Compile.reflect x4)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                        (x0, x1, x2))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_with_get_carry)%expr @
                                        x @ x0 @ x1 @ x2)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                    (x0, x1, x2))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry)%expr @ x @
                                    x0 @ x1 @ x2)%expr_pat
                            end
                        | (($_)%expr @ _)%expr_pat =>
                            match x3 with
                            | #(idc1)%expr_pat =>
                                match
                                  match idc1 with
                                  | @ident.Literal t3 v0 =>
                                      match
                                        t3 as t4
                                        return
                                          (base.base_interp t4 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v1 : Z => Some v1
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v0
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s0 as t3
                                      return
                                        (Compile.value' false t3 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t3 =>
                                        fun v0 : defaults.expr (type.base t3)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t4 : base.type =>
                                           defaults.expr (type.base t4)) t3
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t3) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_addc
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x0, x1, x' v0))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_addc
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1, x2))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_with_get_carry)%expr @
                                                    x @ x0 @ x1 @ x2)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_with_get_carry)%expr @
                                                  x @ x0 @ x1 @ x2)%expr_pat
                                           end)
                                    | (s2 -> d2)%ptype =>
                                        fun
                                          _ : Compile.value' false s2 ->
                                              Compile.value' true d2 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ x1 @ x2)%expr_pat
                                    end (Compile.reflect x4)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                        (x0, x1, x2))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_with_get_carry)%expr @
                                        x @ x0 @ x1 @ x2)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                    (x0, x1, x2))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry)%expr @ x @
                                    x0 @ x1 @ x2)%expr_pat
                            end
                        | (@expr.Abs _ _ _ _ _ _ @ _)%expr_pat =>
                            match x3 with
                            | #(idc1)%expr_pat =>
                                match
                                  match idc1 with
                                  | @ident.Literal t2 v =>
                                      match
                                        t2 as t3
                                        return
                                          (base.base_interp t3 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s0 as t2
                                      return
                                        (Compile.value' false t2 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t2 =>
                                        fun v : defaults.expr (type.base t2)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t3 : base.type =>
                                           defaults.expr (type.base t3)) t2
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t2) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_addc
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x0, x1, x' v))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_addc
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1, x2))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_with_get_carry)%expr @
                                                    x @ x0 @ x1 @ x2)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_with_get_carry)%expr @
                                                  x @ x0 @ x1 @ x2)%expr_pat
                                           end)
                                    | (s3 -> d3)%ptype =>
                                        fun
                                          _ : Compile.value' false s3 ->
                                              Compile.value' true d3 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ x1 @ x2)%expr_pat
                                    end (Compile.reflect x4)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                        (x0, x1, x2))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_with_get_carry)%expr @
                                        x @ x0 @ x1 @ x2)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                    (x0, x1, x2))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry)%expr @ x @
                                    x0 @ x1 @ x2)%expr_pat
                            end
                        | (@expr.App _ _ _ s2 _ #(idc1) x6 @ x5)%expr_pat =>
                            match
                              match idc1 with
                              | ident.Z_shiftl => Some tt
                              | _ => None
                              end
                            with
                            | Some _ =>
                                match x5 with
                                | #(idc2)%expr_pat =>
                                    match
                                      match idc2 with
                                      | @ident.Literal t3 v =>
                                          match
                                            t3 as t4
                                            return
                                              (base.base_interp t4 ->
                                               option Z)
                                          with
                                          | base.type.unit =>
                                              fun _ : unit => None
                                          | base.type.Z =>
                                              fun v0 : Z => Some v0
                                          | base.type.bool =>
                                              fun _ : bool => None
                                          | base.type.nat =>
                                              fun _ : nat => None
                                          end v
                                      | _ => None
                                      end
                                    with
                                    | Some args2 =>
                                        match
                                          s2 as t3
                                          return
                                            (Compile.value' false t3 ->
                                             UnderLets.UnderLets base.type
                                               ident var
                                               (defaults.expr
                                                  (type.base
                                                     (base.type.Z *
                                                      base.type.Z)%etype)))
                                        with
                                        | type.base t3 =>
                                            fun
                                              v : defaults.expr
                                                    (type.base t3) =>
                                            base.try_make_transport_cps
                                              (fun t4 : base.type =>
                                               defaults.expr (type.base t4))
                                              t3 base.type.Z
                                              (UnderLets.UnderLets base.type
                                                 ident var
                                                 (defaults.expr
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)))
                                              (fun
                                                 a : option
                                                       (defaults.expr
                                                          (type.base t3) ->
                                                        defaults.expr
                                                          (type.base
                                                             base.type.Z)) =>
                                               match a with
                                               | Some x' =>
                                                   if args =? 2 ^ Z.log2 args
                                                   then
                                                    UnderLets.Base
                                                      (#(ident.fancy_addc
                                                           (Z.log2 args)
                                                           args2)%expr @
                                                       (x0, x2, x' v))%expr_pat
                                                   else
                                                    match x3 with
                                                    | #(idc3)%expr_pat =>
                                                        match
                                                          match idc3 with
                                                          | @ident.Literal t5
                                                            v0 =>
                                                              match
                                                                t5 as t6
                                                                return
                                                                  (base.base_interp
                                                                    t6 ->
                                                                   option Z)
                                                              with
                                                              | base.type.unit =>
                                                                  fun
                                                                    _ : unit
                                                                  => None
                                                              | base.type.Z =>
                                                                  fun v1 : Z
                                                                  => 
                                                                  Some v1
                                                              | base.type.bool =>
                                                                  fun
                                                                    _ : bool
                                                                  => None
                                                              | base.type.nat =>
                                                                  fun _ : nat
                                                                  => None
                                                              end v0
                                                          | _ => None
                                                          end
                                                        with
                                                        | Some args3 =>
                                                            match
                                                              s0 as t5
                                                              return
                                                                (Compile.value'
                                                                   false t5 ->
                                                                 UnderLets.UnderLets
                                                                   base.type
                                                                   ident var
                                                                   (defaults.expr
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)))
                                                            with
                                                            | type.base t5 =>
                                                                fun
                                                                  v0 : 
                                                                   defaults.expr
                                                                    (type.base
                                                                    t5) =>
                                                                base.try_make_transport_cps
                                                                  (fun
                                                                    t6 : base.type
                                                                   =>
                                                                   defaults.expr
                                                                    (type.base
                                                                    t6)) t5
                                                                  base.type.Z
                                                                  (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)))
                                                                  (fun
                                                                    a0 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t5) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                   =>
                                                                   match
                                                                    a0
                                                                   with
                                                                   | Some
                                                                    x'0 =>
                                                                    if
                                                                    args =?
                                                                    2
                                                                    ^ 
                                                                    Z.log2
                                                                    args
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_addc
                                                                    (Z.log2
                                                                    args)
                                                                    (- args3))%expr @
                                                                    (x0, x1,
                                                                    x'0 v0))%expr_pat
                                                                    else
                                                                    if
                                                                    args =?
                                                                    2
                                                                    ^ 
                                                                    Z.log2
                                                                    args
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_addc
                                                                    (Z.log2
                                                                    args) 0)%expr @
                                                                    (x0, x1,
                                                                    x2))%expr_pat
                                                                    else
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.Z_add_with_get_carry)%expr @
                                                                    x @ x0 @
                                                                    x1 @ x2)%expr_pat
                                                                   | None =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.Z_add_with_get_carry)%expr @
                                                                    x @ x0 @
                                                                    x1 @ x2)%expr_pat
                                                                   end)
                                                            | (s3 -> d3)%ptype =>
                                                                fun
                                                                  _ : 
                                                                   Compile.value'
                                                                    false s3 ->
                                                                   Compile.value'
                                                                    true d3
                                                                =>
                                                                UnderLets.Base
                                                                  (#(ident.Z_add_with_get_carry)%expr @
                                                                   x @ x0 @
                                                                   x1 @ x2)%expr_pat
                                                            end
                                                              (Compile.reflect
                                                                 x4)
                                                        | None =>
                                                            if
                                                             args =?
                                                             2 ^ Z.log2 args
                                                            then
                                                             UnderLets.Base
                                                               (#(ident.fancy_addc
                                                                    (Z.log2
                                                                    args) 0)%expr @
                                                                (x0, x1, x2))%expr_pat
                                                            else
                                                             UnderLets.Base
                                                               (#(ident.Z_add_with_get_carry)%expr @
                                                                x @ x0 @ x1 @
                                                                x2)%expr_pat
                                                        end
                                                    | _ =>
                                                        if
                                                         args =?
                                                         2 ^ Z.log2 args
                                                        then
                                                         UnderLets.Base
                                                           (#(ident.fancy_addc
                                                                (Z.log2 args)
                                                                0)%expr @
                                                            (x0, x1, x2))%expr_pat
                                                        else
                                                         UnderLets.Base
                                                           (#(ident.Z_add_with_get_carry)%expr @
                                                            x @ x0 @ x1 @ x2)%expr_pat
                                                    end
                                               | None =>
                                                   UnderLets.Base
                                                     (#(ident.Z_add_with_get_carry)%expr @
                                                      x @ x0 @ x1 @ x2)%expr_pat
                                               end)
                                        | (s3 -> d3)%ptype =>
                                            fun
                                              _ : Compile.value' false s3 ->
                                                  Compile.value' true d3 =>
                                            UnderLets.Base
                                              (#(ident.Z_add_with_get_carry)%expr @
                                               x @ x0 @ x1 @ x2)%expr_pat
                                        end (Compile.reflect x6)
                                    | None =>
                                        match x3 with
                                        | #(idc3)%expr_pat =>
                                            match
                                              match idc3 with
                                              | @ident.Literal t4 v =>
                                                  match
                                                    t4 as t5
                                                    return
                                                      (base.base_interp t5 ->
                                                       option Z)
                                                  with
                                                  | base.type.unit =>
                                                      fun _ : unit => None
                                                  | base.type.Z =>
                                                      fun v0 : Z => Some v0
                                                  | base.type.bool =>
                                                      fun _ : bool => None
                                                  | base.type.nat =>
                                                      fun _ : nat => None
                                                  end v
                                              | _ => None
                                              end
                                            with
                                            | Some args2 =>
                                                match
                                                  s0 as t4
                                                  return
                                                    (Compile.value' false t4 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             (base.type.Z *
                                                              base.type.Z)%etype)))
                                                with
                                                | type.base t4 =>
                                                    fun
                                                      v : defaults.expr
                                                            (type.base t4) =>
                                                    base.try_make_transport_cps
                                                      (fun t5 : base.type =>
                                                       defaults.expr
                                                         (type.base t5)) t4
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               (base.type.Z *
                                                                base.type.Z)%etype)))
                                                      (fun
                                                         a : option
                                                               (defaults.expr
                                                                  (type.base
                                                                    t4) ->
                                                                defaults.expr
                                                                  (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a with
                                                       | Some x' =>
                                                           if
                                                            args =?
                                                            2 ^ Z.log2 args
                                                           then
                                                            UnderLets.Base
                                                              (#(ident.fancy_addc
                                                                   (Z.log2
                                                                    args)
                                                                   (- args2))%expr @
                                                               (x0, x1, x' v))%expr_pat
                                                           else
                                                            if
                                                             args =?
                                                             2 ^ Z.log2 args
                                                            then
                                                             UnderLets.Base
                                                               (#(ident.fancy_addc
                                                                    (Z.log2
                                                                    args) 0)%expr @
                                                                (x0, x1, x2))%expr_pat
                                                            else
                                                             UnderLets.Base
                                                               (#(ident.Z_add_with_get_carry)%expr @
                                                                x @ x0 @ x1 @
                                                                x2)%expr_pat
                                                       | None =>
                                                           UnderLets.Base
                                                             (#(ident.Z_add_with_get_carry)%expr @
                                                              x @ x0 @ x1 @
                                                              x2)%expr_pat
                                                       end)
                                                | (s3 -> d3)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s3 ->
                                                          Compile.value' true
                                                            d3 =>
                                                    UnderLets.Base
                                                      (#(ident.Z_add_with_get_carry)%expr @
                                                       x @ x0 @ x1 @ x2)%expr_pat
                                                end (Compile.reflect x4)
                                            | None =>
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_addc
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1, x2))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_with_get_carry)%expr @
                                                    x @ x0 @ x1 @ x2)%expr_pat
                                            end
                                        | _ =>
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_addc
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1, x2))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_with_get_carry)%expr @
                                                x @ x0 @ x1 @ x2)%expr_pat
                                        end
                                    end
                                | ($_)%expr =>
                                    match x3 with
                                    | #(idc2)%expr_pat =>
                                        match
                                          match idc2 with
                                          | @ident.Literal t4 v0 =>
                                              match
                                                t4 as t5
                                                return
                                                  (base.base_interp t5 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v1 : Z => Some v1
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v0
                                          | _ => None
                                          end
                                        with
                                        | Some args2 =>
                                            match
                                              s0 as t4
                                              return
                                                (Compile.value' false t4 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base
                                                         (base.type.Z *
                                                          base.type.Z)%etype)))
                                            with
                                            | type.base t4 =>
                                                fun
                                                  v0 : defaults.expr
                                                         (type.base t4) =>
                                                base.try_make_transport_cps
                                                  (fun t5 : base.type =>
                                                   defaults.expr
                                                     (type.base t5)) t4
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           (base.type.Z *
                                                            base.type.Z)%etype)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t4) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       if
                                                        args =?
                                                        2 ^ Z.log2 args
                                                       then
                                                        UnderLets.Base
                                                          (#(ident.fancy_addc
                                                               (Z.log2 args)
                                                               (- args2))%expr @
                                                           (x0, x1, x' v0))%expr_pat
                                                       else
                                                        if
                                                         args =?
                                                         2 ^ Z.log2 args
                                                        then
                                                         UnderLets.Base
                                                           (#(ident.fancy_addc
                                                                (Z.log2 args)
                                                                0)%expr @
                                                            (x0, x1, x2))%expr_pat
                                                        else
                                                         UnderLets.Base
                                                           (#(ident.Z_add_with_get_carry)%expr @
                                                            x @ x0 @ x1 @ x2)%expr_pat
                                                   | None =>
                                                       UnderLets.Base
                                                         (#(ident.Z_add_with_get_carry)%expr @
                                                          x @ x0 @ x1 @ x2)%expr_pat
                                                   end)
                                            | (s3 -> d3)%ptype =>
                                                fun
                                                  _ : Compile.value' false s3 ->
                                                      Compile.value' true d3
                                                =>
                                                UnderLets.Base
                                                  (#(ident.Z_add_with_get_carry)%expr @
                                                   x @ x0 @ x1 @ x2)%expr_pat
                                            end (Compile.reflect x4)
                                        | None =>
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_addc
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1, x2))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_with_get_carry)%expr @
                                                x @ x0 @ x1 @ x2)%expr_pat
                                        end
                                    | _ =>
                                        if args =? 2 ^ Z.log2 args
                                        then
                                         UnderLets.Base
                                           (#(ident.fancy_addc (Z.log2 args)
                                                0)%expr @ (x0, x1, x2))%expr_pat
                                        else
                                         UnderLets.Base
                                           (#(ident.Z_add_with_get_carry)%expr @
                                            x @ x0 @ x1 @ x2)%expr_pat
                                    end
                                | @expr.LetIn _ _ _ _ _ _ _ =>
                                    match x3 with
                                    | #(idc2)%expr_pat =>
                                        match
                                          match idc2 with
                                          | @ident.Literal t3 v =>
                                              match
                                                t3 as t4
                                                return
                                                  (base.base_interp t4 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v0 : Z => Some v0
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v
                                          | _ => None
                                          end
                                        with
                                        | Some args2 =>
                                            match
                                              s0 as t3
                                              return
                                                (Compile.value' false t3 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base
                                                         (base.type.Z *
                                                          base.type.Z)%etype)))
                                            with
                                            | type.base t3 =>
                                                fun
                                                  v : defaults.expr
                                                        (type.base t3) =>
                                                base.try_make_transport_cps
                                                  (fun t4 : base.type =>
                                                   defaults.expr
                                                     (type.base t4)) t3
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           (base.type.Z *
                                                            base.type.Z)%etype)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t3) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       if
                                                        args =?
                                                        2 ^ Z.log2 args
                                                       then
                                                        UnderLets.Base
                                                          (#(ident.fancy_addc
                                                               (Z.log2 args)
                                                               (- args2))%expr @
                                                           (x0, x1, x' v))%expr_pat
                                                       else
                                                        if
                                                         args =?
                                                         2 ^ Z.log2 args
                                                        then
                                                         UnderLets.Base
                                                           (#(ident.fancy_addc
                                                                (Z.log2 args)
                                                                0)%expr @
                                                            (x0, x1, x2))%expr_pat
                                                        else
                                                         UnderLets.Base
                                                           (#(ident.Z_add_with_get_carry)%expr @
                                                            x @ x0 @ x1 @ x2)%expr_pat
                                                   | None =>
                                                       UnderLets.Base
                                                         (#(ident.Z_add_with_get_carry)%expr @
                                                          x @ x0 @ x1 @ x2)%expr_pat
                                                   end)
                                            | (s3 -> d3)%ptype =>
                                                fun
                                                  _ : Compile.value' false s3 ->
                                                      Compile.value' true d3
                                                =>
                                                UnderLets.Base
                                                  (#(ident.Z_add_with_get_carry)%expr @
                                                   x @ x0 @ x1 @ x2)%expr_pat
                                            end (Compile.reflect x4)
                                        | None =>
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_addc
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1, x2))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_with_get_carry)%expr @
                                                x @ x0 @ x1 @ x2)%expr_pat
                                        end
                                    | _ =>
                                        if args =? 2 ^ Z.log2 args
                                        then
                                         UnderLets.Base
                                           (#(ident.fancy_addc (Z.log2 args)
                                                0)%expr @ (x0, x1, x2))%expr_pat
                                        else
                                         UnderLets.Base
                                           (#(ident.Z_add_with_get_carry)%expr @
                                            x @ x0 @ x1 @ x2)%expr_pat
                                    end
                                | _ =>
                                    match x3 with
                                    | #(idc2)%expr_pat =>
                                        match
                                          match idc2 with
                                          | @ident.Literal t3 v =>
                                              match
                                                t3 as t4
                                                return
                                                  (base.base_interp t4 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v0 : Z => Some v0
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v
                                          | _ => None
                                          end
                                        with
                                        | Some args2 =>
                                            match
                                              s0 as t3
                                              return
                                                (Compile.value' false t3 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base
                                                         (base.type.Z *
                                                          base.type.Z)%etype)))
                                            with
                                            | type.base t3 =>
                                                fun
                                                  v : defaults.expr
                                                        (type.base t3) =>
                                                base.try_make_transport_cps
                                                  (fun t4 : base.type =>
                                                   defaults.expr
                                                     (type.base t4)) t3
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           (base.type.Z *
                                                            base.type.Z)%etype)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t3) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       if
                                                        args =?
                                                        2 ^ Z.log2 args
                                                       then
                                                        UnderLets.Base
                                                          (#(ident.fancy_addc
                                                               (Z.log2 args)
                                                               (- args2))%expr @
                                                           (x0, x1, x' v))%expr_pat
                                                       else
                                                        if
                                                         args =?
                                                         2 ^ Z.log2 args
                                                        then
                                                         UnderLets.Base
                                                           (#(ident.fancy_addc
                                                                (Z.log2 args)
                                                                0)%expr @
                                                            (x0, x1, x2))%expr_pat
                                                        else
                                                         UnderLets.Base
                                                           (#(ident.Z_add_with_get_carry)%expr @
                                                            x @ x0 @ x1 @ x2)%expr_pat
                                                   | None =>
                                                       UnderLets.Base
                                                         (#(ident.Z_add_with_get_carry)%expr @
                                                          x @ x0 @ x1 @ x2)%expr_pat
                                                   end)
                                            | (s4 -> d4)%ptype =>
                                                fun
                                                  _ : Compile.value' false s4 ->
                                                      Compile.value' true d4
                                                =>
                                                UnderLets.Base
                                                  (#(ident.Z_add_with_get_carry)%expr @
                                                   x @ x0 @ x1 @ x2)%expr_pat
                                            end (Compile.reflect x4)
                                        | None =>
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_addc
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1, x2))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_with_get_carry)%expr @
                                                x @ x0 @ x1 @ x2)%expr_pat
                                        end
                                    | _ =>
                                        if args =? 2 ^ Z.log2 args
                                        then
                                         UnderLets.Base
                                           (#(ident.fancy_addc (Z.log2 args)
                                                0)%expr @ (x0, x1, x2))%expr_pat
                                        else
                                         UnderLets.Base
                                           (#(ident.Z_add_with_get_carry)%expr @
                                            x @ x0 @ x1 @ x2)%expr_pat
                                    end
                                end
                            | None =>
                                match
                                  match idc1 with
                                  | ident.Z_shiftr => Some tt
                                  | _ => None
                                  end
                                with
                                | Some _ =>
                                    match x3 with
                                    | #(idc2)%expr_pat =>
                                        match
                                          match idc2 with
                                          | @ident.Literal t3 v =>
                                              match
                                                t3 as t4
                                                return
                                                  (base.base_interp t4 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v0 : Z => Some v0
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v
                                          | _ => None
                                          end
                                        with
                                        | Some args2 =>
                                            match
                                              s0 as t3
                                              return
                                                (Compile.value' false t3 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base
                                                         (base.type.Z *
                                                          base.type.Z)%etype)))
                                            with
                                            | type.base t3 =>
                                                fun
                                                  v : defaults.expr
                                                        (type.base t3) =>
                                                base.try_make_transport_cps
                                                  (fun t4 : base.type =>
                                                   defaults.expr
                                                     (type.base t4)) t3
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           (base.type.Z *
                                                            base.type.Z)%etype)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t3) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       if
                                                        args =?
                                                        2 ^ Z.log2 args
                                                       then
                                                        UnderLets.Base
                                                          (#(ident.fancy_addc
                                                               (Z.log2 args)
                                                               (- args2))%expr @
                                                           (x0, x1, x' v))%expr_pat
                                                       else
                                                        match x5 with
                                                        | #(idc3)%expr_pat =>
                                                            match
                                                              match idc3 with
                                                              | @ident.Literal
                                                                t5 v0 =>
                                                                  match
                                                                    t5 as t6
                                                                    return
                                                                    (base.base_interp
                                                                    t6 ->
                                                                    option Z)
                                                                  with
                                                                  | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                  | base.type.Z =>
                                                                    fun
                                                                    v1 : Z =>
                                                                    Some v1
                                                                  | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                  | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                  end v0
                                                              | _ => None
                                                              end
                                                            with
                                                            | Some args3 =>
                                                                match
                                                                  s2 as t5
                                                                  return
                                                                    (Compile.value'
                                                                    false t5 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)))
                                                                with
                                                                | type.base
                                                                  t5 =>
                                                                    fun
                                                                    v0 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t5) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t6 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t6)) t5
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)))
                                                                    (fun
                                                                    a0 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t5) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a0
                                                                    with
                                                                    | Some
                                                                    x'0 =>
                                                                    if
                                                                    args =?
                                                                    2
                                                                    ^ 
                                                                    Z.log2
                                                                    args
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_addc
                                                                    (Z.log2
                                                                    args)
                                                                    (- args3))%expr @
                                                                    (x0, x2,
                                                                    x'0 v0))%expr_pat
                                                                    else
                                                                    if
                                                                    args =?
                                                                    2
                                                                    ^ 
                                                                    Z.log2
                                                                    args
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_addc
                                                                    (Z.log2
                                                                    args) 0)%expr @
                                                                    (x0, x1,
                                                                    x2))%expr_pat
                                                                    else
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.Z_add_with_get_carry)%expr @
                                                                    x @ x0 @
                                                                    x1 @ x2)%expr_pat
                                                                    | None =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.Z_add_with_get_carry)%expr @
                                                                    x @ x0 @
                                                                    x1 @ x2)%expr_pat
                                                                    end)
                                                                | (s3 -> d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.Z_add_with_get_carry)%expr @
                                                                    x @ x0 @
                                                                    x1 @ x2)%expr_pat
                                                                end
                                                                  (Compile.reflect
                                                                    x6)
                                                            | None =>
                                                                if
                                                                 args =?
                                                                 2
                                                                 ^ Z.log2
                                                                    args
                                                                then
                                                                 UnderLets.Base
                                                                   (#
                                                                    (ident.fancy_addc
                                                                    (Z.log2
                                                                    args) 0)%expr @
                                                                    (x0, x1,
                                                                    x2))%expr_pat
                                                                else
                                                                 UnderLets.Base
                                                                   (#
                                                                    (ident.Z_add_with_get_carry)%expr @
                                                                    x @ x0 @
                                                                    x1 @ x2)%expr_pat
                                                            end
                                                        | _ =>
                                                            if
                                                             args =?
                                                             2 ^ Z.log2 args
                                                            then
                                                             UnderLets.Base
                                                               (#(ident.fancy_addc
                                                                    (Z.log2
                                                                    args) 0)%expr @
                                                                (x0, x1, x2))%expr_pat
                                                            else
                                                             UnderLets.Base
                                                               (#(ident.Z_add_with_get_carry)%expr @
                                                                x @ x0 @ x1 @
                                                                x2)%expr_pat
                                                        end
                                                   | None =>
                                                       UnderLets.Base
                                                         (#(ident.Z_add_with_get_carry)%expr @
                                                          x @ x0 @ x1 @ x2)%expr_pat
                                                   end)
                                            | (s3 -> d3)%ptype =>
                                                fun
                                                  _ : Compile.value' false s3 ->
                                                      Compile.value' true d3
                                                =>
                                                UnderLets.Base
                                                  (#(ident.Z_add_with_get_carry)%expr @
                                                   x @ x0 @ x1 @ x2)%expr_pat
                                            end (Compile.reflect x4)
                                        | None =>
                                            match x5 with
                                            | #(idc3)%expr_pat =>
                                                match
                                                  match idc3 with
                                                  | @ident.Literal t4 v =>
                                                      match
                                                        t4 as t5
                                                        return
                                                          (base.base_interp
                                                             t5 -> option Z)
                                                      with
                                                      | base.type.unit =>
                                                          fun _ : unit =>
                                                          None
                                                      | base.type.Z =>
                                                          fun v0 : Z =>
                                                          Some v0
                                                      | base.type.bool =>
                                                          fun _ : bool =>
                                                          None
                                                      | base.type.nat =>
                                                          fun _ : nat => None
                                                      end v
                                                  | _ => None
                                                  end
                                                with
                                                | Some args2 =>
                                                    match
                                                      s2 as t4
                                                      return
                                                        (Compile.value' false
                                                           t4 ->
                                                         UnderLets.UnderLets
                                                           base.type ident
                                                           var
                                                           (defaults.expr
                                                              (type.base
                                                                 (base.type.Z *
                                                                  base.type.Z)%etype)))
                                                    with
                                                    | type.base t4 =>
                                                        fun
                                                          v : defaults.expr
                                                                (type.base t4)
                                                        =>
                                                        base.try_make_transport_cps
                                                          (fun t5 : base.type
                                                           =>
                                                           defaults.expr
                                                             (type.base t5))
                                                          t4 base.type.Z
                                                          (UnderLets.UnderLets
                                                             base.type ident
                                                             var
                                                             (defaults.expr
                                                                (type.base
                                                                   (base.type.Z *
                                                                    base.type.Z)%etype)))
                                                          (fun
                                                             a : option
                                                                   (defaults.expr
                                                                    (type.base
                                                                    t4) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                           =>
                                                           match a with
                                                           | Some x' =>
                                                               if
                                                                args =?
                                                                2
                                                                ^ Z.log2 args
                                                               then
                                                                UnderLets.Base
                                                                  (#(ident.fancy_addc
                                                                    (Z.log2
                                                                    args)
                                                                    (- args2))%expr @
                                                                   (x0, x2,
                                                                   x' v))%expr_pat
                                                               else
                                                                if
                                                                 args =?
                                                                 2
                                                                 ^ Z.log2
                                                                    args
                                                                then
                                                                 UnderLets.Base
                                                                   (#
                                                                    (ident.fancy_addc
                                                                    (Z.log2
                                                                    args) 0)%expr @
                                                                    (x0, x1,
                                                                    x2))%expr_pat
                                                                else
                                                                 UnderLets.Base
                                                                   (#
                                                                    (ident.Z_add_with_get_carry)%expr @
                                                                    x @ x0 @
                                                                    x1 @ x2)%expr_pat
                                                           | None =>
                                                               UnderLets.Base
                                                                 (#(ident.Z_add_with_get_carry)%expr @
                                                                  x @ x0 @ x1 @
                                                                  x2)%expr_pat
                                                           end)
                                                    | (s3 -> d3)%ptype =>
                                                        fun
                                                          _ : Compile.value'
                                                                false s3 ->
                                                              Compile.value'
                                                                true d3 =>
                                                        UnderLets.Base
                                                          (#(ident.Z_add_with_get_carry)%expr @
                                                           x @ x0 @ x1 @ x2)%expr_pat
                                                    end (Compile.reflect x6)
                                                | None =>
                                                    if
                                                     args =? 2 ^ Z.log2 args
                                                    then
                                                     UnderLets.Base
                                                       (#(ident.fancy_addc
                                                            (Z.log2 args) 0)%expr @
                                                        (x0, x1, x2))%expr_pat
                                                    else
                                                     UnderLets.Base
                                                       (#(ident.Z_add_with_get_carry)%expr @
                                                        x @ x0 @ x1 @ x2)%expr_pat
                                                end
                                            | _ =>
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_addc
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1, x2))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_with_get_carry)%expr @
                                                    x @ x0 @ x1 @ x2)%expr_pat
                                            end
                                        end
                                    | ($_)%expr =>
                                        match x5 with
                                        | #(idc2)%expr_pat =>
                                            match
                                              match idc2 with
                                              | @ident.Literal t4 v0 =>
                                                  match
                                                    t4 as t5
                                                    return
                                                      (base.base_interp t5 ->
                                                       option Z)
                                                  with
                                                  | base.type.unit =>
                                                      fun _ : unit => None
                                                  | base.type.Z =>
                                                      fun v1 : Z => Some v1
                                                  | base.type.bool =>
                                                      fun _ : bool => None
                                                  | base.type.nat =>
                                                      fun _ : nat => None
                                                  end v0
                                              | _ => None
                                              end
                                            with
                                            | Some args2 =>
                                                match
                                                  s2 as t4
                                                  return
                                                    (Compile.value' false t4 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             (base.type.Z *
                                                              base.type.Z)%etype)))
                                                with
                                                | type.base t4 =>
                                                    fun
                                                      v0 : defaults.expr
                                                             (type.base t4)
                                                    =>
                                                    base.try_make_transport_cps
                                                      (fun t5 : base.type =>
                                                       defaults.expr
                                                         (type.base t5)) t4
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               (base.type.Z *
                                                                base.type.Z)%etype)))
                                                      (fun
                                                         a : option
                                                               (defaults.expr
                                                                  (type.base
                                                                    t4) ->
                                                                defaults.expr
                                                                  (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a with
                                                       | Some x' =>
                                                           if
                                                            args =?
                                                            2 ^ Z.log2 args
                                                           then
                                                            UnderLets.Base
                                                              (#(ident.fancy_addc
                                                                   (Z.log2
                                                                    args)
                                                                   (- args2))%expr @
                                                               (x0, x2,
                                                               x' v0))%expr_pat
                                                           else
                                                            if
                                                             args =?
                                                             2 ^ Z.log2 args
                                                            then
                                                             UnderLets.Base
                                                               (#(ident.fancy_addc
                                                                    (Z.log2
                                                                    args) 0)%expr @
                                                                (x0, x1, x2))%expr_pat
                                                            else
                                                             UnderLets.Base
                                                               (#(ident.Z_add_with_get_carry)%expr @
                                                                x @ x0 @ x1 @
                                                                x2)%expr_pat
                                                       | None =>
                                                           UnderLets.Base
                                                             (#(ident.Z_add_with_get_carry)%expr @
                                                              x @ x0 @ x1 @
                                                              x2)%expr_pat
                                                       end)
                                                | (s3 -> d3)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s3 ->
                                                          Compile.value' true
                                                            d3 =>
                                                    UnderLets.Base
                                                      (#(ident.Z_add_with_get_carry)%expr @
                                                       x @ x0 @ x1 @ x2)%expr_pat
                                                end (Compile.reflect x6)
                                            | None =>
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_addc
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1, x2))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_with_get_carry)%expr @
                                                    x @ x0 @ x1 @ x2)%expr_pat
                                            end
                                        | _ =>
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_addc
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1, x2))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_with_get_carry)%expr @
                                                x @ x0 @ x1 @ x2)%expr_pat
                                        end
                                    | @expr.LetIn _ _ _ _ _ _ _ =>
                                        match x5 with
                                        | #(idc2)%expr_pat =>
                                            match
                                              match idc2 with
                                              | @ident.Literal t3 v =>
                                                  match
                                                    t3 as t4
                                                    return
                                                      (base.base_interp t4 ->
                                                       option Z)
                                                  with
                                                  | base.type.unit =>
                                                      fun _ : unit => None
                                                  | base.type.Z =>
                                                      fun v0 : Z => Some v0
                                                  | base.type.bool =>
                                                      fun _ : bool => None
                                                  | base.type.nat =>
                                                      fun _ : nat => None
                                                  end v
                                              | _ => None
                                              end
                                            with
                                            | Some args2 =>
                                                match
                                                  s2 as t3
                                                  return
                                                    (Compile.value' false t3 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             (base.type.Z *
                                                              base.type.Z)%etype)))
                                                with
                                                | type.base t3 =>
                                                    fun
                                                      v : defaults.expr
                                                            (type.base t3) =>
                                                    base.try_make_transport_cps
                                                      (fun t4 : base.type =>
                                                       defaults.expr
                                                         (type.base t4)) t3
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               (base.type.Z *
                                                                base.type.Z)%etype)))
                                                      (fun
                                                         a : option
                                                               (defaults.expr
                                                                  (type.base
                                                                    t3) ->
                                                                defaults.expr
                                                                  (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a with
                                                       | Some x' =>
                                                           if
                                                            args =?
                                                            2 ^ Z.log2 args
                                                           then
                                                            UnderLets.Base
                                                              (#(ident.fancy_addc
                                                                   (Z.log2
                                                                    args)
                                                                   (- args2))%expr @
                                                               (x0, x2, x' v))%expr_pat
                                                           else
                                                            if
                                                             args =?
                                                             2 ^ Z.log2 args
                                                            then
                                                             UnderLets.Base
                                                               (#(ident.fancy_addc
                                                                    (Z.log2
                                                                    args) 0)%expr @
                                                                (x0, x1, x2))%expr_pat
                                                            else
                                                             UnderLets.Base
                                                               (#(ident.Z_add_with_get_carry)%expr @
                                                                x @ x0 @ x1 @
                                                                x2)%expr_pat
                                                       | None =>
                                                           UnderLets.Base
                                                             (#(ident.Z_add_with_get_carry)%expr @
                                                              x @ x0 @ x1 @
                                                              x2)%expr_pat
                                                       end)
                                                | (s3 -> d3)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s3 ->
                                                          Compile.value' true
                                                            d3 =>
                                                    UnderLets.Base
                                                      (#(ident.Z_add_with_get_carry)%expr @
                                                       x @ x0 @ x1 @ x2)%expr_pat
                                                end (Compile.reflect x6)
                                            | None =>
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_addc
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1, x2))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_with_get_carry)%expr @
                                                    x @ x0 @ x1 @ x2)%expr_pat
                                            end
                                        | _ =>
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_addc
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1, x2))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_with_get_carry)%expr @
                                                x @ x0 @ x1 @ x2)%expr_pat
                                        end
                                    | _ =>
                                        match x5 with
                                        | #(idc2)%expr_pat =>
                                            match
                                              match idc2 with
                                              | @ident.Literal t3 v =>
                                                  match
                                                    t3 as t4
                                                    return
                                                      (base.base_interp t4 ->
                                                       option Z)
                                                  with
                                                  | base.type.unit =>
                                                      fun _ : unit => None
                                                  | base.type.Z =>
                                                      fun v0 : Z => Some v0
                                                  | base.type.bool =>
                                                      fun _ : bool => None
                                                  | base.type.nat =>
                                                      fun _ : nat => None
                                                  end v
                                              | _ => None
                                              end
                                            with
                                            | Some args2 =>
                                                match
                                                  s2 as t3
                                                  return
                                                    (Compile.value' false t3 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             (base.type.Z *
                                                              base.type.Z)%etype)))
                                                with
                                                | type.base t3 =>
                                                    fun
                                                      v : defaults.expr
                                                            (type.base t3) =>
                                                    base.try_make_transport_cps
                                                      (fun t4 : base.type =>
                                                       defaults.expr
                                                         (type.base t4)) t3
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               (base.type.Z *
                                                                base.type.Z)%etype)))
                                                      (fun
                                                         a : option
                                                               (defaults.expr
                                                                  (type.base
                                                                    t3) ->
                                                                defaults.expr
                                                                  (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a with
                                                       | Some x' =>
                                                           if
                                                            args =?
                                                            2 ^ Z.log2 args
                                                           then
                                                            UnderLets.Base
                                                              (#(ident.fancy_addc
                                                                   (Z.log2
                                                                    args)
                                                                   (- args2))%expr @
                                                               (x0, x2, x' v))%expr_pat
                                                           else
                                                            if
                                                             args =?
                                                             2 ^ Z.log2 args
                                                            then
                                                             UnderLets.Base
                                                               (#(ident.fancy_addc
                                                                    (Z.log2
                                                                    args) 0)%expr @
                                                                (x0, x1, x2))%expr_pat
                                                            else
                                                             UnderLets.Base
                                                               (#(ident.Z_add_with_get_carry)%expr @
                                                                x @ x0 @ x1 @
                                                                x2)%expr_pat
                                                       | None =>
                                                           UnderLets.Base
                                                             (#(ident.Z_add_with_get_carry)%expr @
                                                              x @ x0 @ x1 @
                                                              x2)%expr_pat
                                                       end)
                                                | (s4 -> d4)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s4 ->
                                                          Compile.value' true
                                                            d4 =>
                                                    UnderLets.Base
                                                      (#(ident.Z_add_with_get_carry)%expr @
                                                       x @ x0 @ x1 @ x2)%expr_pat
                                                end (Compile.reflect x6)
                                            | None =>
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_addc
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1, x2))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_with_get_carry)%expr @
                                                    x @ x0 @ x1 @ x2)%expr_pat
                                            end
                                        | _ =>
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_addc
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1, x2))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_with_get_carry)%expr @
                                                x @ x0 @ x1 @ x2)%expr_pat
                                        end
                                    end
                                | None =>
                                    match x3 with
                                    | #(idc2)%expr_pat =>
                                        match
                                          match idc2 with
                                          | @ident.Literal t3 v =>
                                              match
                                                t3 as t4
                                                return
                                                  (base.base_interp t4 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v0 : Z => Some v0
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v
                                          | _ => None
                                          end
                                        with
                                        | Some args1 =>
                                            match
                                              s0 as t3
                                              return
                                                (Compile.value' false t3 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base
                                                         (base.type.Z *
                                                          base.type.Z)%etype)))
                                            with
                                            | type.base t3 =>
                                                fun
                                                  v : defaults.expr
                                                        (type.base t3) =>
                                                base.try_make_transport_cps
                                                  (fun t4 : base.type =>
                                                   defaults.expr
                                                     (type.base t4)) t3
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           (base.type.Z *
                                                            base.type.Z)%etype)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t3) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       if
                                                        args =?
                                                        2 ^ Z.log2 args
                                                       then
                                                        UnderLets.Base
                                                          (#(ident.fancy_addc
                                                               (Z.log2 args)
                                                               (- args1))%expr @
                                                           (x0, x1, x' v))%expr_pat
                                                       else
                                                        if
                                                         args =?
                                                         2 ^ Z.log2 args
                                                        then
                                                         UnderLets.Base
                                                           (#(ident.fancy_addc
                                                                (Z.log2 args)
                                                                0)%expr @
                                                            (x0, x1, x2))%expr_pat
                                                        else
                                                         UnderLets.Base
                                                           (#(ident.Z_add_with_get_carry)%expr @
                                                            x @ x0 @ x1 @ x2)%expr_pat
                                                   | None =>
                                                       UnderLets.Base
                                                         (#(ident.Z_add_with_get_carry)%expr @
                                                          x @ x0 @ x1 @ x2)%expr_pat
                                                   end)
                                            | (s3 -> d3)%ptype =>
                                                fun
                                                  _ : Compile.value' false s3 ->
                                                      Compile.value' true d3
                                                =>
                                                UnderLets.Base
                                                  (#(ident.Z_add_with_get_carry)%expr @
                                                   x @ x0 @ x1 @ x2)%expr_pat
                                            end (Compile.reflect x4)
                                        | None =>
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_addc
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1, x2))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_with_get_carry)%expr @
                                                x @ x0 @ x1 @ x2)%expr_pat
                                        end
                                    | _ =>
                                        if args =? 2 ^ Z.log2 args
                                        then
                                         UnderLets.Base
                                           (#(ident.fancy_addc (Z.log2 args)
                                                0)%expr @ (x0, x1, x2))%expr_pat
                                        else
                                         UnderLets.Base
                                           (#(ident.Z_add_with_get_carry)%expr @
                                            x @ x0 @ x1 @ x2)%expr_pat
                                    end
                                end
                            end
                        | (@expr.App _ _ _ s2 _ ($_)%expr _ @ _)%expr_pat =>
                            match x3 with
                            | #(idc1)%expr_pat =>
                                match
                                  match idc1 with
                                  | @ident.Literal t3 v0 =>
                                      match
                                        t3 as t4
                                        return
                                          (base.base_interp t4 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v1 : Z => Some v1
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v0
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s0 as t3
                                      return
                                        (Compile.value' false t3 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t3 =>
                                        fun v0 : defaults.expr (type.base t3)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t4 : base.type =>
                                           defaults.expr (type.base t4)) t3
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t3) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_addc
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x0, x1, x' v0))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_addc
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1, x2))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_with_get_carry)%expr @
                                                    x @ x0 @ x1 @ x2)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_with_get_carry)%expr @
                                                  x @ x0 @ x1 @ x2)%expr_pat
                                           end)
                                    | (s3 -> d3)%ptype =>
                                        fun
                                          _ : Compile.value' false s3 ->
                                              Compile.value' true d3 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ x1 @ x2)%expr_pat
                                    end (Compile.reflect x4)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                        (x0, x1, x2))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_with_get_carry)%expr @
                                        x @ x0 @ x1 @ x2)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                    (x0, x1, x2))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry)%expr @ x @
                                    x0 @ x1 @ x2)%expr_pat
                            end
                        | (@expr.App _ _ _ s2 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                          (@expr.App _ _ _ s2 _ (_ @ _) _ @ _)%expr_pat =>
                            match x3 with
                            | #(idc1)%expr_pat =>
                                match
                                  match idc1 with
                                  | @ident.Literal t2 v =>
                                      match
                                        t2 as t3
                                        return
                                          (base.base_interp t3 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s0 as t2
                                      return
                                        (Compile.value' false t2 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t2 =>
                                        fun v : defaults.expr (type.base t2)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t3 : base.type =>
                                           defaults.expr (type.base t3)) t2
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t2) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_addc
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x0, x1, x' v))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_addc
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1, x2))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_with_get_carry)%expr @
                                                    x @ x0 @ x1 @ x2)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_with_get_carry)%expr @
                                                  x @ x0 @ x1 @ x2)%expr_pat
                                           end)
                                    | (s4 -> d4)%ptype =>
                                        fun
                                          _ : Compile.value' false s4 ->
                                              Compile.value' true d4 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ x1 @ x2)%expr_pat
                                    end (Compile.reflect x4)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                        (x0, x1, x2))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_with_get_carry)%expr @
                                        x @ x0 @ x1 @ x2)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                    (x0, x1, x2))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry)%expr @ x @
                                    x0 @ x1 @ x2)%expr_pat
                            end
                        | (@expr.App _ _ _ s2 _ (@expr.LetIn _ _ _ _ _ _ _)
                           _ @ _)%expr_pat =>
                            match x3 with
                            | #(idc1)%expr_pat =>
                                match
                                  match idc1 with
                                  | @ident.Literal t2 v =>
                                      match
                                        t2 as t3
                                        return
                                          (base.base_interp t3 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s0 as t2
                                      return
                                        (Compile.value' false t2 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t2 =>
                                        fun v : defaults.expr (type.base t2)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t3 : base.type =>
                                           defaults.expr (type.base t3)) t2
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t2) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_addc
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x0, x1, x' v))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_addc
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1, x2))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_with_get_carry)%expr @
                                                    x @ x0 @ x1 @ x2)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_with_get_carry)%expr @
                                                  x @ x0 @ x1 @ x2)%expr_pat
                                           end)
                                    | (s3 -> d3)%ptype =>
                                        fun
                                          _ : Compile.value' false s3 ->
                                              Compile.value' true d3 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ x1 @ x2)%expr_pat
                                    end (Compile.reflect x4)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                        (x0, x1, x2))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_with_get_carry)%expr @
                                        x @ x0 @ x1 @ x2)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                    (x0, x1, x2))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry)%expr @ x @
                                    x0 @ x1 @ x2)%expr_pat
                            end
                        | @expr.LetIn _ _ _ _ _ _ _ =>
                            match x3 with
                            | #(idc1)%expr_pat =>
                                match
                                  match idc1 with
                                  | @ident.Literal t2 v =>
                                      match
                                        t2 as t3
                                        return
                                          (base.base_interp t3 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s0 as t2
                                      return
                                        (Compile.value' false t2 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t2 =>
                                        fun v : defaults.expr (type.base t2)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t3 : base.type =>
                                           defaults.expr (type.base t3)) t2
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t2) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_addc
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x0, x1, x' v))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_addc
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1, x2))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_with_get_carry)%expr @
                                                    x @ x0 @ x1 @ x2)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_with_get_carry)%expr @
                                                  x @ x0 @ x1 @ x2)%expr_pat
                                           end)
                                    | (s1 -> d1)%ptype =>
                                        fun
                                          _ : Compile.value' false s1 ->
                                              Compile.value' true d1 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ x1 @ x2)%expr_pat
                                    end (Compile.reflect x4)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                        (x0, x1, x2))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_with_get_carry)%expr @
                                        x @ x0 @ x1 @ x2)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                    (x0, x1, x2))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry)%expr @ x @
                                    x0 @ x1 @ x2)%expr_pat
                            end
                        | _ =>
                            match x3 with
                            | #(idc1)%expr_pat =>
                                match
                                  match idc1 with
                                  | @ident.Literal t2 v =>
                                      match
                                        t2 as t3
                                        return
                                          (base.base_interp t3 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s0 as t2
                                      return
                                        (Compile.value' false t2 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t2 =>
                                        fun v : defaults.expr (type.base t2)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t3 : base.type =>
                                           defaults.expr (type.base t3)) t2
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t2) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_addc
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x0, x1, x' v))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_addc
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1, x2))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_with_get_carry)%expr @
                                                    x @ x0 @ x1 @ x2)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_with_get_carry)%expr @
                                                  x @ x0 @ x1 @ x2)%expr_pat
                                           end)
                                    | (s2 -> d2)%ptype =>
                                        fun
                                          _ : Compile.value' false s2 ->
                                              Compile.value' true d2 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ x1 @ x2)%expr_pat
                                    end (Compile.reflect x4)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                        (x0, x1, x2))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_with_get_carry)%expr @
                                        x @ x0 @ x1 @ x2)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                    (x0, x1, x2))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry)%expr @ x @
                                    x0 @ x1 @ x2)%expr_pat
                            end
                        end
                    | None =>
                        match x1 with
                        | (@expr.App _ _ _ s2 _ #(idc1) x6 @ x5)%expr_pat =>
                            match
                              match idc1 with
                              | ident.Z_shiftl => Some tt
                              | _ => None
                              end
                            with
                            | Some _ =>
                                match x5 with
                                | #(idc2)%expr_pat =>
                                    match
                                      match idc2 with
                                      | @ident.Literal t3 v =>
                                          match
                                            t3 as t4
                                            return
                                              (base.base_interp t4 ->
                                               option Z)
                                          with
                                          | base.type.unit =>
                                              fun _ : unit => None
                                          | base.type.Z =>
                                              fun v0 : Z => Some v0
                                          | base.type.bool =>
                                              fun _ : bool => None
                                          | base.type.nat =>
                                              fun _ : nat => None
                                          end v
                                      | _ => None
                                      end
                                    with
                                    | Some args1 =>
                                        match
                                          s2 as t3
                                          return
                                            (Compile.value' false t3 ->
                                             UnderLets.UnderLets base.type
                                               ident var
                                               (defaults.expr
                                                  (type.base
                                                     (base.type.Z *
                                                      base.type.Z)%etype)))
                                        with
                                        | type.base t3 =>
                                            fun
                                              v : defaults.expr
                                                    (type.base t3) =>
                                            base.try_make_transport_cps
                                              (fun t4 : base.type =>
                                               defaults.expr (type.base t4))
                                              t3 base.type.Z
                                              (UnderLets.UnderLets base.type
                                                 ident var
                                                 (defaults.expr
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)))
                                              (fun
                                                 a : option
                                                       (defaults.expr
                                                          (type.base t3) ->
                                                        defaults.expr
                                                          (type.base
                                                             base.type.Z)) =>
                                               match a with
                                               | Some x' =>
                                                   if args =? 2 ^ Z.log2 args
                                                   then
                                                    UnderLets.Base
                                                      (#(ident.fancy_addc
                                                           (Z.log2 args)
                                                           args1)%expr @
                                                       (x0, x2, x' v))%expr_pat
                                                   else
                                                    if
                                                     args =? 2 ^ Z.log2 args
                                                    then
                                                     UnderLets.Base
                                                       (#(ident.fancy_addc
                                                            (Z.log2 args) 0)%expr @
                                                        (x0, x1, x2))%expr_pat
                                                    else
                                                     UnderLets.Base
                                                       (#(ident.Z_add_with_get_carry)%expr @
                                                        x @ x0 @ x1 @ x2)%expr_pat
                                               | None =>
                                                   UnderLets.Base
                                                     (#(ident.Z_add_with_get_carry)%expr @
                                                      x @ x0 @ x1 @ x2)%expr_pat
                                               end)
                                        | (s3 -> d3)%ptype =>
                                            fun
                                              _ : Compile.value' false s3 ->
                                                  Compile.value' true d3 =>
                                            UnderLets.Base
                                              (#(ident.Z_add_with_get_carry)%expr @
                                               x @ x0 @ x1 @ x2)%expr_pat
                                        end (Compile.reflect x6)
                                    | None =>
                                        if args =? 2 ^ Z.log2 args
                                        then
                                         UnderLets.Base
                                           (#(ident.fancy_addc (Z.log2 args)
                                                0)%expr @ (x0, x1, x2))%expr_pat
                                        else
                                         UnderLets.Base
                                           (#(ident.Z_add_with_get_carry)%expr @
                                            x @ x0 @ x1 @ x2)%expr_pat
                                    end
                                | _ =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                        (x0, x1, x2))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_with_get_carry)%expr @
                                        x @ x0 @ x1 @ x2)%expr_pat
                                end
                            | None =>
                                match
                                  match idc1 with
                                  | ident.Z_shiftr => Some tt
                                  | _ => None
                                  end
                                with
                                | Some _ =>
                                    match x5 with
                                    | #(idc2)%expr_pat =>
                                        match
                                          match idc2 with
                                          | @ident.Literal t3 v =>
                                              match
                                                t3 as t4
                                                return
                                                  (base.base_interp t4 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v0 : Z => Some v0
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v
                                          | _ => None
                                          end
                                        with
                                        | Some args1 =>
                                            match
                                              s2 as t3
                                              return
                                                (Compile.value' false t3 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base
                                                         (base.type.Z *
                                                          base.type.Z)%etype)))
                                            with
                                            | type.base t3 =>
                                                fun
                                                  v : defaults.expr
                                                        (type.base t3) =>
                                                base.try_make_transport_cps
                                                  (fun t4 : base.type =>
                                                   defaults.expr
                                                     (type.base t4)) t3
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           (base.type.Z *
                                                            base.type.Z)%etype)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t3) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       if
                                                        args =?
                                                        2 ^ Z.log2 args
                                                       then
                                                        UnderLets.Base
                                                          (#(ident.fancy_addc
                                                               (Z.log2 args)
                                                               (- args1))%expr @
                                                           (x0, x2, x' v))%expr_pat
                                                       else
                                                        if
                                                         args =?
                                                         2 ^ Z.log2 args
                                                        then
                                                         UnderLets.Base
                                                           (#(ident.fancy_addc
                                                                (Z.log2 args)
                                                                0)%expr @
                                                            (x0, x1, x2))%expr_pat
                                                        else
                                                         UnderLets.Base
                                                           (#(ident.Z_add_with_get_carry)%expr @
                                                            x @ x0 @ x1 @ x2)%expr_pat
                                                   | None =>
                                                       UnderLets.Base
                                                         (#(ident.Z_add_with_get_carry)%expr @
                                                          x @ x0 @ x1 @ x2)%expr_pat
                                                   end)
                                            | (s3 -> d3)%ptype =>
                                                fun
                                                  _ : Compile.value' false s3 ->
                                                      Compile.value' true d3
                                                =>
                                                UnderLets.Base
                                                  (#(ident.Z_add_with_get_carry)%expr @
                                                   x @ x0 @ x1 @ x2)%expr_pat
                                            end (Compile.reflect x6)
                                        | None =>
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_addc
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1, x2))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_with_get_carry)%expr @
                                                x @ x0 @ x1 @ x2)%expr_pat
                                        end
                                    | _ =>
                                        if args =? 2 ^ Z.log2 args
                                        then
                                         UnderLets.Base
                                           (#(ident.fancy_addc (Z.log2 args)
                                                0)%expr @ (x0, x1, x2))%expr_pat
                                        else
                                         UnderLets.Base
                                           (#(ident.Z_add_with_get_carry)%expr @
                                            x @ x0 @ x1 @ x2)%expr_pat
                                    end
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                        (x0, x1, x2))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_with_get_carry)%expr @
                                        x @ x0 @ x1 @ x2)%expr_pat
                                end
                            end
                        | (@expr.App _ _ _ s2 _ ($_)%expr _ @ _)%expr_pat |
                          (@expr.App _ _ _ s2 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                          (@expr.App _ _ _ s2 _ (_ @ _) _ @ _)%expr_pat |
                          (@expr.App _ _ _ s2 _ (@expr.LetIn _ _ _ _ _ _ _)
                           _ @ _)%expr_pat =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                (x0, x1, x2))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                        | _ =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                (x0, x1, x2))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                        end
                    end
                end
            | (@expr.App _ _ _ s0 _ ($_)%expr _ @ _)%expr_pat =>
                match x1 with
                | (@expr.App _ _ _ s2 _ #(idc0) x6 @ x5)%expr_pat =>
                    match
                      match idc0 with
                      | ident.Z_shiftl => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match x5 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t3 v0 =>
                                  match
                                    t3 as t4
                                    return (base.base_interp t4 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v1 : Z => Some v1
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v0
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                match
                                  s2 as t3
                                  return
                                    (Compile.value' false t3 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)))
                                with
                                | type.base t3 =>
                                    fun v0 : defaults.expr (type.base t3) =>
                                    base.try_make_transport_cps
                                      (fun t4 : base.type =>
                                       defaults.expr (type.base t4)) t3
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base
                                               (base.type.Z * base.type.Z)%etype)))
                                      (fun
                                         a : option
                                               (defaults.expr (type.base t3) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                       match a with
                                       | Some x' =>
                                           if args =? 2 ^ Z.log2 args
                                           then
                                            UnderLets.Base
                                              (#(ident.fancy_addc
                                                   (Z.log2 args) args1)%expr @
                                               (x0, x2, x' v0))%expr_pat
                                           else
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_addc
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1, x2))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_with_get_carry)%expr @
                                                x @ x0 @ x1 @ x2)%expr_pat
                                       | None =>
                                           UnderLets.Base
                                             (#(ident.Z_add_with_get_carry)%expr @
                                              x @ x0 @ x1 @ x2)%expr_pat
                                       end)
                                | (s3 -> d3)%ptype =>
                                    fun
                                      _ : Compile.value' false s3 ->
                                          Compile.value' true d3 =>
                                    UnderLets.Base
                                      (#(ident.Z_add_with_get_carry)%expr @ x @
                                       x0 @ x1 @ x2)%expr_pat
                                end (Compile.reflect x6)
                            | None =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                    (x0, x1, x2))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry)%expr @ x @
                                    x0 @ x1 @ x2)%expr_pat
                            end
                        | _ =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                (x0, x1, x2))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                        end
                    | None =>
                        match
                          match idc0 with
                          | ident.Z_shiftr => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match x5 with
                            | #(idc1)%expr_pat =>
                                match
                                  match idc1 with
                                  | @ident.Literal t3 v0 =>
                                      match
                                        t3 as t4
                                        return
                                          (base.base_interp t4 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v1 : Z => Some v1
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v0
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s2 as t3
                                      return
                                        (Compile.value' false t3 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t3 =>
                                        fun v0 : defaults.expr (type.base t3)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t4 : base.type =>
                                           defaults.expr (type.base t4)) t3
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t3) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_addc
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x0, x2, x' v0))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_addc
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1, x2))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_with_get_carry)%expr @
                                                    x @ x0 @ x1 @ x2)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_with_get_carry)%expr @
                                                  x @ x0 @ x1 @ x2)%expr_pat
                                           end)
                                    | (s3 -> d3)%ptype =>
                                        fun
                                          _ : Compile.value' false s3 ->
                                              Compile.value' true d3 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ x1 @ x2)%expr_pat
                                    end (Compile.reflect x6)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                        (x0, x1, x2))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_with_get_carry)%expr @
                                        x @ x0 @ x1 @ x2)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                    (x0, x1, x2))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry)%expr @ x @
                                    x0 @ x1 @ x2)%expr_pat
                            end
                        | None =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                (x0, x1, x2))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                        end
                    end
                | (@expr.App _ _ _ s2 _ ($_)%expr _ @ _)%expr_pat |
                  (@expr.App _ _ _ s2 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s2 _ (_ @ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s2 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                        (x0, x1, x2))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                | _ =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                        (x0, x1, x2))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                end
            | (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat =>
                match x1 with
                | (@expr.App _ _ _ s3 _ #(idc0) x6 @ x5)%expr_pat =>
                    match
                      match idc0 with
                      | ident.Z_shiftl => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match x5 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t2 v =>
                                  match
                                    t2 as t3
                                    return (base.base_interp t3 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v0 : Z => Some v0
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                match
                                  s3 as t2
                                  return
                                    (Compile.value' false t2 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)))
                                with
                                | type.base t2 =>
                                    fun v : defaults.expr (type.base t2) =>
                                    base.try_make_transport_cps
                                      (fun t3 : base.type =>
                                       defaults.expr (type.base t3)) t2
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base
                                               (base.type.Z * base.type.Z)%etype)))
                                      (fun
                                         a : option
                                               (defaults.expr (type.base t2) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                       match a with
                                       | Some x' =>
                                           if args =? 2 ^ Z.log2 args
                                           then
                                            UnderLets.Base
                                              (#(ident.fancy_addc
                                                   (Z.log2 args) args1)%expr @
                                               (x0, x2, x' v))%expr_pat
                                           else
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_addc
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1, x2))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_with_get_carry)%expr @
                                                x @ x0 @ x1 @ x2)%expr_pat
                                       | None =>
                                           UnderLets.Base
                                             (#(ident.Z_add_with_get_carry)%expr @
                                              x @ x0 @ x1 @ x2)%expr_pat
                                       end)
                                | (s4 -> d4)%ptype =>
                                    fun
                                      _ : Compile.value' false s4 ->
                                          Compile.value' true d4 =>
                                    UnderLets.Base
                                      (#(ident.Z_add_with_get_carry)%expr @ x @
                                       x0 @ x1 @ x2)%expr_pat
                                end (Compile.reflect x6)
                            | None =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                    (x0, x1, x2))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry)%expr @ x @
                                    x0 @ x1 @ x2)%expr_pat
                            end
                        | _ =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                (x0, x1, x2))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                        end
                    | None =>
                        match
                          match idc0 with
                          | ident.Z_shiftr => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match x5 with
                            | #(idc1)%expr_pat =>
                                match
                                  match idc1 with
                                  | @ident.Literal t2 v =>
                                      match
                                        t2 as t3
                                        return
                                          (base.base_interp t3 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s3 as t2
                                      return
                                        (Compile.value' false t2 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t2 =>
                                        fun v : defaults.expr (type.base t2)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t3 : base.type =>
                                           defaults.expr (type.base t3)) t2
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t2) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_addc
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x0, x2, x' v))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_addc
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1, x2))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_with_get_carry)%expr @
                                                    x @ x0 @ x1 @ x2)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_with_get_carry)%expr @
                                                  x @ x0 @ x1 @ x2)%expr_pat
                                           end)
                                    | (s4 -> d4)%ptype =>
                                        fun
                                          _ : Compile.value' false s4 ->
                                              Compile.value' true d4 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ x1 @ x2)%expr_pat
                                    end (Compile.reflect x6)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                        (x0, x1, x2))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_with_get_carry)%expr @
                                        x @ x0 @ x1 @ x2)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                    (x0, x1, x2))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry)%expr @ x @
                                    x0 @ x1 @ x2)%expr_pat
                            end
                        | None =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                (x0, x1, x2))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                        end
                    end
                | (@expr.App _ _ _ s3 _ ($_)%expr _ @ _)%expr_pat |
                  (@expr.App _ _ _ s3 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s3 _ (_ @ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s3 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                        (x0, x1, x2))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                | _ =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                        (x0, x1, x2))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                end
            | (@expr.App _ _ _ s0 _ (_ @ _) _ @ _)%expr_pat =>
                match x1 with
                | (@expr.App _ _ _ s3 _ #(idc0) x7 @ x6)%expr_pat =>
                    match
                      match idc0 with
                      | ident.Z_shiftl => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match x6 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t2 v =>
                                  match
                                    t2 as t3
                                    return (base.base_interp t3 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v0 : Z => Some v0
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                match
                                  s3 as t2
                                  return
                                    (Compile.value' false t2 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)))
                                with
                                | type.base t2 =>
                                    fun v : defaults.expr (type.base t2) =>
                                    base.try_make_transport_cps
                                      (fun t3 : base.type =>
                                       defaults.expr (type.base t3)) t2
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base
                                               (base.type.Z * base.type.Z)%etype)))
                                      (fun
                                         a : option
                                               (defaults.expr (type.base t2) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                       match a with
                                       | Some x' =>
                                           if args =? 2 ^ Z.log2 args
                                           then
                                            UnderLets.Base
                                              (#(ident.fancy_addc
                                                   (Z.log2 args) args1)%expr @
                                               (x0, x2, x' v))%expr_pat
                                           else
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_addc
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1, x2))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_with_get_carry)%expr @
                                                x @ x0 @ x1 @ x2)%expr_pat
                                       | None =>
                                           UnderLets.Base
                                             (#(ident.Z_add_with_get_carry)%expr @
                                              x @ x0 @ x1 @ x2)%expr_pat
                                       end)
                                | (s4 -> d4)%ptype =>
                                    fun
                                      _ : Compile.value' false s4 ->
                                          Compile.value' true d4 =>
                                    UnderLets.Base
                                      (#(ident.Z_add_with_get_carry)%expr @ x @
                                       x0 @ x1 @ x2)%expr_pat
                                end (Compile.reflect x7)
                            | None =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                    (x0, x1, x2))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry)%expr @ x @
                                    x0 @ x1 @ x2)%expr_pat
                            end
                        | _ =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                (x0, x1, x2))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                        end
                    | None =>
                        match
                          match idc0 with
                          | ident.Z_shiftr => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match x6 with
                            | #(idc1)%expr_pat =>
                                match
                                  match idc1 with
                                  | @ident.Literal t2 v =>
                                      match
                                        t2 as t3
                                        return
                                          (base.base_interp t3 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s3 as t2
                                      return
                                        (Compile.value' false t2 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t2 =>
                                        fun v : defaults.expr (type.base t2)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t3 : base.type =>
                                           defaults.expr (type.base t3)) t2
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t2) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_addc
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x0, x2, x' v))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_addc
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1, x2))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_with_get_carry)%expr @
                                                    x @ x0 @ x1 @ x2)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_with_get_carry)%expr @
                                                  x @ x0 @ x1 @ x2)%expr_pat
                                           end)
                                    | (s4 -> d4)%ptype =>
                                        fun
                                          _ : Compile.value' false s4 ->
                                              Compile.value' true d4 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ x1 @ x2)%expr_pat
                                    end (Compile.reflect x7)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                        (x0, x1, x2))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_with_get_carry)%expr @
                                        x @ x0 @ x1 @ x2)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                    (x0, x1, x2))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry)%expr @ x @
                                    x0 @ x1 @ x2)%expr_pat
                            end
                        | None =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                (x0, x1, x2))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                        end
                    end
                | (@expr.App _ _ _ s3 _ ($_)%expr _ @ _)%expr_pat |
                  (@expr.App _ _ _ s3 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s3 _ (_ @ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s3 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                        (x0, x1, x2))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                | _ =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                        (x0, x1, x2))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                end
            | (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                match x1 with
                | (@expr.App _ _ _ s2 _ #(idc0) x7 @ x6)%expr_pat =>
                    match
                      match idc0 with
                      | ident.Z_shiftl => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match x6 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t2 v =>
                                  match
                                    t2 as t3
                                    return (base.base_interp t3 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v0 : Z => Some v0
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                match
                                  s2 as t2
                                  return
                                    (Compile.value' false t2 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)))
                                with
                                | type.base t2 =>
                                    fun v : defaults.expr (type.base t2) =>
                                    base.try_make_transport_cps
                                      (fun t3 : base.type =>
                                       defaults.expr (type.base t3)) t2
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base
                                               (base.type.Z * base.type.Z)%etype)))
                                      (fun
                                         a : option
                                               (defaults.expr (type.base t2) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                       match a with
                                       | Some x' =>
                                           if args =? 2 ^ Z.log2 args
                                           then
                                            UnderLets.Base
                                              (#(ident.fancy_addc
                                                   (Z.log2 args) args1)%expr @
                                               (x0, x2, x' v))%expr_pat
                                           else
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_addc
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1, x2))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_with_get_carry)%expr @
                                                x @ x0 @ x1 @ x2)%expr_pat
                                       | None =>
                                           UnderLets.Base
                                             (#(ident.Z_add_with_get_carry)%expr @
                                              x @ x0 @ x1 @ x2)%expr_pat
                                       end)
                                | (s3 -> d3)%ptype =>
                                    fun
                                      _ : Compile.value' false s3 ->
                                          Compile.value' true d3 =>
                                    UnderLets.Base
                                      (#(ident.Z_add_with_get_carry)%expr @ x @
                                       x0 @ x1 @ x2)%expr_pat
                                end (Compile.reflect x7)
                            | None =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                    (x0, x1, x2))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry)%expr @ x @
                                    x0 @ x1 @ x2)%expr_pat
                            end
                        | _ =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                (x0, x1, x2))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                        end
                    | None =>
                        match
                          match idc0 with
                          | ident.Z_shiftr => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match x6 with
                            | #(idc1)%expr_pat =>
                                match
                                  match idc1 with
                                  | @ident.Literal t2 v =>
                                      match
                                        t2 as t3
                                        return
                                          (base.base_interp t3 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s2 as t2
                                      return
                                        (Compile.value' false t2 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t2 =>
                                        fun v : defaults.expr (type.base t2)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t3 : base.type =>
                                           defaults.expr (type.base t3)) t2
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t2) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_addc
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x0, x2, x' v))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_addc
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1, x2))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_with_get_carry)%expr @
                                                    x @ x0 @ x1 @ x2)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_with_get_carry)%expr @
                                                  x @ x0 @ x1 @ x2)%expr_pat
                                           end)
                                    | (s3 -> d3)%ptype =>
                                        fun
                                          _ : Compile.value' false s3 ->
                                              Compile.value' true d3 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ x1 @ x2)%expr_pat
                                    end (Compile.reflect x7)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                        (x0, x1, x2))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_with_get_carry)%expr @
                                        x @ x0 @ x1 @ x2)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                    (x0, x1, x2))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry)%expr @ x @
                                    x0 @ x1 @ x2)%expr_pat
                            end
                        | None =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                (x0, x1, x2))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                        end
                    end
                | (@expr.App _ _ _ s2 _ ($_)%expr _ @ _)%expr_pat |
                  (@expr.App _ _ _ s2 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s2 _ (_ @ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s2 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                        (x0, x1, x2))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                | _ =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                        (x0, x1, x2))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                end
            | (@expr.LetIn _ _ _ _ _ _ _ @ _)%expr_pat =>
                match x1 with
                | (@expr.App _ _ _ s1 _ #(idc0) x6 @ x5)%expr_pat =>
                    match
                      match idc0 with
                      | ident.Z_shiftl => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match x5 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t2 v =>
                                  match
                                    t2 as t3
                                    return (base.base_interp t3 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v0 : Z => Some v0
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                match
                                  s1 as t2
                                  return
                                    (Compile.value' false t2 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)))
                                with
                                | type.base t2 =>
                                    fun v : defaults.expr (type.base t2) =>
                                    base.try_make_transport_cps
                                      (fun t3 : base.type =>
                                       defaults.expr (type.base t3)) t2
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base
                                               (base.type.Z * base.type.Z)%etype)))
                                      (fun
                                         a : option
                                               (defaults.expr (type.base t2) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                       match a with
                                       | Some x' =>
                                           if args =? 2 ^ Z.log2 args
                                           then
                                            UnderLets.Base
                                              (#(ident.fancy_addc
                                                   (Z.log2 args) args1)%expr @
                                               (x0, x2, x' v))%expr_pat
                                           else
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_addc
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1, x2))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_with_get_carry)%expr @
                                                x @ x0 @ x1 @ x2)%expr_pat
                                       | None =>
                                           UnderLets.Base
                                             (#(ident.Z_add_with_get_carry)%expr @
                                              x @ x0 @ x1 @ x2)%expr_pat
                                       end)
                                | (s2 -> d2)%ptype =>
                                    fun
                                      _ : Compile.value' false s2 ->
                                          Compile.value' true d2 =>
                                    UnderLets.Base
                                      (#(ident.Z_add_with_get_carry)%expr @ x @
                                       x0 @ x1 @ x2)%expr_pat
                                end (Compile.reflect x6)
                            | None =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                    (x0, x1, x2))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry)%expr @ x @
                                    x0 @ x1 @ x2)%expr_pat
                            end
                        | _ =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                (x0, x1, x2))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                        end
                    | None =>
                        match
                          match idc0 with
                          | ident.Z_shiftr => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match x5 with
                            | #(idc1)%expr_pat =>
                                match
                                  match idc1 with
                                  | @ident.Literal t2 v =>
                                      match
                                        t2 as t3
                                        return
                                          (base.base_interp t3 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s1 as t2
                                      return
                                        (Compile.value' false t2 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t2 =>
                                        fun v : defaults.expr (type.base t2)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t3 : base.type =>
                                           defaults.expr (type.base t3)) t2
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t2) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_addc
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x0, x2, x' v))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_addc
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1, x2))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_with_get_carry)%expr @
                                                    x @ x0 @ x1 @ x2)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_with_get_carry)%expr @
                                                  x @ x0 @ x1 @ x2)%expr_pat
                                           end)
                                    | (s2 -> d2)%ptype =>
                                        fun
                                          _ : Compile.value' false s2 ->
                                              Compile.value' true d2 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ x1 @ x2)%expr_pat
                                    end (Compile.reflect x6)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                        (x0, x1, x2))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_with_get_carry)%expr @
                                        x @ x0 @ x1 @ x2)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                    (x0, x1, x2))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry)%expr @ x @
                                    x0 @ x1 @ x2)%expr_pat
                            end
                        | None =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                (x0, x1, x2))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                        end
                    end
                | (@expr.App _ _ _ s1 _ ($_)%expr _ @ _)%expr_pat |
                  (@expr.App _ _ _ s1 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s1 _ (_ @ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s1 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                        (x0, x1, x2))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                | _ =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                        (x0, x1, x2))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                end
            | @expr.LetIn _ _ _ _ _ _ _ =>
                match x1 with
                | (@expr.App _ _ _ s0 _ #(idc0) x5 @ x4)%expr_pat =>
                    match
                      match idc0 with
                      | ident.Z_shiftl => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match x4 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t2 v =>
                                  match
                                    t2 as t3
                                    return (base.base_interp t3 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v0 : Z => Some v0
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                match
                                  s0 as t2
                                  return
                                    (Compile.value' false t2 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)))
                                with
                                | type.base t2 =>
                                    fun v : defaults.expr (type.base t2) =>
                                    base.try_make_transport_cps
                                      (fun t3 : base.type =>
                                       defaults.expr (type.base t3)) t2
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base
                                               (base.type.Z * base.type.Z)%etype)))
                                      (fun
                                         a : option
                                               (defaults.expr (type.base t2) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                       match a with
                                       | Some x' =>
                                           if args =? 2 ^ Z.log2 args
                                           then
                                            UnderLets.Base
                                              (#(ident.fancy_addc
                                                   (Z.log2 args) args1)%expr @
                                               (x0, x2, x' v))%expr_pat
                                           else
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_addc
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1, x2))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_with_get_carry)%expr @
                                                x @ x0 @ x1 @ x2)%expr_pat
                                       | None =>
                                           UnderLets.Base
                                             (#(ident.Z_add_with_get_carry)%expr @
                                              x @ x0 @ x1 @ x2)%expr_pat
                                       end)
                                | (s1 -> d1)%ptype =>
                                    fun
                                      _ : Compile.value' false s1 ->
                                          Compile.value' true d1 =>
                                    UnderLets.Base
                                      (#(ident.Z_add_with_get_carry)%expr @ x @
                                       x0 @ x1 @ x2)%expr_pat
                                end (Compile.reflect x5)
                            | None =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                    (x0, x1, x2))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry)%expr @ x @
                                    x0 @ x1 @ x2)%expr_pat
                            end
                        | _ =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                (x0, x1, x2))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                        end
                    | None =>
                        match
                          match idc0 with
                          | ident.Z_shiftr => Some tt
                          | _ => None
                          end
                        with
                        | Some _ =>
                            match x4 with
                            | #(idc1)%expr_pat =>
                                match
                                  match idc1 with
                                  | @ident.Literal t2 v =>
                                      match
                                        t2 as t3
                                        return
                                          (base.base_interp t3 -> option Z)
                                      with
                                      | base.type.unit =>
                                          fun _ : unit => None
                                      | base.type.Z => fun v0 : Z => Some v0
                                      | base.type.bool =>
                                          fun _ : bool => None
                                      | base.type.nat => fun _ : nat => None
                                      end v
                                  | _ => None
                                  end
                                with
                                | Some args1 =>
                                    match
                                      s0 as t2
                                      return
                                        (Compile.value' false t2 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t2 =>
                                        fun v : defaults.expr (type.base t2)
                                        =>
                                        base.try_make_transport_cps
                                          (fun t3 : base.type =>
                                           defaults.expr (type.base t3)) t2
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a : option
                                                   (defaults.expr
                                                      (type.base t2) ->
                                                    defaults.expr
                                                      (type.base base.type.Z))
                                           =>
                                           match a with
                                           | Some x' =>
                                               if args =? 2 ^ Z.log2 args
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_addc
                                                       (Z.log2 args)
                                                       (- args1))%expr @
                                                   (x0, x2, x' v))%expr_pat
                                               else
                                                if args =? 2 ^ Z.log2 args
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_addc
                                                        (Z.log2 args) 0)%expr @
                                                    (x0, x1, x2))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_with_get_carry)%expr @
                                                    x @ x0 @ x1 @ x2)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_with_get_carry)%expr @
                                                  x @ x0 @ x1 @ x2)%expr_pat
                                           end)
                                    | (s1 -> d1)%ptype =>
                                        fun
                                          _ : Compile.value' false s1 ->
                                              Compile.value' true d1 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry)%expr @
                                           x @ x0 @ x1 @ x2)%expr_pat
                                    end (Compile.reflect x5)
                                | None =>
                                    if args =? 2 ^ Z.log2 args
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                        (x0, x1, x2))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_with_get_carry)%expr @
                                        x @ x0 @ x1 @ x2)%expr_pat
                                end
                            | _ =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                    (x0, x1, x2))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry)%expr @ x @
                                    x0 @ x1 @ x2)%expr_pat
                            end
                        | None =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                                (x0, x1, x2))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                        end
                    end
                | (@expr.App _ _ _ s0 _ ($_)%expr _ @ _)%expr_pat |
                  (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s0 _ (_ @ _) _ @ _)%expr_pat |
                  (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                        (x0, x1, x2))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                | _ =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_addc (Z.log2 args) 0)%expr @
                        (x0, x1, x2))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                end
            end
        | None =>
            UnderLets.Base
              (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
        end
    | _ =>
        UnderLets.Base
          (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
    end
| ident.Z_sub_get_borrow =>
    fun x x0 x1 : defaults.expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            match x1 with
            | (@expr.App _ _ _ s0 _ #(idc0) x3 @ x2)%expr_pat =>
                match
                  match idc0 with
                  | ident.Z_shiftl => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match x2 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args1 =>
                            match
                              s0 as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (defaults.expr
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)))
                            with
                            | type.base t2 =>
                                fun v : defaults.expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t3 : base.type =>
                                   defaults.expr (type.base t3)) t2
                                  base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (defaults.expr
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)))
                                  (fun
                                     a : option
                                           (defaults.expr (type.base t2) ->
                                            defaults.expr
                                              (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       if args =? 2 ^ Z.log2 args
                                       then
                                        UnderLets.Base
                                          (#(ident.fancy_sub (Z.log2 args)
                                               args1)%expr @ (x0, x' v))%expr_pat
                                       else
                                        if args =? 2 ^ Z.log2 args
                                        then
                                         UnderLets.Base
                                           (#(ident.fancy_sub (Z.log2 args) 0)%expr @
                                            (x0, x1))%expr_pat
                                        else
                                         UnderLets.Base
                                           (#(ident.Z_sub_get_borrow)%expr @
                                            x @ x0 @ x1)%expr_pat
                                   | None =>
                                       UnderLets.Base
                                         (#(ident.Z_sub_get_borrow)%expr @ x @
                                          x0 @ x1)%expr_pat
                                   end)
                            | (s1 -> d1)%ptype =>
                                fun
                                  _ : Compile.value' false s1 ->
                                      Compile.value' true d1 =>
                                UnderLets.Base
                                  (#(ident.Z_sub_get_borrow)%expr @ x @ x0 @
                                   x1)%expr_pat
                            end (Compile.reflect x3)
                        | None =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_sub (Z.log2 args) 0)%expr @
                                (x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_sub_get_borrow)%expr @ x @ x0 @ x1)%expr_pat
                        end
                    | _ =>
                        if args =? 2 ^ Z.log2 args
                        then
                         UnderLets.Base
                           (#(ident.fancy_sub (Z.log2 args) 0)%expr @
                            (x0, x1))%expr_pat
                        else
                         UnderLets.Base
                           (#(ident.Z_sub_get_borrow)%expr @ x @ x0 @ x1)%expr_pat
                    end
                | None =>
                    match
                      match idc0 with
                      | ident.Z_shiftr => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match x2 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t2 v =>
                                  match
                                    t2 as t3
                                    return (base.base_interp t3 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v0 : Z => Some v0
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                match
                                  s0 as t2
                                  return
                                    (Compile.value' false t2 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)))
                                with
                                | type.base t2 =>
                                    fun v : defaults.expr (type.base t2) =>
                                    base.try_make_transport_cps
                                      (fun t3 : base.type =>
                                       defaults.expr (type.base t3)) t2
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base
                                               (base.type.Z * base.type.Z)%etype)))
                                      (fun
                                         a : option
                                               (defaults.expr (type.base t2) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                       match a with
                                       | Some x' =>
                                           if args =? 2 ^ Z.log2 args
                                           then
                                            UnderLets.Base
                                              (#(ident.fancy_sub
                                                   (Z.log2 args) (- args1))%expr @
                                               (x0, x' v))%expr_pat
                                           else
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_sub
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_sub_get_borrow)%expr @
                                                x @ x0 @ x1)%expr_pat
                                       | None =>
                                           UnderLets.Base
                                             (#(ident.Z_sub_get_borrow)%expr @
                                              x @ x0 @ x1)%expr_pat
                                       end)
                                | (s1 -> d1)%ptype =>
                                    fun
                                      _ : Compile.value' false s1 ->
                                          Compile.value' true d1 =>
                                    UnderLets.Base
                                      (#(ident.Z_sub_get_borrow)%expr @ x @
                                       x0 @ x1)%expr_pat
                                end (Compile.reflect x3)
                            | None =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_sub (Z.log2 args) 0)%expr @
                                    (x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_sub_get_borrow)%expr @ x @ x0 @
                                    x1)%expr_pat
                            end
                        | _ =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_sub (Z.log2 args) 0)%expr @
                                (x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_sub_get_borrow)%expr @ x @ x0 @ x1)%expr_pat
                        end
                    | None =>
                        if args =? 2 ^ Z.log2 args
                        then
                         UnderLets.Base
                           (#(ident.fancy_sub (Z.log2 args) 0)%expr @
                            (x0, x1))%expr_pat
                        else
                         UnderLets.Base
                           (#(ident.Z_sub_get_borrow)%expr @ x @ x0 @ x1)%expr_pat
                    end
                end
            | (@expr.App _ _ _ s0 _ ($_)%expr _ @ _)%expr_pat |
              (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
              (@expr.App _ _ _ s0 _ (_ @ _) _ @ _)%expr_pat |
              (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                if args =? 2 ^ Z.log2 args
                then
                 UnderLets.Base
                   (#(ident.fancy_sub (Z.log2 args) 0)%expr @ (x0, x1))%expr_pat
                else
                 UnderLets.Base
                   (#(ident.Z_sub_get_borrow)%expr @ x @ x0 @ x1)%expr_pat
            | _ =>
                if args =? 2 ^ Z.log2 args
                then
                 UnderLets.Base
                   (#(ident.fancy_sub (Z.log2 args) 0)%expr @ (x0, x1))%expr_pat
                else
                 UnderLets.Base
                   (#(ident.Z_sub_get_borrow)%expr @ x @ x0 @ x1)%expr_pat
            end
        | None =>
            UnderLets.Base
              (#(ident.Z_sub_get_borrow)%expr @ x @ x0 @ x1)%expr_pat
        end
    | _ =>
        UnderLets.Base
          (#(ident.Z_sub_get_borrow)%expr @ x @ x0 @ x1)%expr_pat
    end
| ident.Z_sub_with_get_borrow =>
    fun x x0 x1 x2 : defaults.expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            match x2 with
            | (@expr.App _ _ _ s0 _ #(idc0) x4 @ x3)%expr_pat =>
                match
                  match idc0 with
                  | ident.Z_shiftl => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match x3 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args1 =>
                            match
                              s0 as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (defaults.expr
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)))
                            with
                            | type.base t2 =>
                                fun v : defaults.expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t3 : base.type =>
                                   defaults.expr (type.base t3)) t2
                                  base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (defaults.expr
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)))
                                  (fun
                                     a : option
                                           (defaults.expr (type.base t2) ->
                                            defaults.expr
                                              (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       if args =? 2 ^ Z.log2 args
                                       then
                                        UnderLets.Base
                                          (#(ident.fancy_subb (Z.log2 args)
                                               args1)%expr @ (x0, x1, x' v))%expr_pat
                                       else
                                        if args =? 2 ^ Z.log2 args
                                        then
                                         UnderLets.Base
                                           (#(ident.fancy_subb (Z.log2 args)
                                                0)%expr @ (x0, x1, x2))%expr_pat
                                        else
                                         UnderLets.Base
                                           (#(ident.Z_sub_with_get_borrow)%expr @
                                            x @ x0 @ x1 @ x2)%expr_pat
                                   | None =>
                                       UnderLets.Base
                                         (#(ident.Z_sub_with_get_borrow)%expr @
                                          x @ x0 @ x1 @ x2)%expr_pat
                                   end)
                            | (s1 -> d1)%ptype =>
                                fun
                                  _ : Compile.value' false s1 ->
                                      Compile.value' true d1 =>
                                UnderLets.Base
                                  (#(ident.Z_sub_with_get_borrow)%expr @ x @
                                   x0 @ x1 @ x2)%expr_pat
                            end (Compile.reflect x4)
                        | None =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_subb (Z.log2 args) 0)%expr @
                                (x0, x1, x2))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_sub_with_get_borrow)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                        end
                    | _ =>
                        if args =? 2 ^ Z.log2 args
                        then
                         UnderLets.Base
                           (#(ident.fancy_subb (Z.log2 args) 0)%expr @
                            (x0, x1, x2))%expr_pat
                        else
                         UnderLets.Base
                           (#(ident.Z_sub_with_get_borrow)%expr @ x @ x0 @ x1 @
                            x2)%expr_pat
                    end
                | None =>
                    match
                      match idc0 with
                      | ident.Z_shiftr => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match x3 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t2 v =>
                                  match
                                    t2 as t3
                                    return (base.base_interp t3 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v0 : Z => Some v0
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                match
                                  s0 as t2
                                  return
                                    (Compile.value' false t2 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)))
                                with
                                | type.base t2 =>
                                    fun v : defaults.expr (type.base t2) =>
                                    base.try_make_transport_cps
                                      (fun t3 : base.type =>
                                       defaults.expr (type.base t3)) t2
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base
                                               (base.type.Z * base.type.Z)%etype)))
                                      (fun
                                         a : option
                                               (defaults.expr (type.base t2) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                       match a with
                                       | Some x' =>
                                           if args =? 2 ^ Z.log2 args
                                           then
                                            UnderLets.Base
                                              (#(ident.fancy_subb
                                                   (Z.log2 args) (- args1))%expr @
                                               (x0, x1, x' v))%expr_pat
                                           else
                                            if args =? 2 ^ Z.log2 args
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_subb
                                                    (Z.log2 args) 0)%expr @
                                                (x0, x1, x2))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_sub_with_get_borrow)%expr @
                                                x @ x0 @ x1 @ x2)%expr_pat
                                       | None =>
                                           UnderLets.Base
                                             (#(ident.Z_sub_with_get_borrow)%expr @
                                              x @ x0 @ x1 @ x2)%expr_pat
                                       end)
                                | (s1 -> d1)%ptype =>
                                    fun
                                      _ : Compile.value' false s1 ->
                                          Compile.value' true d1 =>
                                    UnderLets.Base
                                      (#(ident.Z_sub_with_get_borrow)%expr @
                                       x @ x0 @ x1 @ x2)%expr_pat
                                end (Compile.reflect x4)
                            | None =>
                                if args =? 2 ^ Z.log2 args
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_subb (Z.log2 args) 0)%expr @
                                    (x0, x1, x2))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_sub_with_get_borrow)%expr @ x @
                                    x0 @ x1 @ x2)%expr_pat
                            end
                        | _ =>
                            if args =? 2 ^ Z.log2 args
                            then
                             UnderLets.Base
                               (#(ident.fancy_subb (Z.log2 args) 0)%expr @
                                (x0, x1, x2))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_sub_with_get_borrow)%expr @ x @ x0 @
                                x1 @ x2)%expr_pat
                        end
                    | None =>
                        if args =? 2 ^ Z.log2 args
                        then
                         UnderLets.Base
                           (#(ident.fancy_subb (Z.log2 args) 0)%expr @
                            (x0, x1, x2))%expr_pat
                        else
                         UnderLets.Base
                           (#(ident.Z_sub_with_get_borrow)%expr @ x @ x0 @ x1 @
                            x2)%expr_pat
                    end
                end
            | (@expr.App _ _ _ s0 _ ($_)%expr _ @ _)%expr_pat |
              (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
              (@expr.App _ _ _ s0 _ (_ @ _) _ @ _)%expr_pat |
              (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                if args =? 2 ^ Z.log2 args
                then
                 UnderLets.Base
                   (#(ident.fancy_subb (Z.log2 args) 0)%expr @ (x0, x1, x2))%expr_pat
                else
                 UnderLets.Base
                   (#(ident.Z_sub_with_get_borrow)%expr @ x @ x0 @ x1 @ x2)%expr_pat
            | _ =>
                if args =? 2 ^ Z.log2 args
                then
                 UnderLets.Base
                   (#(ident.fancy_subb (Z.log2 args) 0)%expr @ (x0, x1, x2))%expr_pat
                else
                 UnderLets.Base
                   (#(ident.Z_sub_with_get_borrow)%expr @ x @ x0 @ x1 @ x2)%expr_pat
            end
        | None =>
            UnderLets.Base
              (#(ident.Z_sub_with_get_borrow)%expr @ x @ x0 @ x1 @ x2)%expr_pat
        end
    | _ =>
        UnderLets.Base
          (#(ident.Z_sub_with_get_borrow)%expr @ x @ x0 @ x1 @ x2)%expr_pat
    end
| ident.Z_zselect =>
    fun x x0 x1 : defaults.expr (type.base base.type.Z) =>
    match x with
    | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ #(idc)%expr_pat x3) x2 =>
        match match idc with
              | ident.Z_cc_m => Some tt
              | _ => None
              end with
        | Some _ =>
            match x3 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (defaults.expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : defaults.expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => defaults.expr (type.base t1))
                          t2 base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (defaults.expr (type.base t2) ->
                                    defaults.expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               if args0 =? 2 ^ Z.log2 args0
                               then
                                UnderLets.Base
                                  (#(ident.fancy_selm (Z.log2 args0))%expr @
                                   (x' v, x0, x1))%expr_pat
                               else
                                UnderLets.Base
                                  (#(ident.fancy_selc)%expr @ (x, x0, x1))%expr_pat
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_zselect)%expr @ x @ x0 @ x1)%expr_pat
                           end)
                    | (s1 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d1 =>
                        UnderLets.Base
                          (#(ident.Z_zselect)%expr @ x @ x0 @ x1)%expr_pat
                    end (Compile.reflect x2)
                | None =>
                    UnderLets.Base
                      (#(ident.fancy_selc)%expr @ (x, x0, x1))%expr_pat
                end
            | _ =>
                UnderLets.Base
                  (#(ident.fancy_selc)%expr @ (x, x0, x1))%expr_pat
            end
        | None =>
            match
              match idc with
              | ident.Z_land => Some tt
              | _ => None
              end
            with
            | Some _ =>
                match x3 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t1 v =>
                          match
                            t1 as t2 return (base.base_interp t2 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v0 : Z => Some v0
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (defaults.expr (type.base base.type.Z)))
                        with
                        | type.base t2 =>
                            fun v : defaults.expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type =>
                               defaults.expr (type.base t1)) t2 base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (defaults.expr (type.base base.type.Z)))
                              (fun
                                 a : option
                                       (defaults.expr (type.base t2) ->
                                        defaults.expr (type.base base.type.Z))
                               =>
                               match a with
                               | Some x' =>
                                   if args0 =? 1
                                   then
                                    UnderLets.Base
                                      (#(ident.fancy_sell)%expr @
                                       (x' v, x0, x1))%expr_pat
                                   else
                                    match x2 with
                                    | #(idc1)%expr_pat =>
                                        match
                                          match idc1 with
                                          | @ident.Literal t3 v0 =>
                                              match
                                                t3 as t4
                                                return
                                                  (base.base_interp t4 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v1 : Z => Some v1
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v0
                                          | _ => None
                                          end
                                        with
                                        | Some args1 =>
                                            match
                                              s0 as t3
                                              return
                                                (Compile.value' false t3 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base base.type.Z)))
                                            with
                                            | type.base t3 =>
                                                fun
                                                  v0 : defaults.expr
                                                         (type.base t3) =>
                                                base.try_make_transport_cps
                                                  (fun t4 : base.type =>
                                                   defaults.expr
                                                     (type.base t4)) t3
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           base.type.Z)))
                                                  (fun
                                                     a0 : option
                                                            (defaults.expr
                                                               (type.base t3) ->
                                                             defaults.expr
                                                               (type.base
                                                                  base.type.Z))
                                                   =>
                                                   match a0 with
                                                   | Some x'0 =>
                                                       if args1 =? 1
                                                       then
                                                        UnderLets.Base
                                                          (#(ident.fancy_sell)%expr @
                                                           (x'0 v0, x0, x1))%expr_pat
                                                       else
                                                        UnderLets.Base
                                                          (#(ident.fancy_selc)%expr @
                                                           (x, x0, x1))%expr_pat
                                                   | None =>
                                                       UnderLets.Base
                                                         (#(ident.Z_zselect)%expr @
                                                          x @ x0 @ x1)%expr_pat
                                                   end)
                                            | (s1 -> d1)%ptype =>
                                                fun
                                                  _ : Compile.value' false s1 ->
                                                      Compile.value' true d1
                                                =>
                                                UnderLets.Base
                                                  (#(ident.Z_zselect)%expr @
                                                   x @ x0 @ x1)%expr_pat
                                            end (Compile.reflect x3)
                                        | None =>
                                            UnderLets.Base
                                              (#(ident.fancy_selc)%expr @
                                               (x, x0, x1))%expr_pat
                                        end
                                    | _ =>
                                        UnderLets.Base
                                          (#(ident.fancy_selc)%expr @
                                           (x, x0, x1))%expr_pat
                                    end
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_zselect)%expr @ x @ x0 @ x1)%expr_pat
                               end)
                        | (s1 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base
                              (#(ident.Z_zselect)%expr @ x @ x0 @ x1)%expr_pat
                        end (Compile.reflect x2)
                    | None =>
                        match x2 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t2 v =>
                                  match
                                    t2 as t3
                                    return (base.base_interp t3 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v0 : Z => Some v0
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v
                              | _ => None
                              end
                            with
                            | Some args0 =>
                                match
                                  s0 as t2
                                  return
                                    (Compile.value' false t2 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr (type.base base.type.Z)))
                                with
                                | type.base t2 =>
                                    fun v : defaults.expr (type.base t2) =>
                                    base.try_make_transport_cps
                                      (fun t3 : base.type =>
                                       defaults.expr (type.base t3)) t2
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base base.type.Z)))
                                      (fun
                                         a : option
                                               (defaults.expr (type.base t2) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                       match a with
                                       | Some x' =>
                                           if args0 =? 1
                                           then
                                            UnderLets.Base
                                              (#(ident.fancy_sell)%expr @
                                               (x' v, x0, x1))%expr_pat
                                           else
                                            UnderLets.Base
                                              (#(ident.fancy_selc)%expr @
                                               (x, x0, x1))%expr_pat
                                       | None =>
                                           UnderLets.Base
                                             (#(ident.Z_zselect)%expr @ x @
                                              x0 @ x1)%expr_pat
                                       end)
                                | (s1 -> d1)%ptype =>
                                    fun
                                      _ : Compile.value' false s1 ->
                                          Compile.value' true d1 =>
                                    UnderLets.Base
                                      (#(ident.Z_zselect)%expr @ x @ x0 @ x1)%expr_pat
                                end (Compile.reflect x3)
                            | None =>
                                UnderLets.Base
                                  (#(ident.fancy_selc)%expr @ (x, x0, x1))%expr_pat
                            end
                        | _ =>
                            UnderLets.Base
                              (#(ident.fancy_selc)%expr @ (x, x0, x1))%expr_pat
                        end
                    end
                | ($_)%expr =>
                    match x2 with
                    | #(idc0)%expr_pat =>
                        match
                          match idc0 with
                          | @ident.Literal t2 v0 =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v1 : Z => Some v1
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v0
                          | _ => None
                          end
                        with
                        | Some args0 =>
                            match
                              s0 as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (defaults.expr (type.base base.type.Z)))
                            with
                            | type.base t2 =>
                                fun v0 : defaults.expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t3 : base.type =>
                                   defaults.expr (type.base t3)) t2
                                  base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (defaults.expr (type.base base.type.Z)))
                                  (fun
                                     a : option
                                           (defaults.expr (type.base t2) ->
                                            defaults.expr
                                              (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       if args0 =? 1
                                       then
                                        UnderLets.Base
                                          (#(ident.fancy_sell)%expr @
                                           (x' v0, x0, x1))%expr_pat
                                       else
                                        UnderLets.Base
                                          (#(ident.fancy_selc)%expr @
                                           (x, x0, x1))%expr_pat
                                   | None =>
                                       UnderLets.Base
                                         (#(ident.Z_zselect)%expr @ x @ x0 @
                                          x1)%expr_pat
                                   end)
                            | (s1 -> d1)%ptype =>
                                fun
                                  _ : Compile.value' false s1 ->
                                      Compile.value' true d1 =>
                                UnderLets.Base
                                  (#(ident.Z_zselect)%expr @ x @ x0 @ x1)%expr_pat
                            end (Compile.reflect x3)
                        | None =>
                            UnderLets.Base
                              (#(ident.fancy_selc)%expr @ (x, x0, x1))%expr_pat
                        end
                    | _ =>
                        UnderLets.Base
                          (#(ident.fancy_selc)%expr @ (x, x0, x1))%expr_pat
                    end
                | @expr.LetIn _ _ _ _ _ _ _ =>
                    match x2 with
                    | #(idc0)%expr_pat =>
                        match
                          match idc0 with
                          | @ident.Literal t1 v =>
                              match
                                t1 as t2
                                return (base.base_interp t2 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args0 =>
                            match
                              s0 as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (defaults.expr (type.base base.type.Z)))
                            with
                            | type.base t2 =>
                                fun v : defaults.expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t1 : base.type =>
                                   defaults.expr (type.base t1)) t2
                                  base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (defaults.expr (type.base base.type.Z)))
                                  (fun
                                     a : option
                                           (defaults.expr (type.base t2) ->
                                            defaults.expr
                                              (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       if args0 =? 1
                                       then
                                        UnderLets.Base
                                          (#(ident.fancy_sell)%expr @
                                           (x' v, x0, x1))%expr_pat
                                       else
                                        UnderLets.Base
                                          (#(ident.fancy_selc)%expr @
                                           (x, x0, x1))%expr_pat
                                   | None =>
                                       UnderLets.Base
                                         (#(ident.Z_zselect)%expr @ x @ x0 @
                                          x1)%expr_pat
                                   end)
                            | (s1 -> d1)%ptype =>
                                fun
                                  _ : Compile.value' false s1 ->
                                      Compile.value' true d1 =>
                                UnderLets.Base
                                  (#(ident.Z_zselect)%expr @ x @ x0 @ x1)%expr_pat
                            end (Compile.reflect x3)
                        | None =>
                            UnderLets.Base
                              (#(ident.fancy_selc)%expr @ (x, x0, x1))%expr_pat
                        end
                    | _ =>
                        UnderLets.Base
                          (#(ident.fancy_selc)%expr @ (x, x0, x1))%expr_pat
                    end
                | _ =>
                    match x2 with
                    | #(idc0)%expr_pat =>
                        match
                          match idc0 with
                          | @ident.Literal t1 v =>
                              match
                                t1 as t2
                                return (base.base_interp t2 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args0 =>
                            match
                              s0 as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (defaults.expr (type.base base.type.Z)))
                            with
                            | type.base t2 =>
                                fun v : defaults.expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t1 : base.type =>
                                   defaults.expr (type.base t1)) t2
                                  base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (defaults.expr (type.base base.type.Z)))
                                  (fun
                                     a : option
                                           (defaults.expr (type.base t2) ->
                                            defaults.expr
                                              (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       if args0 =? 1
                                       then
                                        UnderLets.Base
                                          (#(ident.fancy_sell)%expr @
                                           (x' v, x0, x1))%expr_pat
                                       else
                                        UnderLets.Base
                                          (#(ident.fancy_selc)%expr @
                                           (x, x0, x1))%expr_pat
                                   | None =>
                                       UnderLets.Base
                                         (#(ident.Z_zselect)%expr @ x @ x0 @
                                          x1)%expr_pat
                                   end)
                            | (s2 -> d2)%ptype =>
                                fun
                                  _ : Compile.value' false s2 ->
                                      Compile.value' true d2 =>
                                UnderLets.Base
                                  (#(ident.Z_zselect)%expr @ x @ x0 @ x1)%expr_pat
                            end (Compile.reflect x3)
                        | None =>
                            UnderLets.Base
                              (#(ident.fancy_selc)%expr @ (x, x0, x1))%expr_pat
                        end
                    | _ =>
                        UnderLets.Base
                          (#(ident.fancy_selc)%expr @ (x, x0, x1))%expr_pat
                    end
                end
            | None =>
                UnderLets.Base
                  (#(ident.fancy_selc)%expr @ (x, x0, x1))%expr_pat
            end
        end
    | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ ($_)%expr _) _ | @expr.App _
      _ _ s _ (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _) _ | @expr.App
      _ _ _ s _ (@expr.App _ _ _ s0 _ (_ @ _)%expr_pat _) _ | @expr.App _ _ _
      s _ (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _) _ =>
        UnderLets.Base (#(ident.fancy_selc)%expr @ (x, x0, x1))%expr_pat
    | @expr.App _ _ _ s _ #(_)%expr_pat _ | @expr.App _ _ _ s _ ($_)%expr _ |
      @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _
      (@expr.LetIn _ _ _ _ _ _ _) _ =>
        UnderLets.Base (#(ident.fancy_selc)%expr @ (x, x0, x1))%expr_pat
    | _ => UnderLets.Base (#(ident.fancy_selc)%expr @ (x, x0, x1))%expr_pat
    end
| ident.Z_add_modulo =>
    fun x x0 x1 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.fancy_addm)%expr @ (x, x0, x1))%expr_pat
| ident.Z_rshi =>
    fun x x0 x1 x2 : defaults.expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            match x2 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_rshi (Z.log2 args) args0)%expr @
                        (x0, x1))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_rshi)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                | None =>
                    UnderLets.Base
                      (#(ident.Z_rshi)%expr @ x @ x0 @ x1 @ x2)%expr_pat
                end
            | _ =>
                UnderLets.Base
                  (#(ident.Z_rshi)%expr @ x @ x0 @ x1 @ x2)%expr_pat
            end
        | None =>
            UnderLets.Base (#(ident.Z_rshi)%expr @ x @ x0 @ x1 @ x2)%expr_pat
        end
    | _ => UnderLets.Base (#(ident.Z_rshi)%expr @ x @ x0 @ x1 @ x2)%expr_pat
    end
| ident.Z_cc_m =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_cc_m)%expr @ x @ x0)%expr_pat
| ident.Z_cast range =>
    fun x : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_cast range)%expr @ x)%expr_pat
| ident.Z_cast2 range =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.Z_cast2 range)%expr @ x)%expr_pat
| ident.fancy_add log2wordmax imm =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_add log2wordmax imm)%expr @ x)%expr_pat
| ident.fancy_addc log2wordmax imm =>
    fun
      x : defaults.expr
            (type.base (base.type.Z * base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_addc log2wordmax imm)%expr @ x)%expr_pat
| ident.fancy_sub log2wordmax imm =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_sub log2wordmax imm)%expr @ x)%expr_pat
| ident.fancy_subb log2wordmax imm =>
    fun
      x : defaults.expr
            (type.base (base.type.Z * base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_subb log2wordmax imm)%expr @ x)%expr_pat
| ident.fancy_mulll log2wordmax =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_mulll log2wordmax)%expr @ x)%expr_pat
| ident.fancy_mullh log2wordmax =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_mullh log2wordmax)%expr @ x)%expr_pat
| ident.fancy_mulhl log2wordmax =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_mulhl log2wordmax)%expr @ x)%expr_pat
| ident.fancy_mulhh log2wordmax =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_mulhh log2wordmax)%expr @ x)%expr_pat
| ident.fancy_rshi log2wordmax x =>
    fun x0 : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_rshi log2wordmax x)%expr @ x0)%expr_pat
| ident.fancy_selc =>
    fun
      x : defaults.expr
            (type.base (base.type.Z * base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_selc)%expr @ x)%expr_pat
| ident.fancy_selm log2wordmax =>
    fun
      x : defaults.expr
            (type.base (base.type.Z * base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_selm log2wordmax)%expr @ x)%expr_pat
| ident.fancy_sell =>
    fun
      x : defaults.expr
            (type.base (base.type.Z * base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_sell)%expr @ x)%expr_pat
| ident.fancy_addm =>
    fun
      x : defaults.expr
            (type.base (base.type.Z * base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_addm)%expr @ x)%expr_pat
end
     : Compile.value' true t
