fancy_rewrite_head = 
match idc in (ident t) return (value' true t) with
| @ident.Literal t v =>
    match
      t as t0
      return
        (base.base_interp t0 ->
         UnderLets.UnderLets base.type ident var
           (defaults.expr (type.base t0)))
    with
    | base.type.unit => fun v0 : unit => UnderLets.Base (##v0)%expr
    | base.type.Z => fun v0 : Z => UnderLets.Base (##v0)%expr
    | base.type.bool => fun v0 : bool => UnderLets.Base (##v0)%expr
    | base.type.nat => fun v0 : nat => UnderLets.Base (##v0)%expr
    end v
| ident.Nat_succ =>
    fun x : defaults.expr (type.base base.type.nat) =>
    UnderLets.Base (#(ident.Nat_succ)%expr @ x)%expr_pat
| ident.Nat_pred =>
    fun x : defaults.expr (type.base base.type.nat) =>
    UnderLets.Base (#(ident.Nat_pred)%expr @ x)%expr_pat
| ident.Nat_max =>
    fun x x0 : defaults.expr (type.base base.type.nat) =>
    UnderLets.Base (#(ident.Nat_max)%expr @ x @ x0)%expr_pat
| ident.Nat_mul =>
    fun x x0 : defaults.expr (type.base base.type.nat) =>
    UnderLets.Base (#(ident.Nat_mul)%expr @ x @ x0)%expr_pat
| ident.Nat_add =>
    fun x x0 : defaults.expr (type.base base.type.nat) =>
    UnderLets.Base (#(ident.Nat_add)%expr @ x @ x0)%expr_pat
| ident.Nat_sub =>
    fun x x0 : defaults.expr (type.base base.type.nat) =>
    UnderLets.Base (#(ident.Nat_sub)%expr @ x @ x0)%expr_pat
| @ident.nil t => UnderLets.Base []%expr_pat
| @ident.cons t =>
    fun (x : defaults.expr (type.base t))
      (x0 : defaults.expr (type.base (base.type.list t))) =>
    UnderLets.Base (x :: x0)%expr_pat
| @ident.pair A B =>
    fun (x : defaults.expr (type.base A)) (x0 : defaults.expr (type.base B))
    => UnderLets.Base (x, x0)%expr_pat
| @ident.fst A B =>
    fun x : defaults.expr (type.base (A * B)%etype) =>
    UnderLets.Base (#(ident.fst)%expr @ x)%expr_pat
| @ident.snd A B =>
    fun x : defaults.expr (type.base (A * B)%etype) =>
    UnderLets.Base (#(ident.snd)%expr @ x)%expr_pat
| @ident.prod_rect A B T =>
    fun
      (x : defaults.expr (type.base A) ->
           defaults.expr (type.base B) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base T)))
      (x0 : defaults.expr (type.base (A * B)%etype)) =>
    UnderLets.Base
      (#(ident.prod_rect)%expr @
       (λ (x1 : var (type.base A))(x2 : var (type.base B)),
        UnderLets.to_expr (x ($x1) ($x2)))%expr @ x0)%expr_pat
| @ident.bool_rect T =>
    fun
      (x
       x0 : defaults.expr (type.base base.type.unit) ->
            UnderLets.UnderLets base.type ident var
              (defaults.expr (type.base T)))
      (x1 : defaults.expr (type.base base.type.bool)) =>
    UnderLets.Base
      (#(ident.bool_rect)%expr @
       (λ x2 : var (type.base base.type.unit),
        UnderLets.to_expr (x ($x2)))%expr @
       (λ x2 : var (type.base base.type.unit),
        UnderLets.to_expr (x0 ($x2)))%expr @ x1)%expr_pat
| @ident.nat_rect P =>
    fun
      (x : defaults.expr (type.base base.type.unit) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base P)))
      (x0 : defaults.expr (type.base base.type.nat) ->
            defaults.expr (type.base P) ->
            UnderLets.UnderLets base.type ident var
              (defaults.expr (type.base P)))
      (x1 : defaults.expr (type.base base.type.nat)) =>
    UnderLets.Base
      (#(ident.nat_rect)%expr @
       (λ x2 : var (type.base base.type.unit),
        UnderLets.to_expr (x ($x2)))%expr @
       (λ (x2 : var (type.base base.type.nat))(x3 : var (type.base P)),
        UnderLets.to_expr (x0 ($x2) ($x3)))%expr @ x1)%expr_pat
| @ident.nat_rect_arrow P Q =>
    fun
      (x : defaults.expr (type.base P) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base Q)))
      (x0 : defaults.expr (type.base base.type.nat) ->
            (defaults.expr (type.base P) ->
             UnderLets.UnderLets base.type ident var
               (defaults.expr (type.base Q))) ->
            defaults.expr (type.base P) ->
            UnderLets.UnderLets base.type ident var
              (defaults.expr (type.base Q)))
      (x1 : defaults.expr (type.base base.type.nat))
      (x2 : defaults.expr (type.base P)) =>
    UnderLets.Base
      (#(ident.nat_rect_arrow)%expr @
       (λ x3 : var (type.base P),
        UnderLets.to_expr (x ($x3)))%expr @
       (λ (x3 : var (type.base base.type.nat))(x4 : var
                                                      (type.base P ->
                                                       type.base Q)%ptype)
        (x5 : var (type.base P)),
        UnderLets.to_expr
          (x0 ($x3)
             (fun x6 : defaults.expr (type.base P) =>
              UnderLets.Base ($x4 @ x6)%expr_pat) ($x5)))%expr @ x1 @ x2)%expr_pat
| @ident.list_rect A P =>
    fun
      (x : defaults.expr (type.base base.type.unit) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base P)))
      (x0 : defaults.expr (type.base A) ->
            defaults.expr (type.base (base.type.list A)) ->
            defaults.expr (type.base P) ->
            UnderLets.UnderLets base.type ident var
              (defaults.expr (type.base P)))
      (x1 : defaults.expr (type.base (base.type.list A))) =>
    UnderLets.Base
      (#(ident.list_rect)%expr @
       (λ x2 : var (type.base base.type.unit),
        UnderLets.to_expr (x ($x2)))%expr @
       (λ (x2 : var (type.base A))(x3 : var (type.base (base.type.list A)))
        (x4 : var (type.base P)),
        UnderLets.to_expr (x0 ($x2) ($x3) ($x4)))%expr @ x1)%expr_pat
| @ident.list_case A P =>
    fun
      (x : defaults.expr (type.base base.type.unit) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base P)))
      (x0 : defaults.expr (type.base A) ->
            defaults.expr (type.base (base.type.list A)) ->
            UnderLets.UnderLets base.type ident var
              (defaults.expr (type.base P)))
      (x1 : defaults.expr (type.base (base.type.list A))) =>
    UnderLets.Base
      (#(ident.list_case)%expr @
       (λ x2 : var (type.base base.type.unit),
        UnderLets.to_expr (x ($x2)))%expr @
       (λ (x2 : var (type.base A))(x3 : var (type.base (base.type.list A))),
        UnderLets.to_expr (x0 ($x2) ($x3)))%expr @ x1)%expr_pat
| @ident.List_length T =>
    fun x : defaults.expr (type.base (base.type.list T)) =>
    UnderLets.Base (#(ident.List_length)%expr @ x)%expr_pat
| ident.List_seq =>
    fun x x0 : defaults.expr (type.base base.type.nat) =>
    UnderLets.Base (#(ident.List_seq)%expr @ x @ x0)%expr_pat
| @ident.List_firstn A =>
    fun (x : defaults.expr (type.base base.type.nat))
      (x0 : defaults.expr (type.base (base.type.list A))) =>
    UnderLets.Base (#(ident.List_firstn)%expr @ x @ x0)%expr_pat
| @ident.List_skipn A =>
    fun (x : defaults.expr (type.base base.type.nat))
      (x0 : defaults.expr (type.base (base.type.list A))) =>
    UnderLets.Base (#(ident.List_skipn)%expr @ x @ x0)%expr_pat
| @ident.List_repeat A =>
    fun (x : defaults.expr (type.base A))
      (x0 : defaults.expr (type.base base.type.nat)) =>
    UnderLets.Base (#(ident.List_repeat)%expr @ x @ x0)%expr_pat
| @ident.List_combine A B =>
    fun (x : defaults.expr (type.base (base.type.list A)))
      (x0 : defaults.expr (type.base (base.type.list B))) =>
    UnderLets.Base (#(ident.List_combine)%expr @ x @ x0)%expr_pat
| @ident.List_map A B =>
    fun
      (x : defaults.expr (type.base A) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base B)))
      (x0 : defaults.expr (type.base (base.type.list A))) =>
    UnderLets.Base
      (#(ident.List_map)%expr @
       (λ x1 : var (type.base A),
        UnderLets.to_expr (x ($x1)))%expr @ x0)%expr_pat
| @ident.List_app A =>
    fun x x0 : defaults.expr (type.base (base.type.list A)) =>
    UnderLets.Base (x ++ x0)%expr
| @ident.List_rev A =>
    fun x : defaults.expr (type.base (base.type.list A)) =>
    UnderLets.Base (#(ident.List_rev)%expr @ x)%expr_pat
| @ident.List_flat_map A B =>
    fun
      (x : defaults.expr (type.base A) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base (base.type.list B))))
      (x0 : defaults.expr (type.base (base.type.list A))) =>
    UnderLets.Base
      (#(ident.List_flat_map)%expr @
       (λ x1 : var (type.base A),
        UnderLets.to_expr (x ($x1)))%expr @ x0)%expr_pat
| @ident.List_partition A =>
    fun
      (x : defaults.expr (type.base A) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base base.type.bool)))
      (x0 : defaults.expr (type.base (base.type.list A))) =>
    UnderLets.Base
      (#(ident.List_partition)%expr @
       (λ x1 : var (type.base A),
        UnderLets.to_expr (x ($x1)))%expr @ x0)%expr_pat
| @ident.List_fold_right A B =>
    fun
      (x : defaults.expr (type.base B) ->
           defaults.expr (type.base A) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base A)))
      (x0 : defaults.expr (type.base A))
      (x1 : defaults.expr (type.base (base.type.list B))) =>
    UnderLets.Base
      (#(ident.List_fold_right)%expr @
       (λ (x2 : var (type.base B))(x3 : var (type.base A)),
        UnderLets.to_expr (x ($x2) ($x3)))%expr @ x0 @ x1)%expr_pat
| @ident.List_update_nth T =>
    fun (x : defaults.expr (type.base base.type.nat))
      (x0 : defaults.expr (type.base T) ->
            UnderLets.UnderLets base.type ident var
              (defaults.expr (type.base T)))
      (x1 : defaults.expr (type.base (base.type.list T))) =>
    UnderLets.Base
      (#(ident.List_update_nth)%expr @ x @
       (λ x2 : var (type.base T),
        UnderLets.to_expr (x0 ($x2)))%expr @ x1)%expr_pat
| @ident.List_nth_default T =>
    fun (x : defaults.expr (type.base T))
      (x0 : defaults.expr (type.base (base.type.list T)))
      (x1 : defaults.expr (type.base base.type.nat)) =>
    UnderLets.Base (#(ident.List_nth_default)%expr @ x @ x0 @ x1)%expr_pat
| ident.Z_add =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (x + x0)%expr
| ident.Z_mul =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    (match x with
     | @expr.Ident _ _ _ t idc =>
         args <- pattern.ident.invert_bind_args idc pattern.ident.LiteralZ;
         match x0 with
         | @expr.App _ _ _ s _
           (@expr.App _ _ _ s0 _ (@expr.Ident _ _ _ t0 idc0) x2) x1 =>
             (_ <- pattern.ident.invert_bind_args idc0 pident.Z_land;
              match x1 with
              | @expr.Ident _ _ _ t1 idc1 =>
                  args1 <- pattern.ident.invert_bind_args idc1
                             pattern.ident.LiteralZ;
                  match
                    s0 as t2
                    return
                      (value' false t2 ->
                       option
                         (UnderLets.UnderLets base.type ident var
                            (defaults.expr (type.base base.type.Z))))
                  with
                  | type.base t2 =>
                      fun v : defaults.expr (type.base t2) =>
                      base.try_make_transport_cps t2 base.type.Z
                        (fun
                           a : option
                                 (defaults.expr (type.base t2) ->
                                  defaults.expr (type.base base.type.Z)) =>
                         match a with
                         | Some x' =>
                             if args1 =? 2 ^ (2 * Z.log2_up args1 / 2) - 1
                             then
                              (x3 <- invert_low (2 * Z.log2_up args1) args;
                               Some
                                 (Some
                                    (UnderLets.Base
                                       (#(ident.fancy_mulll
                                            (2 * Z.log2_up args1))%expr @
                                        ((##x3)%expr, x' v))%expr_pat)));;;
                              None
                             else None
                         | None => None
                         end)
                  | (s1 -> d1)%ptype =>
                      fun _ : value' false s1 -> value' true d1 => None
                  end (reflect x2)
              | _ => None
              end;;
              match x2 with
              | @expr.Ident _ _ _ t1 idc1 =>
                  args1 <- pattern.ident.invert_bind_args idc1
                             pattern.ident.LiteralZ;
                  match
                    s as t2
                    return
                      (value' false t2 ->
                       option
                         (UnderLets.UnderLets base.type ident var
                            (defaults.expr (type.base base.type.Z))))
                  with
                  | type.base t2 =>
                      fun v : defaults.expr (type.base t2) =>
                      base.try_make_transport_cps t2 base.type.Z
                        (fun
                           a : option
                                 (defaults.expr (type.base t2) ->
                                  defaults.expr (type.base base.type.Z)) =>
                         match a with
                         | Some x' =>
                             if args1 =? 2 ^ (2 * Z.log2_up args1 / 2) - 1
                             then
                              (x3 <- invert_low (2 * Z.log2_up args1) args;
                               Some
                                 (Some
                                    (UnderLets.Base
                                       (#(ident.fancy_mulll
                                            (2 * Z.log2_up args1))%expr @
                                        ((##x3)%expr, x' v))%expr_pat)));;;
                              None
                             else None
                         | None => None
                         end)
                  | (s1 -> d1)%ptype =>
                      fun _ : value' false s1 -> value' true d1 => None
                  end (reflect x1);;
                  match
                    s as t2
                    return
                      (value' false t2 ->
                       option
                         (UnderLets.UnderLets base.type ident var
                            (defaults.expr (type.base base.type.Z))))
                  with
                  | type.base t2 =>
                      fun v : defaults.expr (type.base t2) =>
                      base.try_make_transport_cps t2 base.type.Z
                        (fun
                           a : option
                                 (defaults.expr (type.base t2) ->
                                  defaults.expr (type.base base.type.Z)) =>
                         match a with
                         | Some x' =>
                             if args1 =? 2 ^ (2 * Z.log2_up args1 / 2) - 1
                             then
                              (x3 <- invert_high (2 * Z.log2_up args1) args;
                               Some
                                 (Some
                                    (UnderLets.Base
                                       (#(ident.fancy_mulhl
                                            (2 * Z.log2_up args1))%expr @
                                        ((##x3)%expr, x' v))%expr_pat)));;;
                              None
                             else None
                         | None => None
                         end)
                  | (s1 -> d1)%ptype =>
                      fun _ : value' false s1 -> value' true d1 => None
                  end (reflect x1)
              | _ => None
              end;;
              match x1 with
              | @expr.Ident _ _ _ t1 idc1 =>
                  args1 <- pattern.ident.invert_bind_args idc1
                             pattern.ident.LiteralZ;
                  match
                    s0 as t2
                    return
                      (value' false t2 ->
                       option
                         (UnderLets.UnderLets base.type ident var
                            (defaults.expr (type.base base.type.Z))))
                  with
                  | type.base t2 =>
                      fun v : defaults.expr (type.base t2) =>
                      base.try_make_transport_cps t2 base.type.Z
                        (fun
                           a : option
                                 (defaults.expr (type.base t2) ->
                                  defaults.expr (type.base base.type.Z)) =>
                         match a with
                         | Some x' =>
                             if args1 =? 2 ^ (2 * Z.log2_up args1 / 2) - 1
                             then
                              (x3 <- invert_high (2 * Z.log2_up args1) args;
                               Some
                                 (Some
                                    (UnderLets.Base
                                       (#(ident.fancy_mulhl
                                            (2 * Z.log2_up args1))%expr @
                                        ((##x3)%expr, x' v))%expr_pat)));;;
                              None
                             else None
                         | None => None
                         end)
                  | (s1 -> d1)%ptype =>
                      fun _ : value' false s1 -> value' true d1 => None
                  end (reflect x2)
              | _ => None
              end);;
             _ <- pattern.ident.invert_bind_args idc0 pident.Z_shiftr;
             match x1 with
             | @expr.Ident _ _ _ t1 idc1 =>
                 args1 <- pattern.ident.invert_bind_args idc1
                            pattern.ident.LiteralZ;
                 match
                   s0 as t2
                   return
                     (value' false t2 ->
                      option
                        (UnderLets.UnderLets base.type ident var
                           (defaults.expr (type.base base.type.Z))))
                 with
                 | type.base t2 =>
                     fun v : defaults.expr (type.base t2) =>
                     base.try_make_transport_cps t2 base.type.Z
                       (fun
                          a : option
                                (defaults.expr (type.base t2) ->
                                 defaults.expr (type.base base.type.Z)) =>
                        match a with
                        | Some x' =>
                            (x3 <- invert_low (2 * args1) args;
                             Some
                               (Some
                                  (UnderLets.Base
                                     (#(ident.fancy_mullh (2 * args1))%expr @
                                      ((##x3)%expr, x' v))%expr_pat)));;;
                            None
                        | None => None
                        end)
                 | (s1 -> d1)%ptype =>
                     fun _ : value' false s1 -> value' true d1 => None
                 end (reflect x2);;
                 match
                   s0 as t2
                   return
                     (value' false t2 ->
                      option
                        (UnderLets.UnderLets base.type ident var
                           (defaults.expr (type.base base.type.Z))))
                 with
                 | type.base t2 =>
                     fun v : defaults.expr (type.base t2) =>
                     base.try_make_transport_cps t2 base.type.Z
                       (fun
                          a : option
                                (defaults.expr (type.base t2) ->
                                 defaults.expr (type.base base.type.Z)) =>
                        match a with
                        | Some x' =>
                            (x3 <- invert_high (2 * args1) args;
                             Some
                               (Some
                                  (UnderLets.Base
                                     (#(ident.fancy_mulhh (2 * args1))%expr @
                                      ((##x3)%expr, x' v))%expr_pat)));;;
                            None
                        | None => None
                        end)
                 | (s1 -> d1)%ptype =>
                     fun _ : value' false s1 -> value' true d1 => None
                 end (reflect x2)
             | _ => None
             end
         | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ ($_)%expr _) _ |
           @expr.App _ _ _ s _
           (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _) _ | @expr.App _ _
           _ s _ (@expr.App _ _ _ s0 _ (_ @ _)%expr_pat _) _ | @expr.App _ _
           _ s _ (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _) _ =>
             None
         | @expr.App _ _ _ s _ #(_)%expr_pat _ | @expr.App _ _ _ s _
           ($_)%expr _ | @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ |
           @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
         | _ => None
         end
     | @expr.App _ _ _ s _
       (@expr.App _ _ _ s0 _ (@expr.Ident _ _ _ t idc) x2) x1 =>
         (_ <- pattern.ident.invert_bind_args idc pident.Z_land;
          match x2 with
          | @expr.Ident _ _ _ t0 idc0 =>
              args0 <- pattern.ident.invert_bind_args idc0
                         pattern.ident.LiteralZ;
              match x0 with
              | @expr.Ident _ _ _ t1 idc1 =>
                  args1 <- pattern.ident.invert_bind_args idc1
                             pattern.ident.LiteralZ;
                  match
                    s as t2
                    return
                      (value' false t2 ->
                       option
                         (UnderLets.UnderLets base.type ident var
                            (defaults.expr (type.base base.type.Z))))
                  with
                  | type.base t2 =>
                      fun v : defaults.expr (type.base t2) =>
                      base.try_make_transport_cps t2 base.type.Z
                        (fun
                           a : option
                                 (defaults.expr (type.base t2) ->
                                  defaults.expr (type.base base.type.Z)) =>
                         match a with
                         | Some x' =>
                             if args0 =? 2 ^ (2 * Z.log2_up args0 / 2) - 1
                             then
                              (y <- invert_low (2 * Z.log2_up args0) args1;
                               Some
                                 (Some
                                    (UnderLets.Base
                                       (#(ident.fancy_mulll
                                            (2 * Z.log2_up args0))%expr @
                                        (x' v, (##y)%expr))%expr_pat)));;;
                              None
                             else None
                         | None => None
                         end)
                  | (s1 -> d1)%ptype =>
                      fun _ : value' false s1 -> value' true d1 => None
                  end (reflect x1)
              | _ => None
              end
          | _ => None
          end;;
          match x1 with
          | @expr.Ident _ _ _ t0 idc0 =>
              args0 <- pattern.ident.invert_bind_args idc0
                         pattern.ident.LiteralZ;
              match x0 with
              | @expr.Ident _ _ _ t1 idc1 =>
                  args1 <- pattern.ident.invert_bind_args idc1
                             pattern.ident.LiteralZ;
                  match
                    s0 as t2
                    return
                      (value' false t2 ->
                       option
                         (UnderLets.UnderLets base.type ident var
                            (defaults.expr (type.base base.type.Z))))
                  with
                  | type.base t2 =>
                      fun v : defaults.expr (type.base t2) =>
                      base.try_make_transport_cps t2 base.type.Z
                        (fun
                           a : option
                                 (defaults.expr (type.base t2) ->
                                  defaults.expr (type.base base.type.Z)) =>
                         match a with
                         | Some x' =>
                             if args0 =? 2 ^ (2 * Z.log2_up args0 / 2) - 1
                             then
                              (y <- invert_low (2 * Z.log2_up args0) args1;
                               Some
                                 (Some
                                    (UnderLets.Base
                                       (#(ident.fancy_mulll
                                            (2 * Z.log2_up args0))%expr @
                                        (x' v, (##y)%expr))%expr_pat)));;;
                              None
                             else None
                         | None => None
                         end)
                  | (s1 -> d1)%ptype =>
                      fun _ : value' false s1 -> value' true d1 => None
                  end (reflect x2)
              | _ => None
              end
          | _ => None
          end;;
          match x2 with
          | @expr.Ident _ _ _ t0 idc0 =>
              args0 <- pattern.ident.invert_bind_args idc0
                         pattern.ident.LiteralZ;
              match x0 with
              | @expr.Ident _ _ _ t1 idc1 =>
                  args1 <- pattern.ident.invert_bind_args idc1
                             pattern.ident.LiteralZ;
                  match
                    s as t2
                    return
                      (value' false t2 ->
                       option
                         (UnderLets.UnderLets base.type ident var
                            (defaults.expr (type.base base.type.Z))))
                  with
                  | type.base t2 =>
                      fun v : defaults.expr (type.base t2) =>
                      base.try_make_transport_cps t2 base.type.Z
                        (fun
                           a : option
                                 (defaults.expr (type.base t2) ->
                                  defaults.expr (type.base base.type.Z)) =>
                         match a with
                         | Some x' =>
                             if args0 =? 2 ^ (2 * Z.log2_up args0 / 2) - 1
                             then
                              (y <- invert_high (2 * Z.log2_up args0) args1;
                               Some
                                 (Some
                                    (UnderLets.Base
                                       (#(ident.fancy_mullh
                                            (2 * Z.log2_up args0))%expr @
                                        (x' v, (##y)%expr))%expr_pat)));;;
                              None
                             else None
                         | None => None
                         end)
                  | (s1 -> d1)%ptype =>
                      fun _ : value' false s1 -> value' true d1 => None
                  end (reflect x1)
              | _ => None
              end
          | _ => None
          end;;
          match x1 with
          | @expr.Ident _ _ _ t0 idc0 =>
              args0 <- pattern.ident.invert_bind_args idc0
                         pattern.ident.LiteralZ;
              match x0 with
              | @expr.Ident _ _ _ t1 idc1 =>
                  args1 <- pattern.ident.invert_bind_args idc1
                             pattern.ident.LiteralZ;
                  match
                    s0 as t2
                    return
                      (value' false t2 ->
                       option
                         (UnderLets.UnderLets base.type ident var
                            (defaults.expr (type.base base.type.Z))))
                  with
                  | type.base t2 =>
                      fun v : defaults.expr (type.base t2) =>
                      base.try_make_transport_cps t2 base.type.Z
                        (fun
                           a : option
                                 (defaults.expr (type.base t2) ->
                                  defaults.expr (type.base base.type.Z)) =>
                         match a with
                         | Some x' =>
                             if args0 =? 2 ^ (2 * Z.log2_up args0 / 2) - 1
                             then
                              (y <- invert_high (2 * Z.log2_up args0) args1;
                               Some
                                 (Some
                                    (UnderLets.Base
                                       (#(ident.fancy_mullh
                                            (2 * Z.log2_up args0))%expr @
                                        (x' v, (##y)%expr))%expr_pat)));;;
                              None
                             else None
                         | None => None
                         end)
                  | (s1 -> d1)%ptype =>
                      fun _ : value' false s1 -> value' true d1 => None
                  end (reflect x2)
              | _ => None
              end
          | _ => None
          end;;
          match x2 with
          | @expr.Ident _ _ _ t0 idc0 =>
              args0 <- pattern.ident.invert_bind_args idc0
                         pattern.ident.LiteralZ;
              match x0 with
              | @expr.App _ _ _ s1 _
                (@expr.Ident _ _ _ t1 idc1 @ x4)%expr_pat x3 =>
                  _ <- pattern.ident.invert_bind_args idc1 pident.Z_land;
                  match x4 with
                  | @expr.Ident _ _ _ t2 idc2 =>
                      args2 <- pattern.ident.invert_bind_args idc2
                                 pattern.ident.LiteralZ;
                      match
                        s as t3
                        return
                          (value' false t3 ->
                           option
                             (UnderLets.UnderLets base.type ident var
                                (defaults.expr (type.base base.type.Z))))
                      with
                      | type.base t3 =>
                          fun v : defaults.expr (type.base t3) =>
                          base.try_make_transport_cps t3 base.type.Z
                            (fun
                               a : option
                                     (defaults.expr (type.base t3) ->
                                      defaults.expr (type.base base.type.Z))
                             =>
                             match a with
                             | Some x' =>
                                 match
                                   s1 as t4
                                   return
                                     (value' false t4 ->
                                      option
                                        (UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base base.type.Z))))
                                 with
                                 | type.base t4 =>
                                     fun v0 : defaults.expr (type.base t4) =>
                                     base.try_make_transport_cps t4
                                       base.type.Z
                                       (fun
                                          a0 : option
                                                 (defaults.expr
                                                    (type.base t4) ->
                                                  defaults.expr
                                                    (type.base base.type.Z))
                                        =>
                                        match a0 with
                                        | Some x'0 =>
                                            if
                                             (args0 =?
                                              2 ^ (2 * Z.log2_up args0 / 2) -
                                              1) &&
                                             (args2 =?
                                              2 ^ (2 * Z.log2_up args0 / 2) -
                                              1)
                                            then
                                             Some
                                               (UnderLets.Base
                                                  (#(ident.fancy_mulll
                                                       (2 * Z.log2_up args0))%expr @
                                                   (x' v, x'0 v0))%expr_pat)
                                            else None
                                        | None => None
                                        end)
                                 | (s3 -> d3)%ptype =>
                                     fun
                                       _ : value' false s3 -> value' true d3
                                     => None
                                 end (reflect x3)
                             | None => None
                             end)
                      | (s3 -> d3)%ptype =>
                          fun _ : value' false s3 -> value' true d3 => None
                      end (reflect x1)
                  | _ => None
                  end
              | @expr.App _ _ _ s1 _ #(_)%expr_pat _ | @expr.App _ _ _ s1 _
                ($_)%expr _ | @expr.App _ _ _ s1 _ (@expr.Abs _ _ _ _ _ _)
                _ | @expr.App _ _ _ s1 _ (($_)%expr @ _)%expr_pat _ |
                @expr.App _ _ _ s1 _ (@expr.Abs _ _ _ _ _ _ @ _)%expr_pat _ |
                @expr.App _ _ _ s1 _ (_ @ _ @ _)%expr_pat _ | @expr.App _ _ _
                s1 _ (@expr.LetIn _ _ _ _ _ _ _ @ _)%expr_pat _ | @expr.App _
                _ _ s1 _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
              | _ => None
              end
          | _ => None
          end;;
          match x1 with
          | @expr.Ident _ _ _ t0 idc0 =>
              args0 <- pattern.ident.invert_bind_args idc0
                         pattern.ident.LiteralZ;
              match x0 with
              | @expr.App _ _ _ s1 _
                (@expr.Ident _ _ _ t1 idc1 @ x4)%expr_pat x3 =>
                  _ <- pattern.ident.invert_bind_args idc1 pident.Z_land;
                  match x4 with
                  | @expr.Ident _ _ _ t2 idc2 =>
                      args2 <- pattern.ident.invert_bind_args idc2
                                 pattern.ident.LiteralZ;
                      match
                        s0 as t3
                        return
                          (value' false t3 ->
                           option
                             (UnderLets.UnderLets base.type ident var
                                (defaults.expr (type.base base.type.Z))))
                      with
                      | type.base t3 =>
                          fun v : defaults.expr (type.base t3) =>
                          base.try_make_transport_cps t3 base.type.Z
                            (fun
                               a : option
                                     (defaults.expr (type.base t3) ->
                                      defaults.expr (type.base base.type.Z))
                             =>
                             match a with
                             | Some x' =>
                                 match
                                   s1 as t4
                                   return
                                     (value' false t4 ->
                                      option
                                        (UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base base.type.Z))))
                                 with
                                 | type.base t4 =>
                                     fun v0 : defaults.expr (type.base t4) =>
                                     base.try_make_transport_cps t4
                                       base.type.Z
                                       (fun
                                          a0 : option
                                                 (defaults.expr
                                                    (type.base t4) ->
                                                  defaults.expr
                                                    (type.base base.type.Z))
                                        =>
                                        match a0 with
                                        | Some x'0 =>
                                            if
                                             (args0 =?
                                              2 ^ (2 * Z.log2_up args0 / 2) -
                                              1) &&
                                             (args2 =?
                                              2 ^ (2 * Z.log2_up args0 / 2) -
                                              1)
                                            then
                                             Some
                                               (UnderLets.Base
                                                  (#(ident.fancy_mulll
                                                       (2 * Z.log2_up args0))%expr @
                                                   (x' v, x'0 v0))%expr_pat)
                                            else None
                                        | None => None
                                        end)
                                 | (s3 -> d3)%ptype =>
                                     fun
                                       _ : value' false s3 -> value' true d3
                                     => None
                                 end (reflect x3)
                             | None => None
                             end)
                      | (s3 -> d3)%ptype =>
                          fun _ : value' false s3 -> value' true d3 => None
                      end (reflect x2)
                  | _ => None
                  end
              | @expr.App _ _ _ s1 _ #(_)%expr_pat _ | @expr.App _ _ _ s1 _
                ($_)%expr _ | @expr.App _ _ _ s1 _ (@expr.Abs _ _ _ _ _ _)
                _ | @expr.App _ _ _ s1 _ (($_)%expr @ _)%expr_pat _ |
                @expr.App _ _ _ s1 _ (@expr.Abs _ _ _ _ _ _ @ _)%expr_pat _ |
                @expr.App _ _ _ s1 _ (_ @ _ @ _)%expr_pat _ | @expr.App _ _ _
                s1 _ (@expr.LetIn _ _ _ _ _ _ _ @ _)%expr_pat _ | @expr.App _
                _ _ s1 _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
              | _ => None
              end
          | _ => None
          end;;
          match x2 with
          | @expr.Ident _ _ _ t0 idc0 =>
              args0 <- pattern.ident.invert_bind_args idc0
                         pattern.ident.LiteralZ;
              match x0 with
              | (@expr.App _ _ _ s2 _ (@expr.Ident _ _ _ t1 idc1) x4 @ x3)%expr_pat =>
                  _ <- pattern.ident.invert_bind_args idc1 pident.Z_land;
                  match x3 with
                  | @expr.Ident _ _ _ t2 idc2 =>
                      args2 <- pattern.ident.invert_bind_args idc2
                                 pattern.ident.LiteralZ;
                      match
                        s as t3
                        return
                          (value' false t3 ->
                           option
                             (UnderLets.UnderLets base.type ident var
                                (defaults.expr (type.base base.type.Z))))
                      with
                      | type.base t3 =>
                          fun v : defaults.expr (type.base t3) =>
                          base.try_make_transport_cps t3 base.type.Z
                            (fun
                               a : option
                                     (defaults.expr (type.base t3) ->
                                      defaults.expr (type.base base.type.Z))
                             =>
                             match a with
                             | Some x' =>
                                 match
                                   s2 as t4
                                   return
                                     (value' false t4 ->
                                      option
                                        (UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base base.type.Z))))
                                 with
                                 | type.base t4 =>
                                     fun v0 : defaults.expr (type.base t4) =>
                                     base.try_make_transport_cps t4
                                       base.type.Z
                                       (fun
                                          a0 : option
                                                 (defaults.expr
                                                    (type.base t4) ->
                                                  defaults.expr
                                                    (type.base base.type.Z))
                                        =>
                                        match a0 with
                                        | Some x'0 =>
                                            if
                                             (args0 =?
                                              2 ^ (2 * Z.log2_up args0 / 2) -
                                              1) &&
                                             (args2 =?
                                              2 ^ (2 * Z.log2_up args0 / 2) -
                                              1)
                                            then
                                             Some
                                               (UnderLets.Base
                                                  (#(ident.fancy_mulll
                                                       (2 * Z.log2_up args0))%expr @
                                                   (x' v, x'0 v0))%expr_pat)
                                            else None
                                        | None => None
                                        end)
                                 | (s3 -> d3)%ptype =>
                                     fun
                                       _ : value' false s3 -> value' true d3
                                     => None
                                 end (reflect x4)
                             | None => None
                             end)
                      | (s3 -> d3)%ptype =>
                          fun _ : value' false s3 -> value' true d3 => None
                      end (reflect x1)
                  | _ => None
                  end
              | (@expr.App _ _ _ s2 _ ($_)%expr _ @ _)%expr_pat |
                (@expr.App _ _ _ s2 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                (@expr.App _ _ _ s2 _ (_ @ _) _ @ _)%expr_pat |
                (@expr.App _ _ _ s2 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                  None
              | _ => None
              end
          | _ => None
          end;;
          match x1 with
          | @expr.Ident _ _ _ t0 idc0 =>
              args0 <- pattern.ident.invert_bind_args idc0
                         pattern.ident.LiteralZ;
              match x0 with
              | (@expr.App _ _ _ s2 _ (@expr.Ident _ _ _ t1 idc1) x4 @ x3)%expr_pat =>
                  _ <- pattern.ident.invert_bind_args idc1 pident.Z_land;
                  match x3 with
                  | @expr.Ident _ _ _ t2 idc2 =>
                      args2 <- pattern.ident.invert_bind_args idc2
                                 pattern.ident.LiteralZ;
                      match
                        s0 as t3
                        return
                          (value' false t3 ->
                           option
                             (UnderLets.UnderLets base.type ident var
                                (defaults.expr (type.base base.type.Z))))
                      with
                      | type.base t3 =>
                          fun v : defaults.expr (type.base t3) =>
                          base.try_make_transport_cps t3 base.type.Z
                            (fun
                               a : option
                                     (defaults.expr (type.base t3) ->
                                      defaults.expr (type.base base.type.Z))
                             =>
                             match a with
                             | Some x' =>
                                 match
                                   s2 as t4
                                   return
                                     (value' false t4 ->
                                      option
                                        (UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base base.type.Z))))
                                 with
                                 | type.base t4 =>
                                     fun v0 : defaults.expr (type.base t4) =>
                                     base.try_make_transport_cps t4
                                       base.type.Z
                                       (fun
                                          a0 : option
                                                 (defaults.expr
                                                    (type.base t4) ->
                                                  defaults.expr
                                                    (type.base base.type.Z))
                                        =>
                                        match a0 with
                                        | Some x'0 =>
                                            if
                                             (args0 =?
                                              2 ^ (2 * Z.log2_up args0 / 2) -
                                              1) &&
                                             (args2 =?
                                              2 ^ (2 * Z.log2_up args0 / 2) -
                                              1)
                                            then
                                             Some
                                               (UnderLets.Base
                                                  (#(ident.fancy_mulll
                                                       (2 * Z.log2_up args0))%expr @
                                                   (x' v, x'0 v0))%expr_pat)
                                            else None
                                        | None => None
                                        end)
                                 | (s3 -> d3)%ptype =>
                                     fun
                                       _ : value' false s3 -> value' true d3
                                     => None
                                 end (reflect x4)
                             | None => None
                             end)
                      | (s3 -> d3)%ptype =>
                          fun _ : value' false s3 -> value' true d3 => None
                      end (reflect x2)
                  | _ => None
                  end
              | (@expr.App _ _ _ s2 _ ($_)%expr _ @ _)%expr_pat |
                (@expr.App _ _ _ s2 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                (@expr.App _ _ _ s2 _ (_ @ _) _ @ _)%expr_pat |
                (@expr.App _ _ _ s2 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                  None
              | _ => None
              end
          | _ => None
          end;;
          match x2 with
          | @expr.Ident _ _ _ t0 idc0 =>
              args0 <- pattern.ident.invert_bind_args idc0
                         pattern.ident.LiteralZ;
              match x0 with
              | (@expr.App _ _ _ s2 _ (@expr.Ident _ _ _ t1 idc1) x4 @ x3)%expr_pat =>
                  _ <- pattern.ident.invert_bind_args idc1 pident.Z_shiftr;
                  match x3 with
                  | @expr.Ident _ _ _ t2 idc2 =>
                      args2 <- pattern.ident.invert_bind_args idc2
                                 pattern.ident.LiteralZ;
                      match
                        s as t3
                        return
                          (value' false t3 ->
                           option
                             (UnderLets.UnderLets base.type ident var
                                (defaults.expr (type.base base.type.Z))))
                      with
                      | type.base t3 =>
                          fun v : defaults.expr (type.base t3) =>
                          base.try_make_transport_cps t3 base.type.Z
                            (fun
                               a : option
                                     (defaults.expr (type.base t3) ->
                                      defaults.expr (type.base base.type.Z))
                             =>
                             match a with
                             | Some x' =>
                                 match
                                   s2 as t4
                                   return
                                     (value' false t4 ->
                                      option
                                        (UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base base.type.Z))))
                                 with
                                 | type.base t4 =>
                                     fun v0 : defaults.expr (type.base t4) =>
                                     base.try_make_transport_cps t4
                                       base.type.Z
                                       (fun
                                          a0 : option
                                                 (defaults.expr
                                                    (type.base t4) ->
                                                  defaults.expr
                                                    (type.base base.type.Z))
                                        =>
                                        match a0 with
                                        | Some x'0 =>
                                            if
                                             args0 =? 2 ^ (2 * args2 / 2) - 1
                                            then
                                             Some
                                               (UnderLets.Base
                                                  (#(ident.fancy_mullh
                                                       (2 * args2))%expr @
                                                   (x' v, x'0 v0))%expr_pat)
                                            else None
                                        | None => None
                                        end)
                                 | (s3 -> d3)%ptype =>
                                     fun
                                       _ : value' false s3 -> value' true d3
                                     => None
                                 end (reflect x4)
                             | None => None
                             end)
                      | (s3 -> d3)%ptype =>
                          fun _ : value' false s3 -> value' true d3 => None
                      end (reflect x1)
                  | _ => None
                  end
              | (@expr.App _ _ _ s2 _ ($_)%expr _ @ _)%expr_pat |
                (@expr.App _ _ _ s2 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                (@expr.App _ _ _ s2 _ (_ @ _) _ @ _)%expr_pat |
                (@expr.App _ _ _ s2 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                  None
              | _ => None
              end
          | _ => None
          end;;
          match x1 with
          | @expr.Ident _ _ _ t0 idc0 =>
              args0 <- pattern.ident.invert_bind_args idc0
                         pattern.ident.LiteralZ;
              match x0 with
              | (@expr.App _ _ _ s2 _ (@expr.Ident _ _ _ t1 idc1) x4 @ x3)%expr_pat =>
                  _ <- pattern.ident.invert_bind_args idc1 pident.Z_shiftr;
                  match x3 with
                  | @expr.Ident _ _ _ t2 idc2 =>
                      args2 <- pattern.ident.invert_bind_args idc2
                                 pattern.ident.LiteralZ;
                      match
                        s0 as t3
                        return
                          (value' false t3 ->
                           option
                             (UnderLets.UnderLets base.type ident var
                                (defaults.expr (type.base base.type.Z))))
                      with
                      | type.base t3 =>
                          fun v : defaults.expr (type.base t3) =>
                          base.try_make_transport_cps t3 base.type.Z
                            (fun
                               a : option
                                     (defaults.expr (type.base t3) ->
                                      defaults.expr (type.base base.type.Z))
                             =>
                             match a with
                             | Some x' =>
                                 match
                                   s2 as t4
                                   return
                                     (value' false t4 ->
                                      option
                                        (UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base base.type.Z))))
                                 with
                                 | type.base t4 =>
                                     fun v0 : defaults.expr (type.base t4) =>
                                     base.try_make_transport_cps t4
                                       base.type.Z
                                       (fun
                                          a0 : option
                                                 (defaults.expr
                                                    (type.base t4) ->
                                                  defaults.expr
                                                    (type.base base.type.Z))
                                        =>
                                        match a0 with
                                        | Some x'0 =>
                                            if
                                             args0 =? 2 ^ (2 * args2 / 2) - 1
                                            then
                                             Some
                                               (UnderLets.Base
                                                  (#(ident.fancy_mullh
                                                       (2 * args2))%expr @
                                                   (x' v, x'0 v0))%expr_pat)
                                            else None
                                        | None => None
                                        end)
                                 | (s3 -> d3)%ptype =>
                                     fun
                                       _ : value' false s3 -> value' true d3
                                     => None
                                 end (reflect x4)
                             | None => None
                             end)
                      | (s3 -> d3)%ptype =>
                          fun _ : value' false s3 -> value' true d3 => None
                      end (reflect x2)
                  | _ => None
                  end
              | (@expr.App _ _ _ s2 _ ($_)%expr _ @ _)%expr_pat |
                (@expr.App _ _ _ s2 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
                (@expr.App _ _ _ s2 _ (_ @ _) _ @ _)%expr_pat |
                (@expr.App _ _ _ s2 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                  None
              | _ => None
              end
          | _ => None
          end);;
         _ <- pattern.ident.invert_bind_args idc pident.Z_shiftr;
         match x1 with
         | @expr.Ident _ _ _ t0 idc0 =>
             args0 <- pattern.ident.invert_bind_args idc0
                        pattern.ident.LiteralZ;
             match x0 with
             | @expr.Ident _ _ _ t1 idc1 =>
                 args1 <- pattern.ident.invert_bind_args idc1
                            pattern.ident.LiteralZ;
                 match
                   s0 as t2
                   return
                     (value' false t2 ->
                      option
                        (UnderLets.UnderLets base.type ident var
                           (defaults.expr (type.base base.type.Z))))
                 with
                 | type.base t2 =>
                     fun v : defaults.expr (type.base t2) =>
                     base.try_make_transport_cps t2 base.type.Z
                       (fun
                          a : option
                                (defaults.expr (type.base t2) ->
                                 defaults.expr (type.base base.type.Z)) =>
                        match a with
                        | Some x' =>
                            (y <- invert_low (2 * args0) args1;
                             Some
                               (Some
                                  (UnderLets.Base
                                     (#(ident.fancy_mulhl (2 * args0))%expr @
                                      (x' v, (##y)%expr))%expr_pat)));;;
                            None
                        | None => None
                        end)
                 | (s1 -> d1)%ptype =>
                     fun _ : value' false s1 -> value' true d1 => None
                 end (reflect x2);;
                 match
                   s0 as t2
                   return
                     (value' false t2 ->
                      option
                        (UnderLets.UnderLets base.type ident var
                           (defaults.expr (type.base base.type.Z))))
                 with
                 | type.base t2 =>
                     fun v : defaults.expr (type.base t2) =>
                     base.try_make_transport_cps t2 base.type.Z
                       (fun
                          a : option
                                (defaults.expr (type.base t2) ->
                                 defaults.expr (type.base base.type.Z)) =>
                        match a with
                        | Some x' =>
                            (y <- invert_high (2 * args0) args1;
                             Some
                               (Some
                                  (UnderLets.Base
                                     (#(ident.fancy_mulhh (2 * args0))%expr @
                                      (x' v, (##y)%expr))%expr_pat)));;;
                            None
                        | None => None
                        end)
                 | (s1 -> d1)%ptype =>
                     fun _ : value' false s1 -> value' true d1 => None
                 end (reflect x2)
             | @expr.App _ _ _ s1 _
               (@expr.App _ _ _ s2 _ (@expr.Ident _ _ _ t1 idc1) x4) x3 =>
                 (_ <- pattern.ident.invert_bind_args idc1 pident.Z_land;
                  match x4 with
                  | @expr.Ident _ _ _ t2 idc2 =>
                      args2 <- pattern.ident.invert_bind_args idc2
                                 pattern.ident.LiteralZ;
                      match
                        s0 as t3
                        return
                          (value' false t3 ->
                           option
                             (UnderLets.UnderLets base.type ident var
                                (defaults.expr (type.base base.type.Z))))
                      with
                      | type.base t3 =>
                          fun v : defaults.expr (type.base t3) =>
                          base.try_make_transport_cps t3 base.type.Z
                            (fun
                               a : option
                                     (defaults.expr (type.base t3) ->
                                      defaults.expr (type.base base.type.Z))
                             =>
                             match a with
                             | Some x' =>
                                 match
                                   s1 as t4
                                   return
                                     (value' false t4 ->
                                      option
                                        (UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base base.type.Z))))
                                 with
                                 | type.base t4 =>
                                     fun v0 : defaults.expr (type.base t4) =>
                                     base.try_make_transport_cps t4
                                       base.type.Z
                                       (fun
                                          a0 : option
                                                 (defaults.expr
                                                    (type.base t4) ->
                                                  defaults.expr
                                                    (type.base base.type.Z))
                                        =>
                                        match a0 with
                                        | Some x'0 =>
                                            if
                                             args2 =? 2 ^ (2 * args0 / 2) - 1
                                            then
                                             Some
                                               (UnderLets.Base
                                                  (#(ident.fancy_mulhl
                                                       (2 * args0))%expr @
                                                   (x' v, x'0 v0))%expr_pat)
                                            else None
                                        | None => None
                                        end)
                                 | (s3 -> d3)%ptype =>
                                     fun
                                       _ : value' false s3 -> value' true d3
                                     => None
                                 end (reflect x3)
                             | None => None
                             end)
                      | (s3 -> d3)%ptype =>
                          fun _ : value' false s3 -> value' true d3 => None
                      end (reflect x2)
                  | _ => None
                  end;;
                  match x3 with
                  | @expr.Ident _ _ _ t2 idc2 =>
                      args2 <- pattern.ident.invert_bind_args idc2
                                 pattern.ident.LiteralZ;
                      match
                        s0 as t3
                        return
                          (value' false t3 ->
                           option
                             (UnderLets.UnderLets base.type ident var
                                (defaults.expr (type.base base.type.Z))))
                      with
                      | type.base t3 =>
                          fun v : defaults.expr (type.base t3) =>
                          base.try_make_transport_cps t3 base.type.Z
                            (fun
                               a : option
                                     (defaults.expr (type.base t3) ->
                                      defaults.expr (type.base base.type.Z))
                             =>
                             match a with
                             | Some x' =>
                                 match
                                   s2 as t4
                                   return
                                     (value' false t4 ->
                                      option
                                        (UnderLets.UnderLets base.type ident
                                           var
                                           (defaults.expr
                                              (type.base base.type.Z))))
                                 with
                                 | type.base t4 =>
                                     fun v0 : defaults.expr (type.base t4) =>
                                     base.try_make_transport_cps t4
                                       base.type.Z
                                       (fun
                                          a0 : option
                                                 (defaults.expr
                                                    (type.base t4) ->
                                                  defaults.expr
                                                    (type.base base.type.Z))
                                        =>
                                        match a0 with
                                        | Some x'0 =>
                                            if
                                             args2 =? 2 ^ (2 * args0 / 2) - 1
                                            then
                                             Some
                                               (UnderLets.Base
                                                  (#(ident.fancy_mulhl
                                                       (2 * args0))%expr @
                                                   (x' v, x'0 v0))%expr_pat)
                                            else None
                                        | None => None
                                        end)
                                 | (s3 -> d3)%ptype =>
                                     fun
                                       _ : value' false s3 -> value' true d3
                                     => None
                                 end (reflect x4)
                             | None => None
                             end)
                      | (s3 -> d3)%ptype =>
                          fun _ : value' false s3 -> value' true d3 => None
                      end (reflect x2)
                  | _ => None
                  end);;
                 _ <- pattern.ident.invert_bind_args idc1 pident.Z_shiftr;
                 match x3 with
                 | @expr.Ident _ _ _ t2 idc2 =>
                     args2 <- pattern.ident.invert_bind_args idc2
                                pattern.ident.LiteralZ;
                     match
                       s0 as t3
                       return
                         (value' false t3 ->
                          option
                            (UnderLets.UnderLets base.type ident var
                               (defaults.expr (type.base base.type.Z))))
                     with
                     | type.base t3 =>
                         fun v : defaults.expr (type.base t3) =>
                         base.try_make_transport_cps t3 base.type.Z
                           (fun
                              a : option
                                    (defaults.expr (type.base t3) ->
                                     defaults.expr (type.base base.type.Z))
                            =>
                            match a with
                            | Some x' =>
                                match
                                  s2 as t4
                                  return
                                    (value' false t4 ->
                                     option
                                       (UnderLets.UnderLets base.type ident
                                          var
                                          (defaults.expr
                                             (type.base base.type.Z))))
                                with
                                | type.base t4 =>
                                    fun v0 : defaults.expr (type.base t4) =>
                                    base.try_make_transport_cps t4
                                      base.type.Z
                                      (fun
                                         a0 : option
                                                (defaults.expr (type.base t4) ->
                                                 defaults.expr
                                                   (type.base base.type.Z))
                                       =>
                                       match a0 with
                                       | Some x'0 =>
                                           if args0 =? args2
                                           then
                                            Some
                                              (UnderLets.Base
                                                 (#(ident.fancy_mulhh
                                                      (2 * args0))%expr @
                                                  (x' v, x'0 v0))%expr_pat)
                                           else None
                                       | None => None
                                       end)
                                | (s3 -> d3)%ptype =>
                                    fun _ : value' false s3 -> value' true d3
                                    => None
                                end (reflect x4)
                            | None => None
                            end)
                     | (s3 -> d3)%ptype =>
                         fun _ : value' false s3 -> value' true d3 => None
                     end (reflect x2)
                 | _ => None
                 end
             | @expr.App _ _ _ s1 _ (@expr.App _ _ _ s2 _ ($_)%expr _) _ |
               @expr.App _ _ _ s1 _
               (@expr.App _ _ _ s2 _ (@expr.Abs _ _ _ _ _ _) _) _ | @expr.App
               _ _ _ s1 _ (@expr.App _ _ _ s2 _ (_ @ _)%expr_pat _) _ |
               @expr.App _ _ _ s1 _
               (@expr.App _ _ _ s2 _ (@expr.LetIn _ _ _ _ _ _ _) _) _ => None
             | @expr.App _ _ _ s1 _ #(_)%expr_pat _ | @expr.App _ _ _ s1 _
               ($_)%expr _ | @expr.App _ _ _ s1 _ (@expr.Abs _ _ _ _ _ _) _ |
               @expr.App _ _ _ s1 _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
             | _ => None
             end
         | _ => None
         end
     | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ ($_)%expr _) _ | @expr.App _
       _ _ s _ (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _) _ | @expr.App
       _ _ _ s _ (@expr.App _ _ _ s0 _ (_ @ _)%expr_pat _) _ | @expr.App _ _
       _ s _ (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _) _ => None
     | @expr.App _ _ _ s _ #(_)%expr_pat _ | @expr.App _ _ _ s _ ($_)%expr
       _ | @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s
       _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
     | _ => None
     end;;;
     UnderLets.Base (x * x0)%expr)%option
| ident.Z_pow =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_pow)%expr @ x @ x0)%expr_pat
| ident.Z_sub =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (x - x0)%expr
| ident.Z_opp =>
    fun x : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (- x)%expr
| ident.Z_div =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (x / x0)%expr
| ident.Z_modulo =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (x mod x0)%expr
| ident.Z_log2 =>
    fun x : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_log2)%expr @ x)%expr_pat
| ident.Z_log2_up =>
    fun x : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_log2_up)%expr @ x)%expr_pat
| ident.Z_eqb =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_eqb)%expr @ x @ x0)%expr_pat
| ident.Z_leb =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_leb)%expr @ x @ x0)%expr_pat
| ident.Z_geb =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_geb)%expr @ x @ x0)%expr_pat
| ident.Z_of_nat =>
    fun x : defaults.expr (type.base base.type.nat) =>
    UnderLets.Base (#(ident.Z_of_nat)%expr @ x)%expr_pat
| ident.Z_to_nat =>
    fun x : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_to_nat)%expr @ x)%expr_pat
| ident.Z_shiftr =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (x >> x0)%expr
| ident.Z_shiftl =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (x << x0)%expr
| ident.Z_land =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (x &' x0)%expr
| ident.Z_lor =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (x || x0)%expr
| ident.Z_bneg =>
    fun x : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_bneg)%expr @ x)%expr_pat
| ident.Z_lnot_modulo =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_lnot_modulo)%expr @ x @ x0)%expr_pat
| ident.Z_mul_split =>
    fun x x0 x1 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_mul_split)%expr @ x @ x0 @ x1)%expr_pat
| ident.Z_add_get_carry =>
    fun x x0 x1 : defaults.expr (type.base base.type.Z) =>
    ((match x with
      | @expr.Ident _ _ _ t idc =>
          args <- pattern.ident.invert_bind_args idc pattern.ident.LiteralZ;
          match x1 with
          | (@expr.App _ _ _ s0 _ (@expr.Ident _ _ _ t0 idc0) x3 @ x2)%expr_pat =>
              _ <- pattern.ident.invert_bind_args idc0 pident.Z_shiftl;
              match x2 with
              | @expr.Ident _ _ _ t1 idc1 =>
                  args1 <- pattern.ident.invert_bind_args idc1
                             pattern.ident.LiteralZ;
                  match
                    s0 as t2
                    return
                      (value' false t2 ->
                       option
                         (UnderLets.UnderLets base.type ident var
                            (defaults.expr
                               (type.base (base.type.Z * base.type.Z)%etype))))
                  with
                  | type.base t2 =>
                      fun v : defaults.expr (type.base t2) =>
                      base.try_make_transport_cps t2 base.type.Z
                        (fun
                           a : option
                                 (defaults.expr (type.base t2) ->
                                  defaults.expr (type.base base.type.Z)) =>
                         match a with
                         | Some x' =>
                             if args =? 2 ^ Z.log2 args
                             then
                              Some
                                (UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 args) args1)%expr @
                                    (x0, x' v))%expr_pat)
                             else None
                         | None => None
                         end)
                  | (s1 -> d1)%ptype =>
                      fun _ : value' false s1 -> value' true d1 => None
                  end (reflect x3)
              | _ => None
              end
          | (@expr.App _ _ _ s0 _ ($_)%expr _ @ _)%expr_pat |
            (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
            (@expr.App _ _ _ s0 _ (_ @ _) _ @ _)%expr_pat |
            (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
              None
          | _ => None
          end;;
          match x0 with
          | (@expr.App _ _ _ s0 _ (@expr.Ident _ _ _ t0 idc0) x3 @ x2)%expr_pat =>
              _ <- pattern.ident.invert_bind_args idc0 pident.Z_shiftl;
              match x2 with
              | @expr.Ident _ _ _ t1 idc1 =>
                  args1 <- pattern.ident.invert_bind_args idc1
                             pattern.ident.LiteralZ;
                  match
                    s0 as t2
                    return
                      (value' false t2 ->
                       option
                         (UnderLets.UnderLets base.type ident var
                            (defaults.expr
                               (type.base (base.type.Z * base.type.Z)%etype))))
                  with
                  | type.base t2 =>
                      fun v : defaults.expr (type.base t2) =>
                      base.try_make_transport_cps t2 base.type.Z
                        (fun
                           a : option
                                 (defaults.expr (type.base t2) ->
                                  defaults.expr (type.base base.type.Z)) =>
                         match a with
                         | Some x' =>
                             if args =? 2 ^ Z.log2 args
                             then
                              Some
                                (UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 args) args1)%expr @
                                    (x1, x' v))%expr_pat)
                             else None
                         | None => None
                         end)
                  | (s1 -> d1)%ptype =>
                      fun _ : value' false s1 -> value' true d1 => None
                  end (reflect x3)
              | _ => None
              end
          | (@expr.App _ _ _ s0 _ ($_)%expr _ @ _)%expr_pat |
            (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
            (@expr.App _ _ _ s0 _ (_ @ _) _ @ _)%expr_pat |
            (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
              None
          | _ => None
          end;;
          match x1 with
          | (@expr.App _ _ _ s0 _ (@expr.Ident _ _ _ t0 idc0) x3 @ x2)%expr_pat =>
              _ <- pattern.ident.invert_bind_args idc0 pident.Z_shiftr;
              match x2 with
              | @expr.Ident _ _ _ t1 idc1 =>
                  args1 <- pattern.ident.invert_bind_args idc1
                             pattern.ident.LiteralZ;
                  match
                    s0 as t2
                    return
                      (value' false t2 ->
                       option
                         (UnderLets.UnderLets base.type ident var
                            (defaults.expr
                               (type.base (base.type.Z * base.type.Z)%etype))))
                  with
                  | type.base t2 =>
                      fun v : defaults.expr (type.base t2) =>
                      base.try_make_transport_cps t2 base.type.Z
                        (fun
                           a : option
                                 (defaults.expr (type.base t2) ->
                                  defaults.expr (type.base base.type.Z)) =>
                         match a with
                         | Some x' =>
                             if args =? 2 ^ Z.log2 args
                             then
                              Some
                                (UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 args) (- args1))%expr @
                                    (x0, x' v))%expr_pat)
                             else None
                         | None => None
                         end)
                  | (s1 -> d1)%ptype =>
                      fun _ : value' false s1 -> value' true d1 => None
                  end (reflect x3)
              | _ => None
              end
          | (@expr.App _ _ _ s0 _ ($_)%expr _ @ _)%expr_pat |
            (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
            (@expr.App _ _ _ s0 _ (_ @ _) _ @ _)%expr_pat |
            (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
              None
          | _ => None
          end;;
          match x0 with
          | (@expr.App _ _ _ s0 _ (@expr.Ident _ _ _ t0 idc0) x3 @ x2)%expr_pat =>
              _ <- pattern.ident.invert_bind_args idc0 pident.Z_shiftr;
              match x2 with
              | @expr.Ident _ _ _ t1 idc1 =>
                  args1 <- pattern.ident.invert_bind_args idc1
                             pattern.ident.LiteralZ;
                  match
                    s0 as t2
                    return
                      (value' false t2 ->
                       option
                         (UnderLets.UnderLets base.type ident var
                            (defaults.expr
                               (type.base (base.type.Z * base.type.Z)%etype))))
                  with
                  | type.base t2 =>
                      fun v : defaults.expr (type.base t2) =>
                      base.try_make_transport_cps t2 base.type.Z
                        (fun
                           a : option
                                 (defaults.expr (type.base t2) ->
                                  defaults.expr (type.base base.type.Z)) =>
                         match a with
                         | Some x' =>
                             if args =? 2 ^ Z.log2 args
                             then
                              Some
                                (UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 args) (- args1))%expr @
                                    (x1, x' v))%expr_pat)
                             else None
                         | None => None
                         end)
                  | (s1 -> d1)%ptype =>
                      fun _ : value' false s1 -> value' true d1 => None
                  end (reflect x3)
              | _ => None
              end
          | (@expr.App _ _ _ s0 _ ($_)%expr _ @ _)%expr_pat |
            (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
            (@expr.App _ _ _ s0 _ (_ @ _) _ @ _)%expr_pat |
            (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
              None
          | _ => None
          end;;
          (if args =? 2 ^ Z.log2 args
           then
            Some
              (UnderLets.Base
                 (#(ident.fancy_add (Z.log2 args) 0)%expr @ (x0, x1))%expr_pat)
           else None)
      | _ => None
      end;;
      None);;;
     UnderLets.Base (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat)%option
| ident.Z_add_with_carry =>
    fun x x0 x1 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_add_with_carry)%expr @ x @ x0 @ x1)%expr_pat
| ident.Z_add_with_get_carry =>
    fun x x0 x1 x2 : defaults.expr (type.base base.type.Z) =>
    ((match x with
      | @expr.Ident _ _ _ t idc =>
          args <- pattern.ident.invert_bind_args idc pattern.ident.LiteralZ;
          match x2 with
          | (@expr.App _ _ _ s0 _ (@expr.Ident _ _ _ t0 idc0) x4 @ x3)%expr_pat =>
              _ <- pattern.ident.invert_bind_args idc0 pident.Z_shiftl;
              match x3 with
              | @expr.Ident _ _ _ t1 idc1 =>
                  args1 <- pattern.ident.invert_bind_args idc1
                             pattern.ident.LiteralZ;
                  match
                    s0 as t2
                    return
                      (value' false t2 ->
                       option
                         (UnderLets.UnderLets base.type ident var
                            (defaults.expr
                               (type.base (base.type.Z * base.type.Z)%etype))))
                  with
                  | type.base t2 =>
                      fun v : defaults.expr (type.base t2) =>
                      base.try_make_transport_cps t2 base.type.Z
                        (fun
                           a : option
                                 (defaults.expr (type.base t2) ->
                                  defaults.expr (type.base base.type.Z)) =>
                         match a with
                         | Some x' =>
                             if args =? 2 ^ Z.log2 args
                             then
                              Some
                                (UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 args) args1)%expr @
                                    (x0, x1, x' v))%expr_pat)
                             else None
                         | None => None
                         end)
                  | (s1 -> d1)%ptype =>
                      fun _ : value' false s1 -> value' true d1 => None
                  end (reflect x4)
              | _ => None
              end
          | (@expr.App _ _ _ s0 _ ($_)%expr _ @ _)%expr_pat |
            (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
            (@expr.App _ _ _ s0 _ (_ @ _) _ @ _)%expr_pat |
            (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
              None
          | _ => None
          end;;
          match x1 with
          | (@expr.App _ _ _ s0 _ (@expr.Ident _ _ _ t0 idc0) x4 @ x3)%expr_pat =>
              _ <- pattern.ident.invert_bind_args idc0 pident.Z_shiftl;
              match x3 with
              | @expr.Ident _ _ _ t1 idc1 =>
                  args1 <- pattern.ident.invert_bind_args idc1
                             pattern.ident.LiteralZ;
                  match
                    s0 as t2
                    return
                      (value' false t2 ->
                       option
                         (UnderLets.UnderLets base.type ident var
                            (defaults.expr
                               (type.base (base.type.Z * base.type.Z)%etype))))
                  with
                  | type.base t2 =>
                      fun v : defaults.expr (type.base t2) =>
                      base.try_make_transport_cps t2 base.type.Z
                        (fun
                           a : option
                                 (defaults.expr (type.base t2) ->
                                  defaults.expr (type.base base.type.Z)) =>
                         match a with
                         | Some x' =>
                             if args =? 2 ^ Z.log2 args
                             then
                              Some
                                (UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 args) args1)%expr @
                                    (x0, x2, x' v))%expr_pat)
                             else None
                         | None => None
                         end)
                  | (s1 -> d1)%ptype =>
                      fun _ : value' false s1 -> value' true d1 => None
                  end (reflect x4)
              | _ => None
              end
          | (@expr.App _ _ _ s0 _ ($_)%expr _ @ _)%expr_pat |
            (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
            (@expr.App _ _ _ s0 _ (_ @ _) _ @ _)%expr_pat |
            (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
              None
          | _ => None
          end;;
          match x2 with
          | (@expr.App _ _ _ s0 _ (@expr.Ident _ _ _ t0 idc0) x4 @ x3)%expr_pat =>
              _ <- pattern.ident.invert_bind_args idc0 pident.Z_shiftr;
              match x3 with
              | @expr.Ident _ _ _ t1 idc1 =>
                  args1 <- pattern.ident.invert_bind_args idc1
                             pattern.ident.LiteralZ;
                  match
                    s0 as t2
                    return
                      (value' false t2 ->
                       option
                         (UnderLets.UnderLets base.type ident var
                            (defaults.expr
                               (type.base (base.type.Z * base.type.Z)%etype))))
                  with
                  | type.base t2 =>
                      fun v : defaults.expr (type.base t2) =>
                      base.try_make_transport_cps t2 base.type.Z
                        (fun
                           a : option
                                 (defaults.expr (type.base t2) ->
                                  defaults.expr (type.base base.type.Z)) =>
                         match a with
                         | Some x' =>
                             if args =? 2 ^ Z.log2 args
                             then
                              Some
                                (UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 args)
                                        (- args1))%expr @ (x0, x1, x' v))%expr_pat)
                             else None
                         | None => None
                         end)
                  | (s1 -> d1)%ptype =>
                      fun _ : value' false s1 -> value' true d1 => None
                  end (reflect x4)
              | _ => None
              end
          | (@expr.App _ _ _ s0 _ ($_)%expr _ @ _)%expr_pat |
            (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
            (@expr.App _ _ _ s0 _ (_ @ _) _ @ _)%expr_pat |
            (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
              None
          | _ => None
          end;;
          match x1 with
          | (@expr.App _ _ _ s0 _ (@expr.Ident _ _ _ t0 idc0) x4 @ x3)%expr_pat =>
              _ <- pattern.ident.invert_bind_args idc0 pident.Z_shiftr;
              match x3 with
              | @expr.Ident _ _ _ t1 idc1 =>
                  args1 <- pattern.ident.invert_bind_args idc1
                             pattern.ident.LiteralZ;
                  match
                    s0 as t2
                    return
                      (value' false t2 ->
                       option
                         (UnderLets.UnderLets base.type ident var
                            (defaults.expr
                               (type.base (base.type.Z * base.type.Z)%etype))))
                  with
                  | type.base t2 =>
                      fun v : defaults.expr (type.base t2) =>
                      base.try_make_transport_cps t2 base.type.Z
                        (fun
                           a : option
                                 (defaults.expr (type.base t2) ->
                                  defaults.expr (type.base base.type.Z)) =>
                         match a with
                         | Some x' =>
                             if args =? 2 ^ Z.log2 args
                             then
                              Some
                                (UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 args)
                                        (- args1))%expr @ (x0, x2, x' v))%expr_pat)
                             else None
                         | None => None
                         end)
                  | (s1 -> d1)%ptype =>
                      fun _ : value' false s1 -> value' true d1 => None
                  end (reflect x4)
              | _ => None
              end
          | (@expr.App _ _ _ s0 _ ($_)%expr _ @ _)%expr_pat |
            (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
            (@expr.App _ _ _ s0 _ (_ @ _) _ @ _)%expr_pat |
            (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
              None
          | _ => None
          end;;
          (if args =? 2 ^ Z.log2 args
           then
            Some
              (UnderLets.Base
                 (#(ident.fancy_addc (Z.log2 args) 0)%expr @ (x0, x1, x2))%expr_pat)
           else None)
      | _ => None
      end;;
      None);;;
     UnderLets.Base
       (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat)%option
| ident.Z_sub_get_borrow =>
    fun x x0 x1 : defaults.expr (type.base base.type.Z) =>
    ((match x with
      | @expr.Ident _ _ _ t idc =>
          args <- pattern.ident.invert_bind_args idc pattern.ident.LiteralZ;
          match x1 with
          | (@expr.App _ _ _ s0 _ (@expr.Ident _ _ _ t0 idc0) x3 @ x2)%expr_pat =>
              (_ <- pattern.ident.invert_bind_args idc0 pident.Z_shiftl;
               match x2 with
               | @expr.Ident _ _ _ t1 idc1 =>
                   args1 <- pattern.ident.invert_bind_args idc1
                              pattern.ident.LiteralZ;
                   match
                     s0 as t2
                     return
                       (value' false t2 ->
                        option
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr
                                (type.base (base.type.Z * base.type.Z)%etype))))
                   with
                   | type.base t2 =>
                       fun v : defaults.expr (type.base t2) =>
                       base.try_make_transport_cps t2 base.type.Z
                         (fun
                            a : option
                                  (defaults.expr (type.base t2) ->
                                   defaults.expr (type.base base.type.Z)) =>
                          match a with
                          | Some x' =>
                              if args =? 2 ^ Z.log2 args
                              then
                               Some
                                 (UnderLets.Base
                                    (#(ident.fancy_sub (Z.log2 args) args1)%expr @
                                     (x0, x' v))%expr_pat)
                              else None
                          | None => None
                          end)
                   | (s1 -> d1)%ptype =>
                       fun _ : value' false s1 -> value' true d1 => None
                   end (reflect x3)
               | _ => None
               end);;
              _ <- pattern.ident.invert_bind_args idc0 pident.Z_shiftr;
              match x2 with
              | @expr.Ident _ _ _ t1 idc1 =>
                  args1 <- pattern.ident.invert_bind_args idc1
                             pattern.ident.LiteralZ;
                  match
                    s0 as t2
                    return
                      (value' false t2 ->
                       option
                         (UnderLets.UnderLets base.type ident var
                            (defaults.expr
                               (type.base (base.type.Z * base.type.Z)%etype))))
                  with
                  | type.base t2 =>
                      fun v : defaults.expr (type.base t2) =>
                      base.try_make_transport_cps t2 base.type.Z
                        (fun
                           a : option
                                 (defaults.expr (type.base t2) ->
                                  defaults.expr (type.base base.type.Z)) =>
                         match a with
                         | Some x' =>
                             if args =? 2 ^ Z.log2 args
                             then
                              Some
                                (UnderLets.Base
                                   (#(ident.fancy_sub (Z.log2 args) (- args1))%expr @
                                    (x0, x' v))%expr_pat)
                             else None
                         | None => None
                         end)
                  | (s1 -> d1)%ptype =>
                      fun _ : value' false s1 -> value' true d1 => None
                  end (reflect x3)
              | _ => None
              end
          | (@expr.App _ _ _ s0 _ ($_)%expr _ @ _)%expr_pat |
            (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
            (@expr.App _ _ _ s0 _ (_ @ _) _ @ _)%expr_pat |
            (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
              None
          | _ => None
          end;;
          (if args =? 2 ^ Z.log2 args
           then
            Some
              (UnderLets.Base
                 (#(ident.fancy_sub (Z.log2 args) 0)%expr @ (x0, x1))%expr_pat)
           else None)
      | _ => None
      end;;
      None);;;
     UnderLets.Base (#(ident.Z_sub_get_borrow)%expr @ x @ x0 @ x1)%expr_pat)%option
| ident.Z_sub_with_get_borrow =>
    fun x x0 x1 x2 : defaults.expr (type.base base.type.Z) =>
    ((match x with
      | @expr.Ident _ _ _ t idc =>
          args <- pattern.ident.invert_bind_args idc pattern.ident.LiteralZ;
          match x2 with
          | (@expr.App _ _ _ s0 _ (@expr.Ident _ _ _ t0 idc0) x4 @ x3)%expr_pat =>
              (_ <- pattern.ident.invert_bind_args idc0 pident.Z_shiftl;
               match x3 with
               | @expr.Ident _ _ _ t1 idc1 =>
                   args1 <- pattern.ident.invert_bind_args idc1
                              pattern.ident.LiteralZ;
                   match
                     s0 as t2
                     return
                       (value' false t2 ->
                        option
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr
                                (type.base (base.type.Z * base.type.Z)%etype))))
                   with
                   | type.base t2 =>
                       fun v : defaults.expr (type.base t2) =>
                       base.try_make_transport_cps t2 base.type.Z
                         (fun
                            a : option
                                  (defaults.expr (type.base t2) ->
                                   defaults.expr (type.base base.type.Z)) =>
                          match a with
                          | Some x' =>
                              if args =? 2 ^ Z.log2 args
                              then
                               Some
                                 (UnderLets.Base
                                    (#(ident.fancy_subb (Z.log2 args) args1)%expr @
                                     (x0, x1, x' v))%expr_pat)
                              else None
                          | None => None
                          end)
                   | (s1 -> d1)%ptype =>
                       fun _ : value' false s1 -> value' true d1 => None
                   end (reflect x4)
               | _ => None
               end);;
              _ <- pattern.ident.invert_bind_args idc0 pident.Z_shiftr;
              match x3 with
              | @expr.Ident _ _ _ t1 idc1 =>
                  args1 <- pattern.ident.invert_bind_args idc1
                             pattern.ident.LiteralZ;
                  match
                    s0 as t2
                    return
                      (value' false t2 ->
                       option
                         (UnderLets.UnderLets base.type ident var
                            (defaults.expr
                               (type.base (base.type.Z * base.type.Z)%etype))))
                  with
                  | type.base t2 =>
                      fun v : defaults.expr (type.base t2) =>
                      base.try_make_transport_cps t2 base.type.Z
                        (fun
                           a : option
                                 (defaults.expr (type.base t2) ->
                                  defaults.expr (type.base base.type.Z)) =>
                         match a with
                         | Some x' =>
                             if args =? 2 ^ Z.log2 args
                             then
                              Some
                                (UnderLets.Base
                                   (#(ident.fancy_subb (Z.log2 args)
                                        (- args1))%expr @ (x0, x1, x' v))%expr_pat)
                             else None
                         | None => None
                         end)
                  | (s1 -> d1)%ptype =>
                      fun _ : value' false s1 -> value' true d1 => None
                  end (reflect x4)
              | _ => None
              end
          | (@expr.App _ _ _ s0 _ ($_)%expr _ @ _)%expr_pat |
            (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
            (@expr.App _ _ _ s0 _ (_ @ _) _ @ _)%expr_pat |
            (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
              None
          | _ => None
          end;;
          (if args =? 2 ^ Z.log2 args
           then
            Some
              (UnderLets.Base
                 (#(ident.fancy_subb (Z.log2 args) 0)%expr @ (x0, x1, x2))%expr_pat)
           else None)
      | _ => None
      end;;
      None);;;
     UnderLets.Base
       (#(ident.Z_sub_with_get_borrow)%expr @ x @ x0 @ x1 @ x2)%expr_pat)%option
| ident.Z_zselect =>
    fun x x0 x1 : defaults.expr (type.base base.type.Z) =>
    (((match x with
       | @expr.App _ _ _ s _
         (@expr.App _ _ _ s0 _ (@expr.Ident _ _ _ t idc) x3) x2 =>
           (_ <- pattern.ident.invert_bind_args idc pident.Z_cc_m;
            match x3 with
            | @expr.Ident _ _ _ t0 idc0 =>
                args0 <- pattern.ident.invert_bind_args idc0
                           pattern.ident.LiteralZ;
                match
                  s as t2
                  return
                    (value' false t2 ->
                     option
                       (UnderLets.UnderLets base.type ident var
                          (defaults.expr (type.base base.type.Z))))
                with
                | type.base t2 =>
                    fun v : defaults.expr (type.base t2) =>
                    base.try_make_transport_cps t2 base.type.Z
                      (fun
                         a : option
                               (defaults.expr (type.base t2) ->
                                defaults.expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' =>
                           if args0 =? 2 ^ Z.log2 args0
                           then
                            Some
                              (UnderLets.Base
                                 (#(ident.fancy_selm (Z.log2 args0))%expr @
                                  (x' v, x0, x1))%expr_pat)
                           else None
                       | None => None
                       end)
                | (s1 -> d1)%ptype =>
                    fun _ : value' false s1 -> value' true d1 => None
                end (reflect x2)
            | _ => None
            end);;
           _ <- pattern.ident.invert_bind_args idc pident.Z_land;
           match x3 with
           | @expr.Ident _ _ _ t0 idc0 =>
               args0 <- pattern.ident.invert_bind_args idc0
                          pattern.ident.LiteralZ;
               match
                 s as t2
                 return
                   (value' false t2 ->
                    option
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr (type.base base.type.Z))))
               with
               | type.base t2 =>
                   fun v : defaults.expr (type.base t2) =>
                   base.try_make_transport_cps t2 base.type.Z
                     (fun
                        a : option
                              (defaults.expr (type.base t2) ->
                               defaults.expr (type.base base.type.Z)) =>
                      match a with
                      | Some x' =>
                          if args0 =? 1
                          then
                           Some
                             (UnderLets.Base
                                (#(ident.fancy_sell)%expr @ (x' v, x0, x1))%expr_pat)
                          else None
                      | None => None
                      end)
               | (s1 -> d1)%ptype =>
                   fun _ : value' false s1 -> value' true d1 => None
               end (reflect x2)
           | _ => None
           end;;
           match x2 with
           | @expr.Ident _ _ _ t0 idc0 =>
               args0 <- pattern.ident.invert_bind_args idc0
                          pattern.ident.LiteralZ;
               match
                 s0 as t2
                 return
                   (value' false t2 ->
                    option
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr (type.base base.type.Z))))
               with
               | type.base t2 =>
                   fun v : defaults.expr (type.base t2) =>
                   base.try_make_transport_cps t2 base.type.Z
                     (fun
                        a : option
                              (defaults.expr (type.base t2) ->
                               defaults.expr (type.base base.type.Z)) =>
                      match a with
                      | Some x' =>
                          if args0 =? 1
                          then
                           Some
                             (UnderLets.Base
                                (#(ident.fancy_sell)%expr @ (x' v, x0, x1))%expr_pat)
                          else None
                      | None => None
                      end)
               | (s1 -> d1)%ptype =>
                   fun _ : value' false s1 -> value' true d1 => None
               end (reflect x3)
           | _ => None
           end
       | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ ($_)%expr _) _ | @expr.App
         _ _ _ s _ (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _) _ |
         @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ (_ @ _)%expr_pat _) _ |
         @expr.App _ _ _ s _
         (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _) _ => None
       | @expr.App _ _ _ s _ #(_)%expr_pat _ | @expr.App _ _ _ s _ ($_)%expr
         _ | @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _
         s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
       | _ => None
       end;;
       Some
         (UnderLets.Base (#(ident.fancy_selc)%expr @ (x, x0, x1))%expr_pat));;
      None);;;
     UnderLets.Base (#(ident.Z_zselect)%expr @ x @ x0 @ x1)%expr_pat)%option
| ident.Z_add_modulo =>
    fun x x0 x1 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.fancy_addm)%expr @ (x, x0, x1))%expr_pat
| ident.Z_rshi =>
    fun x x0 x1 x2 : defaults.expr (type.base base.type.Z) =>
    (match x with
     | @expr.Ident _ _ _ t idc =>
         args <- pattern.ident.invert_bind_args idc pattern.ident.LiteralZ;
         match x2 with
         | @expr.Ident _ _ _ t0 idc0 =>
             args0 <- pattern.ident.invert_bind_args idc0
                        pattern.ident.LiteralZ;
             (if args =? 2 ^ Z.log2 args
              then
               Some
                 (UnderLets.Base
                    (#(ident.fancy_rshi (Z.log2 args) args0)%expr @ (x0, x1))%expr_pat)
              else None)
         | _ => None
         end
     | _ => None
     end;;;
     UnderLets.Base (#(ident.Z_rshi)%expr @ x @ x0 @ x1 @ x2)%expr_pat)%option
| ident.Z_cc_m =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_cc_m)%expr @ x @ x0)%expr_pat
| ident.Z_cast range =>
    fun x : defaults.expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_cast range)%expr @ x)%expr_pat
| ident.Z_cast2 range =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.Z_cast2 range)%expr @ x)%expr_pat
| ident.fancy_add log2wordmax imm =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_add log2wordmax imm)%expr @ x)%expr_pat
| ident.fancy_addc log2wordmax imm =>
    fun
      x : defaults.expr
            (type.base (base.type.Z * base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_addc log2wordmax imm)%expr @ x)%expr_pat
| ident.fancy_sub log2wordmax imm =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_sub log2wordmax imm)%expr @ x)%expr_pat
| ident.fancy_subb log2wordmax imm =>
    fun
      x : defaults.expr
            (type.base (base.type.Z * base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_subb log2wordmax imm)%expr @ x)%expr_pat
| ident.fancy_mulll log2wordmax =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_mulll log2wordmax)%expr @ x)%expr_pat
| ident.fancy_mullh log2wordmax =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_mullh log2wordmax)%expr @ x)%expr_pat
| ident.fancy_mulhl log2wordmax =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_mulhl log2wordmax)%expr @ x)%expr_pat
| ident.fancy_mulhh log2wordmax =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_mulhh log2wordmax)%expr @ x)%expr_pat
| ident.fancy_rshi log2wordmax x =>
    fun x0 : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_rshi log2wordmax x)%expr @ x0)%expr_pat
| ident.fancy_selc =>
    fun
      x : defaults.expr
            (type.base (base.type.Z * base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_selc)%expr @ x)%expr_pat
| ident.fancy_selm log2wordmax =>
    fun
      x : defaults.expr
            (type.base (base.type.Z * base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_selm log2wordmax)%expr @ x)%expr_pat
| ident.fancy_sell =>
    fun
      x : defaults.expr
            (type.base (base.type.Z * base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_sell)%expr @ x)%expr_pat
| ident.fancy_addm =>
    fun
      x : defaults.expr
            (type.base (base.type.Z * base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_addm)%expr @ x)%expr_pat
end
     : value' true t
