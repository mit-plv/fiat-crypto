fancy_rewrite_head = 
match idc in (ident t) return (Compile.value' true t) with
| @ident.Literal t v =>
    match
      t as t0
      return
        (base.base_interp t0 ->
         UnderLets.UnderLets base.type ident var (expr (type.base t0)))
    with
    | base.type.unit => fun v0 : unit => UnderLets.Base ##(v0)%expr
    | base.type.Z => fun v0 : Z => UnderLets.Base ##(v0)%expr
    | base.type.bool => fun v0 : bool => UnderLets.Base ##(v0)%expr
    | base.type.nat => fun v0 : nat => UnderLets.Base ##(v0)%expr
    end v
| ident.Nat_succ =>
    fun x : expr (type.base base.type.nat) =>
    UnderLets.Base (#(ident.Nat_succ)%expr @ x)%expr_pat
| ident.Nat_pred =>
    fun x : expr (type.base base.type.nat) =>
    UnderLets.Base (#(ident.Nat_pred)%expr @ x)%expr_pat
| ident.Nat_max =>
    fun x x0 : expr (type.base base.type.nat) =>
    UnderLets.Base (#(ident.Nat_max)%expr @ x @ x0)%expr_pat
| ident.Nat_mul =>
    fun x x0 : expr (type.base base.type.nat) =>
    UnderLets.Base (#(ident.Nat_mul)%expr @ x @ x0)%expr_pat
| ident.Nat_add =>
    fun x x0 : expr (type.base base.type.nat) =>
    UnderLets.Base (#(ident.Nat_add)%expr @ x @ x0)%expr_pat
| ident.Nat_sub =>
    fun x x0 : expr (type.base base.type.nat) =>
    UnderLets.Base (#(ident.Nat_sub)%expr @ x @ x0)%expr_pat
| @ident.nil t => UnderLets.Base []%expr_pat
| @ident.cons t =>
    fun (x : expr (type.base t)) (x0 : expr (type.base (base.type.list t)))
    => UnderLets.Base (x :: x0)%expr_pat
| @ident.pair A B =>
    fun (x : expr (type.base A)) (x0 : expr (type.base B)) =>
    UnderLets.Base (x, x0)%expr_pat
| @ident.fst A B =>
    fun x : expr (type.base (A * B)%etype) =>
    UnderLets.Base (#(ident.fst)%expr @ x)%expr_pat
| @ident.snd A B =>
    fun x : expr (type.base (A * B)%etype) =>
    UnderLets.Base (#(ident.snd)%expr @ x)%expr_pat
| @ident.prod_rect A B T =>
    fun
      (x : expr (type.base A) ->
           expr (type.base B) ->
           UnderLets.UnderLets base.type ident var (expr (type.base T)))
      (x0 : expr (type.base (A * B)%etype)) =>
    UnderLets.Base
      (#(ident.prod_rect)%expr @
       (λ (x1 : var (type.base A))(x2 : var (type.base B)),
        UnderLets.to_expr (x ($x1) ($x2)))%expr @ x0)%expr_pat
| @ident.bool_rect T =>
    fun
      (x
       x0 : expr (type.base base.type.unit) ->
            UnderLets.UnderLets base.type ident var (expr (type.base T)))
      (x1 : expr (type.base base.type.bool)) =>
    UnderLets.Base
      (#(ident.bool_rect)%expr @
       (λ x2 : var (type.base base.type.unit),
        UnderLets.to_expr (x ($x2)))%expr @
       (λ x2 : var (type.base base.type.unit),
        UnderLets.to_expr (x0 ($x2)))%expr @ x1)%expr_pat
| @ident.nat_rect P =>
    fun
      (x : expr (type.base base.type.unit) ->
           UnderLets.UnderLets base.type ident var (expr (type.base P)))
      (x0 : expr (type.base base.type.nat) ->
            expr (type.base P) ->
            UnderLets.UnderLets base.type ident var (expr (type.base P)))
      (x1 : expr (type.base base.type.nat)) =>
    UnderLets.Base
      (#(ident.nat_rect)%expr @
       (λ x2 : var (type.base base.type.unit),
        UnderLets.to_expr (x ($x2)))%expr @
       (λ (x2 : var (type.base base.type.nat))(x3 : var (type.base P)),
        UnderLets.to_expr (x0 ($x2) ($x3)))%expr @ x1)%expr_pat
| @ident.list_rect A P =>
    fun
      (x : expr (type.base base.type.unit) ->
           UnderLets.UnderLets base.type ident var (expr (type.base P)))
      (x0 : expr (type.base A) ->
            expr (type.base (base.type.list A)) ->
            expr (type.base P) ->
            UnderLets.UnderLets base.type ident var (expr (type.base P)))
      (x1 : expr (type.base (base.type.list A))) =>
    UnderLets.Base
      (#(ident.list_rect)%expr @
       (λ x2 : var (type.base base.type.unit),
        UnderLets.to_expr (x ($x2)))%expr @
       (λ (x2 : var (type.base A))(x3 : var (type.base (base.type.list A)))
        (x4 : var (type.base P)),
        UnderLets.to_expr (x0 ($x2) ($x3) ($x4)))%expr @ x1)%expr_pat
| @ident.list_case A P =>
    fun
      (x : expr (type.base base.type.unit) ->
           UnderLets.UnderLets base.type ident var (expr (type.base P)))
      (x0 : expr (type.base A) ->
            expr (type.base (base.type.list A)) ->
            UnderLets.UnderLets base.type ident var (expr (type.base P)))
      (x1 : expr (type.base (base.type.list A))) =>
    UnderLets.Base
      (#(ident.list_case)%expr @
       (λ x2 : var (type.base base.type.unit),
        UnderLets.to_expr (x ($x2)))%expr @
       (λ (x2 : var (type.base A))(x3 : var (type.base (base.type.list A))),
        UnderLets.to_expr (x0 ($x2) ($x3)))%expr @ x1)%expr_pat
| @ident.List_length T =>
    fun x : expr (type.base (base.type.list T)) =>
    UnderLets.Base (#(ident.List_length)%expr @ x)%expr_pat
| ident.List_seq =>
    fun x x0 : expr (type.base base.type.nat) =>
    UnderLets.Base (#(ident.List_seq)%expr @ x @ x0)%expr_pat
| @ident.List_repeat A =>
    fun (x : expr (type.base A)) (x0 : expr (type.base base.type.nat)) =>
    UnderLets.Base (#(ident.List_repeat)%expr @ x @ x0)%expr_pat
| @ident.List_combine A B =>
    fun (x : expr (type.base (base.type.list A)))
      (x0 : expr (type.base (base.type.list B))) =>
    UnderLets.Base (#(ident.List_combine)%expr @ x @ x0)%expr_pat
| @ident.List_map A B =>
    fun
      (x : expr (type.base A) ->
           UnderLets.UnderLets base.type ident var (expr (type.base B)))
      (x0 : expr (type.base (base.type.list A))) =>
    UnderLets.Base
      (#(ident.List_map)%expr @
       (λ x1 : var (type.base A),
        UnderLets.to_expr (x ($x1)))%expr @ x0)%expr_pat
| @ident.List_app A =>
    fun x x0 : expr (type.base (base.type.list A)) =>
    UnderLets.Base (x ++ x0)%expr
| @ident.List_rev A =>
    fun x : expr (type.base (base.type.list A)) =>
    UnderLets.Base (#(ident.List_rev)%expr @ x)%expr_pat
| @ident.List_flat_map A B =>
    fun
      (x : expr (type.base A) ->
           UnderLets.UnderLets base.type ident var
             (expr (type.base (base.type.list B))))
      (x0 : expr (type.base (base.type.list A))) =>
    UnderLets.Base
      (#(ident.List_flat_map)%expr @
       (λ x1 : var (type.base A),
        UnderLets.to_expr (x ($x1)))%expr @ x0)%expr_pat
| @ident.List_partition A =>
    fun
      (x : expr (type.base A) ->
           UnderLets.UnderLets base.type ident var
             (expr (type.base base.type.bool)))
      (x0 : expr (type.base (base.type.list A))) =>
    UnderLets.Base
      (#(ident.List_partition)%expr @
       (λ x1 : var (type.base A),
        UnderLets.to_expr (x ($x1)))%expr @ x0)%expr_pat
| @ident.List_fold_right A B =>
    fun
      (x : expr (type.base B) ->
           expr (type.base A) ->
           UnderLets.UnderLets base.type ident var (expr (type.base A)))
      (x0 : expr (type.base A)) (x1 : expr (type.base (base.type.list B))) =>
    UnderLets.Base
      (#(ident.List_fold_right)%expr @
       (λ (x2 : var (type.base B))(x3 : var (type.base A)),
        UnderLets.to_expr (x ($x2) ($x3)))%expr @ x0 @ x1)%expr_pat
| @ident.List_update_nth T =>
    fun (x : expr (type.base base.type.nat))
      (x0 : expr (type.base T) ->
            UnderLets.UnderLets base.type ident var (expr (type.base T)))
      (x1 : expr (type.base (base.type.list T))) =>
    UnderLets.Base
      (#(ident.List_update_nth)%expr @ x @
       (λ x2 : var (type.base T),
        UnderLets.to_expr (x0 ($x2)))%expr @ x1)%expr_pat
| @ident.List_nth_default T =>
    fun (x : expr (type.base T)) (x0 : expr (type.base (base.type.list T)))
      (x1 : expr (type.base base.type.nat)) =>
    UnderLets.Base (#(ident.List_nth_default)%expr @ x @ x0 @ x1)%expr_pat
| ident.Z_add =>
    fun x x0 : expr (type.base base.type.Z) => UnderLets.Base (x + x0)%expr
| ident.Z_mul =>
    fun x x0 : expr (type.base base.type.Z) =>
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            match x0 with
            | @expr.App _ _ _ s _ #(idc0)%expr_pat x1 =>
                match
                  match idc0 with
                  | ident.Z_land mask => Some mask
                  | _ => None
                  end
                with
                | Some args0 =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => expr (type.base t1)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               if args0 =? 2 ^ (2 * Z.log2_up args0 / 2) - 1
                               then
                                match
                                  invert_low (2 * Z.log2_up args0) args
                                with
                                | Some x2 =>
                                    UnderLets.Base
                                      (#(ident.fancy_mulll
                                           (2 * Z.log2_up args0))%expr @
                                       (##(x2)%expr, x' v))%expr_pat
                                | None =>
                                    match
                                      s as t3
                                      return
                                        (Compile.value' false t3 ->
                                         UnderLets.UnderLets base.type ident
                                           var (expr (type.base base.type.Z)))
                                    with
                                    | type.base t3 =>
                                        fun v0 : expr (type.base t3) =>
                                        base.try_make_transport_cps
                                          (fun t1 : base.type =>
                                           expr (type.base t1)) t3
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (expr (type.base base.type.Z)))
                                          (fun
                                             a0 : option
                                                    (expr (type.base t3) ->
                                                     expr
                                                       (type.base base.type.Z))
                                           =>
                                           match a0 with
                                           | Some x'0 =>
                                               if
                                                args0 =?
                                                2 ^ (2 * Z.log2_up args0 / 2) -
                                                1
                                               then
                                                match
                                                  invert_high
                                                    (2 * Z.log2_up args0)
                                                    args
                                                with
                                                | Some x2 =>
                                                    UnderLets.Base
                                                      (#(ident.fancy_mulhl
                                                           (2 *
                                                            Z.log2_up args0))%expr @
                                                       (##(x2)%expr, x'0 v0))%expr_pat
                                                | None =>
                                                    UnderLets.Base
                                                      (x * x0)%expr
                                                end
                                               else
                                                UnderLets.Base (x * x0)%expr
                                           | None =>
                                               UnderLets.Base (x * x0)%expr
                                           end)
                                    | (s0 -> d0)%ptype =>
                                        fun
                                          _ : Compile.value' false s0 ->
                                              Compile.value' true d0 =>
                                        UnderLets.Base (x * x0)%expr
                                    end (Compile.reflect x1)
                                end
                               else
                                match
                                  s as t3
                                  return
                                    (Compile.value' false t3 ->
                                     UnderLets.UnderLets base.type ident var
                                       (expr (type.base base.type.Z)))
                                with
                                | type.base t3 =>
                                    fun v0 : expr (type.base t3) =>
                                    base.try_make_transport_cps
                                      (fun t1 : base.type =>
                                       expr (type.base t1)) t3 base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var (expr (type.base base.type.Z)))
                                      (fun
                                         a0 : option
                                                (expr (type.base t3) ->
                                                 expr (type.base base.type.Z))
                                       =>
                                       match a0 with
                                       | Some x'0 =>
                                           if
                                            args0 =?
                                            2 ^ (2 * Z.log2_up args0 / 2) - 1
                                           then
                                            match
                                              invert_high
                                                (2 * Z.log2_up args0) args
                                            with
                                            | Some x2 =>
                                                UnderLets.Base
                                                  (#(ident.fancy_mulhl
                                                       (2 * Z.log2_up args0))%expr @
                                                   (##(x2)%expr, x'0 v0))%expr_pat
                                            | None =>
                                                UnderLets.Base (x * x0)%expr
                                            end
                                           else UnderLets.Base (x * x0)%expr
                                       | None => UnderLets.Base (x * x0)%expr
                                       end)
                                | (s0 -> d0)%ptype =>
                                    fun
                                      _ : Compile.value' false s0 ->
                                          Compile.value' true d0 =>
                                    UnderLets.Base (x * x0)%expr
                                end (Compile.reflect x1)
                           | None => UnderLets.Base (x * x0)%expr
                           end)
                    | (s0 -> d0)%ptype =>
                        fun
                          _ : Compile.value' false s0 ->
                              Compile.value' true d0 =>
                        UnderLets.Base (x * x0)%expr
                    end (Compile.reflect x1)
                | None =>
                    match
                      match idc0 with
                      | ident.Z_shiftr offset => Some offset
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr (type.base base.type.Z)))
                        with
                        | type.base t2 =>
                            fun v : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type => expr (type.base t1)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr (type.base base.type.Z)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   match invert_low (2 * args0) args with
                                   | Some x2 =>
                                       UnderLets.Base
                                         (#(ident.fancy_mullh (2 * args0))%expr @
                                          (##(x2)%expr, x' v))%expr_pat
                                   | None =>
                                       match
                                         s as t3
                                         return
                                           (Compile.value' false t3 ->
                                            UnderLets.UnderLets base.type
                                              ident var
                                              (expr (type.base base.type.Z)))
                                       with
                                       | type.base t3 =>
                                           fun v0 : expr (type.base t3) =>
                                           base.try_make_transport_cps
                                             (fun t1 : base.type =>
                                              expr (type.base t1)) t3
                                             base.type.Z
                                             (UnderLets.UnderLets base.type
                                                ident var
                                                (expr (type.base base.type.Z)))
                                             (fun
                                                a0 : option
                                                       (expr (type.base t3) ->
                                                        expr
                                                          (type.base
                                                             base.type.Z)) =>
                                              match a0 with
                                              | Some x'0 =>
                                                  match
                                                    invert_high (2 * args0)
                                                      args
                                                  with
                                                  | Some x2 =>
                                                      UnderLets.Base
                                                        (#(ident.fancy_mulhh
                                                             (2 * args0))%expr @
                                                         (##(x2)%expr,
                                                         x'0 v0))%expr_pat
                                                  | None =>
                                                      UnderLets.Base
                                                        (x * x0)%expr
                                                  end
                                              | None =>
                                                  UnderLets.Base
                                                    (x * x0)%expr
                                              end)
                                       | (s0 -> d0)%ptype =>
                                           fun
                                             _ : Compile.value' false s0 ->
                                                 Compile.value' true d0 =>
                                           UnderLets.Base (x * x0)%expr
                                       end (Compile.reflect x1)
                                   end
                               | None => UnderLets.Base (x * x0)%expr
                               end)
                        | (s0 -> d0)%ptype =>
                            fun
                              _ : Compile.value' false s0 ->
                                  Compile.value' true d0 =>
                            UnderLets.Base (x * x0)%expr
                        end (Compile.reflect x1)
                    | None => UnderLets.Base (x * x0)%expr
                    end
                end
            | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
              (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _
              (_ @ _)%expr_pat _ | @expr.App _ _ _ s _
              (@expr.LetIn _ _ _ _ _ _ _) _ => UnderLets.Base (x * x0)%expr
            | _ => UnderLets.Base (x * x0)%expr
            end
        | None => UnderLets.Base (x * x0)%expr
        end
    | @expr.App _ _ _ s _ #(idc)%expr_pat x1 =>
        match
          match idc with
          | ident.Z_land mask => Some mask
          | _ => None
          end
        with
        | Some args =>
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => expr (type.base t1)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               if args =? 2 ^ (2 * Z.log2_up args / 2) - 1
                               then
                                match
                                  invert_low (2 * Z.log2_up args) args0
                                with
                                | Some y =>
                                    UnderLets.Base
                                      (#(ident.fancy_mulll
                                           (2 * Z.log2_up args))%expr @
                                       (x' v, ##(y)%expr))%expr_pat
                                | None =>
                                    match
                                      s as t3
                                      return
                                        (Compile.value' false t3 ->
                                         UnderLets.UnderLets base.type ident
                                           var (expr (type.base base.type.Z)))
                                    with
                                    | type.base t3 =>
                                        fun v0 : expr (type.base t3) =>
                                        base.try_make_transport_cps
                                          (fun t1 : base.type =>
                                           expr (type.base t1)) t3
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (expr (type.base base.type.Z)))
                                          (fun
                                             a0 : option
                                                    (expr (type.base t3) ->
                                                     expr
                                                       (type.base base.type.Z))
                                           =>
                                           match a0 with
                                           | Some x'0 =>
                                               if
                                                args =?
                                                2 ^ (2 * Z.log2_up args / 2) -
                                                1
                                               then
                                                match
                                                  invert_high
                                                    (2 * Z.log2_up args)
                                                    args0
                                                with
                                                | Some y =>
                                                    UnderLets.Base
                                                      (#(ident.fancy_mullh
                                                           (2 *
                                                            Z.log2_up args))%expr @
                                                       (x'0 v0, ##(y)%expr))%expr_pat
                                                | None =>
                                                    UnderLets.Base
                                                      (x * x0)%expr
                                                end
                                               else
                                                UnderLets.Base (x * x0)%expr
                                           | None =>
                                               UnderLets.Base (x * x0)%expr
                                           end)
                                    | (s0 -> d0)%ptype =>
                                        fun
                                          _ : Compile.value' false s0 ->
                                              Compile.value' true d0 =>
                                        UnderLets.Base (x * x0)%expr
                                    end (Compile.reflect x1)
                                end
                               else
                                match
                                  s as t3
                                  return
                                    (Compile.value' false t3 ->
                                     UnderLets.UnderLets base.type ident var
                                       (expr (type.base base.type.Z)))
                                with
                                | type.base t3 =>
                                    fun v0 : expr (type.base t3) =>
                                    base.try_make_transport_cps
                                      (fun t1 : base.type =>
                                       expr (type.base t1)) t3 base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var (expr (type.base base.type.Z)))
                                      (fun
                                         a0 : option
                                                (expr (type.base t3) ->
                                                 expr (type.base base.type.Z))
                                       =>
                                       match a0 with
                                       | Some x'0 =>
                                           if
                                            args =?
                                            2 ^ (2 * Z.log2_up args / 2) - 1
                                           then
                                            match
                                              invert_high
                                                (2 * Z.log2_up args) args0
                                            with
                                            | Some y =>
                                                UnderLets.Base
                                                  (#(ident.fancy_mullh
                                                       (2 * Z.log2_up args))%expr @
                                                   (x'0 v0, ##(y)%expr))%expr_pat
                                            | None =>
                                                UnderLets.Base (x * x0)%expr
                                            end
                                           else UnderLets.Base (x * x0)%expr
                                       | None => UnderLets.Base (x * x0)%expr
                                       end)
                                | (s0 -> d0)%ptype =>
                                    fun
                                      _ : Compile.value' false s0 ->
                                          Compile.value' true d0 =>
                                    UnderLets.Base (x * x0)%expr
                                end (Compile.reflect x1)
                           | None => UnderLets.Base (x * x0)%expr
                           end)
                    | (s0 -> d0)%ptype =>
                        fun
                          _ : Compile.value' false s0 ->
                              Compile.value' true d0 =>
                        UnderLets.Base (x * x0)%expr
                    end (Compile.reflect x1)
                | None => UnderLets.Base (x * x0)%expr
                end
            | @expr.App _ _ _ s0 _ #(idc0)%expr_pat x2 =>
                match
                  match idc0 with
                  | ident.Z_land mask => Some mask
                  | _ => None
                  end
                with
                | Some args0 =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => expr (type.base t1)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               match
                                 s0 as t3
                                 return
                                   (Compile.value' false t3 ->
                                    UnderLets.UnderLets base.type ident var
                                      (expr (type.base base.type.Z)))
                               with
                               | type.base t3 =>
                                   fun v0 : expr (type.base t3) =>
                                   base.try_make_transport_cps
                                     (fun t1 : base.type =>
                                      expr (type.base t1)) t3 base.type.Z
                                     (UnderLets.UnderLets base.type ident var
                                        (expr (type.base base.type.Z)))
                                     (fun
                                        a0 : option
                                               (expr (type.base t3) ->
                                                expr (type.base base.type.Z))
                                      =>
                                      match a0 with
                                      | Some x'0 =>
                                          if
                                           (args =?
                                            2 ^ (2 * Z.log2_up args / 2) - 1) &&
                                           (args0 =?
                                            2 ^ (2 * Z.log2_up args / 2) - 1)
                                          then
                                           UnderLets.Base
                                             (#(ident.fancy_mulll
                                                  (2 * Z.log2_up args))%expr @
                                              (x' v, x'0 v0))%expr_pat
                                          else UnderLets.Base (x * x0)%expr
                                      | None => UnderLets.Base (x * x0)%expr
                                      end)
                               | (s1 -> d1)%ptype =>
                                   fun
                                     _ : Compile.value' false s1 ->
                                         Compile.value' true d1 =>
                                   UnderLets.Base (x * x0)%expr
                               end (Compile.reflect x2)
                           | None => UnderLets.Base (x * x0)%expr
                           end)
                    | (s1 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d1 =>
                        UnderLets.Base (x * x0)%expr
                    end (Compile.reflect x1)
                | None =>
                    match
                      match idc0 with
                      | ident.Z_shiftr offset => Some offset
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr (type.base base.type.Z)))
                        with
                        | type.base t2 =>
                            fun v : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type => expr (type.base t1)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr (type.base base.type.Z)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   match
                                     s0 as t3
                                     return
                                       (Compile.value' false t3 ->
                                        UnderLets.UnderLets base.type ident
                                          var (expr (type.base base.type.Z)))
                                   with
                                   | type.base t3 =>
                                       fun v0 : expr (type.base t3) =>
                                       base.try_make_transport_cps
                                         (fun t1 : base.type =>
                                          expr (type.base t1)) t3 base.type.Z
                                         (UnderLets.UnderLets base.type ident
                                            var
                                            (expr (type.base base.type.Z)))
                                         (fun
                                            a0 : option
                                                   (expr (type.base t3) ->
                                                    expr
                                                      (type.base base.type.Z))
                                          =>
                                          match a0 with
                                          | Some x'0 =>
                                              if
                                               args =?
                                               2 ^ (2 * args0 / 2) - 1
                                              then
                                               UnderLets.Base
                                                 (#(ident.fancy_mullh
                                                      (2 * args0))%expr @
                                                  (x' v, x'0 v0))%expr_pat
                                              else
                                               UnderLets.Base (x * x0)%expr
                                          | None =>
                                              UnderLets.Base (x * x0)%expr
                                          end)
                                   | (s1 -> d1)%ptype =>
                                       fun
                                         _ : Compile.value' false s1 ->
                                             Compile.value' true d1 =>
                                       UnderLets.Base (x * x0)%expr
                                   end (Compile.reflect x2)
                               | None => UnderLets.Base (x * x0)%expr
                               end)
                        | (s1 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base (x * x0)%expr
                        end (Compile.reflect x1)
                    | None => UnderLets.Base (x * x0)%expr
                    end
                end
            | @expr.App _ _ _ s0 _ ($_)%expr _ | @expr.App _ _ _ s0 _
              (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0 _
              (_ @ _)%expr_pat _ | @expr.App _ _ _ s0 _
              (@expr.LetIn _ _ _ _ _ _ _) _ => UnderLets.Base (x * x0)%expr
            | _ => UnderLets.Base (x * x0)%expr
            end
        | None =>
            match
              match idc with
              | ident.Z_shiftr offset => Some offset
              | _ => None
              end
            with
            | Some args =>
                match x0 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t1 v =>
                          match
                            t1 as t2 return (base.base_interp t2 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v0 : Z => Some v0
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr (type.base base.type.Z)))
                        with
                        | type.base t2 =>
                            fun v : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type => expr (type.base t1)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr (type.base base.type.Z)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   match invert_low (2 * args) args0 with
                                   | Some y =>
                                       UnderLets.Base
                                         (#(ident.fancy_mulhl (2 * args))%expr @
                                          (x' v, ##(y)%expr))%expr_pat
                                   | None =>
                                       match
                                         s as t3
                                         return
                                           (Compile.value' false t3 ->
                                            UnderLets.UnderLets base.type
                                              ident var
                                              (expr (type.base base.type.Z)))
                                       with
                                       | type.base t3 =>
                                           fun v0 : expr (type.base t3) =>
                                           base.try_make_transport_cps
                                             (fun t1 : base.type =>
                                              expr (type.base t1)) t3
                                             base.type.Z
                                             (UnderLets.UnderLets base.type
                                                ident var
                                                (expr (type.base base.type.Z)))
                                             (fun
                                                a0 : option
                                                       (expr (type.base t3) ->
                                                        expr
                                                          (type.base
                                                             base.type.Z)) =>
                                              match a0 with
                                              | Some x'0 =>
                                                  match
                                                    invert_high (2 * args)
                                                      args0
                                                  with
                                                  | Some y =>
                                                      UnderLets.Base
                                                        (#(ident.fancy_mulhh
                                                             (2 * args))%expr @
                                                         (x'0 v0, ##(y)%expr))%expr_pat
                                                  | None =>
                                                      UnderLets.Base
                                                        (x * x0)%expr
                                                  end
                                              | None =>
                                                  UnderLets.Base
                                                    (x * x0)%expr
                                              end)
                                       | (s0 -> d0)%ptype =>
                                           fun
                                             _ : Compile.value' false s0 ->
                                                 Compile.value' true d0 =>
                                           UnderLets.Base (x * x0)%expr
                                       end (Compile.reflect x1)
                                   end
                               | None => UnderLets.Base (x * x0)%expr
                               end)
                        | (s0 -> d0)%ptype =>
                            fun
                              _ : Compile.value' false s0 ->
                                  Compile.value' true d0 =>
                            UnderLets.Base (x * x0)%expr
                        end (Compile.reflect x1)
                    | None => UnderLets.Base (x * x0)%expr
                    end
                | @expr.App _ _ _ s0 _ #(idc0)%expr_pat x2 =>
                    match
                      match idc0 with
                      | ident.Z_land mask => Some mask
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr (type.base base.type.Z)))
                        with
                        | type.base t2 =>
                            fun v : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type => expr (type.base t1)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr (type.base base.type.Z)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   match
                                     s0 as t3
                                     return
                                       (Compile.value' false t3 ->
                                        UnderLets.UnderLets base.type ident
                                          var (expr (type.base base.type.Z)))
                                   with
                                   | type.base t3 =>
                                       fun v0 : expr (type.base t3) =>
                                       base.try_make_transport_cps
                                         (fun t1 : base.type =>
                                          expr (type.base t1)) t3 base.type.Z
                                         (UnderLets.UnderLets base.type ident
                                            var
                                            (expr (type.base base.type.Z)))
                                         (fun
                                            a0 : option
                                                   (expr (type.base t3) ->
                                                    expr
                                                      (type.base base.type.Z))
                                          =>
                                          match a0 with
                                          | Some x'0 =>
                                              if
                                               args0 =?
                                               2 ^ (2 * args / 2) - 1
                                              then
                                               UnderLets.Base
                                                 (#(ident.fancy_mulhl
                                                      (2 * args))%expr @
                                                  (x' v, x'0 v0))%expr_pat
                                              else
                                               UnderLets.Base (x * x0)%expr
                                          | None =>
                                              UnderLets.Base (x * x0)%expr
                                          end)
                                   | (s1 -> d1)%ptype =>
                                       fun
                                         _ : Compile.value' false s1 ->
                                             Compile.value' true d1 =>
                                       UnderLets.Base (x * x0)%expr
                                   end (Compile.reflect x2)
                               | None => UnderLets.Base (x * x0)%expr
                               end)
                        | (s1 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base (x * x0)%expr
                        end (Compile.reflect x1)
                    | None =>
                        match
                          match idc0 with
                          | ident.Z_shiftr offset => Some offset
                          | _ => None
                          end
                        with
                        | Some args0 =>
                            match
                              s as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (expr (type.base base.type.Z)))
                            with
                            | type.base t2 =>
                                fun v : expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t1 : base.type => expr (type.base t1))
                                  t2 base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (expr (type.base base.type.Z)))
                                  (fun
                                     a : option
                                           (expr (type.base t2) ->
                                            expr (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       match
                                         s0 as t3
                                         return
                                           (Compile.value' false t3 ->
                                            UnderLets.UnderLets base.type
                                              ident var
                                              (expr (type.base base.type.Z)))
                                       with
                                       | type.base t3 =>
                                           fun v0 : expr (type.base t3) =>
                                           base.try_make_transport_cps
                                             (fun t1 : base.type =>
                                              expr (type.base t1)) t3
                                             base.type.Z
                                             (UnderLets.UnderLets base.type
                                                ident var
                                                (expr (type.base base.type.Z)))
                                             (fun
                                                a0 : option
                                                       (expr (type.base t3) ->
                                                        expr
                                                          (type.base
                                                             base.type.Z)) =>
                                              match a0 with
                                              | Some x'0 =>
                                                  if args =? args0
                                                  then
                                                   UnderLets.Base
                                                     (#(ident.fancy_mulhh
                                                          (2 * args))%expr @
                                                      (x' v, x'0 v0))%expr_pat
                                                  else
                                                   UnderLets.Base
                                                     (x * x0)%expr
                                              | None =>
                                                  UnderLets.Base
                                                    (x * x0)%expr
                                              end)
                                       | (s1 -> d1)%ptype =>
                                           fun
                                             _ : Compile.value' false s1 ->
                                                 Compile.value' true d1 =>
                                           UnderLets.Base (x * x0)%expr
                                       end (Compile.reflect x2)
                                   | None => UnderLets.Base (x * x0)%expr
                                   end)
                            | (s1 -> d1)%ptype =>
                                fun
                                  _ : Compile.value' false s1 ->
                                      Compile.value' true d1 =>
                                UnderLets.Base (x * x0)%expr
                            end (Compile.reflect x1)
                        | None => UnderLets.Base (x * x0)%expr
                        end
                    end
                | @expr.App _ _ _ s0 _ ($_)%expr _ | @expr.App _ _ _ s0 _
                  (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0 _
                  (_ @ _)%expr_pat _ | @expr.App _ _ _ s0 _
                  (@expr.LetIn _ _ _ _ _ _ _) _ =>
                    UnderLets.Base (x * x0)%expr
                | _ => UnderLets.Base (x * x0)%expr
                end
            | None => UnderLets.Base (x * x0)%expr
            end
        end
    | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
      (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat _ |
      @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
        UnderLets.Base (x * x0)%expr
    | _ => UnderLets.Base (x * x0)%expr
    end
| ident.Z_pow =>
    fun x x0 : expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_pow)%expr @ x @ x0)%expr_pat
| ident.Z_sub =>
    fun x x0 : expr (type.base base.type.Z) => UnderLets.Base (x - x0)%expr
| ident.Z_opp =>
    fun x : expr (type.base base.type.Z) => UnderLets.Base (- x)%expr
| ident.Z_div =>
    fun x x0 : expr (type.base base.type.Z) => UnderLets.Base (x / x0)%expr
| ident.Z_modulo =>
    fun x x0 : expr (type.base base.type.Z) => UnderLets.Base (x mod x0)%expr
| ident.Z_eqb =>
    fun x x0 : expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_eqb)%expr @ x @ x0)%expr_pat
| ident.Z_leb =>
    fun x x0 : expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_leb)%expr @ x @ x0)%expr_pat
| ident.Z_of_nat =>
    fun x : expr (type.base base.type.nat) =>
    UnderLets.Base (#(ident.Z_of_nat)%expr @ x)%expr_pat
| ident.Z_shiftr offset =>
    fun x : expr (type.base base.type.Z) => UnderLets.Base (x >> offset)%expr
| ident.Z_shiftl offset =>
    fun x : expr (type.base base.type.Z) => UnderLets.Base (x << offset)%expr
| ident.Z_land mask =>
    fun x : expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_land mask)%expr @ x)%expr_pat
| ident.Z_mul_split =>
    fun x x0 x1 : expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_mul_split)%expr @ x @ x0 @ x1)%expr_pat
| ident.Z_mul_split_concrete s =>
    fun x x0 : expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_mul_split_concrete s)%expr @ x @ x0)%expr_pat
| ident.Z_add_get_carry =>
    fun x x0 x1 : expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat
| ident.Z_add_get_carry_concrete s =>
    fun x x0 : expr (type.base base.type.Z) =>
    match x0 with
    | #(_)%expr_pat =>
        match x with
        | @expr.App _ _ _ s0 _ #(idc0)%expr_pat x1 =>
            match
              match idc0 with
              | ident.Z_shiftl offset => Some offset
              | _ => None
              end
            with
            | Some args =>
                match
                  s0 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base (base.type.Z * base.type.Z)%etype)))
                with
                | type.base t2 =>
                    fun v : expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t1 : base.type => expr (type.base t1)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base (base.type.Z * base.type.Z)%etype)))
                      (fun
                         a : option
                               (expr (type.base t2) ->
                                expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' =>
                           if s =? 2 ^ Z.log2 s
                           then
                            UnderLets.Base
                              (#(ident.fancy_add (Z.log2 s) args)%expr @
                               (x0, x' v))%expr_pat
                           else
                            if s =? 2 ^ Z.log2 s
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 s) 0)%expr @
                                (x, x0))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry_concrete s)%expr @ x @
                                x0)%expr_pat
                       | None =>
                           UnderLets.Base
                             (#(ident.Z_add_get_carry_concrete s)%expr @ x @
                              x0)%expr_pat
                       end)
                | (s1 -> d0)%ptype =>
                    fun _ : Compile.value' false s1 -> Compile.value' true d0
                    =>
                    UnderLets.Base
                      (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                end (Compile.reflect x1)
            | None =>
                match
                  match idc0 with
                  | ident.Z_shiftr offset => Some offset
                  | _ => None
                  end
                with
                | Some args =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => expr (type.base t1)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               if s =? 2 ^ Z.log2 s
                               then
                                UnderLets.Base
                                  (#(ident.fancy_add (Z.log2 s) (- args))%expr @
                                   (x0, x' v))%expr_pat
                               else
                                if s =? 2 ^ Z.log2 s
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 s) 0)%expr @
                                    (x, x0))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry_concrete s)%expr @
                                    x @ x0)%expr_pat
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_add_get_carry_concrete s)%expr @
                                  x @ x0)%expr_pat
                           end)
                    | (s1 -> d0)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d0 =>
                        UnderLets.Base
                          (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                    end (Compile.reflect x1)
                | None =>
                    if s =? 2 ^ Z.log2 s
                    then
                     UnderLets.Base
                       (#(ident.fancy_add (Z.log2 s) 0)%expr @ (x, x0))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                end
            end
        | @expr.App _ _ _ s0 _ ($_)%expr _ | @expr.App _ _ _ s0 _
          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0 _ (_ @ _)%expr_pat
          _ | @expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            if s =? 2 ^ Z.log2 s
            then
             UnderLets.Base
               (#(ident.fancy_add (Z.log2 s) 0)%expr @ (x, x0))%expr_pat
            else
             UnderLets.Base
               (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
        | _ =>
            if s =? 2 ^ Z.log2 s
            then
             UnderLets.Base
               (#(ident.fancy_add (Z.log2 s) 0)%expr @ (x, x0))%expr_pat
            else
             UnderLets.Base
               (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
        end
    | ($_)%expr =>
        match x with
        | @expr.App _ _ _ s0 _ #(idc)%expr_pat x1 =>
            match
              match idc with
              | ident.Z_shiftl offset => Some offset
              | _ => None
              end
            with
            | Some args =>
                match
                  s0 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base (base.type.Z * base.type.Z)%etype)))
                with
                | type.base t2 =>
                    fun v0 : expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t1 : base.type => expr (type.base t1)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base (base.type.Z * base.type.Z)%etype)))
                      (fun
                         a : option
                               (expr (type.base t2) ->
                                expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' =>
                           if s =? 2 ^ Z.log2 s
                           then
                            UnderLets.Base
                              (#(ident.fancy_add (Z.log2 s) args)%expr @
                               (x0, x' v0))%expr_pat
                           else
                            if s =? 2 ^ Z.log2 s
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 s) 0)%expr @
                                (x, x0))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry_concrete s)%expr @ x @
                                x0)%expr_pat
                       | None =>
                           UnderLets.Base
                             (#(ident.Z_add_get_carry_concrete s)%expr @ x @
                              x0)%expr_pat
                       end)
                | (s1 -> d0)%ptype =>
                    fun _ : Compile.value' false s1 -> Compile.value' true d0
                    =>
                    UnderLets.Base
                      (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                end (Compile.reflect x1)
            | None =>
                match
                  match idc with
                  | ident.Z_shiftr offset => Some offset
                  | _ => None
                  end
                with
                | Some args =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v0 : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => expr (type.base t1)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               if s =? 2 ^ Z.log2 s
                               then
                                UnderLets.Base
                                  (#(ident.fancy_add (Z.log2 s) (- args))%expr @
                                   (x0, x' v0))%expr_pat
                               else
                                if s =? 2 ^ Z.log2 s
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 s) 0)%expr @
                                    (x, x0))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry_concrete s)%expr @
                                    x @ x0)%expr_pat
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_add_get_carry_concrete s)%expr @
                                  x @ x0)%expr_pat
                           end)
                    | (s1 -> d0)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d0 =>
                        UnderLets.Base
                          (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                    end (Compile.reflect x1)
                | None =>
                    if s =? 2 ^ Z.log2 s
                    then
                     UnderLets.Base
                       (#(ident.fancy_add (Z.log2 s) 0)%expr @ (x, x0))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                end
            end
        | @expr.App _ _ _ s0 _ ($_)%expr _ | @expr.App _ _ _ s0 _
          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0 _ (_ @ _)%expr_pat
          _ | @expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            if s =? 2 ^ Z.log2 s
            then
             UnderLets.Base
               (#(ident.fancy_add (Z.log2 s) 0)%expr @ (x, x0))%expr_pat
            else
             UnderLets.Base
               (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
        | _ =>
            if s =? 2 ^ Z.log2 s
            then
             UnderLets.Base
               (#(ident.fancy_add (Z.log2 s) 0)%expr @ (x, x0))%expr_pat
            else
             UnderLets.Base
               (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
        end
    | @expr.Abs _ _ _ _ _ _ =>
        match x with
        | @expr.App _ _ _ s1 _ #(idc)%expr_pat x1 =>
            match
              match idc with
              | ident.Z_shiftl offset => Some offset
              | _ => None
              end
            with
            | Some args =>
                match
                  s1 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base (base.type.Z * base.type.Z)%etype)))
                with
                | type.base t2 =>
                    fun v : expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => expr (type.base t0)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base (base.type.Z * base.type.Z)%etype)))
                      (fun
                         a : option
                               (expr (type.base t2) ->
                                expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' =>
                           if s =? 2 ^ Z.log2 s
                           then
                            UnderLets.Base
                              (#(ident.fancy_add (Z.log2 s) args)%expr @
                               (x0, x' v))%expr_pat
                           else
                            if s =? 2 ^ Z.log2 s
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 s) 0)%expr @
                                (x, x0))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry_concrete s)%expr @ x @
                                x0)%expr_pat
                       | None =>
                           UnderLets.Base
                             (#(ident.Z_add_get_carry_concrete s)%expr @ x @
                              x0)%expr_pat
                       end)
                | (s2 -> d1)%ptype =>
                    fun _ : Compile.value' false s2 -> Compile.value' true d1
                    =>
                    UnderLets.Base
                      (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                end (Compile.reflect x1)
            | None =>
                match
                  match idc with
                  | ident.Z_shiftr offset => Some offset
                  | _ => None
                  end
                with
                | Some args =>
                    match
                      s1 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => expr (type.base t0)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               if s =? 2 ^ Z.log2 s
                               then
                                UnderLets.Base
                                  (#(ident.fancy_add (Z.log2 s) (- args))%expr @
                                   (x0, x' v))%expr_pat
                               else
                                if s =? 2 ^ Z.log2 s
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 s) 0)%expr @
                                    (x, x0))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry_concrete s)%expr @
                                    x @ x0)%expr_pat
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_add_get_carry_concrete s)%expr @
                                  x @ x0)%expr_pat
                           end)
                    | (s2 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s2 ->
                              Compile.value' true d1 =>
                        UnderLets.Base
                          (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                    end (Compile.reflect x1)
                | None =>
                    if s =? 2 ^ Z.log2 s
                    then
                     UnderLets.Base
                       (#(ident.fancy_add (Z.log2 s) 0)%expr @ (x, x0))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                end
            end
        | @expr.App _ _ _ s1 _ ($_)%expr _ | @expr.App _ _ _ s1 _
          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s1 _ (_ @ _)%expr_pat
          _ | @expr.App _ _ _ s1 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            if s =? 2 ^ Z.log2 s
            then
             UnderLets.Base
               (#(ident.fancy_add (Z.log2 s) 0)%expr @ (x, x0))%expr_pat
            else
             UnderLets.Base
               (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
        | _ =>
            if s =? 2 ^ Z.log2 s
            then
             UnderLets.Base
               (#(ident.fancy_add (Z.log2 s) 0)%expr @ (x, x0))%expr_pat
            else
             UnderLets.Base
               (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
        end
    | @expr.App _ _ _ s0 _ #(idc)%expr_pat x1 =>
        match
          match idc with
          | ident.Z_shiftl offset => Some offset
          | _ => None
          end
        with
        | Some args =>
            match
              s0 as t2
              return
                (Compile.value' false t2 ->
                 UnderLets.UnderLets base.type ident var
                   (expr (type.base (base.type.Z * base.type.Z)%etype)))
            with
            | type.base t2 =>
                fun v : expr (type.base t2) =>
                base.try_make_transport_cps
                  (fun t0 : base.type => expr (type.base t0)) t2 base.type.Z
                  (UnderLets.UnderLets base.type ident var
                     (expr (type.base (base.type.Z * base.type.Z)%etype)))
                  (fun
                     a : option
                           (expr (type.base t2) ->
                            expr (type.base base.type.Z)) =>
                   match a with
                   | Some x' =>
                       if s =? 2 ^ Z.log2 s
                       then
                        UnderLets.Base
                          (#(ident.fancy_add (Z.log2 s) args)%expr @
                           (x, x' v))%expr_pat
                       else
                        match x with
                        | @expr.App _ _ _ s1 _ #(idc0)%expr_pat x2 =>
                            match
                              match idc0 with
                              | ident.Z_shiftl offset => Some offset
                              | _ => None
                              end
                            with
                            | Some args0 =>
                                match
                                  s1 as t3
                                  return
                                    (Compile.value' false t3 ->
                                     UnderLets.UnderLets base.type ident var
                                       (expr
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)))
                                with
                                | type.base t3 =>
                                    fun v0 : expr (type.base t3) =>
                                    base.try_make_transport_cps
                                      (fun t1 : base.type =>
                                       expr (type.base t1)) t3 base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (expr
                                            (type.base
                                               (base.type.Z * base.type.Z)%etype)))
                                      (fun
                                         a0 : option
                                                (expr (type.base t3) ->
                                                 expr (type.base base.type.Z))
                                       =>
                                       match a0 with
                                       | Some x'0 =>
                                           if s =? 2 ^ Z.log2 s
                                           then
                                            UnderLets.Base
                                              (#(ident.fancy_add (Z.log2 s)
                                                   args0)%expr @ (x0, x'0 v0))%expr_pat
                                           else
                                            if s =? 2 ^ Z.log2 s
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_add (Z.log2 s)
                                                    0)%expr @ (x, x0))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_get_carry_concrete
                                                    s)%expr @ x @ x0)%expr_pat
                                       | None =>
                                           UnderLets.Base
                                             (#(ident.Z_add_get_carry_concrete
                                                  s)%expr @ x @ x0)%expr_pat
                                       end)
                                | (s2 -> d1)%ptype =>
                                    fun
                                      _ : Compile.value' false s2 ->
                                          Compile.value' true d1 =>
                                    UnderLets.Base
                                      (#(ident.Z_add_get_carry_concrete s)%expr @
                                       x @ x0)%expr_pat
                                end (Compile.reflect x2)
                            | None =>
                                match
                                  match idc0 with
                                  | ident.Z_shiftr offset => Some offset
                                  | _ => None
                                  end
                                with
                                | Some args0 =>
                                    match
                                      s1 as t3
                                      return
                                        (Compile.value' false t3 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t3 =>
                                        fun v0 : expr (type.base t3) =>
                                        base.try_make_transport_cps
                                          (fun t1 : base.type =>
                                           expr (type.base t1)) t3
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a0 : option
                                                    (expr (type.base t3) ->
                                                     expr
                                                       (type.base base.type.Z))
                                           =>
                                           match a0 with
                                           | Some x'0 =>
                                               if s =? 2 ^ Z.log2 s
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_add
                                                       (Z.log2 s) (- args0))%expr @
                                                   (x0, x'0 v0))%expr_pat
                                               else
                                                if s =? 2 ^ Z.log2 s
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_add
                                                        (Z.log2 s) 0)%expr @
                                                    (x, x0))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_get_carry_concrete
                                                        s)%expr @ x @ x0)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_get_carry_concrete
                                                      s)%expr @ x @ x0)%expr_pat
                                           end)
                                    | (s2 -> d1)%ptype =>
                                        fun
                                          _ : Compile.value' false s2 ->
                                              Compile.value' true d1 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_get_carry_concrete s)%expr @
                                           x @ x0)%expr_pat
                                    end (Compile.reflect x2)
                                | None =>
                                    if s =? 2 ^ Z.log2 s
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_add (Z.log2 s) 0)%expr @
                                        (x, x0))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_get_carry_concrete s)%expr @
                                        x @ x0)%expr_pat
                                end
                            end
                        | @expr.App _ _ _ s1 _ ($_)%expr _ | @expr.App _ _ _
                          s1 _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s1
                          _ (_ @ _)%expr_pat _ | @expr.App _ _ _ s1 _
                          (@expr.LetIn _ _ _ _ _ _ _) _ =>
                            if s =? 2 ^ Z.log2 s
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 s) 0)%expr @
                                (x, x0))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry_concrete s)%expr @ x @
                                x0)%expr_pat
                        | _ =>
                            if s =? 2 ^ Z.log2 s
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 s) 0)%expr @
                                (x, x0))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry_concrete s)%expr @ x @
                                x0)%expr_pat
                        end
                   | None =>
                       UnderLets.Base
                         (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                   end)
            | (s1 -> d0)%ptype =>
                fun _ : Compile.value' false s1 -> Compile.value' true d0 =>
                UnderLets.Base
                  (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
            end (Compile.reflect x1)
        | None =>
            match
              match idc with
              | ident.Z_shiftr offset => Some offset
              | _ => None
              end
            with
            | Some args =>
                match x with
                | #(_)%expr_pat =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => expr (type.base t1)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               if s =? 2 ^ Z.log2 s
                               then
                                UnderLets.Base
                                  (#(ident.fancy_add (Z.log2 s) (- args))%expr @
                                   (x, x' v))%expr_pat
                               else
                                if s =? 2 ^ Z.log2 s
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 s) 0)%expr @
                                    (x, x0))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry_concrete s)%expr @
                                    x @ x0)%expr_pat
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_add_get_carry_concrete s)%expr @
                                  x @ x0)%expr_pat
                           end)
                    | (s1 -> d0)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d0 =>
                        UnderLets.Base
                          (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                    end (Compile.reflect x1)
                | ($_)%expr =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v0 : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => expr (type.base t1)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               if s =? 2 ^ Z.log2 s
                               then
                                UnderLets.Base
                                  (#(ident.fancy_add (Z.log2 s) (- args))%expr @
                                   (x, x' v0))%expr_pat
                               else
                                if s =? 2 ^ Z.log2 s
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 s) 0)%expr @
                                    (x, x0))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry_concrete s)%expr @
                                    x @ x0)%expr_pat
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_add_get_carry_concrete s)%expr @
                                  x @ x0)%expr_pat
                           end)
                    | (s1 -> d0)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d0 =>
                        UnderLets.Base
                          (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                    end (Compile.reflect x1)
                | @expr.Abs _ _ _ _ _ _ =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => expr (type.base t0)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               if s =? 2 ^ Z.log2 s
                               then
                                UnderLets.Base
                                  (#(ident.fancy_add (Z.log2 s) (- args))%expr @
                                   (x, x' v))%expr_pat
                               else
                                if s =? 2 ^ Z.log2 s
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 s) 0)%expr @
                                    (x, x0))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry_concrete s)%expr @
                                    x @ x0)%expr_pat
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_add_get_carry_concrete s)%expr @
                                  x @ x0)%expr_pat
                           end)
                    | (s2 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s2 ->
                              Compile.value' true d1 =>
                        UnderLets.Base
                          (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                    end (Compile.reflect x1)
                | @expr.App _ _ _ s1 _ #(idc0)%expr_pat x2 =>
                    match
                      match idc0 with
                      | ident.Z_shiftl offset => Some offset
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        match
                          s1 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type => expr (type.base t1)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   if s =? 2 ^ Z.log2 s
                                   then
                                    UnderLets.Base
                                      (#(ident.fancy_add (Z.log2 s) args0)%expr @
                                       (x0, x' v))%expr_pat
                                   else
                                    match
                                      s0 as t3
                                      return
                                        (Compile.value' false t3 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t3 =>
                                        fun v0 : expr (type.base t3) =>
                                        base.try_make_transport_cps
                                          (fun t1 : base.type =>
                                           expr (type.base t1)) t3
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a0 : option
                                                    (expr (type.base t3) ->
                                                     expr
                                                       (type.base base.type.Z))
                                           =>
                                           match a0 with
                                           | Some x'0 =>
                                               if s =? 2 ^ Z.log2 s
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_add
                                                       (Z.log2 s) (- args))%expr @
                                                   (x, x'0 v0))%expr_pat
                                               else
                                                if s =? 2 ^ Z.log2 s
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_add
                                                        (Z.log2 s) 0)%expr @
                                                    (x, x0))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_get_carry_concrete
                                                        s)%expr @ x @ x0)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_get_carry_concrete
                                                      s)%expr @ x @ x0)%expr_pat
                                           end)
                                    | (s2 -> d1)%ptype =>
                                        fun
                                          _ : Compile.value' false s2 ->
                                              Compile.value' true d1 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_get_carry_concrete s)%expr @
                                           x @ x0)%expr_pat
                                    end (Compile.reflect x1)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_get_carry_concrete s)%expr @
                                      x @ x0)%expr_pat
                               end)
                        | (s2 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s2 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base
                              (#(ident.Z_add_get_carry_concrete s)%expr @ x @
                               x0)%expr_pat
                        end (Compile.reflect x2)
                    | None =>
                        match
                          match idc0 with
                          | ident.Z_shiftr offset => Some offset
                          | _ => None
                          end
                        with
                        | Some args0 =>
                            match
                              s0 as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (expr
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)))
                            with
                            | type.base t2 =>
                                fun v : expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t1 : base.type => expr (type.base t1))
                                  t2 base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (expr
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)))
                                  (fun
                                     a : option
                                           (expr (type.base t2) ->
                                            expr (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       if s =? 2 ^ Z.log2 s
                                       then
                                        UnderLets.Base
                                          (#(ident.fancy_add (Z.log2 s)
                                               (- args))%expr @ (x, x' v))%expr_pat
                                       else
                                        match
                                          s1 as t3
                                          return
                                            (Compile.value' false t3 ->
                                             UnderLets.UnderLets base.type
                                               ident var
                                               (expr
                                                  (type.base
                                                     (base.type.Z *
                                                      base.type.Z)%etype)))
                                        with
                                        | type.base t3 =>
                                            fun v0 : expr (type.base t3) =>
                                            base.try_make_transport_cps
                                              (fun t1 : base.type =>
                                               expr (type.base t1)) t3
                                              base.type.Z
                                              (UnderLets.UnderLets base.type
                                                 ident var
                                                 (expr
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)))
                                              (fun
                                                 a0 : option
                                                        (expr (type.base t3) ->
                                                         expr
                                                           (type.base
                                                              base.type.Z))
                                               =>
                                               match a0 with
                                               | Some x'0 =>
                                                   if s =? 2 ^ Z.log2 s
                                                   then
                                                    UnderLets.Base
                                                      (#(ident.fancy_add
                                                           (Z.log2 s)
                                                           (- args0))%expr @
                                                       (x0, x'0 v0))%expr_pat
                                                   else
                                                    if s =? 2 ^ Z.log2 s
                                                    then
                                                     UnderLets.Base
                                                       (#(ident.fancy_add
                                                            (Z.log2 s) 0)%expr @
                                                        (x, x0))%expr_pat
                                                    else
                                                     UnderLets.Base
                                                       (#(ident.Z_add_get_carry_concrete
                                                            s)%expr @ x @ x0)%expr_pat
                                               | None =>
                                                   UnderLets.Base
                                                     (#(ident.Z_add_get_carry_concrete
                                                          s)%expr @ x @ x0)%expr_pat
                                               end)
                                        | (s2 -> d1)%ptype =>
                                            fun
                                              _ : Compile.value' false s2 ->
                                                  Compile.value' true d1 =>
                                            UnderLets.Base
                                              (#(ident.Z_add_get_carry_concrete
                                                   s)%expr @ x @ x0)%expr_pat
                                        end (Compile.reflect x2)
                                   | None =>
                                       UnderLets.Base
                                         (#(ident.Z_add_get_carry_concrete s)%expr @
                                          x @ x0)%expr_pat
                                   end)
                            | (s2 -> d1)%ptype =>
                                fun
                                  _ : Compile.value' false s2 ->
                                      Compile.value' true d1 =>
                                UnderLets.Base
                                  (#(ident.Z_add_get_carry_concrete s)%expr @
                                   x @ x0)%expr_pat
                            end (Compile.reflect x1)
                        | None =>
                            match
                              s0 as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (expr
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)))
                            with
                            | type.base t2 =>
                                fun v : expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t1 : base.type => expr (type.base t1))
                                  t2 base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (expr
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)))
                                  (fun
                                     a : option
                                           (expr (type.base t2) ->
                                            expr (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       if s =? 2 ^ Z.log2 s
                                       then
                                        UnderLets.Base
                                          (#(ident.fancy_add (Z.log2 s)
                                               (- args))%expr @ (x, x' v))%expr_pat
                                       else
                                        if s =? 2 ^ Z.log2 s
                                        then
                                         UnderLets.Base
                                           (#(ident.fancy_add (Z.log2 s) 0)%expr @
                                            (x, x0))%expr_pat
                                        else
                                         UnderLets.Base
                                           (#(ident.Z_add_get_carry_concrete
                                                s)%expr @ x @ x0)%expr_pat
                                   | None =>
                                       UnderLets.Base
                                         (#(ident.Z_add_get_carry_concrete s)%expr @
                                          x @ x0)%expr_pat
                                   end)
                            | (s2 -> d1)%ptype =>
                                fun
                                  _ : Compile.value' false s2 ->
                                      Compile.value' true d1 =>
                                UnderLets.Base
                                  (#(ident.Z_add_get_carry_concrete s)%expr @
                                   x @ x0)%expr_pat
                            end (Compile.reflect x1)
                        end
                    end
                | @expr.App _ _ _ s1 _ ($_)%expr _ =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v0 : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => expr (type.base t1)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               if s =? 2 ^ Z.log2 s
                               then
                                UnderLets.Base
                                  (#(ident.fancy_add (Z.log2 s) (- args))%expr @
                                   (x, x' v0))%expr_pat
                               else
                                if s =? 2 ^ Z.log2 s
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 s) 0)%expr @
                                    (x, x0))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry_concrete s)%expr @
                                    x @ x0)%expr_pat
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_add_get_carry_concrete s)%expr @
                                  x @ x0)%expr_pat
                           end)
                    | (s2 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s2 ->
                              Compile.value' true d1 =>
                        UnderLets.Base
                          (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                    end (Compile.reflect x1)
                | @expr.App _ _ _ s1 _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App
                  _ _ _ s1 _ (_ @ _)%expr_pat _ =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => expr (type.base t0)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               if s =? 2 ^ Z.log2 s
                               then
                                UnderLets.Base
                                  (#(ident.fancy_add (Z.log2 s) (- args))%expr @
                                   (x, x' v))%expr_pat
                               else
                                if s =? 2 ^ Z.log2 s
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 s) 0)%expr @
                                    (x, x0))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry_concrete s)%expr @
                                    x @ x0)%expr_pat
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_add_get_carry_concrete s)%expr @
                                  x @ x0)%expr_pat
                           end)
                    | (s3 -> d2)%ptype =>
                        fun
                          _ : Compile.value' false s3 ->
                              Compile.value' true d2 =>
                        UnderLets.Base
                          (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                    end (Compile.reflect x1)
                | @expr.App _ _ _ s1 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => expr (type.base t0)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               if s =? 2 ^ Z.log2 s
                               then
                                UnderLets.Base
                                  (#(ident.fancy_add (Z.log2 s) (- args))%expr @
                                   (x, x' v))%expr_pat
                               else
                                if s =? 2 ^ Z.log2 s
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 s) 0)%expr @
                                    (x, x0))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry_concrete s)%expr @
                                    x @ x0)%expr_pat
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_add_get_carry_concrete s)%expr @
                                  x @ x0)%expr_pat
                           end)
                    | (s2 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s2 ->
                              Compile.value' true d1 =>
                        UnderLets.Base
                          (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                    end (Compile.reflect x1)
                | @expr.LetIn _ _ _ _ _ _ _ =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => expr (type.base t0)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               if s =? 2 ^ Z.log2 s
                               then
                                UnderLets.Base
                                  (#(ident.fancy_add (Z.log2 s) (- args))%expr @
                                   (x, x' v))%expr_pat
                               else
                                if s =? 2 ^ Z.log2 s
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 s) 0)%expr @
                                    (x, x0))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry_concrete s)%expr @
                                    x @ x0)%expr_pat
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_add_get_carry_concrete s)%expr @
                                  x @ x0)%expr_pat
                           end)
                    | (s1 -> d0)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d0 =>
                        UnderLets.Base
                          (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                    end (Compile.reflect x1)
                end
            | None =>
                match x with
                | @expr.App _ _ _ s1 _ #(idc0)%expr_pat x2 =>
                    match
                      match idc0 with
                      | ident.Z_shiftl offset => Some offset
                      | _ => None
                      end
                    with
                    | Some args =>
                        match
                          s1 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type => expr (type.base t1)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   if s =? 2 ^ Z.log2 s
                                   then
                                    UnderLets.Base
                                      (#(ident.fancy_add (Z.log2 s) args)%expr @
                                       (x0, x' v))%expr_pat
                                   else
                                    if s =? 2 ^ Z.log2 s
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_add (Z.log2 s) 0)%expr @
                                        (x, x0))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_get_carry_concrete s)%expr @
                                        x @ x0)%expr_pat
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_get_carry_concrete s)%expr @
                                      x @ x0)%expr_pat
                               end)
                        | (s2 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s2 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base
                              (#(ident.Z_add_get_carry_concrete s)%expr @ x @
                               x0)%expr_pat
                        end (Compile.reflect x2)
                    | None =>
                        match
                          match idc0 with
                          | ident.Z_shiftr offset => Some offset
                          | _ => None
                          end
                        with
                        | Some args =>
                            match
                              s1 as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (expr
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)))
                            with
                            | type.base t2 =>
                                fun v : expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t1 : base.type => expr (type.base t1))
                                  t2 base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (expr
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)))
                                  (fun
                                     a : option
                                           (expr (type.base t2) ->
                                            expr (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       if s =? 2 ^ Z.log2 s
                                       then
                                        UnderLets.Base
                                          (#(ident.fancy_add (Z.log2 s)
                                               (- args))%expr @ (x0, x' v))%expr_pat
                                       else
                                        if s =? 2 ^ Z.log2 s
                                        then
                                         UnderLets.Base
                                           (#(ident.fancy_add (Z.log2 s) 0)%expr @
                                            (x, x0))%expr_pat
                                        else
                                         UnderLets.Base
                                           (#(ident.Z_add_get_carry_concrete
                                                s)%expr @ x @ x0)%expr_pat
                                   | None =>
                                       UnderLets.Base
                                         (#(ident.Z_add_get_carry_concrete s)%expr @
                                          x @ x0)%expr_pat
                                   end)
                            | (s2 -> d1)%ptype =>
                                fun
                                  _ : Compile.value' false s2 ->
                                      Compile.value' true d1 =>
                                UnderLets.Base
                                  (#(ident.Z_add_get_carry_concrete s)%expr @
                                   x @ x0)%expr_pat
                            end (Compile.reflect x2)
                        | None =>
                            if s =? 2 ^ Z.log2 s
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 s) 0)%expr @
                                (x, x0))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry_concrete s)%expr @ x @
                                x0)%expr_pat
                        end
                    end
                | @expr.App _ _ _ s1 _ ($_)%expr _ | @expr.App _ _ _ s1 _
                  (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s1 _
                  (_ @ _)%expr_pat _ | @expr.App _ _ _ s1 _
                  (@expr.LetIn _ _ _ _ _ _ _) _ =>
                    if s =? 2 ^ Z.log2 s
                    then
                     UnderLets.Base
                       (#(ident.fancy_add (Z.log2 s) 0)%expr @ (x, x0))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                | _ =>
                    if s =? 2 ^ Z.log2 s
                    then
                     UnderLets.Base
                       (#(ident.fancy_add (Z.log2 s) 0)%expr @ (x, x0))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                end
            end
        end
    | @expr.App _ _ _ s0 _ ($_)%expr _ =>
        match x with
        | @expr.App _ _ _ s1 _ #(idc)%expr_pat x2 =>
            match
              match idc with
              | ident.Z_shiftl offset => Some offset
              | _ => None
              end
            with
            | Some args =>
                match
                  s1 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base (base.type.Z * base.type.Z)%etype)))
                with
                | type.base t2 =>
                    fun v0 : expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t1 : base.type => expr (type.base t1)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base (base.type.Z * base.type.Z)%etype)))
                      (fun
                         a : option
                               (expr (type.base t2) ->
                                expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' =>
                           if s =? 2 ^ Z.log2 s
                           then
                            UnderLets.Base
                              (#(ident.fancy_add (Z.log2 s) args)%expr @
                               (x0, x' v0))%expr_pat
                           else
                            if s =? 2 ^ Z.log2 s
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 s) 0)%expr @
                                (x, x0))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry_concrete s)%expr @ x @
                                x0)%expr_pat
                       | None =>
                           UnderLets.Base
                             (#(ident.Z_add_get_carry_concrete s)%expr @ x @
                              x0)%expr_pat
                       end)
                | (s2 -> d1)%ptype =>
                    fun _ : Compile.value' false s2 -> Compile.value' true d1
                    =>
                    UnderLets.Base
                      (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                end (Compile.reflect x2)
            | None =>
                match
                  match idc with
                  | ident.Z_shiftr offset => Some offset
                  | _ => None
                  end
                with
                | Some args =>
                    match
                      s1 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v0 : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => expr (type.base t1)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               if s =? 2 ^ Z.log2 s
                               then
                                UnderLets.Base
                                  (#(ident.fancy_add (Z.log2 s) (- args))%expr @
                                   (x0, x' v0))%expr_pat
                               else
                                if s =? 2 ^ Z.log2 s
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 s) 0)%expr @
                                    (x, x0))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry_concrete s)%expr @
                                    x @ x0)%expr_pat
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_add_get_carry_concrete s)%expr @
                                  x @ x0)%expr_pat
                           end)
                    | (s2 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s2 ->
                              Compile.value' true d1 =>
                        UnderLets.Base
                          (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                    end (Compile.reflect x2)
                | None =>
                    if s =? 2 ^ Z.log2 s
                    then
                     UnderLets.Base
                       (#(ident.fancy_add (Z.log2 s) 0)%expr @ (x, x0))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                end
            end
        | @expr.App _ _ _ s1 _ ($_)%expr _ | @expr.App _ _ _ s1 _
          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s1 _ (_ @ _)%expr_pat
          _ | @expr.App _ _ _ s1 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            if s =? 2 ^ Z.log2 s
            then
             UnderLets.Base
               (#(ident.fancy_add (Z.log2 s) 0)%expr @ (x, x0))%expr_pat
            else
             UnderLets.Base
               (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
        | _ =>
            if s =? 2 ^ Z.log2 s
            then
             UnderLets.Base
               (#(ident.fancy_add (Z.log2 s) 0)%expr @ (x, x0))%expr_pat
            else
             UnderLets.Base
               (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
        end
    | @expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ =>
        match x with
        | @expr.App _ _ _ s2 _ #(idc)%expr_pat x2 =>
            match
              match idc with
              | ident.Z_shiftl offset => Some offset
              | _ => None
              end
            with
            | Some args =>
                match
                  s2 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base (base.type.Z * base.type.Z)%etype)))
                with
                | type.base t2 =>
                    fun v : expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => expr (type.base t0)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base (base.type.Z * base.type.Z)%etype)))
                      (fun
                         a : option
                               (expr (type.base t2) ->
                                expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' =>
                           if s =? 2 ^ Z.log2 s
                           then
                            UnderLets.Base
                              (#(ident.fancy_add (Z.log2 s) args)%expr @
                               (x0, x' v))%expr_pat
                           else
                            if s =? 2 ^ Z.log2 s
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 s) 0)%expr @
                                (x, x0))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry_concrete s)%expr @ x @
                                x0)%expr_pat
                       | None =>
                           UnderLets.Base
                             (#(ident.Z_add_get_carry_concrete s)%expr @ x @
                              x0)%expr_pat
                       end)
                | (s3 -> d2)%ptype =>
                    fun _ : Compile.value' false s3 -> Compile.value' true d2
                    =>
                    UnderLets.Base
                      (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                end (Compile.reflect x2)
            | None =>
                match
                  match idc with
                  | ident.Z_shiftr offset => Some offset
                  | _ => None
                  end
                with
                | Some args =>
                    match
                      s2 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => expr (type.base t0)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               if s =? 2 ^ Z.log2 s
                               then
                                UnderLets.Base
                                  (#(ident.fancy_add (Z.log2 s) (- args))%expr @
                                   (x0, x' v))%expr_pat
                               else
                                if s =? 2 ^ Z.log2 s
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 s) 0)%expr @
                                    (x, x0))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry_concrete s)%expr @
                                    x @ x0)%expr_pat
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_add_get_carry_concrete s)%expr @
                                  x @ x0)%expr_pat
                           end)
                    | (s3 -> d2)%ptype =>
                        fun
                          _ : Compile.value' false s3 ->
                              Compile.value' true d2 =>
                        UnderLets.Base
                          (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                    end (Compile.reflect x2)
                | None =>
                    if s =? 2 ^ Z.log2 s
                    then
                     UnderLets.Base
                       (#(ident.fancy_add (Z.log2 s) 0)%expr @ (x, x0))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                end
            end
        | @expr.App _ _ _ s2 _ ($_)%expr _ | @expr.App _ _ _ s2 _
          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s2 _ (_ @ _)%expr_pat
          _ | @expr.App _ _ _ s2 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            if s =? 2 ^ Z.log2 s
            then
             UnderLets.Base
               (#(ident.fancy_add (Z.log2 s) 0)%expr @ (x, x0))%expr_pat
            else
             UnderLets.Base
               (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
        | _ =>
            if s =? 2 ^ Z.log2 s
            then
             UnderLets.Base
               (#(ident.fancy_add (Z.log2 s) 0)%expr @ (x, x0))%expr_pat
            else
             UnderLets.Base
               (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
        end
    | @expr.App _ _ _ s0 _ (_ @ _)%expr_pat _ =>
        match x with
        | @expr.App _ _ _ s2 _ #(idc)%expr_pat x3 =>
            match
              match idc with
              | ident.Z_shiftl offset => Some offset
              | _ => None
              end
            with
            | Some args =>
                match
                  s2 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base (base.type.Z * base.type.Z)%etype)))
                with
                | type.base t2 =>
                    fun v : expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => expr (type.base t0)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base (base.type.Z * base.type.Z)%etype)))
                      (fun
                         a : option
                               (expr (type.base t2) ->
                                expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' =>
                           if s =? 2 ^ Z.log2 s
                           then
                            UnderLets.Base
                              (#(ident.fancy_add (Z.log2 s) args)%expr @
                               (x0, x' v))%expr_pat
                           else
                            if s =? 2 ^ Z.log2 s
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 s) 0)%expr @
                                (x, x0))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry_concrete s)%expr @ x @
                                x0)%expr_pat
                       | None =>
                           UnderLets.Base
                             (#(ident.Z_add_get_carry_concrete s)%expr @ x @
                              x0)%expr_pat
                       end)
                | (s3 -> d2)%ptype =>
                    fun _ : Compile.value' false s3 -> Compile.value' true d2
                    =>
                    UnderLets.Base
                      (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                end (Compile.reflect x3)
            | None =>
                match
                  match idc with
                  | ident.Z_shiftr offset => Some offset
                  | _ => None
                  end
                with
                | Some args =>
                    match
                      s2 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => expr (type.base t0)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               if s =? 2 ^ Z.log2 s
                               then
                                UnderLets.Base
                                  (#(ident.fancy_add (Z.log2 s) (- args))%expr @
                                   (x0, x' v))%expr_pat
                               else
                                if s =? 2 ^ Z.log2 s
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 s) 0)%expr @
                                    (x, x0))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry_concrete s)%expr @
                                    x @ x0)%expr_pat
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_add_get_carry_concrete s)%expr @
                                  x @ x0)%expr_pat
                           end)
                    | (s3 -> d2)%ptype =>
                        fun
                          _ : Compile.value' false s3 ->
                              Compile.value' true d2 =>
                        UnderLets.Base
                          (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                    end (Compile.reflect x3)
                | None =>
                    if s =? 2 ^ Z.log2 s
                    then
                     UnderLets.Base
                       (#(ident.fancy_add (Z.log2 s) 0)%expr @ (x, x0))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                end
            end
        | @expr.App _ _ _ s2 _ ($_)%expr _ | @expr.App _ _ _ s2 _
          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s2 _ (_ @ _)%expr_pat
          _ | @expr.App _ _ _ s2 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            if s =? 2 ^ Z.log2 s
            then
             UnderLets.Base
               (#(ident.fancy_add (Z.log2 s) 0)%expr @ (x, x0))%expr_pat
            else
             UnderLets.Base
               (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
        | _ =>
            if s =? 2 ^ Z.log2 s
            then
             UnderLets.Base
               (#(ident.fancy_add (Z.log2 s) 0)%expr @ (x, x0))%expr_pat
            else
             UnderLets.Base
               (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
        end
    | @expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
        match x with
        | @expr.App _ _ _ s1 _ #(idc)%expr_pat x3 =>
            match
              match idc with
              | ident.Z_shiftl offset => Some offset
              | _ => None
              end
            with
            | Some args =>
                match
                  s1 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base (base.type.Z * base.type.Z)%etype)))
                with
                | type.base t2 =>
                    fun v : expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => expr (type.base t0)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base (base.type.Z * base.type.Z)%etype)))
                      (fun
                         a : option
                               (expr (type.base t2) ->
                                expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' =>
                           if s =? 2 ^ Z.log2 s
                           then
                            UnderLets.Base
                              (#(ident.fancy_add (Z.log2 s) args)%expr @
                               (x0, x' v))%expr_pat
                           else
                            if s =? 2 ^ Z.log2 s
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 s) 0)%expr @
                                (x, x0))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry_concrete s)%expr @ x @
                                x0)%expr_pat
                       | None =>
                           UnderLets.Base
                             (#(ident.Z_add_get_carry_concrete s)%expr @ x @
                              x0)%expr_pat
                       end)
                | (s2 -> d1)%ptype =>
                    fun _ : Compile.value' false s2 -> Compile.value' true d1
                    =>
                    UnderLets.Base
                      (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                end (Compile.reflect x3)
            | None =>
                match
                  match idc with
                  | ident.Z_shiftr offset => Some offset
                  | _ => None
                  end
                with
                | Some args =>
                    match
                      s1 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => expr (type.base t0)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               if s =? 2 ^ Z.log2 s
                               then
                                UnderLets.Base
                                  (#(ident.fancy_add (Z.log2 s) (- args))%expr @
                                   (x0, x' v))%expr_pat
                               else
                                if s =? 2 ^ Z.log2 s
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 s) 0)%expr @
                                    (x, x0))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry_concrete s)%expr @
                                    x @ x0)%expr_pat
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_add_get_carry_concrete s)%expr @
                                  x @ x0)%expr_pat
                           end)
                    | (s2 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s2 ->
                              Compile.value' true d1 =>
                        UnderLets.Base
                          (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                    end (Compile.reflect x3)
                | None =>
                    if s =? 2 ^ Z.log2 s
                    then
                     UnderLets.Base
                       (#(ident.fancy_add (Z.log2 s) 0)%expr @ (x, x0))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                end
            end
        | @expr.App _ _ _ s1 _ ($_)%expr _ | @expr.App _ _ _ s1 _
          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s1 _ (_ @ _)%expr_pat
          _ | @expr.App _ _ _ s1 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            if s =? 2 ^ Z.log2 s
            then
             UnderLets.Base
               (#(ident.fancy_add (Z.log2 s) 0)%expr @ (x, x0))%expr_pat
            else
             UnderLets.Base
               (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
        | _ =>
            if s =? 2 ^ Z.log2 s
            then
             UnderLets.Base
               (#(ident.fancy_add (Z.log2 s) 0)%expr @ (x, x0))%expr_pat
            else
             UnderLets.Base
               (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
        end
    | @expr.LetIn _ _ _ _ _ _ _ =>
        match x with
        | @expr.App _ _ _ s0 _ #(idc)%expr_pat x2 =>
            match
              match idc with
              | ident.Z_shiftl offset => Some offset
              | _ => None
              end
            with
            | Some args =>
                match
                  s0 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base (base.type.Z * base.type.Z)%etype)))
                with
                | type.base t2 =>
                    fun v : expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => expr (type.base t0)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base (base.type.Z * base.type.Z)%etype)))
                      (fun
                         a : option
                               (expr (type.base t2) ->
                                expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' =>
                           if s =? 2 ^ Z.log2 s
                           then
                            UnderLets.Base
                              (#(ident.fancy_add (Z.log2 s) args)%expr @
                               (x0, x' v))%expr_pat
                           else
                            if s =? 2 ^ Z.log2 s
                            then
                             UnderLets.Base
                               (#(ident.fancy_add (Z.log2 s) 0)%expr @
                                (x, x0))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_get_carry_concrete s)%expr @ x @
                                x0)%expr_pat
                       | None =>
                           UnderLets.Base
                             (#(ident.Z_add_get_carry_concrete s)%expr @ x @
                              x0)%expr_pat
                       end)
                | (s1 -> d0)%ptype =>
                    fun _ : Compile.value' false s1 -> Compile.value' true d0
                    =>
                    UnderLets.Base
                      (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                end (Compile.reflect x2)
            | None =>
                match
                  match idc with
                  | ident.Z_shiftr offset => Some offset
                  | _ => None
                  end
                with
                | Some args =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => expr (type.base t0)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               if s =? 2 ^ Z.log2 s
                               then
                                UnderLets.Base
                                  (#(ident.fancy_add (Z.log2 s) (- args))%expr @
                                   (x0, x' v))%expr_pat
                               else
                                if s =? 2 ^ Z.log2 s
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_add (Z.log2 s) 0)%expr @
                                    (x, x0))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_get_carry_concrete s)%expr @
                                    x @ x0)%expr_pat
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_add_get_carry_concrete s)%expr @
                                  x @ x0)%expr_pat
                           end)
                    | (s1 -> d0)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d0 =>
                        UnderLets.Base
                          (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                    end (Compile.reflect x2)
                | None =>
                    if s =? 2 ^ Z.log2 s
                    then
                     UnderLets.Base
                       (#(ident.fancy_add (Z.log2 s) 0)%expr @ (x, x0))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
                end
            end
        | @expr.App _ _ _ s0 _ ($_)%expr _ | @expr.App _ _ _ s0 _
          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0 _ (_ @ _)%expr_pat
          _ | @expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            if s =? 2 ^ Z.log2 s
            then
             UnderLets.Base
               (#(ident.fancy_add (Z.log2 s) 0)%expr @ (x, x0))%expr_pat
            else
             UnderLets.Base
               (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
        | _ =>
            if s =? 2 ^ Z.log2 s
            then
             UnderLets.Base
               (#(ident.fancy_add (Z.log2 s) 0)%expr @ (x, x0))%expr_pat
            else
             UnderLets.Base
               (#(ident.Z_add_get_carry_concrete s)%expr @ x @ x0)%expr_pat
        end
    end
| ident.Z_add_with_carry =>
    fun x x0 x1 : expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_add_with_carry)%expr @ x @ x0 @ x1)%expr_pat
| ident.Z_add_with_get_carry =>
    fun x x0 x1 x2 : expr (type.base base.type.Z) =>
    UnderLets.Base
      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat
| ident.Z_add_with_get_carry_concrete s =>
    fun x x0 x1 : expr (type.base base.type.Z) =>
    match x1 with
    | #(_)%expr_pat =>
        match x0 with
        | @expr.App _ _ _ s0 _ #(idc0)%expr_pat x2 =>
            match
              match idc0 with
              | ident.Z_shiftl offset => Some offset
              | _ => None
              end
            with
            | Some args =>
                match
                  s0 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base (base.type.Z * base.type.Z)%etype)))
                with
                | type.base t2 =>
                    fun v : expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t1 : base.type => expr (type.base t1)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base (base.type.Z * base.type.Z)%etype)))
                      (fun
                         a : option
                               (expr (type.base t2) ->
                                expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' =>
                           if s =? 2 ^ Z.log2 s
                           then
                            UnderLets.Base
                              (#(ident.fancy_addc (Z.log2 s) args)%expr @
                               (x, x1, x' v))%expr_pat
                           else
                            if s =? 2 ^ Z.log2 s
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 s) 0)%expr @
                                (x, x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                x @ x0 @ x1)%expr_pat
                       | None =>
                           UnderLets.Base
                             (#(ident.Z_add_with_get_carry_concrete s)%expr @
                              x @ x0 @ x1)%expr_pat
                       end)
                | (s1 -> d0)%ptype =>
                    fun _ : Compile.value' false s1 -> Compile.value' true d0
                    =>
                    UnderLets.Base
                      (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @
                       x1)%expr_pat
                end (Compile.reflect x2)
            | None =>
                match
                  match idc0 with
                  | ident.Z_shiftr offset => Some offset
                  | _ => None
                  end
                with
                | Some args =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => expr (type.base t1)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               if s =? 2 ^ Z.log2 s
                               then
                                UnderLets.Base
                                  (#(ident.fancy_addc (Z.log2 s) (- args))%expr @
                                   (x, x1, x' v))%expr_pat
                               else
                                if s =? 2 ^ Z.log2 s
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 s) 0)%expr @
                                    (x, x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                    x @ x0 @ x1)%expr_pat
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                  x @ x0 @ x1)%expr_pat
                           end)
                    | (s1 -> d0)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d0 =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                           x0 @ x1)%expr_pat
                    end (Compile.reflect x2)
                | None =>
                    if s =? 2 ^ Z.log2 s
                    then
                     UnderLets.Base
                       (#(ident.fancy_addc (Z.log2 s) 0)%expr @ (x, x0, x1))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                        x0 @ x1)%expr_pat
                end
            end
        | @expr.App _ _ _ s0 _ ($_)%expr _ | @expr.App _ _ _ s0 _
          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0 _ (_ @ _)%expr_pat
          _ | @expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            if s =? 2 ^ Z.log2 s
            then
             UnderLets.Base
               (#(ident.fancy_addc (Z.log2 s) 0)%expr @ (x, x0, x1))%expr_pat
            else
             UnderLets.Base
               (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @ x1)%expr_pat
        | _ =>
            if s =? 2 ^ Z.log2 s
            then
             UnderLets.Base
               (#(ident.fancy_addc (Z.log2 s) 0)%expr @ (x, x0, x1))%expr_pat
            else
             UnderLets.Base
               (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @ x1)%expr_pat
        end
    | ($_)%expr =>
        match x0 with
        | @expr.App _ _ _ s0 _ #(idc)%expr_pat x2 =>
            match
              match idc with
              | ident.Z_shiftl offset => Some offset
              | _ => None
              end
            with
            | Some args =>
                match
                  s0 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base (base.type.Z * base.type.Z)%etype)))
                with
                | type.base t2 =>
                    fun v0 : expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t1 : base.type => expr (type.base t1)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base (base.type.Z * base.type.Z)%etype)))
                      (fun
                         a : option
                               (expr (type.base t2) ->
                                expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' =>
                           if s =? 2 ^ Z.log2 s
                           then
                            UnderLets.Base
                              (#(ident.fancy_addc (Z.log2 s) args)%expr @
                               (x, x1, x' v0))%expr_pat
                           else
                            if s =? 2 ^ Z.log2 s
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 s) 0)%expr @
                                (x, x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                x @ x0 @ x1)%expr_pat
                       | None =>
                           UnderLets.Base
                             (#(ident.Z_add_with_get_carry_concrete s)%expr @
                              x @ x0 @ x1)%expr_pat
                       end)
                | (s1 -> d0)%ptype =>
                    fun _ : Compile.value' false s1 -> Compile.value' true d0
                    =>
                    UnderLets.Base
                      (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @
                       x1)%expr_pat
                end (Compile.reflect x2)
            | None =>
                match
                  match idc with
                  | ident.Z_shiftr offset => Some offset
                  | _ => None
                  end
                with
                | Some args =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v0 : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => expr (type.base t1)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               if s =? 2 ^ Z.log2 s
                               then
                                UnderLets.Base
                                  (#(ident.fancy_addc (Z.log2 s) (- args))%expr @
                                   (x, x1, x' v0))%expr_pat
                               else
                                if s =? 2 ^ Z.log2 s
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 s) 0)%expr @
                                    (x, x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                    x @ x0 @ x1)%expr_pat
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                  x @ x0 @ x1)%expr_pat
                           end)
                    | (s1 -> d0)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d0 =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                           x0 @ x1)%expr_pat
                    end (Compile.reflect x2)
                | None =>
                    if s =? 2 ^ Z.log2 s
                    then
                     UnderLets.Base
                       (#(ident.fancy_addc (Z.log2 s) 0)%expr @ (x, x0, x1))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                        x0 @ x1)%expr_pat
                end
            end
        | @expr.App _ _ _ s0 _ ($_)%expr _ | @expr.App _ _ _ s0 _
          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0 _ (_ @ _)%expr_pat
          _ | @expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            if s =? 2 ^ Z.log2 s
            then
             UnderLets.Base
               (#(ident.fancy_addc (Z.log2 s) 0)%expr @ (x, x0, x1))%expr_pat
            else
             UnderLets.Base
               (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @ x1)%expr_pat
        | _ =>
            if s =? 2 ^ Z.log2 s
            then
             UnderLets.Base
               (#(ident.fancy_addc (Z.log2 s) 0)%expr @ (x, x0, x1))%expr_pat
            else
             UnderLets.Base
               (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @ x1)%expr_pat
        end
    | @expr.Abs _ _ _ _ _ _ =>
        match x0 with
        | @expr.App _ _ _ s1 _ #(idc)%expr_pat x2 =>
            match
              match idc with
              | ident.Z_shiftl offset => Some offset
              | _ => None
              end
            with
            | Some args =>
                match
                  s1 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base (base.type.Z * base.type.Z)%etype)))
                with
                | type.base t2 =>
                    fun v : expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => expr (type.base t0)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base (base.type.Z * base.type.Z)%etype)))
                      (fun
                         a : option
                               (expr (type.base t2) ->
                                expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' =>
                           if s =? 2 ^ Z.log2 s
                           then
                            UnderLets.Base
                              (#(ident.fancy_addc (Z.log2 s) args)%expr @
                               (x, x1, x' v))%expr_pat
                           else
                            if s =? 2 ^ Z.log2 s
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 s) 0)%expr @
                                (x, x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                x @ x0 @ x1)%expr_pat
                       | None =>
                           UnderLets.Base
                             (#(ident.Z_add_with_get_carry_concrete s)%expr @
                              x @ x0 @ x1)%expr_pat
                       end)
                | (s2 -> d1)%ptype =>
                    fun _ : Compile.value' false s2 -> Compile.value' true d1
                    =>
                    UnderLets.Base
                      (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @
                       x1)%expr_pat
                end (Compile.reflect x2)
            | None =>
                match
                  match idc with
                  | ident.Z_shiftr offset => Some offset
                  | _ => None
                  end
                with
                | Some args =>
                    match
                      s1 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => expr (type.base t0)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               if s =? 2 ^ Z.log2 s
                               then
                                UnderLets.Base
                                  (#(ident.fancy_addc (Z.log2 s) (- args))%expr @
                                   (x, x1, x' v))%expr_pat
                               else
                                if s =? 2 ^ Z.log2 s
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 s) 0)%expr @
                                    (x, x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                    x @ x0 @ x1)%expr_pat
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                  x @ x0 @ x1)%expr_pat
                           end)
                    | (s2 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s2 ->
                              Compile.value' true d1 =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                           x0 @ x1)%expr_pat
                    end (Compile.reflect x2)
                | None =>
                    if s =? 2 ^ Z.log2 s
                    then
                     UnderLets.Base
                       (#(ident.fancy_addc (Z.log2 s) 0)%expr @ (x, x0, x1))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                        x0 @ x1)%expr_pat
                end
            end
        | @expr.App _ _ _ s1 _ ($_)%expr _ | @expr.App _ _ _ s1 _
          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s1 _ (_ @ _)%expr_pat
          _ | @expr.App _ _ _ s1 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            if s =? 2 ^ Z.log2 s
            then
             UnderLets.Base
               (#(ident.fancy_addc (Z.log2 s) 0)%expr @ (x, x0, x1))%expr_pat
            else
             UnderLets.Base
               (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @ x1)%expr_pat
        | _ =>
            if s =? 2 ^ Z.log2 s
            then
             UnderLets.Base
               (#(ident.fancy_addc (Z.log2 s) 0)%expr @ (x, x0, x1))%expr_pat
            else
             UnderLets.Base
               (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @ x1)%expr_pat
        end
    | @expr.App _ _ _ s0 _ #(idc)%expr_pat x2 =>
        match
          match idc with
          | ident.Z_shiftl offset => Some offset
          | _ => None
          end
        with
        | Some args =>
            match
              s0 as t2
              return
                (Compile.value' false t2 ->
                 UnderLets.UnderLets base.type ident var
                   (expr (type.base (base.type.Z * base.type.Z)%etype)))
            with
            | type.base t2 =>
                fun v : expr (type.base t2) =>
                base.try_make_transport_cps
                  (fun t0 : base.type => expr (type.base t0)) t2 base.type.Z
                  (UnderLets.UnderLets base.type ident var
                     (expr (type.base (base.type.Z * base.type.Z)%etype)))
                  (fun
                     a : option
                           (expr (type.base t2) ->
                            expr (type.base base.type.Z)) =>
                   match a with
                   | Some x' =>
                       if s =? 2 ^ Z.log2 s
                       then
                        UnderLets.Base
                          (#(ident.fancy_addc (Z.log2 s) args)%expr @
                           (x, x0, x' v))%expr_pat
                       else
                        match x0 with
                        | @expr.App _ _ _ s1 _ #(idc0)%expr_pat x3 =>
                            match
                              match idc0 with
                              | ident.Z_shiftl offset => Some offset
                              | _ => None
                              end
                            with
                            | Some args0 =>
                                match
                                  s1 as t3
                                  return
                                    (Compile.value' false t3 ->
                                     UnderLets.UnderLets base.type ident var
                                       (expr
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)))
                                with
                                | type.base t3 =>
                                    fun v0 : expr (type.base t3) =>
                                    base.try_make_transport_cps
                                      (fun t1 : base.type =>
                                       expr (type.base t1)) t3 base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (expr
                                            (type.base
                                               (base.type.Z * base.type.Z)%etype)))
                                      (fun
                                         a0 : option
                                                (expr (type.base t3) ->
                                                 expr (type.base base.type.Z))
                                       =>
                                       match a0 with
                                       | Some x'0 =>
                                           if s =? 2 ^ Z.log2 s
                                           then
                                            UnderLets.Base
                                              (#(ident.fancy_addc (Z.log2 s)
                                                   args0)%expr @
                                               (x, x1, x'0 v0))%expr_pat
                                           else
                                            if s =? 2 ^ Z.log2 s
                                            then
                                             UnderLets.Base
                                               (#(ident.fancy_addc (Z.log2 s)
                                                    0)%expr @ (x, x0, x1))%expr_pat
                                            else
                                             UnderLets.Base
                                               (#(ident.Z_add_with_get_carry_concrete
                                                    s)%expr @ x @ x0 @ x1)%expr_pat
                                       | None =>
                                           UnderLets.Base
                                             (#(ident.Z_add_with_get_carry_concrete
                                                  s)%expr @ x @ x0 @ x1)%expr_pat
                                       end)
                                | (s2 -> d1)%ptype =>
                                    fun
                                      _ : Compile.value' false s2 ->
                                          Compile.value' true d1 =>
                                    UnderLets.Base
                                      (#(ident.Z_add_with_get_carry_concrete
                                           s)%expr @ x @ x0 @ x1)%expr_pat
                                end (Compile.reflect x3)
                            | None =>
                                match
                                  match idc0 with
                                  | ident.Z_shiftr offset => Some offset
                                  | _ => None
                                  end
                                with
                                | Some args0 =>
                                    match
                                      s1 as t3
                                      return
                                        (Compile.value' false t3 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t3 =>
                                        fun v0 : expr (type.base t3) =>
                                        base.try_make_transport_cps
                                          (fun t1 : base.type =>
                                           expr (type.base t1)) t3
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a0 : option
                                                    (expr (type.base t3) ->
                                                     expr
                                                       (type.base base.type.Z))
                                           =>
                                           match a0 with
                                           | Some x'0 =>
                                               if s =? 2 ^ Z.log2 s
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_addc
                                                       (Z.log2 s) (- args0))%expr @
                                                   (x, x1, x'0 v0))%expr_pat
                                               else
                                                if s =? 2 ^ Z.log2 s
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_addc
                                                        (Z.log2 s) 0)%expr @
                                                    (x, x0, x1))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_with_get_carry_concrete
                                                        s)%expr @ x @ x0 @ x1)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_with_get_carry_concrete
                                                      s)%expr @ x @ x0 @ x1)%expr_pat
                                           end)
                                    | (s2 -> d1)%ptype =>
                                        fun
                                          _ : Compile.value' false s2 ->
                                              Compile.value' true d1 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry_concrete
                                               s)%expr @ x @ x0 @ x1)%expr_pat
                                    end (Compile.reflect x3)
                                | None =>
                                    if s =? 2 ^ Z.log2 s
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_addc (Z.log2 s) 0)%expr @
                                        (x, x0, x1))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_with_get_carry_concrete
                                            s)%expr @ x @ x0 @ x1)%expr_pat
                                end
                            end
                        | @expr.App _ _ _ s1 _ ($_)%expr _ | @expr.App _ _ _
                          s1 _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s1
                          _ (_ @ _)%expr_pat _ | @expr.App _ _ _ s1 _
                          (@expr.LetIn _ _ _ _ _ _ _) _ =>
                            if s =? 2 ^ Z.log2 s
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 s) 0)%expr @
                                (x, x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                x @ x0 @ x1)%expr_pat
                        | _ =>
                            if s =? 2 ^ Z.log2 s
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 s) 0)%expr @
                                (x, x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                x @ x0 @ x1)%expr_pat
                        end
                   | None =>
                       UnderLets.Base
                         (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                          x0 @ x1)%expr_pat
                   end)
            | (s1 -> d0)%ptype =>
                fun _ : Compile.value' false s1 -> Compile.value' true d0 =>
                UnderLets.Base
                  (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @
                   x1)%expr_pat
            end (Compile.reflect x2)
        | None =>
            match
              match idc with
              | ident.Z_shiftr offset => Some offset
              | _ => None
              end
            with
            | Some args =>
                match x0 with
                | #(_)%expr_pat =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => expr (type.base t1)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               if s =? 2 ^ Z.log2 s
                               then
                                UnderLets.Base
                                  (#(ident.fancy_addc (Z.log2 s) (- args))%expr @
                                   (x, x0, x' v))%expr_pat
                               else
                                if s =? 2 ^ Z.log2 s
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 s) 0)%expr @
                                    (x, x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                    x @ x0 @ x1)%expr_pat
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                  x @ x0 @ x1)%expr_pat
                           end)
                    | (s1 -> d0)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d0 =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                           x0 @ x1)%expr_pat
                    end (Compile.reflect x2)
                | ($_)%expr =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v0 : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => expr (type.base t1)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               if s =? 2 ^ Z.log2 s
                               then
                                UnderLets.Base
                                  (#(ident.fancy_addc (Z.log2 s) (- args))%expr @
                                   (x, x0, x' v0))%expr_pat
                               else
                                if s =? 2 ^ Z.log2 s
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 s) 0)%expr @
                                    (x, x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                    x @ x0 @ x1)%expr_pat
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                  x @ x0 @ x1)%expr_pat
                           end)
                    | (s1 -> d0)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d0 =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                           x0 @ x1)%expr_pat
                    end (Compile.reflect x2)
                | @expr.Abs _ _ _ _ _ _ =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => expr (type.base t0)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               if s =? 2 ^ Z.log2 s
                               then
                                UnderLets.Base
                                  (#(ident.fancy_addc (Z.log2 s) (- args))%expr @
                                   (x, x0, x' v))%expr_pat
                               else
                                if s =? 2 ^ Z.log2 s
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 s) 0)%expr @
                                    (x, x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                    x @ x0 @ x1)%expr_pat
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                  x @ x0 @ x1)%expr_pat
                           end)
                    | (s2 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s2 ->
                              Compile.value' true d1 =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                           x0 @ x1)%expr_pat
                    end (Compile.reflect x2)
                | @expr.App _ _ _ s1 _ #(idc0)%expr_pat x3 =>
                    match
                      match idc0 with
                      | ident.Z_shiftl offset => Some offset
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        match
                          s1 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type => expr (type.base t1)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   if s =? 2 ^ Z.log2 s
                                   then
                                    UnderLets.Base
                                      (#(ident.fancy_addc (Z.log2 s) args0)%expr @
                                       (x, x1, x' v))%expr_pat
                                   else
                                    match
                                      s0 as t3
                                      return
                                        (Compile.value' false t3 ->
                                         UnderLets.UnderLets base.type ident
                                           var
                                           (expr
                                              (type.base
                                                 (base.type.Z * base.type.Z)%etype)))
                                    with
                                    | type.base t3 =>
                                        fun v0 : expr (type.base t3) =>
                                        base.try_make_transport_cps
                                          (fun t1 : base.type =>
                                           expr (type.base t1)) t3
                                          base.type.Z
                                          (UnderLets.UnderLets base.type
                                             ident var
                                             (expr
                                                (type.base
                                                   (base.type.Z * base.type.Z)%etype)))
                                          (fun
                                             a0 : option
                                                    (expr (type.base t3) ->
                                                     expr
                                                       (type.base base.type.Z))
                                           =>
                                           match a0 with
                                           | Some x'0 =>
                                               if s =? 2 ^ Z.log2 s
                                               then
                                                UnderLets.Base
                                                  (#(ident.fancy_addc
                                                       (Z.log2 s) (- args))%expr @
                                                   (x, x0, x'0 v0))%expr_pat
                                               else
                                                if s =? 2 ^ Z.log2 s
                                                then
                                                 UnderLets.Base
                                                   (#(ident.fancy_addc
                                                        (Z.log2 s) 0)%expr @
                                                    (x, x0, x1))%expr_pat
                                                else
                                                 UnderLets.Base
                                                   (#(ident.Z_add_with_get_carry_concrete
                                                        s)%expr @ x @ x0 @ x1)%expr_pat
                                           | None =>
                                               UnderLets.Base
                                                 (#(ident.Z_add_with_get_carry_concrete
                                                      s)%expr @ x @ x0 @ x1)%expr_pat
                                           end)
                                    | (s2 -> d1)%ptype =>
                                        fun
                                          _ : Compile.value' false s2 ->
                                              Compile.value' true d1 =>
                                        UnderLets.Base
                                          (#(ident.Z_add_with_get_carry_concrete
                                               s)%expr @ x @ x0 @ x1)%expr_pat
                                    end (Compile.reflect x2)
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                      x @ x0 @ x1)%expr_pat
                               end)
                        | (s2 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s2 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete s)%expr @
                               x @ x0 @ x1)%expr_pat
                        end (Compile.reflect x3)
                    | None =>
                        match
                          match idc0 with
                          | ident.Z_shiftr offset => Some offset
                          | _ => None
                          end
                        with
                        | Some args0 =>
                            match
                              s0 as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (expr
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)))
                            with
                            | type.base t2 =>
                                fun v : expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t1 : base.type => expr (type.base t1))
                                  t2 base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (expr
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)))
                                  (fun
                                     a : option
                                           (expr (type.base t2) ->
                                            expr (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       if s =? 2 ^ Z.log2 s
                                       then
                                        UnderLets.Base
                                          (#(ident.fancy_addc (Z.log2 s)
                                               (- args))%expr @ (x, x0, x' v))%expr_pat
                                       else
                                        match
                                          s1 as t3
                                          return
                                            (Compile.value' false t3 ->
                                             UnderLets.UnderLets base.type
                                               ident var
                                               (expr
                                                  (type.base
                                                     (base.type.Z *
                                                      base.type.Z)%etype)))
                                        with
                                        | type.base t3 =>
                                            fun v0 : expr (type.base t3) =>
                                            base.try_make_transport_cps
                                              (fun t1 : base.type =>
                                               expr (type.base t1)) t3
                                              base.type.Z
                                              (UnderLets.UnderLets base.type
                                                 ident var
                                                 (expr
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)))
                                              (fun
                                                 a0 : option
                                                        (expr (type.base t3) ->
                                                         expr
                                                           (type.base
                                                              base.type.Z))
                                               =>
                                               match a0 with
                                               | Some x'0 =>
                                                   if s =? 2 ^ Z.log2 s
                                                   then
                                                    UnderLets.Base
                                                      (#(ident.fancy_addc
                                                           (Z.log2 s)
                                                           (- args0))%expr @
                                                       (x, x1, x'0 v0))%expr_pat
                                                   else
                                                    if s =? 2 ^ Z.log2 s
                                                    then
                                                     UnderLets.Base
                                                       (#(ident.fancy_addc
                                                            (Z.log2 s) 0)%expr @
                                                        (x, x0, x1))%expr_pat
                                                    else
                                                     UnderLets.Base
                                                       (#(ident.Z_add_with_get_carry_concrete
                                                            s)%expr @ x @ x0 @
                                                        x1)%expr_pat
                                               | None =>
                                                   UnderLets.Base
                                                     (#(ident.Z_add_with_get_carry_concrete
                                                          s)%expr @ x @ x0 @
                                                      x1)%expr_pat
                                               end)
                                        | (s2 -> d1)%ptype =>
                                            fun
                                              _ : Compile.value' false s2 ->
                                                  Compile.value' true d1 =>
                                            UnderLets.Base
                                              (#(ident.Z_add_with_get_carry_concrete
                                                   s)%expr @ x @ x0 @ x1)%expr_pat
                                        end (Compile.reflect x3)
                                   | None =>
                                       UnderLets.Base
                                         (#(ident.Z_add_with_get_carry_concrete
                                              s)%expr @ x @ x0 @ x1)%expr_pat
                                   end)
                            | (s2 -> d1)%ptype =>
                                fun
                                  _ : Compile.value' false s2 ->
                                      Compile.value' true d1 =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                   x @ x0 @ x1)%expr_pat
                            end (Compile.reflect x2)
                        | None =>
                            match
                              s0 as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (expr
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)))
                            with
                            | type.base t2 =>
                                fun v : expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t1 : base.type => expr (type.base t1))
                                  t2 base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (expr
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)))
                                  (fun
                                     a : option
                                           (expr (type.base t2) ->
                                            expr (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       if s =? 2 ^ Z.log2 s
                                       then
                                        UnderLets.Base
                                          (#(ident.fancy_addc (Z.log2 s)
                                               (- args))%expr @ (x, x0, x' v))%expr_pat
                                       else
                                        if s =? 2 ^ Z.log2 s
                                        then
                                         UnderLets.Base
                                           (#(ident.fancy_addc (Z.log2 s) 0)%expr @
                                            (x, x0, x1))%expr_pat
                                        else
                                         UnderLets.Base
                                           (#(ident.Z_add_with_get_carry_concrete
                                                s)%expr @ x @ x0 @ x1)%expr_pat
                                   | None =>
                                       UnderLets.Base
                                         (#(ident.Z_add_with_get_carry_concrete
                                              s)%expr @ x @ x0 @ x1)%expr_pat
                                   end)
                            | (s2 -> d1)%ptype =>
                                fun
                                  _ : Compile.value' false s2 ->
                                      Compile.value' true d1 =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                   x @ x0 @ x1)%expr_pat
                            end (Compile.reflect x2)
                        end
                    end
                | @expr.App _ _ _ s1 _ ($_)%expr _ =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v0 : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => expr (type.base t1)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               if s =? 2 ^ Z.log2 s
                               then
                                UnderLets.Base
                                  (#(ident.fancy_addc (Z.log2 s) (- args))%expr @
                                   (x, x0, x' v0))%expr_pat
                               else
                                if s =? 2 ^ Z.log2 s
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 s) 0)%expr @
                                    (x, x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                    x @ x0 @ x1)%expr_pat
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                  x @ x0 @ x1)%expr_pat
                           end)
                    | (s2 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s2 ->
                              Compile.value' true d1 =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                           x0 @ x1)%expr_pat
                    end (Compile.reflect x2)
                | @expr.App _ _ _ s1 _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App
                  _ _ _ s1 _ (_ @ _)%expr_pat _ =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => expr (type.base t0)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               if s =? 2 ^ Z.log2 s
                               then
                                UnderLets.Base
                                  (#(ident.fancy_addc (Z.log2 s) (- args))%expr @
                                   (x, x0, x' v))%expr_pat
                               else
                                if s =? 2 ^ Z.log2 s
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 s) 0)%expr @
                                    (x, x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                    x @ x0 @ x1)%expr_pat
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                  x @ x0 @ x1)%expr_pat
                           end)
                    | (s3 -> d2)%ptype =>
                        fun
                          _ : Compile.value' false s3 ->
                              Compile.value' true d2 =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                           x0 @ x1)%expr_pat
                    end (Compile.reflect x2)
                | @expr.App _ _ _ s1 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => expr (type.base t0)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               if s =? 2 ^ Z.log2 s
                               then
                                UnderLets.Base
                                  (#(ident.fancy_addc (Z.log2 s) (- args))%expr @
                                   (x, x0, x' v))%expr_pat
                               else
                                if s =? 2 ^ Z.log2 s
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 s) 0)%expr @
                                    (x, x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                    x @ x0 @ x1)%expr_pat
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                  x @ x0 @ x1)%expr_pat
                           end)
                    | (s2 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s2 ->
                              Compile.value' true d1 =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                           x0 @ x1)%expr_pat
                    end (Compile.reflect x2)
                | @expr.LetIn _ _ _ _ _ _ _ =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => expr (type.base t0)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               if s =? 2 ^ Z.log2 s
                               then
                                UnderLets.Base
                                  (#(ident.fancy_addc (Z.log2 s) (- args))%expr @
                                   (x, x0, x' v))%expr_pat
                               else
                                if s =? 2 ^ Z.log2 s
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 s) 0)%expr @
                                    (x, x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                    x @ x0 @ x1)%expr_pat
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                  x @ x0 @ x1)%expr_pat
                           end)
                    | (s1 -> d0)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d0 =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                           x0 @ x1)%expr_pat
                    end (Compile.reflect x2)
                end
            | None =>
                match x0 with
                | @expr.App _ _ _ s1 _ #(idc0)%expr_pat x3 =>
                    match
                      match idc0 with
                      | ident.Z_shiftl offset => Some offset
                      | _ => None
                      end
                    with
                    | Some args =>
                        match
                          s1 as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (expr
                                  (type.base
                                     (base.type.Z * base.type.Z)%etype)))
                        with
                        | type.base t2 =>
                            fun v : expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type => expr (type.base t1)) t2
                              base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (expr
                                    (type.base
                                       (base.type.Z * base.type.Z)%etype)))
                              (fun
                                 a : option
                                       (expr (type.base t2) ->
                                        expr (type.base base.type.Z)) =>
                               match a with
                               | Some x' =>
                                   if s =? 2 ^ Z.log2 s
                                   then
                                    UnderLets.Base
                                      (#(ident.fancy_addc (Z.log2 s) args)%expr @
                                       (x, x1, x' v))%expr_pat
                                   else
                                    if s =? 2 ^ Z.log2 s
                                    then
                                     UnderLets.Base
                                       (#(ident.fancy_addc (Z.log2 s) 0)%expr @
                                        (x, x0, x1))%expr_pat
                                    else
                                     UnderLets.Base
                                       (#(ident.Z_add_with_get_carry_concrete
                                            s)%expr @ x @ x0 @ x1)%expr_pat
                               | None =>
                                   UnderLets.Base
                                     (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                      x @ x0 @ x1)%expr_pat
                               end)
                        | (s2 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s2 ->
                                  Compile.value' true d1 =>
                            UnderLets.Base
                              (#(ident.Z_add_with_get_carry_concrete s)%expr @
                               x @ x0 @ x1)%expr_pat
                        end (Compile.reflect x3)
                    | None =>
                        match
                          match idc0 with
                          | ident.Z_shiftr offset => Some offset
                          | _ => None
                          end
                        with
                        | Some args =>
                            match
                              s1 as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (expr
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)))
                            with
                            | type.base t2 =>
                                fun v : expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t1 : base.type => expr (type.base t1))
                                  t2 base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (expr
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)))
                                  (fun
                                     a : option
                                           (expr (type.base t2) ->
                                            expr (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       if s =? 2 ^ Z.log2 s
                                       then
                                        UnderLets.Base
                                          (#(ident.fancy_addc (Z.log2 s)
                                               (- args))%expr @ (x, x1, x' v))%expr_pat
                                       else
                                        if s =? 2 ^ Z.log2 s
                                        then
                                         UnderLets.Base
                                           (#(ident.fancy_addc (Z.log2 s) 0)%expr @
                                            (x, x0, x1))%expr_pat
                                        else
                                         UnderLets.Base
                                           (#(ident.Z_add_with_get_carry_concrete
                                                s)%expr @ x @ x0 @ x1)%expr_pat
                                   | None =>
                                       UnderLets.Base
                                         (#(ident.Z_add_with_get_carry_concrete
                                              s)%expr @ x @ x0 @ x1)%expr_pat
                                   end)
                            | (s2 -> d1)%ptype =>
                                fun
                                  _ : Compile.value' false s2 ->
                                      Compile.value' true d1 =>
                                UnderLets.Base
                                  (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                   x @ x0 @ x1)%expr_pat
                            end (Compile.reflect x3)
                        | None =>
                            if s =? 2 ^ Z.log2 s
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 s) 0)%expr @
                                (x, x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                x @ x0 @ x1)%expr_pat
                        end
                    end
                | @expr.App _ _ _ s1 _ ($_)%expr _ | @expr.App _ _ _ s1 _
                  (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s1 _
                  (_ @ _)%expr_pat _ | @expr.App _ _ _ s1 _
                  (@expr.LetIn _ _ _ _ _ _ _) _ =>
                    if s =? 2 ^ Z.log2 s
                    then
                     UnderLets.Base
                       (#(ident.fancy_addc (Z.log2 s) 0)%expr @ (x, x0, x1))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                        x0 @ x1)%expr_pat
                | _ =>
                    if s =? 2 ^ Z.log2 s
                    then
                     UnderLets.Base
                       (#(ident.fancy_addc (Z.log2 s) 0)%expr @ (x, x0, x1))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                        x0 @ x1)%expr_pat
                end
            end
        end
    | @expr.App _ _ _ s0 _ ($_)%expr _ =>
        match x0 with
        | @expr.App _ _ _ s1 _ #(idc)%expr_pat x3 =>
            match
              match idc with
              | ident.Z_shiftl offset => Some offset
              | _ => None
              end
            with
            | Some args =>
                match
                  s1 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base (base.type.Z * base.type.Z)%etype)))
                with
                | type.base t2 =>
                    fun v0 : expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t1 : base.type => expr (type.base t1)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base (base.type.Z * base.type.Z)%etype)))
                      (fun
                         a : option
                               (expr (type.base t2) ->
                                expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' =>
                           if s =? 2 ^ Z.log2 s
                           then
                            UnderLets.Base
                              (#(ident.fancy_addc (Z.log2 s) args)%expr @
                               (x, x1, x' v0))%expr_pat
                           else
                            if s =? 2 ^ Z.log2 s
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 s) 0)%expr @
                                (x, x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                x @ x0 @ x1)%expr_pat
                       | None =>
                           UnderLets.Base
                             (#(ident.Z_add_with_get_carry_concrete s)%expr @
                              x @ x0 @ x1)%expr_pat
                       end)
                | (s2 -> d1)%ptype =>
                    fun _ : Compile.value' false s2 -> Compile.value' true d1
                    =>
                    UnderLets.Base
                      (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @
                       x1)%expr_pat
                end (Compile.reflect x3)
            | None =>
                match
                  match idc with
                  | ident.Z_shiftr offset => Some offset
                  | _ => None
                  end
                with
                | Some args =>
                    match
                      s1 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v0 : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => expr (type.base t1)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               if s =? 2 ^ Z.log2 s
                               then
                                UnderLets.Base
                                  (#(ident.fancy_addc (Z.log2 s) (- args))%expr @
                                   (x, x1, x' v0))%expr_pat
                               else
                                if s =? 2 ^ Z.log2 s
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 s) 0)%expr @
                                    (x, x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                    x @ x0 @ x1)%expr_pat
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                  x @ x0 @ x1)%expr_pat
                           end)
                    | (s2 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s2 ->
                              Compile.value' true d1 =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                           x0 @ x1)%expr_pat
                    end (Compile.reflect x3)
                | None =>
                    if s =? 2 ^ Z.log2 s
                    then
                     UnderLets.Base
                       (#(ident.fancy_addc (Z.log2 s) 0)%expr @ (x, x0, x1))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                        x0 @ x1)%expr_pat
                end
            end
        | @expr.App _ _ _ s1 _ ($_)%expr _ | @expr.App _ _ _ s1 _
          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s1 _ (_ @ _)%expr_pat
          _ | @expr.App _ _ _ s1 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            if s =? 2 ^ Z.log2 s
            then
             UnderLets.Base
               (#(ident.fancy_addc (Z.log2 s) 0)%expr @ (x, x0, x1))%expr_pat
            else
             UnderLets.Base
               (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @ x1)%expr_pat
        | _ =>
            if s =? 2 ^ Z.log2 s
            then
             UnderLets.Base
               (#(ident.fancy_addc (Z.log2 s) 0)%expr @ (x, x0, x1))%expr_pat
            else
             UnderLets.Base
               (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @ x1)%expr_pat
        end
    | @expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ =>
        match x0 with
        | @expr.App _ _ _ s2 _ #(idc)%expr_pat x3 =>
            match
              match idc with
              | ident.Z_shiftl offset => Some offset
              | _ => None
              end
            with
            | Some args =>
                match
                  s2 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base (base.type.Z * base.type.Z)%etype)))
                with
                | type.base t2 =>
                    fun v : expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => expr (type.base t0)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base (base.type.Z * base.type.Z)%etype)))
                      (fun
                         a : option
                               (expr (type.base t2) ->
                                expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' =>
                           if s =? 2 ^ Z.log2 s
                           then
                            UnderLets.Base
                              (#(ident.fancy_addc (Z.log2 s) args)%expr @
                               (x, x1, x' v))%expr_pat
                           else
                            if s =? 2 ^ Z.log2 s
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 s) 0)%expr @
                                (x, x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                x @ x0 @ x1)%expr_pat
                       | None =>
                           UnderLets.Base
                             (#(ident.Z_add_with_get_carry_concrete s)%expr @
                              x @ x0 @ x1)%expr_pat
                       end)
                | (s3 -> d2)%ptype =>
                    fun _ : Compile.value' false s3 -> Compile.value' true d2
                    =>
                    UnderLets.Base
                      (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @
                       x1)%expr_pat
                end (Compile.reflect x3)
            | None =>
                match
                  match idc with
                  | ident.Z_shiftr offset => Some offset
                  | _ => None
                  end
                with
                | Some args =>
                    match
                      s2 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => expr (type.base t0)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               if s =? 2 ^ Z.log2 s
                               then
                                UnderLets.Base
                                  (#(ident.fancy_addc (Z.log2 s) (- args))%expr @
                                   (x, x1, x' v))%expr_pat
                               else
                                if s =? 2 ^ Z.log2 s
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 s) 0)%expr @
                                    (x, x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                    x @ x0 @ x1)%expr_pat
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                  x @ x0 @ x1)%expr_pat
                           end)
                    | (s3 -> d2)%ptype =>
                        fun
                          _ : Compile.value' false s3 ->
                              Compile.value' true d2 =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                           x0 @ x1)%expr_pat
                    end (Compile.reflect x3)
                | None =>
                    if s =? 2 ^ Z.log2 s
                    then
                     UnderLets.Base
                       (#(ident.fancy_addc (Z.log2 s) 0)%expr @ (x, x0, x1))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                        x0 @ x1)%expr_pat
                end
            end
        | @expr.App _ _ _ s2 _ ($_)%expr _ | @expr.App _ _ _ s2 _
          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s2 _ (_ @ _)%expr_pat
          _ | @expr.App _ _ _ s2 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            if s =? 2 ^ Z.log2 s
            then
             UnderLets.Base
               (#(ident.fancy_addc (Z.log2 s) 0)%expr @ (x, x0, x1))%expr_pat
            else
             UnderLets.Base
               (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @ x1)%expr_pat
        | _ =>
            if s =? 2 ^ Z.log2 s
            then
             UnderLets.Base
               (#(ident.fancy_addc (Z.log2 s) 0)%expr @ (x, x0, x1))%expr_pat
            else
             UnderLets.Base
               (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @ x1)%expr_pat
        end
    | @expr.App _ _ _ s0 _ (_ @ _)%expr_pat _ =>
        match x0 with
        | @expr.App _ _ _ s2 _ #(idc)%expr_pat x4 =>
            match
              match idc with
              | ident.Z_shiftl offset => Some offset
              | _ => None
              end
            with
            | Some args =>
                match
                  s2 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base (base.type.Z * base.type.Z)%etype)))
                with
                | type.base t2 =>
                    fun v : expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => expr (type.base t0)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base (base.type.Z * base.type.Z)%etype)))
                      (fun
                         a : option
                               (expr (type.base t2) ->
                                expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' =>
                           if s =? 2 ^ Z.log2 s
                           then
                            UnderLets.Base
                              (#(ident.fancy_addc (Z.log2 s) args)%expr @
                               (x, x1, x' v))%expr_pat
                           else
                            if s =? 2 ^ Z.log2 s
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 s) 0)%expr @
                                (x, x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                x @ x0 @ x1)%expr_pat
                       | None =>
                           UnderLets.Base
                             (#(ident.Z_add_with_get_carry_concrete s)%expr @
                              x @ x0 @ x1)%expr_pat
                       end)
                | (s3 -> d2)%ptype =>
                    fun _ : Compile.value' false s3 -> Compile.value' true d2
                    =>
                    UnderLets.Base
                      (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @
                       x1)%expr_pat
                end (Compile.reflect x4)
            | None =>
                match
                  match idc with
                  | ident.Z_shiftr offset => Some offset
                  | _ => None
                  end
                with
                | Some args =>
                    match
                      s2 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => expr (type.base t0)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               if s =? 2 ^ Z.log2 s
                               then
                                UnderLets.Base
                                  (#(ident.fancy_addc (Z.log2 s) (- args))%expr @
                                   (x, x1, x' v))%expr_pat
                               else
                                if s =? 2 ^ Z.log2 s
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 s) 0)%expr @
                                    (x, x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                    x @ x0 @ x1)%expr_pat
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                  x @ x0 @ x1)%expr_pat
                           end)
                    | (s3 -> d2)%ptype =>
                        fun
                          _ : Compile.value' false s3 ->
                              Compile.value' true d2 =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                           x0 @ x1)%expr_pat
                    end (Compile.reflect x4)
                | None =>
                    if s =? 2 ^ Z.log2 s
                    then
                     UnderLets.Base
                       (#(ident.fancy_addc (Z.log2 s) 0)%expr @ (x, x0, x1))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                        x0 @ x1)%expr_pat
                end
            end
        | @expr.App _ _ _ s2 _ ($_)%expr _ | @expr.App _ _ _ s2 _
          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s2 _ (_ @ _)%expr_pat
          _ | @expr.App _ _ _ s2 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            if s =? 2 ^ Z.log2 s
            then
             UnderLets.Base
               (#(ident.fancy_addc (Z.log2 s) 0)%expr @ (x, x0, x1))%expr_pat
            else
             UnderLets.Base
               (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @ x1)%expr_pat
        | _ =>
            if s =? 2 ^ Z.log2 s
            then
             UnderLets.Base
               (#(ident.fancy_addc (Z.log2 s) 0)%expr @ (x, x0, x1))%expr_pat
            else
             UnderLets.Base
               (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @ x1)%expr_pat
        end
    | @expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
        match x0 with
        | @expr.App _ _ _ s1 _ #(idc)%expr_pat x4 =>
            match
              match idc with
              | ident.Z_shiftl offset => Some offset
              | _ => None
              end
            with
            | Some args =>
                match
                  s1 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base (base.type.Z * base.type.Z)%etype)))
                with
                | type.base t2 =>
                    fun v : expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => expr (type.base t0)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base (base.type.Z * base.type.Z)%etype)))
                      (fun
                         a : option
                               (expr (type.base t2) ->
                                expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' =>
                           if s =? 2 ^ Z.log2 s
                           then
                            UnderLets.Base
                              (#(ident.fancy_addc (Z.log2 s) args)%expr @
                               (x, x1, x' v))%expr_pat
                           else
                            if s =? 2 ^ Z.log2 s
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 s) 0)%expr @
                                (x, x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                x @ x0 @ x1)%expr_pat
                       | None =>
                           UnderLets.Base
                             (#(ident.Z_add_with_get_carry_concrete s)%expr @
                              x @ x0 @ x1)%expr_pat
                       end)
                | (s2 -> d1)%ptype =>
                    fun _ : Compile.value' false s2 -> Compile.value' true d1
                    =>
                    UnderLets.Base
                      (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @
                       x1)%expr_pat
                end (Compile.reflect x4)
            | None =>
                match
                  match idc with
                  | ident.Z_shiftr offset => Some offset
                  | _ => None
                  end
                with
                | Some args =>
                    match
                      s1 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => expr (type.base t0)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               if s =? 2 ^ Z.log2 s
                               then
                                UnderLets.Base
                                  (#(ident.fancy_addc (Z.log2 s) (- args))%expr @
                                   (x, x1, x' v))%expr_pat
                               else
                                if s =? 2 ^ Z.log2 s
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 s) 0)%expr @
                                    (x, x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                    x @ x0 @ x1)%expr_pat
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                  x @ x0 @ x1)%expr_pat
                           end)
                    | (s2 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s2 ->
                              Compile.value' true d1 =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                           x0 @ x1)%expr_pat
                    end (Compile.reflect x4)
                | None =>
                    if s =? 2 ^ Z.log2 s
                    then
                     UnderLets.Base
                       (#(ident.fancy_addc (Z.log2 s) 0)%expr @ (x, x0, x1))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                        x0 @ x1)%expr_pat
                end
            end
        | @expr.App _ _ _ s1 _ ($_)%expr _ | @expr.App _ _ _ s1 _
          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s1 _ (_ @ _)%expr_pat
          _ | @expr.App _ _ _ s1 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            if s =? 2 ^ Z.log2 s
            then
             UnderLets.Base
               (#(ident.fancy_addc (Z.log2 s) 0)%expr @ (x, x0, x1))%expr_pat
            else
             UnderLets.Base
               (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @ x1)%expr_pat
        | _ =>
            if s =? 2 ^ Z.log2 s
            then
             UnderLets.Base
               (#(ident.fancy_addc (Z.log2 s) 0)%expr @ (x, x0, x1))%expr_pat
            else
             UnderLets.Base
               (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @ x1)%expr_pat
        end
    | @expr.LetIn _ _ _ _ _ _ _ =>
        match x0 with
        | @expr.App _ _ _ s0 _ #(idc)%expr_pat x3 =>
            match
              match idc with
              | ident.Z_shiftl offset => Some offset
              | _ => None
              end
            with
            | Some args =>
                match
                  s0 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base (base.type.Z * base.type.Z)%etype)))
                with
                | type.base t2 =>
                    fun v : expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => expr (type.base t0)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base (base.type.Z * base.type.Z)%etype)))
                      (fun
                         a : option
                               (expr (type.base t2) ->
                                expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' =>
                           if s =? 2 ^ Z.log2 s
                           then
                            UnderLets.Base
                              (#(ident.fancy_addc (Z.log2 s) args)%expr @
                               (x, x1, x' v))%expr_pat
                           else
                            if s =? 2 ^ Z.log2 s
                            then
                             UnderLets.Base
                               (#(ident.fancy_addc (Z.log2 s) 0)%expr @
                                (x, x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                x @ x0 @ x1)%expr_pat
                       | None =>
                           UnderLets.Base
                             (#(ident.Z_add_with_get_carry_concrete s)%expr @
                              x @ x0 @ x1)%expr_pat
                       end)
                | (s1 -> d0)%ptype =>
                    fun _ : Compile.value' false s1 -> Compile.value' true d0
                    =>
                    UnderLets.Base
                      (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @
                       x1)%expr_pat
                end (Compile.reflect x3)
            | None =>
                match
                  match idc with
                  | ident.Z_shiftr offset => Some offset
                  | _ => None
                  end
                with
                | Some args =>
                    match
                      s0 as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v : expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t0 : base.type => expr (type.base t0)) t2
                          base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (expr (type.base t2) ->
                                    expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               if s =? 2 ^ Z.log2 s
                               then
                                UnderLets.Base
                                  (#(ident.fancy_addc (Z.log2 s) (- args))%expr @
                                   (x, x1, x' v))%expr_pat
                               else
                                if s =? 2 ^ Z.log2 s
                                then
                                 UnderLets.Base
                                   (#(ident.fancy_addc (Z.log2 s) 0)%expr @
                                    (x, x0, x1))%expr_pat
                                else
                                 UnderLets.Base
                                   (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                    x @ x0 @ x1)%expr_pat
                           | None =>
                               UnderLets.Base
                                 (#(ident.Z_add_with_get_carry_concrete s)%expr @
                                  x @ x0 @ x1)%expr_pat
                           end)
                    | (s1 -> d0)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d0 =>
                        UnderLets.Base
                          (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                           x0 @ x1)%expr_pat
                    end (Compile.reflect x3)
                | None =>
                    if s =? 2 ^ Z.log2 s
                    then
                     UnderLets.Base
                       (#(ident.fancy_addc (Z.log2 s) 0)%expr @ (x, x0, x1))%expr_pat
                    else
                     UnderLets.Base
                       (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @
                        x0 @ x1)%expr_pat
                end
            end
        | @expr.App _ _ _ s0 _ ($_)%expr _ | @expr.App _ _ _ s0 _
          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0 _ (_ @ _)%expr_pat
          _ | @expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
            if s =? 2 ^ Z.log2 s
            then
             UnderLets.Base
               (#(ident.fancy_addc (Z.log2 s) 0)%expr @ (x, x0, x1))%expr_pat
            else
             UnderLets.Base
               (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @ x1)%expr_pat
        | _ =>
            if s =? 2 ^ Z.log2 s
            then
             UnderLets.Base
               (#(ident.fancy_addc (Z.log2 s) 0)%expr @ (x, x0, x1))%expr_pat
            else
             UnderLets.Base
               (#(ident.Z_add_with_get_carry_concrete s)%expr @ x @ x0 @ x1)%expr_pat
        end
    end
| ident.Z_sub_get_borrow =>
    fun x x0 x1 : expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_sub_get_borrow)%expr @ x @ x0 @ x1)%expr_pat
| ident.Z_sub_get_borrow_concrete s =>
    fun x x0 : expr (type.base base.type.Z) =>
    match x0 with
    | @expr.App _ _ _ s0 _ #(idc)%expr_pat x1 =>
        match
          match idc with
          | ident.Z_shiftl offset => Some offset
          | _ => None
          end
        with
        | Some args =>
            match
              s0 as t2
              return
                (Compile.value' false t2 ->
                 UnderLets.UnderLets base.type ident var
                   (expr (type.base (base.type.Z * base.type.Z)%etype)))
            with
            | type.base t2 =>
                fun v : expr (type.base t2) =>
                base.try_make_transport_cps
                  (fun t0 : base.type => expr (type.base t0)) t2 base.type.Z
                  (UnderLets.UnderLets base.type ident var
                     (expr (type.base (base.type.Z * base.type.Z)%etype)))
                  (fun
                     a : option
                           (expr (type.base t2) ->
                            expr (type.base base.type.Z)) =>
                   match a with
                   | Some x' =>
                       if s =? 2 ^ Z.log2 s
                       then
                        UnderLets.Base
                          (#(ident.fancy_sub (Z.log2 s) args)%expr @
                           (x, x' v))%expr_pat
                       else
                        if s =? 2 ^ Z.log2 s
                        then
                         UnderLets.Base
                           (#(ident.fancy_sub (Z.log2 s) 0)%expr @ (x, x0))%expr_pat
                        else
                         UnderLets.Base
                           (#(ident.Z_sub_get_borrow_concrete s)%expr @ x @
                            x0)%expr_pat
                   | None =>
                       UnderLets.Base
                         (#(ident.Z_sub_get_borrow_concrete s)%expr @ x @ x0)%expr_pat
                   end)
            | (s1 -> d0)%ptype =>
                fun _ : Compile.value' false s1 -> Compile.value' true d0 =>
                UnderLets.Base
                  (#(ident.Z_sub_get_borrow_concrete s)%expr @ x @ x0)%expr_pat
            end (Compile.reflect x1)
        | None =>
            match
              match idc with
              | ident.Z_shiftr offset => Some offset
              | _ => None
              end
            with
            | Some args =>
                match
                  s0 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base (base.type.Z * base.type.Z)%etype)))
                with
                | type.base t2 =>
                    fun v : expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => expr (type.base t0)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base (base.type.Z * base.type.Z)%etype)))
                      (fun
                         a : option
                               (expr (type.base t2) ->
                                expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' =>
                           if s =? 2 ^ Z.log2 s
                           then
                            UnderLets.Base
                              (#(ident.fancy_sub (Z.log2 s) (- args))%expr @
                               (x, x' v))%expr_pat
                           else
                            if s =? 2 ^ Z.log2 s
                            then
                             UnderLets.Base
                               (#(ident.fancy_sub (Z.log2 s) 0)%expr @
                                (x, x0))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_sub_get_borrow_concrete s)%expr @ x @
                                x0)%expr_pat
                       | None =>
                           UnderLets.Base
                             (#(ident.Z_sub_get_borrow_concrete s)%expr @ x @
                              x0)%expr_pat
                       end)
                | (s1 -> d0)%ptype =>
                    fun _ : Compile.value' false s1 -> Compile.value' true d0
                    =>
                    UnderLets.Base
                      (#(ident.Z_sub_get_borrow_concrete s)%expr @ x @ x0)%expr_pat
                end (Compile.reflect x1)
            | None =>
                if s =? 2 ^ Z.log2 s
                then
                 UnderLets.Base
                   (#(ident.fancy_sub (Z.log2 s) 0)%expr @ (x, x0))%expr_pat
                else
                 UnderLets.Base
                   (#(ident.Z_sub_get_borrow_concrete s)%expr @ x @ x0)%expr_pat
            end
        end
    | @expr.App _ _ _ s0 _ ($_)%expr _ | @expr.App _ _ _ s0 _
      (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0 _ (_ @ _)%expr_pat _ |
      @expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
        if s =? 2 ^ Z.log2 s
        then
         UnderLets.Base
           (#(ident.fancy_sub (Z.log2 s) 0)%expr @ (x, x0))%expr_pat
        else
         UnderLets.Base
           (#(ident.Z_sub_get_borrow_concrete s)%expr @ x @ x0)%expr_pat
    | _ =>
        if s =? 2 ^ Z.log2 s
        then
         UnderLets.Base
           (#(ident.fancy_sub (Z.log2 s) 0)%expr @ (x, x0))%expr_pat
        else
         UnderLets.Base
           (#(ident.Z_sub_get_borrow_concrete s)%expr @ x @ x0)%expr_pat
    end
| ident.Z_sub_with_get_borrow =>
    fun x x0 x1 x2 : expr (type.base base.type.Z) =>
    UnderLets.Base
      (#(ident.Z_sub_with_get_borrow)%expr @ x @ x0 @ x1 @ x2)%expr_pat
| ident.Z_sub_with_get_borrow_concrete s =>
    fun x x0 x1 : expr (type.base base.type.Z) =>
    match x1 with
    | @expr.App _ _ _ s0 _ #(idc)%expr_pat x2 =>
        match
          match idc with
          | ident.Z_shiftl offset => Some offset
          | _ => None
          end
        with
        | Some args =>
            match
              s0 as t2
              return
                (Compile.value' false t2 ->
                 UnderLets.UnderLets base.type ident var
                   (expr (type.base (base.type.Z * base.type.Z)%etype)))
            with
            | type.base t2 =>
                fun v : expr (type.base t2) =>
                base.try_make_transport_cps
                  (fun t0 : base.type => expr (type.base t0)) t2 base.type.Z
                  (UnderLets.UnderLets base.type ident var
                     (expr (type.base (base.type.Z * base.type.Z)%etype)))
                  (fun
                     a : option
                           (expr (type.base t2) ->
                            expr (type.base base.type.Z)) =>
                   match a with
                   | Some x' =>
                       if s =? 2 ^ Z.log2 s
                       then
                        UnderLets.Base
                          (#(ident.fancy_subb (Z.log2 s) args)%expr @
                           (x, x0, x' v))%expr_pat
                       else
                        if s =? 2 ^ Z.log2 s
                        then
                         UnderLets.Base
                           (#(ident.fancy_subb (Z.log2 s) 0)%expr @
                            (x, x0, x1))%expr_pat
                        else
                         UnderLets.Base
                           (#(ident.Z_sub_with_get_borrow_concrete s)%expr @
                            x @ x0 @ x1)%expr_pat
                   | None =>
                       UnderLets.Base
                         (#(ident.Z_sub_with_get_borrow_concrete s)%expr @ x @
                          x0 @ x1)%expr_pat
                   end)
            | (s1 -> d0)%ptype =>
                fun _ : Compile.value' false s1 -> Compile.value' true d0 =>
                UnderLets.Base
                  (#(ident.Z_sub_with_get_borrow_concrete s)%expr @ x @ x0 @
                   x1)%expr_pat
            end (Compile.reflect x2)
        | None =>
            match
              match idc with
              | ident.Z_shiftr offset => Some offset
              | _ => None
              end
            with
            | Some args =>
                match
                  s0 as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base (base.type.Z * base.type.Z)%etype)))
                with
                | type.base t2 =>
                    fun v : expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => expr (type.base t0)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base (base.type.Z * base.type.Z)%etype)))
                      (fun
                         a : option
                               (expr (type.base t2) ->
                                expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' =>
                           if s =? 2 ^ Z.log2 s
                           then
                            UnderLets.Base
                              (#(ident.fancy_subb (Z.log2 s) (- args))%expr @
                               (x, x0, x' v))%expr_pat
                           else
                            if s =? 2 ^ Z.log2 s
                            then
                             UnderLets.Base
                               (#(ident.fancy_subb (Z.log2 s) 0)%expr @
                                (x, x0, x1))%expr_pat
                            else
                             UnderLets.Base
                               (#(ident.Z_sub_with_get_borrow_concrete s)%expr @
                                x @ x0 @ x1)%expr_pat
                       | None =>
                           UnderLets.Base
                             (#(ident.Z_sub_with_get_borrow_concrete s)%expr @
                              x @ x0 @ x1)%expr_pat
                       end)
                | (s1 -> d0)%ptype =>
                    fun _ : Compile.value' false s1 -> Compile.value' true d0
                    =>
                    UnderLets.Base
                      (#(ident.Z_sub_with_get_borrow_concrete s)%expr @ x @
                       x0 @ x1)%expr_pat
                end (Compile.reflect x2)
            | None =>
                if s =? 2 ^ Z.log2 s
                then
                 UnderLets.Base
                   (#(ident.fancy_subb (Z.log2 s) 0)%expr @ (x, x0, x1))%expr_pat
                else
                 UnderLets.Base
                   (#(ident.Z_sub_with_get_borrow_concrete s)%expr @ x @ x0 @
                    x1)%expr_pat
            end
        end
    | @expr.App _ _ _ s0 _ ($_)%expr _ | @expr.App _ _ _ s0 _
      (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0 _ (_ @ _)%expr_pat _ |
      @expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
        if s =? 2 ^ Z.log2 s
        then
         UnderLets.Base
           (#(ident.fancy_subb (Z.log2 s) 0)%expr @ (x, x0, x1))%expr_pat
        else
         UnderLets.Base
           (#(ident.Z_sub_with_get_borrow_concrete s)%expr @ x @ x0 @ x1)%expr_pat
    | _ =>
        if s =? 2 ^ Z.log2 s
        then
         UnderLets.Base
           (#(ident.fancy_subb (Z.log2 s) 0)%expr @ (x, x0, x1))%expr_pat
        else
         UnderLets.Base
           (#(ident.Z_sub_with_get_borrow_concrete s)%expr @ x @ x0 @ x1)%expr_pat
    end
| ident.Z_zselect =>
    fun x x0 x1 : expr (type.base base.type.Z) =>
    match x with
    | @expr.App _ _ _ s _ #(idc)%expr_pat x2 =>
        match
          match idc with
          | ident.Z_cc_m_concrete s0 => Some s0
          | _ => None
          end
        with
        | Some args =>
            match
              s as t2
              return
                (Compile.value' false t2 ->
                 UnderLets.UnderLets base.type ident var
                   (expr (type.base base.type.Z)))
            with
            | type.base t2 =>
                fun v : expr (type.base t2) =>
                base.try_make_transport_cps
                  (fun t0 : base.type => expr (type.base t0)) t2 base.type.Z
                  (UnderLets.UnderLets base.type ident var
                     (expr (type.base base.type.Z)))
                  (fun
                     a : option
                           (expr (type.base t2) ->
                            expr (type.base base.type.Z)) =>
                   match a with
                   | Some x' =>
                       if args =? 2 ^ Z.log2 args
                       then
                        UnderLets.Base
                          (#(ident.fancy_selm (Z.log2 args))%expr @
                           (x' v, x0, x1))%expr_pat
                       else
                        UnderLets.Base
                          (#(ident.fancy_selc)%expr @ (x, x0, x1))%expr_pat
                   | None =>
                       UnderLets.Base
                         (#(ident.Z_zselect)%expr @ x @ x0 @ x1)%expr_pat
                   end)
            | (s0 -> d0)%ptype =>
                fun _ : Compile.value' false s0 -> Compile.value' true d0 =>
                UnderLets.Base
                  (#(ident.Z_zselect)%expr @ x @ x0 @ x1)%expr_pat
            end (Compile.reflect x2)
        | None =>
            match
              match idc with
              | ident.Z_land mask => Some mask
              | _ => None
              end
            with
            | Some args =>
                match
                  s as t2
                  return
                    (Compile.value' false t2 ->
                     UnderLets.UnderLets base.type ident var
                       (expr (type.base base.type.Z)))
                with
                | type.base t2 =>
                    fun v : expr (type.base t2) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => expr (type.base t0)) t2
                      base.type.Z
                      (UnderLets.UnderLets base.type ident var
                         (expr (type.base base.type.Z)))
                      (fun
                         a : option
                               (expr (type.base t2) ->
                                expr (type.base base.type.Z)) =>
                       match a with
                       | Some x' =>
                           if args =? 1
                           then
                            UnderLets.Base
                              (#(ident.fancy_sell)%expr @ (x' v, x0, x1))%expr_pat
                           else
                            UnderLets.Base
                              (#(ident.fancy_selc)%expr @ (x, x0, x1))%expr_pat
                       | None =>
                           UnderLets.Base
                             (#(ident.Z_zselect)%expr @ x @ x0 @ x1)%expr_pat
                       end)
                | (s0 -> d0)%ptype =>
                    fun _ : Compile.value' false s0 -> Compile.value' true d0
                    =>
                    UnderLets.Base
                      (#(ident.Z_zselect)%expr @ x @ x0 @ x1)%expr_pat
                end (Compile.reflect x2)
            | None =>
                UnderLets.Base
                  (#(ident.fancy_selc)%expr @ (x, x0, x1))%expr_pat
            end
        end
    | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
      (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat _ |
      @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
        UnderLets.Base (#(ident.fancy_selc)%expr @ (x, x0, x1))%expr_pat
    | _ => UnderLets.Base (#(ident.fancy_selc)%expr @ (x, x0, x1))%expr_pat
    end
| ident.Z_add_modulo =>
    fun x x0 x1 : expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.fancy_addm)%expr @ (x, x0, x1))%expr_pat
| ident.Z_rshi =>
    fun x x0 x1 x2 : expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_rshi)%expr @ x @ x0 @ x1 @ x2)%expr_pat
| ident.Z_rshi_concrete s offset =>
    fun x x0 : expr (type.base base.type.Z) =>
    if s =? 2 ^ Z.log2 s
    then
     UnderLets.Base
       (#(ident.fancy_rshi (Z.log2 s) offset)%expr @ (x, x0))%expr_pat
    else
     UnderLets.Base
       (#(ident.Z_rshi_concrete s offset)%expr @ x @ x0)%expr_pat
| ident.Z_cc_m =>
    fun x x0 : expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_cc_m)%expr @ x @ x0)%expr_pat
| ident.Z_cc_m_concrete s =>
    fun x : expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_cc_m_concrete s)%expr @ x)%expr_pat
| ident.Z_neg_snd =>
    fun x : expr (type.base (base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.Z_neg_snd)%expr @ x)%expr_pat
| ident.Z_cast range =>
    fun x : expr (type.base base.type.Z) =>
    UnderLets.Base (#(ident.Z_cast range)%expr @ x)%expr_pat
| ident.Z_cast2 range =>
    fun x : expr (type.base (base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.Z_cast2 range)%expr @ x)%expr_pat
| ident.fancy_add log2wordmax imm =>
    fun x : expr (type.base (base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_add log2wordmax imm)%expr @ x)%expr_pat
| ident.fancy_addc log2wordmax imm =>
    fun x : expr (type.base (base.type.Z * base.type.Z * base.type.Z)%etype)
    => UnderLets.Base (#(ident.fancy_addc log2wordmax imm)%expr @ x)%expr_pat
| ident.fancy_sub log2wordmax imm =>
    fun x : expr (type.base (base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_sub log2wordmax imm)%expr @ x)%expr_pat
| ident.fancy_subb log2wordmax imm =>
    fun x : expr (type.base (base.type.Z * base.type.Z * base.type.Z)%etype)
    => UnderLets.Base (#(ident.fancy_subb log2wordmax imm)%expr @ x)%expr_pat
| ident.fancy_mulll log2wordmax =>
    fun x : expr (type.base (base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_mulll log2wordmax)%expr @ x)%expr_pat
| ident.fancy_mullh log2wordmax =>
    fun x : expr (type.base (base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_mullh log2wordmax)%expr @ x)%expr_pat
| ident.fancy_mulhl log2wordmax =>
    fun x : expr (type.base (base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_mulhl log2wordmax)%expr @ x)%expr_pat
| ident.fancy_mulhh log2wordmax =>
    fun x : expr (type.base (base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_mulhh log2wordmax)%expr @ x)%expr_pat
| ident.fancy_rshi log2wordmax x =>
    fun x0 : expr (type.base (base.type.Z * base.type.Z)%etype) =>
    UnderLets.Base (#(ident.fancy_rshi log2wordmax x)%expr @ x0)%expr_pat
| ident.fancy_selc =>
    fun x : expr (type.base (base.type.Z * base.type.Z * base.type.Z)%etype)
    => UnderLets.Base (#(ident.fancy_selc)%expr @ x)%expr_pat
| ident.fancy_selm log2wordmax =>
    fun x : expr (type.base (base.type.Z * base.type.Z * base.type.Z)%etype)
    => UnderLets.Base (#(ident.fancy_selm log2wordmax)%expr @ x)%expr_pat
| ident.fancy_sell =>
    fun x : expr (type.base (base.type.Z * base.type.Z * base.type.Z)%etype)
    => UnderLets.Base (#(ident.fancy_sell)%expr @ x)%expr_pat
| ident.fancy_addm =>
    fun x : expr (type.base (base.type.Z * base.type.Z * base.type.Z)%etype)
    => UnderLets.Base (#(ident.fancy_addm)%expr @ x)%expr_pat
end
     : Compile.value' true t
