arith_with_casts_rewrite_head = 
match idc in (Compilers.ident t) return (Compile.value' true t) with
| @Literal t v => Base (##v)%expr
| Nat_succ => fun x : expr ℕ => Base (#(Nat_succ)%expr @ x)%expr_pat
| Nat_pred => fun x : expr ℕ => Base (#(Nat_pred)%expr @ x)%expr_pat
| Nat_max => fun x x0 : expr ℕ => Base (#(Nat_max)%expr @ x @ x0)%expr_pat
| Nat_mul => fun x x0 : expr ℕ => Base (#(Nat_mul)%expr @ x @ x0)%expr_pat
| Nat_add => fun x x0 : expr ℕ => Base (#(Nat_add)%expr @ x @ x0)%expr_pat
| Nat_sub => fun x x0 : expr ℕ => Base (#(Nat_sub)%expr @ x @ x0)%expr_pat
| @nil t => Base []%expr_pat
| @cons t => fun (x : expr t) (x0 : expr (list t)) => Base (x :: x0)%expr_pat
| @pair A B => fun (x : expr A) (x0 : expr B) => Base (x, x0)%expr_pat
| @fst A B =>
    fun x : expr (A * B)%etype =>
    ((match x with
      | @expr.App _ _ _ s _
        (@expr.App _ _ _ s0 _ (@expr.Ident _ _ _ t idc) x1) _ =>
          args <- invert_bind_args idc Raw.ident.pair;
          match
            pattern.type.unify_extracted_cps
              ((('1 * '2)%pbtype -> '1%pbtype) ->
               (('1%pbtype -> '2%pbtype -> ('1 * '2)%pbtype) -> '1%pbtype) ->
               '2%pbtype)%ptype
              (((A * B)%etype -> A) ->
               (((let (x2, _) := args in x2) ->
                 (let (_, y) := args in y) ->
                 ((let (x2, _) := args in x2) * (let (_, y) := args in y))%etype) ->
                s0) -> s)%ptype option (fun x2 : option => x2)
          with
          | Some (_, _, _, (_, (_, (_, _)), b3, b2))%zrange =>
              if
               type.type_beq base.type base.type.type_beq
                 (((b3 * b2)%etype -> b3) ->
                  ((b3 -> b2 -> (b3 * b2)%etype) -> b3) -> b2)%ptype
                 (((A * B)%etype -> A) ->
                  (((let (x2, _) := args in x2) ->
                    (let (_, y) := args in y) ->
                    ((let (x2, _) := args in x2) * (let (_, y) := args in y))%etype) ->
                   s0) -> s)%ptype
              then
               _ <- ident.unify pattern.ident.fst fst;
               _ <- ident.unify pattern.ident.pair pair;
               v <- type.try_make_transport_cps s0 b3;
               _ <- type.try_make_transport_cps s b2;
               v1 <- base.try_make_transport_cps b3 b3;
               _ <- base.try_make_transport_cps b2 b2;
               v3 <- base.try_make_transport_cps b3 A;
               v4 <- base.try_make_transport_cps A A;
               Some (Base (v4 (v3 (v1 (v (Compile.reflect x1))))))
              else None
          | None => None
          end
      | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ ($_)%expr _) _ | @expr.App
        _ _ _ s _ (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _) _ |
        @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ (_ @ _)%expr_pat _) _ |
        @expr.App _ _ _ s _
        (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _) _ => None
      | @expr.App _ _ _ s _ #(_)%expr_pat _ | @expr.App _ _ _ s _ ($_)%expr
        _ | @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s
        _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
      | _ => None
      end;;
      None);;;
     Base (#(fst)%expr @ x)%expr_pat)%option
| @snd A B =>
    fun x : expr (A * B)%etype =>
    ((match x with
      | @expr.App _ _ _ s _
        (@expr.App _ _ _ s0 _ (@expr.Ident _ _ _ t idc) _) x0 =>
          args <- invert_bind_args idc Raw.ident.pair;
          match
            pattern.type.unify_extracted_cps
              ((('1 * '2)%pbtype -> '2%pbtype) ->
               (('1%pbtype -> '2%pbtype -> ('1 * '2)%pbtype) -> '1%pbtype) ->
               '2%pbtype)%ptype
              (((A * B)%etype -> B) ->
               (((let (x2, _) := args in x2) ->
                 (let (_, y) := args in y) ->
                 ((let (x2, _) := args in x2) * (let (_, y) := args in y))%etype) ->
                s0) -> s)%ptype option (fun x2 : option => x2)
          with
          | Some (_, _, _, (_, (_, (_, _)), b3, b2))%zrange =>
              if
               type.type_beq base.type base.type.type_beq
                 (((b3 * b2)%etype -> b2) ->
                  ((b3 -> b2 -> (b3 * b2)%etype) -> b3) -> b2)%ptype
                 (((A * B)%etype -> B) ->
                  (((let (x2, _) := args in x2) ->
                    (let (_, y) := args in y) ->
                    ((let (x2, _) := args in x2) * (let (_, y) := args in y))%etype) ->
                   s0) -> s)%ptype
              then
               _ <- ident.unify pattern.ident.snd snd;
               _ <- ident.unify pattern.ident.pair pair;
               _ <- type.try_make_transport_cps s0 b3;
               v0 <- type.try_make_transport_cps s b2;
               _ <- base.try_make_transport_cps b3 b3;
               v2 <- base.try_make_transport_cps b2 b2;
               v3 <- base.try_make_transport_cps b2 B;
               v4 <- base.try_make_transport_cps B B;
               Some (Base (v4 (v3 (v2 (v0 (Compile.reflect x0))))))
              else None
          | None => None
          end
      | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ ($_)%expr _) _ | @expr.App
        _ _ _ s _ (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _) _ |
        @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ (_ @ _)%expr_pat _) _ |
        @expr.App _ _ _ s _
        (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _) _ => None
      | @expr.App _ _ _ s _ #(_)%expr_pat _ | @expr.App _ _ _ s _ ($_)%expr
        _ | @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s
        _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
      | _ => None
      end;;
      None);;;
     Base (#(snd)%expr @ x)%expr_pat)%option
| @prod_rect A B T =>
    fun (x : expr A -> expr B -> UnderLets (expr T))
      (x0 : expr (A * B)%etype) =>
    Base
      (#(prod_rect)%expr @
       (λ (x1 : var A)(x2 : var B),
        to_expr (x ($x1) ($x2)))%expr @ x0)%expr_pat
| @bool_rect T =>
    fun (x x0 : expr unit -> UnderLets (expr T)) (x1 : expr bool) =>
    Base
      (#(bool_rect)%expr @ (λ x2 : var unit,
                            to_expr (x ($x2)))%expr @
       (λ x2 : var unit,
        to_expr (x0 ($x2)))%expr @ x1)%expr_pat
| @nat_rect P =>
    fun (x : expr unit -> UnderLets (expr P))
      (x0 : expr ℕ -> expr P -> UnderLets (expr P)) (x1 : expr ℕ) =>
    Base
      (#(nat_rect)%expr @ (λ x2 : var unit,
                           to_expr (x ($x2)))%expr @
       (λ (x2 : var ℕ)(x3 : var P),
        to_expr (x0 ($x2) ($x3)))%expr @ x1)%expr_pat
| @nat_rect_arrow P Q =>
    fun (x : expr P -> UnderLets (expr Q))
      (x0 : expr ℕ ->
            (expr P -> UnderLets (expr Q)) -> expr P -> UnderLets (expr Q))
      (x1 : expr ℕ) (x2 : expr P) =>
    Base
      (#(nat_rect_arrow)%expr @ (λ x3 : var P,
                                 to_expr (x ($x3)))%expr @
       (λ (x3 : var ℕ)(x4 : var (P -> Q)%ptype)(x5 : var P),
        to_expr
          (x0 ($x3) (fun x6 : expr P => Base ($x4 @ x6)%expr_pat) ($x5)))%expr @
       x1 @ x2)%expr_pat
| @list_rect A P =>
    fun (x : expr unit -> UnderLets (expr P))
      (x0 : expr A -> expr (list A) -> expr P -> UnderLets (expr P))
      (x1 : expr (list A)) =>
    Base
      (#(list_rect)%expr @ (λ x2 : var unit,
                            to_expr (x ($x2)))%expr @
       (λ (x2 : var A)(x3 : var (list A))(x4 : var P),
        to_expr (x0 ($x2) ($x3) ($x4)))%expr @ x1)%expr_pat
| @list_case A P =>
    fun (x : expr unit -> UnderLets (expr P))
      (x0 : expr A -> expr (list A) -> UnderLets (expr P))
      (x1 : expr (list A)) =>
    Base
      (#(list_case)%expr @ (λ x2 : var unit,
                            to_expr (x ($x2)))%expr @
       (λ (x2 : var A)(x3 : var (list A)),
        to_expr (x0 ($x2) ($x3)))%expr @ x1)%expr_pat
| @List_length T =>
    fun x : expr (list T) => Base (#(List_length)%expr @ x)%expr_pat
| List_seq => fun x x0 : expr ℕ => Base (#(List_seq)%expr @ x @ x0)%expr_pat
| @List_firstn A =>
    fun (x : expr ℕ) (x0 : expr (list A)) =>
    Base (#(List_firstn)%expr @ x @ x0)%expr_pat
| @List_skipn A =>
    fun (x : expr ℕ) (x0 : expr (list A)) =>
    Base (#(List_skipn)%expr @ x @ x0)%expr_pat
| @List_repeat A =>
    fun (x : expr A) (x0 : expr ℕ) =>
    Base (#(List_repeat)%expr @ x @ x0)%expr_pat
| @List_combine A B =>
    fun (x : expr (list A)) (x0 : expr (list B)) =>
    Base (#(List_combine)%expr @ x @ x0)%expr_pat
| @List_map A B =>
    fun (x : expr A -> UnderLets (expr B)) (x0 : expr (list A)) =>
    Base
      (#(List_map)%expr @ (λ x1 : var A,
                           to_expr (x ($x1)))%expr @ x0)%expr_pat
| @List_app A => fun x x0 : expr (list A) => Base (x ++ x0)%expr
| @List_rev A =>
    fun x : expr (list A) => Base (#(List_rev)%expr @ x)%expr_pat
| @List_flat_map A B =>
    fun (x : expr A -> UnderLets (expr (list B))) (x0 : expr (list A)) =>
    Base
      (#(List_flat_map)%expr @ (λ x1 : var A,
                                to_expr (x ($x1)))%expr @ x0)%expr_pat
| @List_partition A =>
    fun (x : expr A -> UnderLets (expr bool)) (x0 : expr (list A)) =>
    Base
      (#(List_partition)%expr @ (λ x1 : var A,
                                 to_expr (x ($x1)))%expr @ x0)%expr_pat
| @List_fold_right A B =>
    fun (x : expr B -> expr A -> UnderLets (expr A)) (x0 : expr A)
      (x1 : expr (list B)) =>
    Base
      (#(List_fold_right)%expr @
       (λ (x2 : var B)(x3 : var A),
        to_expr (x ($x2) ($x3)))%expr @ x0 @ x1)%expr_pat
| @List_update_nth T =>
    fun (x : expr ℕ) (x0 : expr T -> UnderLets (expr T)) (x1 : expr (list T))
    =>
    Base
      (#(List_update_nth)%expr @ x @ (λ x2 : var T,
                                      to_expr (x0 ($x2)))%expr @ x1)%expr_pat
| @List_nth_default T =>
    fun (x : expr T) (x0 : expr (list T)) (x1 : expr ℕ) =>
    Base (#(List_nth_default)%expr @ x @ x0 @ x1)%expr_pat
| Z_add => fun x x0 : expr ℤ => Base (x + x0)%expr
| Z_mul => fun x x0 : expr ℤ => Base (x * x0)%expr
| Z_pow => fun x x0 : expr ℤ => Base (#(Z_pow)%expr @ x @ x0)%expr_pat
| Z_sub =>
    fun x x0 : expr ℤ =>
    ((match x with
      | @expr.Ident _ _ _ t idc =>
          match x0 with
          | (@expr.Ident _ _ _ t0 idc0 @
             (@expr.Ident _ _ _ t1 idc1 @ @expr.App _ _ _ s1 _
              (@expr.Ident _ _ _ t2 idc2) x3))%expr_pat =>
              args <- invert_bind_args idc2 Raw.ident.Z_cast;
              _ <- invert_bind_args idc1 Raw.ident.Z_opp;
              args1 <- invert_bind_args idc0 Raw.ident.Z_cast;
              args2 <- invert_bind_args idc Raw.ident.Literal;
              match
                pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype
                  ((projT1 args2) -> s1)%ptype option (fun x4 : option => x4)
              with
              | Some (_, _)%zrange =>
                  if
                   type.type_beq base.type base.type.type_beq (ℤ -> ℤ)%ptype
                     ((projT1 args2) -> s1)%ptype
                  then
                   xv <- ident.unify pattern.ident.Literal ##(projT2 args2);
                   v <- type.try_make_transport_cps s1 ℤ;
                   fv <- (x4 <- (if
                                  ((let (x4, _) := xv in x4) =? 0) &&
                                  (ZRange.normalize args <=?
                                   - ZRange.normalize args1)%zrange
                                 then
                                  Some
                                    (#(Z_cast args)%expr @
                                     v (Compile.reflect x3))%expr_pat
                                 else None);
                          Some (Base x4));
                   Some (fv0 <-- fv;
                         Base fv0)%under_lets
                  else None
              | None => None
              end
          | (@expr.Ident _ _ _ t0 idc0 @
             (@expr.Ident _ _ _ t1 idc1 @ @expr.App _ _ _ s1 _ ($_)%expr _))%expr_pat |
            (@expr.Ident _ _ _ t0 idc0 @
             (@expr.Ident _ _ _ t1 idc1 @ @expr.App _ _ _ s1 _
              (@expr.Abs _ _ _ _ _ _) _))%expr_pat |
            (@expr.Ident _ _ _ t0 idc0 @
             (@expr.Ident _ _ _ t1 idc1 @ @expr.App _ _ _ s1 _ (_ @ _) _))%expr_pat |
            (@expr.Ident _ _ _ t0 idc0 @
             (@expr.Ident _ _ _ t1 idc1 @ @expr.App _ _ _ s1 _
              (@expr.LetIn _ _ _ _ _ _ _) _))%expr_pat => None
          | (@expr.Ident _ _ _ t0 idc0 @ (@expr.Ident _ _ _ t1 idc1 @ #(_)))%expr_pat |
            (@expr.Ident _ _ _ t0 idc0 @
             (@expr.Ident _ _ _ t1 idc1 @ ($_)%expr))%expr_pat |
            (@expr.Ident _ _ _ t0 idc0 @
             (@expr.Ident _ _ _ t1 idc1 @ @expr.Abs _ _ _ _ _ _))%expr_pat |
            (@expr.Ident _ _ _ t0 idc0 @
             (@expr.Ident _ _ _ t1 idc1 @ @expr.LetIn _ _ _ _ _ _ _))%expr_pat =>
              None
          | (@expr.Ident _ _ _ t0 idc0 @ #(_))%expr_pat |
            (@expr.Ident _ _ _ t0 idc0 @ ($_)%expr)%expr_pat |
            (@expr.Ident _ _ _ t0 idc0 @ @expr.Abs _ _ _ _ _ _)%expr_pat |
            (@expr.Ident _ _ _ t0 idc0 @ (($_)%expr @ _))%expr_pat |
            (@expr.Ident _ _ _ t0 idc0 @ (@expr.Abs _ _ _ _ _ _ @ _))%expr_pat |
            (@expr.Ident _ _ _ t0 idc0 @ (_ @ _ @ _))%expr_pat |
            (@expr.Ident _ _ _ t0 idc0 @ (@expr.LetIn _ _ _ _ _ _ _ @ _))%expr_pat |
            (@expr.Ident _ _ _ t0 idc0 @ @expr.LetIn _ _ _ _ _ _ _)%expr_pat =>
              None
          | _ => None
          end;;
          args <- invert_bind_args idc Raw.ident.Literal;
          match
            pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype
              ((projT1 args) -> ℤ)%ptype option (fun x1 : option => x1)
          with
          | Some (_, _)%zrange =>
              if
               type.type_beq base.type base.type.type_beq (ℤ -> ℤ)%ptype
                 ((projT1 args) -> ℤ)%ptype
              then
               xv <- ident.unify pattern.ident.Literal ##(projT2 args);
               fv <- (x1 <- (if (let (x1, _) := xv in x1) =? 0
                             then Some (- x0)%expr
                             else None);
                      Some (Base x1));
               Some (fv0 <-- fv;
                     Base fv0)%under_lets
              else None
          | None => None
          end
      | _ => None
      end;;
      None);;;
     Base (x - x0)%expr)%option
| Z_opp =>
    fun x : expr ℤ =>
    ((match x with
      | (@expr.Ident _ _ _ t idc @
         (@expr.Ident _ _ _ t0 idc0 @ @expr.App _ _ _ s1 _
          (@expr.Ident _ _ _ t1 idc1) x2))%expr_pat =>
          args <- invert_bind_args idc1 Raw.ident.Z_cast;
          _ <- invert_bind_args idc0 Raw.ident.Z_opp;
          args1 <- invert_bind_args idc Raw.ident.Z_cast;
          match
            pattern.type.unify_extracted_cps ℤ s1 option
              (fun x3 : option => x3)
          with
          | Some _ =>
              if type.type_beq base.type base.type.type_beq ℤ s1
              then
               v <- type.try_make_transport_cps s1 ℤ;
               fv <- (x3 <- (if
                              (ZRange.normalize args <=?
                               - ZRange.normalize args1)%zrange
                             then
                              Some
                                (#(Z_cast args)%expr @ v (Compile.reflect x2))%expr_pat
                             else None);
                      Some (Base x3));
               Some (fv0 <-- fv;
                     Base fv0)%under_lets
              else None
          | None => None
          end
      | (@expr.Ident _ _ _ t idc @
         (@expr.Ident _ _ _ t0 idc0 @ @expr.App _ _ _ s1 _ ($_)%expr _))%expr_pat |
        (@expr.Ident _ _ _ t idc @
         (@expr.Ident _ _ _ t0 idc0 @ @expr.App _ _ _ s1 _
          (@expr.Abs _ _ _ _ _ _) _))%expr_pat |
        (@expr.Ident _ _ _ t idc @
         (@expr.Ident _ _ _ t0 idc0 @ @expr.App _ _ _ s1 _ (_ @ _) _))%expr_pat |
        (@expr.Ident _ _ _ t idc @
         (@expr.Ident _ _ _ t0 idc0 @ @expr.App _ _ _ s1 _
          (@expr.LetIn _ _ _ _ _ _ _) _))%expr_pat => None
      | (@expr.Ident _ _ _ t idc @ (@expr.Ident _ _ _ t0 idc0 @ #(_)))%expr_pat |
        (@expr.Ident _ _ _ t idc @ (@expr.Ident _ _ _ t0 idc0 @ ($_)%expr))%expr_pat |
        (@expr.Ident _ _ _ t idc @
         (@expr.Ident _ _ _ t0 idc0 @ @expr.Abs _ _ _ _ _ _))%expr_pat |
        (@expr.Ident _ _ _ t idc @
         (@expr.Ident _ _ _ t0 idc0 @ @expr.LetIn _ _ _ _ _ _ _))%expr_pat =>
          None
      | (@expr.Ident _ _ _ t idc @ #(_))%expr_pat |
        (@expr.Ident _ _ _ t idc @ ($_)%expr)%expr_pat |
        (@expr.Ident _ _ _ t idc @ @expr.Abs _ _ _ _ _ _)%expr_pat |
        (@expr.Ident _ _ _ t idc @ (($_)%expr @ _))%expr_pat |
        (@expr.Ident _ _ _ t idc @ (@expr.Abs _ _ _ _ _ _ @ _))%expr_pat |
        (@expr.Ident _ _ _ t idc @ (_ @ _ @ _))%expr_pat |
        (@expr.Ident _ _ _ t idc @ (@expr.LetIn _ _ _ _ _ _ _ @ _))%expr_pat |
        (@expr.Ident _ _ _ t idc @ @expr.LetIn _ _ _ _ _ _ _)%expr_pat =>
          None
      | _ => None
      end;;
      None);;;
     Base (- x)%expr)%option
| Z_div => fun x x0 : expr ℤ => Base (x / x0)%expr
| Z_modulo => fun x x0 : expr ℤ => Base (x mod x0)%expr
| Z_log2 => fun x : expr ℤ => Base (#(Z_log2)%expr @ x)%expr_pat
| Z_log2_up => fun x : expr ℤ => Base (#(Z_log2_up)%expr @ x)%expr_pat
| Z_eqb => fun x x0 : expr ℤ => Base (#(Z_eqb)%expr @ x @ x0)%expr_pat
| Z_leb => fun x x0 : expr ℤ => Base (#(Z_leb)%expr @ x @ x0)%expr_pat
| Z_geb => fun x x0 : expr ℤ => Base (#(Z_geb)%expr @ x @ x0)%expr_pat
| Z_of_nat => fun x : expr ℕ => Base (#(Z_of_nat)%expr @ x)%expr_pat
| Z_to_nat => fun x : expr ℤ => Base (#(Z_to_nat)%expr @ x)%expr_pat
| Z_shiftr => fun x x0 : expr ℤ => Base (x >> x0)%expr
| Z_shiftl =>
    fun x x0 : expr ℤ =>
    (match x with
     | @expr.Ident _ _ _ t idc =>
         args <- invert_bind_args idc Raw.ident.Literal;
         match
           pattern.type.unify_extracted_cps (ℤ -> ℤ)%ptype
             ((projT1 args) -> ℤ)%ptype option (fun x1 : option => x1)
         with
         | Some (_, _)%zrange =>
             if
              type.type_beq base.type base.type.type_beq (ℤ -> ℤ)%ptype
                ((projT1 args) -> ℤ)%ptype
             then
              xv <- ident.unify pattern.ident.Literal ##(projT2 args);
              fv <- (x1 <- (if (let (x1, _) := xv in x1) =? 0
                            then Some (##0)%expr
                            else None);
                     Some (Base x1));
              Some (fv0 <-- fv;
                    Base fv0)%under_lets
             else None
         | None => None
         end
     | _ => None
     end;;;
     Base (x << x0)%expr)%option
| Z_land => fun x x0 : expr ℤ => Base (x &' x0)%expr
| Z_lor => fun x x0 : expr ℤ => Base (x || x0)%expr
| Z_bneg => fun x : expr ℤ => Base (#(Z_bneg)%expr @ x)%expr_pat
| Z_lnot_modulo =>
    fun x x0 : expr ℤ => Base (#(Z_lnot_modulo)%expr @ x @ x0)%expr_pat
| Z_mul_split =>
    fun x x0 x1 : expr ℤ =>
    ((match x with
      | @expr.Ident _ _ _ t idc =>
          match x0 with
          | @expr.Ident _ _ _ t0 idc0 =>
              args <- invert_bind_args idc0 Raw.ident.Literal;
              args0 <- invert_bind_args idc Raw.ident.Literal;
              match
                pattern.type.unify_extracted_cps ((ℤ -> ℤ) -> ℤ)%ptype
                  (((projT1 args0) -> (projT1 args)) -> ℤ)%ptype option
                  (fun x2 : option => x2)
              with
              | Some (_, _, _)%zrange =>
                  if
                   type.type_beq base.type base.type.type_beq
                     ((ℤ -> ℤ) -> ℤ)%ptype
                     (((projT1 args0) -> (projT1 args)) -> ℤ)%ptype
                  then
                   _ <- ident.unify pattern.ident.Literal ##(projT2 args0);
                   xv0 <- ident.unify pattern.ident.Literal ##(projT2 args);
                   fv <- (x2 <- (if (let (x2, _) := xv0 in x2) =? 0
                                 then Some ((##0)%expr, (##0)%expr)%expr_pat
                                 else None);
                          Some (Base x2));
                   Some (fv0 <-- fv;
                         Base fv0)%under_lets
                  else None
              | None => None
              end
          | _ => None
          end;;
          match x1 with
          | @expr.Ident _ _ _ t0 idc0 =>
              (args <- invert_bind_args idc0 Raw.ident.Literal;
               args0 <- invert_bind_args idc Raw.ident.Literal;
               match
                 pattern.type.unify_extracted_cps ((ℤ -> ℤ) -> ℤ)%ptype
                   (((projT1 args0) -> ℤ) -> (projT1 args))%ptype option
                   (fun x2 : option => x2)
               with
               | Some (_, _, _)%zrange =>
                   if
                    type.type_beq base.type base.type.type_beq
                      ((ℤ -> ℤ) -> ℤ)%ptype
                      (((projT1 args0) -> ℤ) -> (projT1 args))%ptype
                   then
                    _ <- ident.unify pattern.ident.Literal ##(projT2 args0);
                    xv0 <- ident.unify pattern.ident.Literal ##(projT2 args);
                    fv <- (x2 <- (if (let (x2, _) := xv0 in x2) =? 0
                                  then Some ((##0)%expr, (##0)%expr)%expr_pat
                                  else None);
                           Some (Base x2));
                    Some (fv0 <-- fv;
                          Base fv0)%under_lets
                   else None
               | None => None
               end);;
              match x0 with
              | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t1 idc1) x2 =>
                  args <- invert_bind_args idc1 Raw.ident.Z_cast;
                  args0 <- invert_bind_args idc0 Raw.ident.Literal;
                  args1 <- invert_bind_args idc Raw.ident.Literal;
                  match
                    pattern.type.unify_extracted_cps ((ℤ -> ℤ) -> ℤ)%ptype
                      (((projT1 args1) -> s) -> (projT1 args0))%ptype option
                      (fun x3 : option => x3)
                  with
                  | Some (_, _, _)%zrange =>
                      if
                       type.type_beq base.type base.type.type_beq
                         ((ℤ -> ℤ) -> ℤ)%ptype
                         (((projT1 args1) -> s) -> (projT1 args0))%ptype
                      then
                       xv <- ident.unify pattern.ident.Literal
                               ##(projT2 args1);
                       v <- type.try_make_transport_cps s ℤ;
                       xv0 <- ident.unify pattern.ident.Literal
                                ##(projT2 args0);
                       fv <- (x3 <- (if
                                      ((let (x3, _) := xv0 in x3) =? 1) &&
                                      (ZRange.normalize args <=?
                                       r[0 ~> (let (x3, _) := xv in x3) - 1])%zrange
                                     then
                                      Some
                                        (#(Z_cast args)%expr @
                                         v (Compile.reflect x2), (##0)%expr)%expr_pat
                                     else None);
                              Some (Base x3));
                       Some (fv0 <-- fv;
                             Base fv0)%under_lets
                      else None
                  | None => None
                  end
              | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
                (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _
                (_ @ _)%expr_pat _ | @expr.App _ _ _ s _
                (@expr.LetIn _ _ _ _ _ _ _) _ => None
              | _ => None
              end
          | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t0 idc0) x2 =>
              match x0 with
              | @expr.Ident _ _ _ t1 idc1 =>
                  args <- invert_bind_args idc1 Raw.ident.Literal;
                  args0 <- invert_bind_args idc0 Raw.ident.Z_cast;
                  args1 <- invert_bind_args idc Raw.ident.Literal;
                  match
                    pattern.type.unify_extracted_cps ((ℤ -> ℤ) -> ℤ)%ptype
                      (((projT1 args1) -> (projT1 args)) -> s)%ptype option
                      (fun x3 : option => x3)
                  with
                  | Some (_, _, _)%zrange =>
                      if
                       type.type_beq base.type base.type.type_beq
                         ((ℤ -> ℤ) -> ℤ)%ptype
                         (((projT1 args1) -> (projT1 args)) -> s)%ptype
                      then
                       xv <- ident.unify pattern.ident.Literal
                               ##(projT2 args1);
                       xv0 <- ident.unify pattern.ident.Literal
                                ##(projT2 args);
                       v <- type.try_make_transport_cps s ℤ;
                       fv <- (x3 <- (if
                                      ((let (x3, _) := xv0 in x3) =? 1) &&
                                      (ZRange.normalize args0 <=?
                                       r[0 ~> (let (x3, _) := xv in x3) - 1])%zrange
                                     then
                                      Some
                                        (#(Z_cast args0)%expr @
                                         v (Compile.reflect x2), (##0)%expr)%expr_pat
                                     else None);
                              Some (Base x3));
                       Some (fv0 <-- fv;
                             Base fv0)%under_lets
                      else None
                  | None => None
                  end
              | _ => None
              end
          | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
            (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat
            _ | @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
          | _ => None
          end
      | _ => None
      end;;
      None);;;
     Base (#(Z_mul_split)%expr @ x @ x0 @ x1)%expr_pat)%option
| Z_add_get_carry =>
    fun x x0 x1 : expr ℤ =>
    ((match x with
      | @expr.Ident _ _ _ t idc =>
          match x0 with
          | @expr.Ident _ _ _ t0 idc0 =>
              match x1 with
              | @expr.Ident _ _ _ t1 idc1 =>
                  args <- invert_bind_args idc1 Raw.ident.Literal;
                  args0 <- invert_bind_args idc0 Raw.ident.Literal;
                  args1 <- invert_bind_args idc Raw.ident.Literal;
                  match
                    pattern.type.unify_extracted_cps ((ℤ -> ℤ) -> ℤ)%ptype
                      (((projT1 args1) -> (projT1 args0)) -> (projT1 args))%ptype
                      option (fun x2 : option => x2)
                  with
                  | Some (_, _, _)%zrange =>
                      if
                       type.type_beq base.type base.type.type_beq
                         ((ℤ -> ℤ) -> ℤ)%ptype
                         (((projT1 args1) -> (projT1 args0)) -> (projT1 args))%ptype
                      then
                       xv <- ident.unify pattern.ident.Literal
                               ##(projT2 args1);
                       xv0 <- ident.unify pattern.ident.Literal
                                ##(projT2 args0);
                       xv1 <- ident.unify pattern.ident.Literal
                                ##(projT2 args);
                       Some
                         (Base
                            (let
                             '(a1, b1)%zrange :=
                              Z.add_get_carry_full (let (x2, _) := xv in x2)
                                (let (x2, _) := xv0 in x2)
                                (let (x2, _) := xv1 in x2) in
                              ((##a1)%expr, (##b1)%expr)%expr_pat))
                      else None
                  | None => None
                  end
              | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t1 idc1) x2 =>
                  args <- invert_bind_args idc1 Raw.ident.Z_cast;
                  args0 <- invert_bind_args idc0 Raw.ident.Literal;
                  args1 <- invert_bind_args idc Raw.ident.Literal;
                  match
                    pattern.type.unify_extracted_cps ((ℤ -> ℤ) -> ℤ)%ptype
                      (((projT1 args1) -> (projT1 args0)) -> s)%ptype option
                      (fun x3 : option => x3)
                  with
                  | Some (_, _, _)%zrange =>
                      if
                       type.type_beq base.type base.type.type_beq
                         ((ℤ -> ℤ) -> ℤ)%ptype
                         (((projT1 args1) -> (projT1 args0)) -> s)%ptype
                      then
                       xv <- ident.unify pattern.ident.Literal
                               ##(projT2 args1);
                       xv0 <- ident.unify pattern.ident.Literal
                                ##(projT2 args0);
                       v <- type.try_make_transport_cps s ℤ;
                       fv <- (x3 <- (if
                                      ((let (x3, _) := xv0 in x3) =? 0) &&
                                      (ZRange.normalize args <=?
                                       r[0 ~> (let (x3, _) := xv in x3) - 1])%zrange
                                     then
                                      Some
                                        (#(Z_cast args)%expr @
                                         v (Compile.reflect x2), (##0)%expr)%expr_pat
                                     else None);
                              Some (Base x3));
                       Some (fv0 <-- fv;
                             Base fv0)%under_lets
                      else None
                  | None => None
                  end
              | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
                (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _
                (_ @ _)%expr_pat _ | @expr.App _ _ _ s _
                (@expr.LetIn _ _ _ _ _ _ _) _ => None
              | _ => None
              end
          | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t0 idc0) x2 =>
              match x1 with
              | @expr.Ident _ _ _ t1 idc1 =>
                  args <- invert_bind_args idc1 Raw.ident.Literal;
                  args0 <- invert_bind_args idc0 Raw.ident.Z_cast;
                  args1 <- invert_bind_args idc Raw.ident.Literal;
                  match
                    pattern.type.unify_extracted_cps ((ℤ -> ℤ) -> ℤ)%ptype
                      (((projT1 args1) -> s) -> (projT1 args))%ptype option
                      (fun x3 : option => x3)
                  with
                  | Some (_, _, _)%zrange =>
                      if
                       type.type_beq base.type base.type.type_beq
                         ((ℤ -> ℤ) -> ℤ)%ptype
                         (((projT1 args1) -> s) -> (projT1 args))%ptype
                      then
                       xv <- ident.unify pattern.ident.Literal
                               ##(projT2 args1);
                       v <- type.try_make_transport_cps s ℤ;
                       xv0 <- ident.unify pattern.ident.Literal
                                ##(projT2 args);
                       fv <- (x3 <- (if
                                      ((let (x3, _) := xv0 in x3) =? 0) &&
                                      (ZRange.normalize args0 <=?
                                       r[0 ~> (let (x3, _) := xv in x3) - 1])%zrange
                                     then
                                      Some
                                        (#(Z_cast args0)%expr @
                                         v (Compile.reflect x2), (##0)%expr)%expr_pat
                                     else None);
                              Some (Base x3));
                       Some (fv0 <-- fv;
                             Base fv0)%under_lets
                      else None
                  | None => None
                  end
              | _ => None
              end
          | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
            (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat
            _ | @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
          | _ => None
          end
      | _ => None
      end;;
      None);;;
     Base (#(Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat)%option
| Z_add_with_carry =>
    fun x x0 x1 : expr ℤ =>
    (match x with
     | @expr.Ident _ _ _ t idc =>
         args <- invert_bind_args idc Raw.ident.Literal;
         match
           pattern.type.unify_extracted_cps ((ℤ -> ℤ) -> ℤ)%ptype
             (((projT1 args) -> ℤ) -> ℤ)%ptype option (fun x2 : option => x2)
         with
         | Some (_, _, _)%zrange =>
             if
              type.type_beq base.type base.type.type_beq
                ((ℤ -> ℤ) -> ℤ)%ptype (((projT1 args) -> ℤ) -> ℤ)%ptype
             then
              xv <- ident.unify pattern.ident.Literal ##(projT2 args);
              fv <- (x2 <- (if (let (x2, _) := xv in x2) =? 0
                            then Some (x0 + x1)%expr
                            else None);
                     Some (Base x2));
              Some (fv0 <-- fv;
                    Base fv0)%under_lets
             else None
         | None => None
         end
     | _ => None
     end;;;
     Base (#(Z_add_with_carry)%expr @ x @ x0 @ x1)%expr_pat)%option
| Z_add_with_get_carry =>
    fun x x0 x1 x2 : expr ℤ =>
    (match x with
     | @expr.Ident _ _ _ t idc =>
         match x0 with
         | @expr.Ident _ _ _ t0 idc0 =>
             match x1 with
             | @expr.Ident _ _ _ t1 idc1 =>
                 match x2 with
                 | @expr.Ident _ _ _ t2 idc2 =>
                     args <- invert_bind_args idc2 Raw.ident.Literal;
                     args0 <- invert_bind_args idc1 Raw.ident.Literal;
                     args1 <- invert_bind_args idc0 Raw.ident.Literal;
                     args2 <- invert_bind_args idc Raw.ident.Literal;
                     match
                       pattern.type.unify_extracted_cps
                         (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
                         ((((projT1 args2) -> (projT1 args1)) ->
                           (projT1 args0)) -> (projT1 args))%ptype option
                         (fun x3 : option => x3)
                     with
                     | Some (_, _, _, _)%zrange =>
                         if
                          type.type_beq base.type base.type.type_beq
                            (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
                            ((((projT1 args2) -> (projT1 args1)) ->
                              (projT1 args0)) -> (projT1 args))%ptype
                         then
                          xv <- ident.unify pattern.ident.Literal
                                  ##(projT2 args2);
                          xv0 <- ident.unify pattern.ident.Literal
                                   ##(projT2 args1);
                          xv1 <- ident.unify pattern.ident.Literal
                                   ##(projT2 args0);
                          xv2 <- ident.unify pattern.ident.Literal
                                   ##(projT2 args);
                          Some
                            (Base
                               (let
                                '(a2, b2)%zrange :=
                                 Z.add_with_get_carry_full
                                   (let (x3, _) := xv in x3)
                                   (let (x3, _) := xv0 in x3)
                                   (let (x3, _) := xv1 in x3)
                                   (let (x3, _) := xv2 in x3) in
                                 ((##a2)%expr, (##b2)%expr)%expr_pat))
                         else None
                     | None => None
                     end
                 | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t2 idc2) x3 =>
                     args <- invert_bind_args idc2 Raw.ident.Z_cast;
                     args0 <- invert_bind_args idc1 Raw.ident.Literal;
                     args1 <- invert_bind_args idc0 Raw.ident.Literal;
                     args2 <- invert_bind_args idc Raw.ident.Literal;
                     match
                       pattern.type.unify_extracted_cps
                         (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
                         ((((projT1 args2) -> (projT1 args1)) ->
                           (projT1 args0)) -> s)%ptype option
                         (fun x4 : option => x4)
                     with
                     | Some (_, _, _, _)%zrange =>
                         if
                          type.type_beq base.type base.type.type_beq
                            (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
                            ((((projT1 args2) -> (projT1 args1)) ->
                              (projT1 args0)) -> s)%ptype
                         then
                          xv <- ident.unify pattern.ident.Literal
                                  ##(projT2 args2);
                          xv0 <- ident.unify pattern.ident.Literal
                                   ##(projT2 args1);
                          xv1 <- ident.unify pattern.ident.Literal
                                   ##(projT2 args0);
                          v <- type.try_make_transport_cps s ℤ;
                          fv <- (x4 <- (if
                                         ((let (x4, _) := xv0 in x4) =? 0) &&
                                         ((let (x4, _) := xv1 in x4) =? 0) &&
                                         (ZRange.normalize args <=?
                                          r[0 ~> (let (x4, _) := xv in x4) -
                                                 1])%zrange
                                        then
                                         Some
                                           (#(Z_cast args)%expr @
                                            v (Compile.reflect x3),
                                           (##0)%expr)%expr_pat
                                        else None);
                                 Some (Base x4));
                          Some (fv0 <-- fv;
                                Base fv0)%under_lets
                         else None
                     | None => None
                     end
                 | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
                   (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _
                   (_ @ _)%expr_pat _ | @expr.App _ _ _ s _
                   (@expr.LetIn _ _ _ _ _ _ _) _ => None
                 | _ => None
                 end
             | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t1 idc1) x3 =>
                 match x2 with
                 | @expr.Ident _ _ _ t2 idc2 =>
                     args <- invert_bind_args idc2 Raw.ident.Literal;
                     args0 <- invert_bind_args idc1 Raw.ident.Z_cast;
                     args1 <- invert_bind_args idc0 Raw.ident.Literal;
                     args2 <- invert_bind_args idc Raw.ident.Literal;
                     match
                       pattern.type.unify_extracted_cps
                         (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
                         ((((projT1 args2) -> (projT1 args1)) -> s) ->
                          (projT1 args))%ptype option (fun x4 : option => x4)
                     with
                     | Some (_, _, _, _)%zrange =>
                         if
                          type.type_beq base.type base.type.type_beq
                            (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
                            ((((projT1 args2) -> (projT1 args1)) -> s) ->
                             (projT1 args))%ptype
                         then
                          xv <- ident.unify pattern.ident.Literal
                                  ##(projT2 args2);
                          xv0 <- ident.unify pattern.ident.Literal
                                   ##(projT2 args1);
                          v <- type.try_make_transport_cps s ℤ;
                          xv1 <- ident.unify pattern.ident.Literal
                                   ##(projT2 args);
                          fv <- (x4 <- (if
                                         ((let (x4, _) := xv0 in x4) =? 0) &&
                                         ((let (x4, _) := xv1 in x4) =? 0) &&
                                         (ZRange.normalize args0 <=?
                                          r[0 ~> (let (x4, _) := xv in x4) -
                                                 1])%zrange
                                        then
                                         Some
                                           (#(Z_cast args0)%expr @
                                            v (Compile.reflect x3),
                                           (##0)%expr)%expr_pat
                                        else None);
                                 Some (Base x4));
                          Some (fv0 <-- fv;
                                Base fv0)%under_lets
                         else None
                     | None => None
                     end
                 | _ => None
                 end
             | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
               (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _
               (_ @ _)%expr_pat _ | @expr.App _ _ _ s _
               (@expr.LetIn _ _ _ _ _ _ _) _ => None
             | _ => None
             end
         | _ => None
         end
     | _ => None
     end;;;
     Base (#(Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat)%option
| Z_sub_get_borrow =>
    fun x x0 x1 : expr ℤ =>
    Base (#(Z_sub_get_borrow)%expr @ x @ x0 @ x1)%expr_pat
| Z_sub_with_get_borrow =>
    fun x x0 x1 x2 : expr ℤ =>
    Base (#(Z_sub_with_get_borrow)%expr @ x @ x0 @ x1 @ x2)%expr_pat
| Z_zselect =>
    fun x x0 x1 : expr ℤ => Base (#(Z_zselect)%expr @ x @ x0 @ x1)%expr_pat
| Z_add_modulo =>
    fun x x0 x1 : expr ℤ =>
    Base (#(Z_add_modulo)%expr @ x @ x0 @ x1)%expr_pat
| Z_rshi =>
    fun x x0 x1 x2 : expr ℤ =>
    Base (#(Z_rshi)%expr @ x @ x0 @ x1 @ x2)%expr_pat
| Z_cc_m => fun x x0 : expr ℤ => Base (#(Z_cc_m)%expr @ x @ x0)%expr_pat
| Z_cast range =>
    fun x : expr ℤ =>
    (((match
         pattern.type.unify_extracted_cps ℤ ℤ option (fun x0 : option => x0)
       with
       | Some _ =>
           if type.type_beq base.type base.type.type_beq ℤ ℤ
           then
            fv <- (x0 <- (if lower range =? upper range
                          then Some (##(lower range))%expr
                          else None);
                   Some (Base x0));
            Some (fv0 <-- fv;
                  Base fv0)%under_lets
           else None
       | None => None
       end;;
       match x with
       | @expr.Ident _ _ _ t idc =>
           args <- invert_bind_args idc Raw.ident.Literal;
           match
             pattern.type.unify_extracted_cps ℤ (projT1 args) option
               (fun x0 : option => x0)
           with
           | Some _ =>
               if type.type_beq base.type base.type.type_beq ℤ (projT1 args)
               then
                xv <- ident.unify pattern.ident.Literal ##(projT2 args);
                fv <- (x0 <- (if
                               is_bounded_by_bool (let (x0, _) := xv in x0)
                                 range
                              then Some (##(let (x0, _) := xv in x0))%expr
                              else None);
                       Some (Base x0));
                Some (fv0 <-- fv;
                      Base fv0)%under_lets
               else None
           | None => None
           end
       | @expr.App _ _ _ s _ (@expr.Ident _ _ _ t idc) x0 =>
           args <- invert_bind_args idc Raw.ident.Z_cast;
           match
             pattern.type.unify_extracted_cps ℤ s option
               (fun x1 : option => x1)
           with
           | Some _ =>
               if type.type_beq base.type base.type.type_beq ℤ s
               then
                v <- type.try_make_transport_cps s ℤ;
                fv <- (x1 <- (if
                               (ZRange.normalize args <=?
                                ZRange.normalize range)%zrange
                              then
                               Some
                                 (#(Z_cast args)%expr @
                                  v (Compile.reflect x0))%expr_pat
                              else None);
                       Some (Base x1));
                Some (fv0 <-- fv;
                      Base fv0)%under_lets
               else None
           | None => None
           end
       | @expr.App _ _ _ s _
         (@expr.App _ _ _ s0 _
          (@expr.App _ _ _ s1 _ (@expr.Ident _ _ _ t idc) x2) x1) x0 =>
           _ <- invert_bind_args idc Raw.ident.Z_add_with_carry;
           match
             pattern.type.unify_extracted_cps ((ℤ -> ℤ) -> ℤ)%ptype
               ((s1 -> s0) -> s)%ptype option (fun x3 : option => x3)
           with
           | Some (_, _, _)%zrange =>
               if
                type.type_beq base.type base.type.type_beq
                  ((ℤ -> ℤ) -> ℤ)%ptype ((s1 -> s0) -> s)%ptype
               then
                v <- type.try_make_transport_cps s1 ℤ;
                v0 <- type.try_make_transport_cps s0 ℤ;
                v1 <- type.try_make_transport_cps s ℤ;
                Some
                  (UnderLet
                     (#(Z_cast range)%expr @
                      (#(Z_add_with_carry)%expr @ v (Compile.reflect x2) @
                       v0 (Compile.reflect x1) @ v1 (Compile.reflect x0)))%expr_pat
                     (fun v2 : var ℤ =>
                      Base (#(Z_cast range)%expr @ ($v2)%expr)%expr_pat))
               else None
           | None => None
           end
       | @expr.App _ _ _ s _
         (@expr.App _ _ _ s0 _ (@expr.App _ _ _ s1 _ ($_)%expr _) _) _ |
         @expr.App _ _ _ s _
         (@expr.App _ _ _ s0 _
          (@expr.App _ _ _ s1 _ (@expr.Abs _ _ _ _ _ _) _) _) _ | @expr.App _
         _ _ s _
         (@expr.App _ _ _ s0 _ (@expr.App _ _ _ s1 _ (_ @ _)%expr_pat _) _)
         _ | @expr.App _ _ _ s _
         (@expr.App _ _ _ s0 _
          (@expr.App _ _ _ s1 _ (@expr.LetIn _ _ _ _ _ _ _) _) _) _ => None
       | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ #(_)%expr_pat _) _ |
         @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ ($_)%expr _) _ | @expr.App
         _ _ _ s _ (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _) _ |
         @expr.App _ _ _ s _
         (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _) _ => None
       | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
         (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _
         (@expr.LetIn _ _ _ _ _ _ _) _ => None
       | _ => None
       end);;
      None);;;
     Base (#(Z_cast range)%expr @ x)%expr_pat)%option
| Z_cast2 range =>
    fun x : expr (ℤ * ℤ)%etype =>
    (match x with
     | @expr.App _ _ _ s _
       (@expr.App _ _ _ s0 _ (@expr.Ident _ _ _ t idc) x1) x0 =>
         args <- invert_bind_args idc Raw.ident.pair;
         match
           pattern.type.unify_extracted_cps
             (((ℤ -> ℤ -> (ℤ * ℤ)%pbtype) -> ℤ) -> ℤ)%ptype
             ((((let (x2, _) := args in x2) ->
                (let (_, y) := args in y) ->
                ((let (x2, _) := args in x2) * (let (_, y) := args in y))%etype) ->
               s0) -> s)%ptype option (fun x2 : option => x2)
         with
         | Some (_, (_, (_, _)), _, _)%zrange =>
             if
              type.type_beq base.type base.type.type_beq
                (((ℤ -> ℤ -> (ℤ * ℤ)%etype) -> ℤ) -> ℤ)%ptype
                ((((let (x2, _) := args in x2) ->
                   (let (_, y) := args in y) ->
                   ((let (x2, _) := args in x2) * (let (_, y) := args in y))%etype) ->
                  s0) -> s)%ptype
             then
              _ <- ident.unify pattern.ident.pair pair;
              v <- type.try_make_transport_cps s0 ℤ;
              v0 <- type.try_make_transport_cps s ℤ;
              Some
                (fv0 <-- do_again (ℤ * ℤ)
                           (#(Z_cast (Datatypes.fst range))%expr @
                            ($(v (Compile.reflect x1)))%expr,
                           #(Z_cast (Datatypes.snd range))%expr @
                           ($(v0 (Compile.reflect x0)))%expr)%expr_pat;
                 Base fv0)%under_lets
             else None
         | None => None
         end
     | @expr.App _ _ _ s _
       (@expr.App _ _ _ s0 _
        (@expr.App _ _ _ s1 _ (@expr.Ident _ _ _ t idc) x2) x1) x0 =>
         (match x1 with
          | (@expr.Ident _ _ _ t0 idc0 @
             (@expr.Ident _ _ _ t1 idc1 @ @expr.App _ _ _ s4 _
              (@expr.Ident _ _ _ t2 idc2) x5))%expr_pat =>
              args <- invert_bind_args idc2 Raw.ident.Z_cast;
              _ <- invert_bind_args idc1 Raw.ident.Z_opp;
              args1 <- invert_bind_args idc0 Raw.ident.Z_cast;
              _ <- invert_bind_args idc Raw.ident.Z_add_get_carry;
              match
                pattern.type.unify_extracted_cps ((ℤ -> ℤ) -> ℤ)%ptype
                  ((s1 -> s4) -> s)%ptype option (fun x6 : option => x6)
              with
              | Some (_, _, _)%zrange =>
                  if
                   type.type_beq base.type base.type.type_beq
                     ((ℤ -> ℤ) -> ℤ)%ptype ((s1 -> s4) -> s)%ptype
                  then
                   v <- type.try_make_transport_cps s1 ℤ;
                   v0 <- type.try_make_transport_cps s4 ℤ;
                   v1 <- type.try_make_transport_cps s ℤ;
                   fv <- (if
                           (ZRange.normalize args <=?
                            - ZRange.normalize args1)%zrange
                          then
                           Some
                             (UnderLet
                                (#(Z_cast2
                                     (Datatypes.fst range,
                                     - Datatypes.snd range))%expr @
                                 (#(Z_sub_get_borrow)%expr @
                                  v (Compile.reflect x2) @
                                  v1 (Compile.reflect x0) @
                                  (#(Z_cast args)%expr @
                                   v0 (Compile.reflect x5))))%expr_pat
                                (fun vc : var (ℤ * ℤ)%etype =>
                                 Base
                                   (#(Z_cast (Datatypes.fst range))%expr @
                                    (#(fst)%expr @
                                     (#(Z_cast2
                                          (Datatypes.fst range,
                                          - Datatypes.snd range))%expr @
                                      ($vc)%expr)),
                                   #(Z_cast (Datatypes.snd range))%expr @
                                   (-
                                    (#(Z_cast (- Datatypes.snd range))%expr @
                                     (#(snd)%expr @
                                      (#(Z_cast2
                                           (Datatypes.fst range,
                                           - Datatypes.snd range))%expr @ $vc)))%expr_pat)%expr)%expr_pat))
                          else None);
                   Some (fv0 <-- fv;
                         Base fv0)%under_lets
                  else None
              | None => None
              end
          | (@expr.Ident _ _ _ t0 idc0 @
             (@expr.Ident _ _ _ t1 idc1 @ @expr.App _ _ _ s4 _ ($_)%expr _))%expr_pat |
            (@expr.Ident _ _ _ t0 idc0 @
             (@expr.Ident _ _ _ t1 idc1 @ @expr.App _ _ _ s4 _
              (@expr.Abs _ _ _ _ _ _) _))%expr_pat |
            (@expr.Ident _ _ _ t0 idc0 @
             (@expr.Ident _ _ _ t1 idc1 @ @expr.App _ _ _ s4 _ (_ @ _) _))%expr_pat |
            (@expr.Ident _ _ _ t0 idc0 @
             (@expr.Ident _ _ _ t1 idc1 @ @expr.App _ _ _ s4 _
              (@expr.LetIn _ _ _ _ _ _ _) _))%expr_pat => None
          | (@expr.Ident _ _ _ t0 idc0 @ (@expr.Ident _ _ _ t1 idc1 @ #(_)))%expr_pat |
            (@expr.Ident _ _ _ t0 idc0 @
             (@expr.Ident _ _ _ t1 idc1 @ ($_)%expr))%expr_pat |
            (@expr.Ident _ _ _ t0 idc0 @
             (@expr.Ident _ _ _ t1 idc1 @ @expr.Abs _ _ _ _ _ _))%expr_pat |
            (@expr.Ident _ _ _ t0 idc0 @
             (@expr.Ident _ _ _ t1 idc1 @ @expr.LetIn _ _ _ _ _ _ _))%expr_pat =>
              None
          | (@expr.Ident _ _ _ t0 idc0 @ #(_))%expr_pat |
            (@expr.Ident _ _ _ t0 idc0 @ ($_)%expr)%expr_pat |
            (@expr.Ident _ _ _ t0 idc0 @ @expr.Abs _ _ _ _ _ _)%expr_pat |
            (@expr.Ident _ _ _ t0 idc0 @ (($_)%expr @ _))%expr_pat |
            (@expr.Ident _ _ _ t0 idc0 @ (@expr.Abs _ _ _ _ _ _ @ _))%expr_pat |
            (@expr.Ident _ _ _ t0 idc0 @ (_ @ _ @ _))%expr_pat |
            (@expr.Ident _ _ _ t0 idc0 @ (@expr.LetIn _ _ _ _ _ _ _ @ _))%expr_pat |
            (@expr.Ident _ _ _ t0 idc0 @ @expr.LetIn _ _ _ _ _ _ _)%expr_pat =>
              None
          | _ => None
          end;;
          match x0 with
          | (@expr.Ident _ _ _ t0 idc0 @
             (@expr.Ident _ _ _ t1 idc1 @ @expr.App _ _ _ s4 _
              (@expr.Ident _ _ _ t2 idc2) x5))%expr_pat =>
              args <- invert_bind_args idc2 Raw.ident.Z_cast;
              _ <- invert_bind_args idc1 Raw.ident.Z_opp;
              args1 <- invert_bind_args idc0 Raw.ident.Z_cast;
              _ <- invert_bind_args idc Raw.ident.Z_add_get_carry;
              match
                pattern.type.unify_extracted_cps ((ℤ -> ℤ) -> ℤ)%ptype
                  ((s1 -> s0) -> s4)%ptype option (fun x6 : option => x6)
              with
              | Some (_, _, _)%zrange =>
                  if
                   type.type_beq base.type base.type.type_beq
                     ((ℤ -> ℤ) -> ℤ)%ptype ((s1 -> s0) -> s4)%ptype
                  then
                   v <- type.try_make_transport_cps s1 ℤ;
                   v0 <- type.try_make_transport_cps s0 ℤ;
                   v1 <- type.try_make_transport_cps s4 ℤ;
                   fv <- (if
                           (ZRange.normalize args <=?
                            - ZRange.normalize args1)%zrange
                          then
                           Some
                             (UnderLet
                                (#(Z_cast2
                                     (Datatypes.fst range,
                                     - Datatypes.snd range))%expr @
                                 (#(Z_sub_get_borrow)%expr @
                                  v (Compile.reflect x2) @
                                  v0 (Compile.reflect x1) @
                                  (#(Z_cast args)%expr @
                                   v1 (Compile.reflect x5))))%expr_pat
                                (fun vc : var (ℤ * ℤ)%etype =>
                                 Base
                                   (#(Z_cast (Datatypes.fst range))%expr @
                                    (#(fst)%expr @
                                     (#(Z_cast2
                                          (Datatypes.fst range,
                                          - Datatypes.snd range))%expr @
                                      ($vc)%expr)),
                                   #(Z_cast (Datatypes.snd range))%expr @
                                   (-
                                    (#(Z_cast (- Datatypes.snd range))%expr @
                                     (#(snd)%expr @
                                      (#(Z_cast2
                                           (Datatypes.fst range,
                                           - Datatypes.snd range))%expr @ $vc)))%expr_pat)%expr)%expr_pat))
                          else None);
                   Some (fv0 <-- fv;
                         Base fv0)%under_lets
                  else None
              | None => None
              end
          | (@expr.Ident _ _ _ t0 idc0 @
             (@expr.Ident _ _ _ t1 idc1 @ @expr.App _ _ _ s4 _ ($_)%expr _))%expr_pat |
            (@expr.Ident _ _ _ t0 idc0 @
             (@expr.Ident _ _ _ t1 idc1 @ @expr.App _ _ _ s4 _
              (@expr.Abs _ _ _ _ _ _) _))%expr_pat |
            (@expr.Ident _ _ _ t0 idc0 @
             (@expr.Ident _ _ _ t1 idc1 @ @expr.App _ _ _ s4 _ (_ @ _) _))%expr_pat |
            (@expr.Ident _ _ _ t0 idc0 @
             (@expr.Ident _ _ _ t1 idc1 @ @expr.App _ _ _ s4 _
              (@expr.LetIn _ _ _ _ _ _ _) _))%expr_pat => None
          | (@expr.Ident _ _ _ t0 idc0 @ (@expr.Ident _ _ _ t1 idc1 @ #(_)))%expr_pat |
            (@expr.Ident _ _ _ t0 idc0 @
             (@expr.Ident _ _ _ t1 idc1 @ ($_)%expr))%expr_pat |
            (@expr.Ident _ _ _ t0 idc0 @
             (@expr.Ident _ _ _ t1 idc1 @ @expr.Abs _ _ _ _ _ _))%expr_pat |
            (@expr.Ident _ _ _ t0 idc0 @
             (@expr.Ident _ _ _ t1 idc1 @ @expr.LetIn _ _ _ _ _ _ _))%expr_pat =>
              None
          | (@expr.Ident _ _ _ t0 idc0 @ #(_))%expr_pat |
            (@expr.Ident _ _ _ t0 idc0 @ ($_)%expr)%expr_pat |
            (@expr.Ident _ _ _ t0 idc0 @ @expr.Abs _ _ _ _ _ _)%expr_pat |
            (@expr.Ident _ _ _ t0 idc0 @ (($_)%expr @ _))%expr_pat |
            (@expr.Ident _ _ _ t0 idc0 @ (@expr.Abs _ _ _ _ _ _ @ _))%expr_pat |
            (@expr.Ident _ _ _ t0 idc0 @ (_ @ _ @ _))%expr_pat |
            (@expr.Ident _ _ _ t0 idc0 @ (@expr.LetIn _ _ _ _ _ _ _ @ _))%expr_pat |
            (@expr.Ident _ _ _ t0 idc0 @ @expr.LetIn _ _ _ _ _ _ _)%expr_pat =>
              None
          | _ => None
          end;;
          match x1 with
          | @expr.Ident _ _ _ t0 idc0 =>
              args <- invert_bind_args idc0 Raw.ident.Literal;
              _ <- invert_bind_args idc Raw.ident.Z_add_get_carry;
              match
                pattern.type.unify_extracted_cps ((ℤ -> ℤ) -> ℤ)%ptype
                  ((s1 -> (projT1 args)) -> s)%ptype option
                  (fun x3 : option => x3)
              with
              | Some (_, _, _)%zrange =>
                  if
                   type.type_beq base.type base.type.type_beq
                     ((ℤ -> ℤ) -> ℤ)%ptype ((s1 -> (projT1 args)) -> s)%ptype
                  then
                   v <- type.try_make_transport_cps s1 ℤ;
                   xv <- ident.unify pattern.ident.Literal ##(projT2 args);
                   v0 <- type.try_make_transport_cps s ℤ;
                   fv <- (if (let (x3, _) := xv in x3) <? 0
                          then
                           Some
                             (UnderLet
                                (#(Z_cast2
                                     (Datatypes.fst range,
                                     - Datatypes.snd range))%expr @
                                 (#(Z_sub_get_borrow)%expr @
                                  v (Compile.reflect x2) @
                                  v0 (Compile.reflect x0) @
                                  (##(- (let (x3, _) := xv in x3))%Z)%expr))%expr_pat
                                (fun vc : var (ℤ * ℤ)%etype =>
                                 Base
                                   (#(Z_cast (Datatypes.fst range))%expr @
                                    (#(fst)%expr @
                                     (#(Z_cast2
                                          (Datatypes.fst range,
                                          - Datatypes.snd range))%expr @
                                      ($vc)%expr)),
                                   #(Z_cast (Datatypes.snd range))%expr @
                                   (-
                                    (#(Z_cast (- Datatypes.snd range))%expr @
                                     (#(snd)%expr @
                                      (#(Z_cast2
                                           (Datatypes.fst range,
                                           - Datatypes.snd range))%expr @ $vc)))%expr_pat)%expr)%expr_pat))
                          else None);
                   Some (fv0 <-- fv;
                         Base fv0)%under_lets
                  else None
              | None => None
              end
          | _ => None
          end;;
          match x0 with
          | @expr.Ident _ _ _ t0 idc0 =>
              args <- invert_bind_args idc0 Raw.ident.Literal;
              _ <- invert_bind_args idc Raw.ident.Z_add_get_carry;
              match
                pattern.type.unify_extracted_cps ((ℤ -> ℤ) -> ℤ)%ptype
                  ((s1 -> s0) -> (projT1 args))%ptype option
                  (fun x3 : option => x3)
              with
              | Some (_, _, _)%zrange =>
                  if
                   type.type_beq base.type base.type.type_beq
                     ((ℤ -> ℤ) -> ℤ)%ptype
                     ((s1 -> s0) -> (projT1 args))%ptype
                  then
                   v <- type.try_make_transport_cps s1 ℤ;
                   v0 <- type.try_make_transport_cps s0 ℤ;
                   xv <- ident.unify pattern.ident.Literal ##(projT2 args);
                   fv <- (if (let (x3, _) := xv in x3) <? 0
                          then
                           Some
                             (UnderLet
                                (#(Z_cast2
                                     (Datatypes.fst range,
                                     - Datatypes.snd range))%expr @
                                 (#(Z_sub_get_borrow)%expr @
                                  v (Compile.reflect x2) @
                                  v0 (Compile.reflect x1) @
                                  (##(- (let (x3, _) := xv in x3))%Z)%expr))%expr_pat
                                (fun vc : var (ℤ * ℤ)%etype =>
                                 Base
                                   (#(Z_cast (Datatypes.fst range))%expr @
                                    (#(fst)%expr @
                                     (#(Z_cast2
                                          (Datatypes.fst range,
                                          - Datatypes.snd range))%expr @
                                      ($vc)%expr)),
                                   #(Z_cast (Datatypes.snd range))%expr @
                                   (-
                                    (#(Z_cast (- Datatypes.snd range))%expr @
                                     (#(snd)%expr @
                                      (#(Z_cast2
                                           (Datatypes.fst range,
                                           - Datatypes.snd range))%expr @ $vc)))%expr_pat)%expr)%expr_pat))
                          else None);
                   Some (fv0 <-- fv;
                         Base fv0)%under_lets
                  else None
              | None => None
              end
          | _ => None
          end;;
          _ <- invert_bind_args idc Raw.ident.Z_add_get_carry;
          match
            pattern.type.unify_extracted_cps ((ℤ -> ℤ) -> ℤ)%ptype
              ((s1 -> s0) -> s)%ptype option (fun x3 : option => x3)
          with
          | Some (_, _, _)%zrange =>
              if
               type.type_beq base.type base.type.type_beq
                 ((ℤ -> ℤ) -> ℤ)%ptype ((s1 -> s0) -> s)%ptype
              then
               v <- type.try_make_transport_cps s1 ℤ;
               v0 <- type.try_make_transport_cps s0 ℤ;
               v1 <- type.try_make_transport_cps s ℤ;
               Some
                 (UnderLet
                    (#(Z_cast2 range)%expr @
                     (#(Z_add_get_carry)%expr @ v (Compile.reflect x2) @
                      v0 (Compile.reflect x1) @ v1 (Compile.reflect x0)))%expr_pat
                    (fun v2 : var (ℤ * ℤ)%etype =>
                     Base
                       (#(Z_cast (Datatypes.fst range))%expr @
                        (#(fst)%expr @ (#(Z_cast2 range)%expr @ ($v2)%expr)),
                       #(Z_cast (Datatypes.snd range))%expr @
                       (#(snd)%expr @ (#(Z_cast2 range)%expr @ ($v2)%expr)))%expr_pat))
              else None
          | None => None
          end);;
         (_ <- invert_bind_args idc Raw.ident.Z_sub_get_borrow;
          match
            pattern.type.unify_extracted_cps ((ℤ -> ℤ) -> ℤ)%ptype
              ((s1 -> s0) -> s)%ptype option (fun x3 : option => x3)
          with
          | Some (_, _, _)%zrange =>
              if
               type.type_beq base.type base.type.type_beq
                 ((ℤ -> ℤ) -> ℤ)%ptype ((s1 -> s0) -> s)%ptype
              then
               v <- type.try_make_transport_cps s1 ℤ;
               v0 <- type.try_make_transport_cps s0 ℤ;
               v1 <- type.try_make_transport_cps s ℤ;
               Some
                 (UnderLet
                    (#(Z_cast2 range)%expr @
                     (#(Z_sub_get_borrow)%expr @ v (Compile.reflect x2) @
                      v0 (Compile.reflect x1) @ v1 (Compile.reflect x0)))%expr_pat
                    (fun v2 : var (ℤ * ℤ)%etype =>
                     Base
                       (#(Z_cast (Datatypes.fst range))%expr @
                        (#(fst)%expr @ (#(Z_cast2 range)%expr @ ($v2)%expr)),
                       #(Z_cast (Datatypes.snd range))%expr @
                       (#(snd)%expr @ (#(Z_cast2 range)%expr @ ($v2)%expr)))%expr_pat))
              else None
          | None => None
          end);;
         _ <- invert_bind_args idc Raw.ident.Z_mul_split;
         match
           pattern.type.unify_extracted_cps ((ℤ -> ℤ) -> ℤ)%ptype
             ((s1 -> s0) -> s)%ptype option (fun x3 : option => x3)
         with
         | Some (_, _, _)%zrange =>
             if
              type.type_beq base.type base.type.type_beq
                ((ℤ -> ℤ) -> ℤ)%ptype ((s1 -> s0) -> s)%ptype
             then
              v <- type.try_make_transport_cps s1 ℤ;
              v0 <- type.try_make_transport_cps s0 ℤ;
              v1 <- type.try_make_transport_cps s ℤ;
              Some
                (UnderLet
                   (#(Z_cast2 range)%expr @
                    (#(Z_mul_split)%expr @ v (Compile.reflect x2) @
                     v0 (Compile.reflect x1) @ v1 (Compile.reflect x0)))%expr_pat
                   (fun v2 : var (ℤ * ℤ)%etype =>
                    Base
                      (#(Z_cast (Datatypes.fst range))%expr @
                       (#(fst)%expr @ (#(Z_cast2 range)%expr @ ($v2)%expr)),
                      #(Z_cast (Datatypes.snd range))%expr @
                      (#(snd)%expr @ (#(Z_cast2 range)%expr @ ($v2)%expr)))%expr_pat))
             else None
         | None => None
         end
     | @expr.App _ _ _ s _
       (@expr.App _ _ _ s0 _
        (@expr.App _ _ _ s1 _
         (@expr.App _ _ _ s2 _ (@expr.Ident _ _ _ t idc) x3) x2) x1) x0 =>
         (match x2 with
          | @expr.Ident _ _ _ t0 idc0 =>
              match x1 with
              | (@expr.Ident _ _ _ t1 idc1 @
                 (@expr.Ident _ _ _ t2 idc2 @ @expr.App _ _ _ s5 _
                  (@expr.Ident _ _ _ t3 idc3) x6))%expr_pat =>
                  (args <- invert_bind_args idc3 Raw.ident.Z_cast;
                   _ <- invert_bind_args idc2 Raw.ident.Z_opp;
                   args1 <- invert_bind_args idc1 Raw.ident.Z_cast;
                   args2 <- invert_bind_args idc0 Raw.ident.Literal;
                   _ <- invert_bind_args idc Raw.ident.Z_add_with_get_carry;
                   match
                     pattern.type.unify_extracted_cps
                       (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
                       (((s2 -> (projT1 args2)) -> s5) -> s)%ptype option
                       (fun x7 : option => x7)
                   with
                   | Some (_, _, _, _)%zrange =>
                       if
                        type.type_beq base.type base.type.type_beq
                          (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
                          (((s2 -> (projT1 args2)) -> s5) -> s)%ptype
                       then
                        v <- type.try_make_transport_cps s2 ℤ;
                        xv <- ident.unify pattern.ident.Literal
                                ##(projT2 args2);
                        v0 <- type.try_make_transport_cps s5 ℤ;
                        v1 <- type.try_make_transport_cps s ℤ;
                        fv <- (if
                                ((let (x7, _) := xv in x7) =? 0) &&
                                (ZRange.normalize args <=?
                                 - ZRange.normalize args1)%zrange
                               then
                                Some
                                  (UnderLet
                                     (#(Z_cast2
                                          (Datatypes.fst range,
                                          - Datatypes.snd range))%expr @
                                      (#(Z_sub_get_borrow)%expr @
                                       v (Compile.reflect x3) @
                                       v1 (Compile.reflect x0) @
                                       (#(Z_cast args)%expr @
                                        v0 (Compile.reflect x6))))%expr_pat
                                     (fun vc : var (ℤ * ℤ)%etype =>
                                      Base
                                        (#(Z_cast (Datatypes.fst range))%expr @
                                         (#(fst)%expr @
                                          (#(Z_cast2
                                               (Datatypes.fst range,
                                               - Datatypes.snd range))%expr @
                                           ($vc)%expr)),
                                        #(Z_cast (Datatypes.snd range))%expr @
                                        (-
                                         (#(Z_cast (- Datatypes.snd range))%expr @
                                          (#(snd)%expr @
                                           (#(Z_cast2
                                                (Datatypes.fst range,
                                                - Datatypes.snd range))%expr @
                                            $vc)))%expr_pat)%expr)%expr_pat))
                               else None);
                        Some (fv0 <-- fv;
                              Base fv0)%under_lets
                       else None
                   | None => None
                   end);;
                  args <- invert_bind_args idc3 Raw.ident.Z_cast;
                  _ <- invert_bind_args idc2 Raw.ident.Z_opp;
                  args1 <- invert_bind_args idc1 Raw.ident.Z_cast;
                  args2 <- invert_bind_args idc0 Raw.ident.Literal;
                  _ <- invert_bind_args idc Raw.ident.Z_add_with_get_carry;
                  match
                    pattern.type.unify_extracted_cps
                      (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
                      (((s2 -> (projT1 args2)) -> s5) -> s)%ptype option
                      (fun x7 : option => x7)
                  with
                  | Some (_, _, _, _)%zrange =>
                      if
                       type.type_beq base.type base.type.type_beq
                         (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
                         (((s2 -> (projT1 args2)) -> s5) -> s)%ptype
                      then
                       v <- type.try_make_transport_cps s2 ℤ;
                       xv <- ident.unify pattern.ident.Literal
                               ##(projT2 args2);
                       v0 <- type.try_make_transport_cps s5 ℤ;
                       v1 <- type.try_make_transport_cps s ℤ;
                       fv <- (if
                               ((let (x7, _) := xv in x7) <? 0) &&
                               (ZRange.normalize args <=?
                                - ZRange.normalize args1)%zrange
                              then
                               Some
                                 (UnderLet
                                    (#(Z_cast2
                                         (Datatypes.fst range,
                                         - Datatypes.snd range))%expr @
                                     (#(Z_sub_with_get_borrow)%expr @
                                      v (Compile.reflect x3) @
                                      (##(- (let (x7, _) := xv in x7))%Z)%expr @
                                      v1 (Compile.reflect x0) @
                                      (#(Z_cast args)%expr @
                                       v0 (Compile.reflect x6))))%expr_pat
                                    (fun vc : var (ℤ * ℤ)%etype =>
                                     Base
                                       (#(Z_cast (Datatypes.fst range))%expr @
                                        (#(fst)%expr @
                                         (#(Z_cast2
                                              (Datatypes.fst range,
                                              - Datatypes.snd range))%expr @
                                          ($vc)%expr)),
                                       #(Z_cast (Datatypes.snd range))%expr @
                                       (-
                                        (#(Z_cast (- Datatypes.snd range))%expr @
                                         (#(snd)%expr @
                                          (#(Z_cast2
                                               (Datatypes.fst range,
                                               - Datatypes.snd range))%expr @
                                           $vc)))%expr_pat)%expr)%expr_pat))
                              else None);
                       Some (fv0 <-- fv;
                             Base fv0)%under_lets
                      else None
                  | None => None
                  end
              | (@expr.Ident _ _ _ t1 idc1 @
                 (@expr.Ident _ _ _ t2 idc2 @ @expr.App _ _ _ s5 _ ($_)%expr
                  _))%expr_pat |
                (@expr.Ident _ _ _ t1 idc1 @
                 (@expr.Ident _ _ _ t2 idc2 @ @expr.App _ _ _ s5 _
                  (@expr.Abs _ _ _ _ _ _) _))%expr_pat |
                (@expr.Ident _ _ _ t1 idc1 @
                 (@expr.Ident _ _ _ t2 idc2 @ @expr.App _ _ _ s5 _ (_ @ _) _))%expr_pat |
                (@expr.Ident _ _ _ t1 idc1 @
                 (@expr.Ident _ _ _ t2 idc2 @ @expr.App _ _ _ s5 _
                  (@expr.LetIn _ _ _ _ _ _ _) _))%expr_pat => None
              | (@expr.Ident _ _ _ t1 idc1 @
                 (@expr.Ident _ _ _ t2 idc2 @ #(_)))%expr_pat |
                (@expr.Ident _ _ _ t1 idc1 @
                 (@expr.Ident _ _ _ t2 idc2 @ ($_)%expr))%expr_pat |
                (@expr.Ident _ _ _ t1 idc1 @
                 (@expr.Ident _ _ _ t2 idc2 @ @expr.Abs _ _ _ _ _ _))%expr_pat |
                (@expr.Ident _ _ _ t1 idc1 @
                 (@expr.Ident _ _ _ t2 idc2 @ @expr.LetIn _ _ _ _ _ _ _))%expr_pat =>
                  None
              | (@expr.Ident _ _ _ t1 idc1 @ #(_))%expr_pat |
                (@expr.Ident _ _ _ t1 idc1 @ ($_)%expr)%expr_pat |
                (@expr.Ident _ _ _ t1 idc1 @ @expr.Abs _ _ _ _ _ _)%expr_pat |
                (@expr.Ident _ _ _ t1 idc1 @ (($_)%expr @ _))%expr_pat |
                (@expr.Ident _ _ _ t1 idc1 @ (@expr.Abs _ _ _ _ _ _ @ _))%expr_pat |
                (@expr.Ident _ _ _ t1 idc1 @ (_ @ _ @ _))%expr_pat |
                (@expr.Ident _ _ _ t1 idc1 @ (@expr.LetIn _ _ _ _ _ _ _ @ _))%expr_pat |
                (@expr.Ident _ _ _ t1 idc1 @ @expr.LetIn _ _ _ _ _ _ _)%expr_pat =>
                  None
              | _ => None
              end;;
              match x0 with
              | (@expr.Ident _ _ _ t1 idc1 @
                 (@expr.Ident _ _ _ t2 idc2 @ @expr.App _ _ _ s5 _
                  (@expr.Ident _ _ _ t3 idc3) x6))%expr_pat =>
                  (args <- invert_bind_args idc3 Raw.ident.Z_cast;
                   _ <- invert_bind_args idc2 Raw.ident.Z_opp;
                   args1 <- invert_bind_args idc1 Raw.ident.Z_cast;
                   args2 <- invert_bind_args idc0 Raw.ident.Literal;
                   _ <- invert_bind_args idc Raw.ident.Z_add_with_get_carry;
                   match
                     pattern.type.unify_extracted_cps
                       (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
                       (((s2 -> (projT1 args2)) -> s0) -> s5)%ptype option
                       (fun x7 : option => x7)
                   with
                   | Some (_, _, _, _)%zrange =>
                       if
                        type.type_beq base.type base.type.type_beq
                          (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
                          (((s2 -> (projT1 args2)) -> s0) -> s5)%ptype
                       then
                        v <- type.try_make_transport_cps s2 ℤ;
                        xv <- ident.unify pattern.ident.Literal
                                ##(projT2 args2);
                        v0 <- type.try_make_transport_cps s0 ℤ;
                        v1 <- type.try_make_transport_cps s5 ℤ;
                        fv <- (if
                                ((let (x7, _) := xv in x7) =? 0) &&
                                (ZRange.normalize args <=?
                                 - ZRange.normalize args1)%zrange
                               then
                                Some
                                  (UnderLet
                                     (#(Z_cast2
                                          (Datatypes.fst range,
                                          - Datatypes.snd range))%expr @
                                      (#(Z_sub_get_borrow)%expr @
                                       v (Compile.reflect x3) @
                                       v0 (Compile.reflect x1) @
                                       (#(Z_cast args)%expr @
                                        v1 (Compile.reflect x6))))%expr_pat
                                     (fun vc : var (ℤ * ℤ)%etype =>
                                      Base
                                        (#(Z_cast (Datatypes.fst range))%expr @
                                         (#(fst)%expr @
                                          (#(Z_cast2
                                               (Datatypes.fst range,
                                               - Datatypes.snd range))%expr @
                                           ($vc)%expr)),
                                        #(Z_cast (Datatypes.snd range))%expr @
                                        (-
                                         (#(Z_cast (- Datatypes.snd range))%expr @
                                          (#(snd)%expr @
                                           (#(Z_cast2
                                                (Datatypes.fst range,
                                                - Datatypes.snd range))%expr @
                                            $vc)))%expr_pat)%expr)%expr_pat))
                               else None);
                        Some (fv0 <-- fv;
                              Base fv0)%under_lets
                       else None
                   | None => None
                   end);;
                  args <- invert_bind_args idc3 Raw.ident.Z_cast;
                  _ <- invert_bind_args idc2 Raw.ident.Z_opp;
                  args1 <- invert_bind_args idc1 Raw.ident.Z_cast;
                  args2 <- invert_bind_args idc0 Raw.ident.Literal;
                  _ <- invert_bind_args idc Raw.ident.Z_add_with_get_carry;
                  match
                    pattern.type.unify_extracted_cps
                      (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
                      (((s2 -> (projT1 args2)) -> s0) -> s5)%ptype option
                      (fun x7 : option => x7)
                  with
                  | Some (_, _, _, _)%zrange =>
                      if
                       type.type_beq base.type base.type.type_beq
                         (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
                         (((s2 -> (projT1 args2)) -> s0) -> s5)%ptype
                      then
                       v <- type.try_make_transport_cps s2 ℤ;
                       xv <- ident.unify pattern.ident.Literal
                               ##(projT2 args2);
                       v0 <- type.try_make_transport_cps s0 ℤ;
                       v1 <- type.try_make_transport_cps s5 ℤ;
                       fv <- (if
                               ((let (x7, _) := xv in x7) <? 0) &&
                               (ZRange.normalize args <=?
                                - ZRange.normalize args1)%zrange
                              then
                               Some
                                 (UnderLet
                                    (#(Z_cast2
                                         (Datatypes.fst range,
                                         - Datatypes.snd range))%expr @
                                     (#(Z_sub_with_get_borrow)%expr @
                                      v (Compile.reflect x3) @
                                      (##(- (let (x7, _) := xv in x7))%Z)%expr @
                                      v0 (Compile.reflect x1) @
                                      (#(Z_cast args)%expr @
                                       v1 (Compile.reflect x6))))%expr_pat
                                    (fun vc : var (ℤ * ℤ)%etype =>
                                     Base
                                       (#(Z_cast (Datatypes.fst range))%expr @
                                        (#(fst)%expr @
                                         (#(Z_cast2
                                              (Datatypes.fst range,
                                              - Datatypes.snd range))%expr @
                                          ($vc)%expr)),
                                       #(Z_cast (Datatypes.snd range))%expr @
                                       (-
                                        (#(Z_cast (- Datatypes.snd range))%expr @
                                         (#(snd)%expr @
                                          (#(Z_cast2
                                               (Datatypes.fst range,
                                               - Datatypes.snd range))%expr @
                                           $vc)))%expr_pat)%expr)%expr_pat))
                              else None);
                       Some (fv0 <-- fv;
                             Base fv0)%under_lets
                      else None
                  | None => None
                  end
              | (@expr.Ident _ _ _ t1 idc1 @
                 (@expr.Ident _ _ _ t2 idc2 @ @expr.App _ _ _ s5 _ ($_)%expr
                  _))%expr_pat |
                (@expr.Ident _ _ _ t1 idc1 @
                 (@expr.Ident _ _ _ t2 idc2 @ @expr.App _ _ _ s5 _
                  (@expr.Abs _ _ _ _ _ _) _))%expr_pat |
                (@expr.Ident _ _ _ t1 idc1 @
                 (@expr.Ident _ _ _ t2 idc2 @ @expr.App _ _ _ s5 _ (_ @ _) _))%expr_pat |
                (@expr.Ident _ _ _ t1 idc1 @
                 (@expr.Ident _ _ _ t2 idc2 @ @expr.App _ _ _ s5 _
                  (@expr.LetIn _ _ _ _ _ _ _) _))%expr_pat => None
              | (@expr.Ident _ _ _ t1 idc1 @
                 (@expr.Ident _ _ _ t2 idc2 @ #(_)))%expr_pat |
                (@expr.Ident _ _ _ t1 idc1 @
                 (@expr.Ident _ _ _ t2 idc2 @ ($_)%expr))%expr_pat |
                (@expr.Ident _ _ _ t1 idc1 @
                 (@expr.Ident _ _ _ t2 idc2 @ @expr.Abs _ _ _ _ _ _))%expr_pat |
                (@expr.Ident _ _ _ t1 idc1 @
                 (@expr.Ident _ _ _ t2 idc2 @ @expr.LetIn _ _ _ _ _ _ _))%expr_pat =>
                  None
              | (@expr.Ident _ _ _ t1 idc1 @ #(_))%expr_pat |
                (@expr.Ident _ _ _ t1 idc1 @ ($_)%expr)%expr_pat |
                (@expr.Ident _ _ _ t1 idc1 @ @expr.Abs _ _ _ _ _ _)%expr_pat |
                (@expr.Ident _ _ _ t1 idc1 @ (($_)%expr @ _))%expr_pat |
                (@expr.Ident _ _ _ t1 idc1 @ (@expr.Abs _ _ _ _ _ _ @ _))%expr_pat |
                (@expr.Ident _ _ _ t1 idc1 @ (_ @ _ @ _))%expr_pat |
                (@expr.Ident _ _ _ t1 idc1 @ (@expr.LetIn _ _ _ _ _ _ _ @ _))%expr_pat |
                (@expr.Ident _ _ _ t1 idc1 @ @expr.LetIn _ _ _ _ _ _ _)%expr_pat =>
                  None
              | _ => None
              end;;
              match x1 with
              | @expr.Ident _ _ _ t1 idc1 =>
                  args <- invert_bind_args idc1 Raw.ident.Literal;
                  args0 <- invert_bind_args idc0 Raw.ident.Literal;
                  _ <- invert_bind_args idc Raw.ident.Z_add_with_get_carry;
                  match
                    pattern.type.unify_extracted_cps
                      (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
                      (((s2 -> (projT1 args0)) -> (projT1 args)) -> s)%ptype
                      option (fun x4 : option => x4)
                  with
                  | Some (_, _, _, _)%zrange =>
                      if
                       type.type_beq base.type base.type.type_beq
                         (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
                         (((s2 -> (projT1 args0)) -> (projT1 args)) -> s)%ptype
                      then
                       v <- type.try_make_transport_cps s2 ℤ;
                       xv <- ident.unify pattern.ident.Literal
                               ##(projT2 args0);
                       xv0 <- ident.unify pattern.ident.Literal
                                ##(projT2 args);
                       v0 <- type.try_make_transport_cps s ℤ;
                       fv <- (if
                               ((let (x4, _) := xv0 in x4) <=? 0) &&
                               ((let (x4, _) := xv in x4) <=? 0) &&
                               ((let (x4, _) := xv0 in x4) +
                                (let (x4, _) := xv in x4) <? 0)
                              then
                               Some
                                 (UnderLet
                                    (#(Z_cast2
                                         (Datatypes.fst range,
                                         - Datatypes.snd range))%expr @
                                     (#(Z_sub_with_get_borrow)%expr @
                                      v (Compile.reflect x3) @
                                      (##(- (let (x4, _) := xv in x4))%Z)%expr @
                                      v0 (Compile.reflect x0) @
                                      (##(- (let (x4, _) := xv0 in x4))%Z)%expr))%expr_pat
                                    (fun vc : var (ℤ * ℤ)%etype =>
                                     Base
                                       (#(Z_cast (Datatypes.fst range))%expr @
                                        (#(fst)%expr @
                                         (#(Z_cast2
                                              (Datatypes.fst range,
                                              - Datatypes.snd range))%expr @
                                          ($vc)%expr)),
                                       #(Z_cast (Datatypes.snd range))%expr @
                                       (-
                                        (#(Z_cast (- Datatypes.snd range))%expr @
                                         (#(snd)%expr @
                                          (#(Z_cast2
                                               (Datatypes.fst range,
                                               - Datatypes.snd range))%expr @
                                           $vc)))%expr_pat)%expr)%expr_pat))
                              else None);
                       Some (fv0 <-- fv;
                             Base fv0)%under_lets
                      else None
                  | None => None
                  end
              | _ => None
              end;;
              match x0 with
              | @expr.Ident _ _ _ t1 idc1 =>
                  args <- invert_bind_args idc1 Raw.ident.Literal;
                  args0 <- invert_bind_args idc0 Raw.ident.Literal;
                  _ <- invert_bind_args idc Raw.ident.Z_add_with_get_carry;
                  match
                    pattern.type.unify_extracted_cps
                      (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
                      (((s2 -> (projT1 args0)) -> s0) -> (projT1 args))%ptype
                      option (fun x4 : option => x4)
                  with
                  | Some (_, _, _, _)%zrange =>
                      if
                       type.type_beq base.type base.type.type_beq
                         (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
                         (((s2 -> (projT1 args0)) -> s0) -> (projT1 args))%ptype
                      then
                       v <- type.try_make_transport_cps s2 ℤ;
                       xv <- ident.unify pattern.ident.Literal
                               ##(projT2 args0);
                       v0 <- type.try_make_transport_cps s0 ℤ;
                       xv0 <- ident.unify pattern.ident.Literal
                                ##(projT2 args);
                       fv <- (if
                               ((let (x4, _) := xv0 in x4) <=? 0) &&
                               ((let (x4, _) := xv in x4) <=? 0) &&
                               ((let (x4, _) := xv0 in x4) +
                                (let (x4, _) := xv in x4) <? 0)
                              then
                               Some
                                 (UnderLet
                                    (#(Z_cast2
                                         (Datatypes.fst range,
                                         - Datatypes.snd range))%expr @
                                     (#(Z_sub_with_get_borrow)%expr @
                                      v (Compile.reflect x3) @
                                      (##(- (let (x4, _) := xv in x4))%Z)%expr @
                                      v0 (Compile.reflect x1) @
                                      (##(- (let (x4, _) := xv0 in x4))%Z)%expr))%expr_pat
                                    (fun vc : var (ℤ * ℤ)%etype =>
                                     Base
                                       (#(Z_cast (Datatypes.fst range))%expr @
                                        (#(fst)%expr @
                                         (#(Z_cast2
                                              (Datatypes.fst range,
                                              - Datatypes.snd range))%expr @
                                          ($vc)%expr)),
                                       #(Z_cast (Datatypes.snd range))%expr @
                                       (-
                                        (#(Z_cast (- Datatypes.snd range))%expr @
                                         (#(snd)%expr @
                                          (#(Z_cast2
                                               (Datatypes.fst range,
                                               - Datatypes.snd range))%expr @
                                           $vc)))%expr_pat)%expr)%expr_pat))
                              else None);
                       Some (fv0 <-- fv;
                             Base fv0)%under_lets
                      else None
                  | None => None
                  end
              | _ => None
              end;;
              args <- invert_bind_args idc0 Raw.ident.Literal;
              _ <- invert_bind_args idc Raw.ident.Z_add_with_get_carry;
              match
                pattern.type.unify_extracted_cps (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
                  (((s2 -> (projT1 args)) -> s0) -> s)%ptype option
                  (fun x4 : option => x4)
              with
              | Some (_, _, _, _)%zrange =>
                  if
                   type.type_beq base.type base.type.type_beq
                     (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
                     (((s2 -> (projT1 args)) -> s0) -> s)%ptype
                  then
                   v <- type.try_make_transport_cps s2 ℤ;
                   xv <- ident.unify pattern.ident.Literal ##(projT2 args);
                   v0 <- type.try_make_transport_cps s0 ℤ;
                   v1 <- type.try_make_transport_cps s ℤ;
                   fv <- (if (let (x4, _) := xv in x4) =? 0
                          then
                           Some
                             (UnderLet
                                (#(Z_cast2 range)%expr @
                                 (#(Z_add_get_carry)%expr @
                                  v (Compile.reflect x3) @
                                  v0 (Compile.reflect x1) @
                                  v1 (Compile.reflect x0)))%expr_pat
                                (fun vc : var (ℤ * ℤ)%etype =>
                                 Base
                                   (#(Z_cast (Datatypes.fst range))%expr @
                                    (#(fst)%expr @
                                     (#(Z_cast2 range)%expr @ ($vc)%expr)),
                                   #(Z_cast (Datatypes.snd range))%expr @
                                   (#(snd)%expr @
                                    (#(Z_cast2 range)%expr @ ($vc)%expr)))%expr_pat))
                          else None);
                   Some (fv0 <-- fv;
                         Base fv0)%under_lets
                  else None
              | None => None
              end
          | @expr.App _ _ _ s3 _ (@expr.Ident _ _ _ t0 idc0) x4 =>
              match x4 with
              | (@expr.Ident _ _ _ t1 idc1 @ @expr.App _ _ _ s5 _
                 (@expr.Ident _ _ _ t2 idc2) x6)%expr_pat =>
                  match x1 with
                  | (@expr.Ident _ _ _ t3 idc3 @
                     (@expr.Ident _ _ _ t4 idc4 @ @expr.App _ _ _ s8 _
                      (@expr.Ident _ _ _ t5 idc5) x9))%expr_pat =>
                      args <- invert_bind_args idc5 Raw.ident.Z_cast;
                      _ <- invert_bind_args idc4 Raw.ident.Z_opp;
                      args1 <- invert_bind_args idc3 Raw.ident.Z_cast;
                      args2 <- invert_bind_args idc2 Raw.ident.Z_cast;
                      _ <- invert_bind_args idc1 Raw.ident.Z_opp;
                      args4 <- invert_bind_args idc0 Raw.ident.Z_cast;
                      _ <- invert_bind_args idc
                             Raw.ident.Z_add_with_get_carry;
                      match
                        pattern.type.unify_extracted_cps
                          (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
                          (((s2 -> s5) -> s8) -> s)%ptype option
                          (fun x10 : option => x10)
                      with
                      | Some (_, _, _, _)%zrange =>
                          if
                           type.type_beq base.type base.type.type_beq
                             (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
                             (((s2 -> s5) -> s8) -> s)%ptype
                          then
                           v <- type.try_make_transport_cps s2 ℤ;
                           v0 <- type.try_make_transport_cps s5 ℤ;
                           v1 <- type.try_make_transport_cps s8 ℤ;
                           v2 <- type.try_make_transport_cps s ℤ;
                           fv <- (if
                                   (ZRange.normalize args <=?
                                    - ZRange.normalize args1)%zrange &&
                                   (ZRange.normalize args2 <=?
                                    - ZRange.normalize args4)%zrange
                                  then
                                   Some
                                     (UnderLet
                                        (#(Z_cast2
                                             (Datatypes.fst range,
                                             - Datatypes.snd range))%expr @
                                         (#(Z_sub_with_get_borrow)%expr @
                                          v (Compile.reflect x3) @
                                          (#(Z_cast args2)%expr @
                                           v0 (Compile.reflect x6)) @
                                          v2 (Compile.reflect x0) @
                                          (#(Z_cast args)%expr @
                                           v1 (Compile.reflect x9))))%expr_pat
                                        (fun vc : var (ℤ * ℤ)%etype =>
                                         Base
                                           (#(Z_cast (Datatypes.fst range))%expr @
                                            (#(fst)%expr @
                                             (#(Z_cast2
                                                  (Datatypes.fst range,
                                                  - Datatypes.snd range))%expr @
                                              ($vc)%expr)),
                                           #(Z_cast (Datatypes.snd range))%expr @
                                           (-
                                            (#(Z_cast (- Datatypes.snd range))%expr @
                                             (#(snd)%expr @
                                              (#(Z_cast2
                                                   (Datatypes.fst range,
                                                   - Datatypes.snd range))%expr @
                                               $vc)))%expr_pat)%expr)%expr_pat))
                                  else None);
                           Some (fv0 <-- fv;
                                 Base fv0)%under_lets
                          else None
                      | None => None
                      end
                  | (@expr.Ident _ _ _ t3 idc3 @
                     (@expr.Ident _ _ _ t4 idc4 @ @expr.App _ _ _ s8 _
                      ($_)%expr _))%expr_pat |
                    (@expr.Ident _ _ _ t3 idc3 @
                     (@expr.Ident _ _ _ t4 idc4 @ @expr.App _ _ _ s8 _
                      (@expr.Abs _ _ _ _ _ _) _))%expr_pat |
                    (@expr.Ident _ _ _ t3 idc3 @
                     (@expr.Ident _ _ _ t4 idc4 @ @expr.App _ _ _ s8 _
                      (_ @ _) _))%expr_pat |
                    (@expr.Ident _ _ _ t3 idc3 @
                     (@expr.Ident _ _ _ t4 idc4 @ @expr.App _ _ _ s8 _
                      (@expr.LetIn _ _ _ _ _ _ _) _))%expr_pat => None
                  | (@expr.Ident _ _ _ t3 idc3 @
                     (@expr.Ident _ _ _ t4 idc4 @ #(_)))%expr_pat |
                    (@expr.Ident _ _ _ t3 idc3 @
                     (@expr.Ident _ _ _ t4 idc4 @ ($_)%expr))%expr_pat |
                    (@expr.Ident _ _ _ t3 idc3 @
                     (@expr.Ident _ _ _ t4 idc4 @ @expr.Abs _ _ _ _ _ _))%expr_pat |
                    (@expr.Ident _ _ _ t3 idc3 @
                     (@expr.Ident _ _ _ t4 idc4 @ @expr.LetIn _ _ _ _ _ _ _))%expr_pat =>
                      None
                  | (@expr.Ident _ _ _ t3 idc3 @ #(_))%expr_pat |
                    (@expr.Ident _ _ _ t3 idc3 @ ($_)%expr)%expr_pat |
                    (@expr.Ident _ _ _ t3 idc3 @ @expr.Abs _ _ _ _ _ _)%expr_pat |
                    (@expr.Ident _ _ _ t3 idc3 @ (($_)%expr @ _))%expr_pat |
                    (@expr.Ident _ _ _ t3 idc3 @ (@expr.Abs _ _ _ _ _ _ @ _))%expr_pat |
                    (@expr.Ident _ _ _ t3 idc3 @ (_ @ _ @ _))%expr_pat |
                    (@expr.Ident _ _ _ t3 idc3 @
                     (@expr.LetIn _ _ _ _ _ _ _ @ _))%expr_pat |
                    (@expr.Ident _ _ _ t3 idc3 @ @expr.LetIn _ _ _ _ _ _ _)%expr_pat =>
                      None
                  | _ => None
                  end;;
                  match x0 with
                  | (@expr.Ident _ _ _ t3 idc3 @
                     (@expr.Ident _ _ _ t4 idc4 @ @expr.App _ _ _ s8 _
                      (@expr.Ident _ _ _ t5 idc5) x9))%expr_pat =>
                      args <- invert_bind_args idc5 Raw.ident.Z_cast;
                      _ <- invert_bind_args idc4 Raw.ident.Z_opp;
                      args1 <- invert_bind_args idc3 Raw.ident.Z_cast;
                      args2 <- invert_bind_args idc2 Raw.ident.Z_cast;
                      _ <- invert_bind_args idc1 Raw.ident.Z_opp;
                      args4 <- invert_bind_args idc0 Raw.ident.Z_cast;
                      _ <- invert_bind_args idc
                             Raw.ident.Z_add_with_get_carry;
                      match
                        pattern.type.unify_extracted_cps
                          (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
                          (((s2 -> s5) -> s0) -> s8)%ptype option
                          (fun x10 : option => x10)
                      with
                      | Some (_, _, _, _)%zrange =>
                          if
                           type.type_beq base.type base.type.type_beq
                             (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
                             (((s2 -> s5) -> s0) -> s8)%ptype
                          then
                           v <- type.try_make_transport_cps s2 ℤ;
                           v0 <- type.try_make_transport_cps s5 ℤ;
                           v1 <- type.try_make_transport_cps s0 ℤ;
                           v2 <- type.try_make_transport_cps s8 ℤ;
                           fv <- (if
                                   (ZRange.normalize args <=?
                                    - ZRange.normalize args1)%zrange &&
                                   (ZRange.normalize args2 <=?
                                    - ZRange.normalize args4)%zrange
                                  then
                                   Some
                                     (UnderLet
                                        (#(Z_cast2
                                             (Datatypes.fst range,
                                             - Datatypes.snd range))%expr @
                                         (#(Z_sub_with_get_borrow)%expr @
                                          v (Compile.reflect x3) @
                                          (#(Z_cast args2)%expr @
                                           v0 (Compile.reflect x6)) @
                                          v1 (Compile.reflect x1) @
                                          (#(Z_cast args)%expr @
                                           v2 (Compile.reflect x9))))%expr_pat
                                        (fun vc : var (ℤ * ℤ)%etype =>
                                         Base
                                           (#(Z_cast (Datatypes.fst range))%expr @
                                            (#(fst)%expr @
                                             (#(Z_cast2
                                                  (Datatypes.fst range,
                                                  - Datatypes.snd range))%expr @
                                              ($vc)%expr)),
                                           #(Z_cast (Datatypes.snd range))%expr @
                                           (-
                                            (#(Z_cast (- Datatypes.snd range))%expr @
                                             (#(snd)%expr @
                                              (#(Z_cast2
                                                   (Datatypes.fst range,
                                                   - Datatypes.snd range))%expr @
                                               $vc)))%expr_pat)%expr)%expr_pat))
                                  else None);
                           Some (fv0 <-- fv;
                                 Base fv0)%under_lets
                          else None
                      | None => None
                      end
                  | (@expr.Ident _ _ _ t3 idc3 @
                     (@expr.Ident _ _ _ t4 idc4 @ @expr.App _ _ _ s8 _
                      ($_)%expr _))%expr_pat |
                    (@expr.Ident _ _ _ t3 idc3 @
                     (@expr.Ident _ _ _ t4 idc4 @ @expr.App _ _ _ s8 _
                      (@expr.Abs _ _ _ _ _ _) _))%expr_pat |
                    (@expr.Ident _ _ _ t3 idc3 @
                     (@expr.Ident _ _ _ t4 idc4 @ @expr.App _ _ _ s8 _
                      (_ @ _) _))%expr_pat |
                    (@expr.Ident _ _ _ t3 idc3 @
                     (@expr.Ident _ _ _ t4 idc4 @ @expr.App _ _ _ s8 _
                      (@expr.LetIn _ _ _ _ _ _ _) _))%expr_pat => None
                  | (@expr.Ident _ _ _ t3 idc3 @
                     (@expr.Ident _ _ _ t4 idc4 @ #(_)))%expr_pat |
                    (@expr.Ident _ _ _ t3 idc3 @
                     (@expr.Ident _ _ _ t4 idc4 @ ($_)%expr))%expr_pat |
                    (@expr.Ident _ _ _ t3 idc3 @
                     (@expr.Ident _ _ _ t4 idc4 @ @expr.Abs _ _ _ _ _ _))%expr_pat |
                    (@expr.Ident _ _ _ t3 idc3 @
                     (@expr.Ident _ _ _ t4 idc4 @ @expr.LetIn _ _ _ _ _ _ _))%expr_pat =>
                      None
                  | (@expr.Ident _ _ _ t3 idc3 @ #(_))%expr_pat |
                    (@expr.Ident _ _ _ t3 idc3 @ ($_)%expr)%expr_pat |
                    (@expr.Ident _ _ _ t3 idc3 @ @expr.Abs _ _ _ _ _ _)%expr_pat |
                    (@expr.Ident _ _ _ t3 idc3 @ (($_)%expr @ _))%expr_pat |
                    (@expr.Ident _ _ _ t3 idc3 @ (@expr.Abs _ _ _ _ _ _ @ _))%expr_pat |
                    (@expr.Ident _ _ _ t3 idc3 @ (_ @ _ @ _))%expr_pat |
                    (@expr.Ident _ _ _ t3 idc3 @
                     (@expr.LetIn _ _ _ _ _ _ _ @ _))%expr_pat |
                    (@expr.Ident _ _ _ t3 idc3 @ @expr.LetIn _ _ _ _ _ _ _)%expr_pat =>
                      None
                  | _ => None
                  end;;
                  match x1 with
                  | @expr.Ident _ _ _ t3 idc3 =>
                      args <- invert_bind_args idc3 Raw.ident.Literal;
                      args0 <- invert_bind_args idc2 Raw.ident.Z_cast;
                      _ <- invert_bind_args idc1 Raw.ident.Z_opp;
                      args2 <- invert_bind_args idc0 Raw.ident.Z_cast;
                      _ <- invert_bind_args idc
                             Raw.ident.Z_add_with_get_carry;
                      match
                        pattern.type.unify_extracted_cps
                          (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
                          (((s2 -> s5) -> (projT1 args)) -> s)%ptype option
                          (fun x7 : option => x7)
                      with
                      | Some (_, _, _, _)%zrange =>
                          if
                           type.type_beq base.type base.type.type_beq
                             (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
                             (((s2 -> s5) -> (projT1 args)) -> s)%ptype
                          then
                           v <- type.try_make_transport_cps s2 ℤ;
                           v0 <- type.try_make_transport_cps s5 ℤ;
                           xv <- ident.unify pattern.ident.Literal
                                   ##(projT2 args);
                           v1 <- type.try_make_transport_cps s ℤ;
                           fv <- (if
                                   ((let (x7, _) := xv in x7) <=? 0) &&
                                   (ZRange.normalize args0 <=?
                                    - ZRange.normalize args2)%zrange
                                  then
                                   Some
                                     (UnderLet
                                        (#(Z_cast2
                                             (Datatypes.fst range,
                                             - Datatypes.snd range))%expr @
                                         (#(Z_sub_with_get_borrow)%expr @
                                          v (Compile.reflect x3) @
                                          (#(Z_cast args0)%expr @
                                           v0 (Compile.reflect x6)) @
                                          v1 (Compile.reflect x0) @
                                          (##(- (let (x7, _) := xv in x7))%Z)%expr))%expr_pat
                                        (fun vc : var (ℤ * ℤ)%etype =>
                                         Base
                                           (#(Z_cast (Datatypes.fst range))%expr @
                                            (#(fst)%expr @
                                             (#(Z_cast2
                                                  (Datatypes.fst range,
                                                  - Datatypes.snd range))%expr @
                                              ($vc)%expr)),
                                           #(Z_cast (Datatypes.snd range))%expr @
                                           (-
                                            (#(Z_cast (- Datatypes.snd range))%expr @
                                             (#(snd)%expr @
                                              (#(Z_cast2
                                                   (Datatypes.fst range,
                                                   - Datatypes.snd range))%expr @
                                               $vc)))%expr_pat)%expr)%expr_pat))
                                  else None);
                           Some (fv0 <-- fv;
                                 Base fv0)%under_lets
                          else None
                      | None => None
                      end
                  | _ => None
                  end;;
                  match x0 with
                  | @expr.Ident _ _ _ t3 idc3 =>
                      args <- invert_bind_args idc3 Raw.ident.Literal;
                      args0 <- invert_bind_args idc2 Raw.ident.Z_cast;
                      _ <- invert_bind_args idc1 Raw.ident.Z_opp;
                      args2 <- invert_bind_args idc0 Raw.ident.Z_cast;
                      _ <- invert_bind_args idc
                             Raw.ident.Z_add_with_get_carry;
                      match
                        pattern.type.unify_extracted_cps
                          (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
                          (((s2 -> s5) -> s0) -> (projT1 args))%ptype option
                          (fun x7 : option => x7)
                      with
                      | Some (_, _, _, _)%zrange =>
                          if
                           type.type_beq base.type base.type.type_beq
                             (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
                             (((s2 -> s5) -> s0) -> (projT1 args))%ptype
                          then
                           v <- type.try_make_transport_cps s2 ℤ;
                           v0 <- type.try_make_transport_cps s5 ℤ;
                           v1 <- type.try_make_transport_cps s0 ℤ;
                           xv <- ident.unify pattern.ident.Literal
                                   ##(projT2 args);
                           fv <- (if
                                   ((let (x7, _) := xv in x7) <=? 0) &&
                                   (ZRange.normalize args0 <=?
                                    - ZRange.normalize args2)%zrange
                                  then
                                   Some
                                     (UnderLet
                                        (#(Z_cast2
                                             (Datatypes.fst range,
                                             - Datatypes.snd range))%expr @
                                         (#(Z_sub_with_get_borrow)%expr @
                                          v (Compile.reflect x3) @
                                          (#(Z_cast args0)%expr @
                                           v0 (Compile.reflect x6)) @
                                          v1 (Compile.reflect x1) @
                                          (##(- (let (x7, _) := xv in x7))%Z)%expr))%expr_pat
                                        (fun vc : var (ℤ * ℤ)%etype =>
                                         Base
                                           (#(Z_cast (Datatypes.fst range))%expr @
                                            (#(fst)%expr @
                                             (#(Z_cast2
                                                  (Datatypes.fst range,
                                                  - Datatypes.snd range))%expr @
                                              ($vc)%expr)),
                                           #(Z_cast (Datatypes.snd range))%expr @
                                           (-
                                            (#(Z_cast (- Datatypes.snd range))%expr @
                                             (#(snd)%expr @
                                              (#(Z_cast2
                                                   (Datatypes.fst range,
                                                   - Datatypes.snd range))%expr @
                                               $vc)))%expr_pat)%expr)%expr_pat))
                                  else None);
                           Some (fv0 <-- fv;
                                 Base fv0)%under_lets
                          else None
                      | None => None
                      end
                  | _ => None
                  end
              | (@expr.Ident _ _ _ t1 idc1 @ @expr.App _ _ _ s5 _ ($_)%expr _)%expr_pat |
                (@expr.Ident _ _ _ t1 idc1 @ @expr.App _ _ _ s5 _
                 (@expr.Abs _ _ _ _ _ _) _)%expr_pat |
                (@expr.Ident _ _ _ t1 idc1 @ @expr.App _ _ _ s5 _ (_ @ _) _)%expr_pat |
                (@expr.Ident _ _ _ t1 idc1 @ @expr.App _ _ _ s5 _
                 (@expr.LetIn _ _ _ _ _ _ _) _)%expr_pat => None
              | (@expr.Ident _ _ _ t1 idc1 @ #(_))%expr_pat |
                (@expr.Ident _ _ _ t1 idc1 @ ($_)%expr)%expr_pat |
                (@expr.Ident _ _ _ t1 idc1 @ @expr.Abs _ _ _ _ _ _)%expr_pat |
                (@expr.Ident _ _ _ t1 idc1 @ @expr.LetIn _ _ _ _ _ _ _)%expr_pat =>
                  None
              | _ => None
              end;;
              match x3 with
              | @expr.Ident _ _ _ t1 idc1 =>
                  match x1 with
                  | @expr.Ident _ _ _ t2 idc2 =>
                      match x0 with
                      | @expr.Ident _ _ _ t3 idc3 =>
                          args <- invert_bind_args idc3 Raw.ident.Literal;
                          args0 <- invert_bind_args idc2 Raw.ident.Literal;
                          args1 <- invert_bind_args idc1 Raw.ident.Literal;
                          args2 <- invert_bind_args idc0 Raw.ident.Z_cast;
                          _ <- invert_bind_args idc
                                 Raw.ident.Z_add_with_get_carry;
                          match
                            pattern.type.unify_extracted_cps
                              (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
                              ((((projT1 args1) -> s3) -> (projT1 args0)) ->
                               (projT1 args))%ptype option
                              (fun x5 : option => x5)
                          with
                          | Some (_, _, _, _)%zrange =>
                              if
                               type.type_beq base.type base.type.type_beq
                                 (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
                                 ((((projT1 args1) -> s3) -> (projT1 args0)) ->
                                  (projT1 args))%ptype
                              then
                               xv <- ident.unify pattern.ident.Literal
                                       ##(projT2 args1);
                               v <- type.try_make_transport_cps s3 ℤ;
                               xv0 <- ident.unify pattern.ident.Literal
                                        ##(projT2 args0);
                               xv1 <- ident.unify pattern.ident.Literal
                                        ##(projT2 args);
                               fv <- (if
                                       ((let (x5, _) := xv0 in x5) =? 0) &&
                                       ((let (x5, _) := xv1 in x5) =? 0) &&
                                       (ZRange.normalize args2 <=?
                                        r[0 ~> (let (x5, _) := xv in x5) - 1])%zrange &&
                                       is_bounded_by_bool 0
                                         (Datatypes.snd range)
                                      then
                                       Some
                                         (UnderLet
                                            (#(Z_cast2 range)%expr @
                                             (#(Z_add_with_get_carry)%expr @
                                              (##(let (x5, _) := xv in x5))%expr @
                                              (#(Z_cast args2)%expr @
                                               v (Compile.reflect x4)) @
                                              (##(let (x5, _) := xv0 in x5))%expr @
                                              (##(let (x5, _) := xv1 in x5))%expr))%expr_pat
                                            (fun vc : var (ℤ * ℤ)%etype =>
                                             Base
                                               (#(Z_cast
                                                    (Datatypes.fst range))%expr @
                                                (#(fst)%expr @
                                                 (#(Z_cast2 range)%expr @
                                                  ($vc)%expr)), (##0)%expr)%expr_pat))
                                      else None);
                               Some (fv0 <-- fv;
                                     Base fv0)%under_lets
                              else None
                          | None => None
                          end
                      | _ => None
                      end
                  | _ => None
                  end
              | _ => None
              end
          | @expr.App _ _ _ s3 _ ($_)%expr _ | @expr.App _ _ _ s3 _
            (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s3 _ (_ @ _)%expr_pat
            _ | @expr.App _ _ _ s3 _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
          | _ => None
          end;;
          _ <- invert_bind_args idc Raw.ident.Z_add_with_get_carry;
          match
            pattern.type.unify_extracted_cps (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
              (((s2 -> s1) -> s0) -> s)%ptype option (fun x4 : option => x4)
          with
          | Some (_, _, _, _)%zrange =>
              if
               type.type_beq base.type base.type.type_beq
                 (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype (((s2 -> s1) -> s0) -> s)%ptype
              then
               v <- type.try_make_transport_cps s2 ℤ;
               v0 <- type.try_make_transport_cps s1 ℤ;
               v1 <- type.try_make_transport_cps s0 ℤ;
               v2 <- type.try_make_transport_cps s ℤ;
               Some
                 (UnderLet
                    (#(Z_cast2 range)%expr @
                     (#(Z_add_with_get_carry)%expr @ v (Compile.reflect x3) @
                      v0 (Compile.reflect x2) @ v1 (Compile.reflect x1) @
                      v2 (Compile.reflect x0)))%expr_pat
                    (fun v3 : var (ℤ * ℤ)%etype =>
                     Base
                       (#(Z_cast (Datatypes.fst range))%expr @
                        (#(fst)%expr @ (#(Z_cast2 range)%expr @ ($v3)%expr)),
                       #(Z_cast (Datatypes.snd range))%expr @
                       (#(snd)%expr @ (#(Z_cast2 range)%expr @ ($v3)%expr)))%expr_pat))
              else None
          | None => None
          end);;
         _ <- invert_bind_args idc Raw.ident.Z_sub_with_get_borrow;
         match
           pattern.type.unify_extracted_cps (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype
             (((s2 -> s1) -> s0) -> s)%ptype option (fun x4 : option => x4)
         with
         | Some (_, _, _, _)%zrange =>
             if
              type.type_beq base.type base.type.type_beq
                (((ℤ -> ℤ) -> ℤ) -> ℤ)%ptype (((s2 -> s1) -> s0) -> s)%ptype
             then
              v <- type.try_make_transport_cps s2 ℤ;
              v0 <- type.try_make_transport_cps s1 ℤ;
              v1 <- type.try_make_transport_cps s0 ℤ;
              v2 <- type.try_make_transport_cps s ℤ;
              Some
                (UnderLet
                   (#(Z_cast2 range)%expr @
                    (#(Z_sub_with_get_borrow)%expr @ v (Compile.reflect x3) @
                     v0 (Compile.reflect x2) @ v1 (Compile.reflect x1) @
                     v2 (Compile.reflect x0)))%expr_pat
                   (fun v3 : var (ℤ * ℤ)%etype =>
                    Base
                      (#(Z_cast (Datatypes.fst range))%expr @
                       (#(fst)%expr @ (#(Z_cast2 range)%expr @ ($v3)%expr)),
                      #(Z_cast (Datatypes.snd range))%expr @
                      (#(snd)%expr @ (#(Z_cast2 range)%expr @ ($v3)%expr)))%expr_pat))
             else None
         | None => None
         end
     | @expr.App _ _ _ s _
       (@expr.App _ _ _ s0 _
        (@expr.App _ _ _ s1 _ (@expr.App _ _ _ s2 _ ($_)%expr _) _) _) _ |
       @expr.App _ _ _ s _
       (@expr.App _ _ _ s0 _
        (@expr.App _ _ _ s1 _
         (@expr.App _ _ _ s2 _ (@expr.Abs _ _ _ _ _ _) _) _) _) _ | @expr.App
       _ _ _ s _
       (@expr.App _ _ _ s0 _
        (@expr.App _ _ _ s1 _ (@expr.App _ _ _ s2 _ (_ @ _)%expr_pat _) _) _)
       _ | @expr.App _ _ _ s _
       (@expr.App _ _ _ s0 _
        (@expr.App _ _ _ s1 _
         (@expr.App _ _ _ s2 _ (@expr.LetIn _ _ _ _ _ _ _) _) _) _) _ => None
     | @expr.App _ _ _ s _
       (@expr.App _ _ _ s0 _ (@expr.App _ _ _ s1 _ ($_)%expr _) _) _ |
       @expr.App _ _ _ s _
       (@expr.App _ _ _ s0 _ (@expr.App _ _ _ s1 _ (@expr.Abs _ _ _ _ _ _) _)
        _) _ | @expr.App _ _ _ s _
       (@expr.App _ _ _ s0 _
        (@expr.App _ _ _ s1 _ (@expr.LetIn _ _ _ _ _ _ _) _) _) _ => None
     | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ ($_)%expr _) _ | @expr.App _
       _ _ s _ (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _) _ | @expr.App
       _ _ _ s _ (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _) _ =>
         None
     | @expr.App _ _ _ s _ #(_)%expr_pat _ | @expr.App _ _ _ s _ ($_)%expr
       _ | @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s
       _ (@expr.LetIn _ _ _ _ _ _ _) _ => None
     | _ => None
     end;;;
     Base (#(Z_cast2 range)%expr @ x)%expr_pat)%option
| fancy_add log2wordmax imm =>
    fun x : expr (ℤ * ℤ)%etype =>
    Base (#(fancy_add log2wordmax imm)%expr @ x)%expr_pat
| fancy_addc log2wordmax imm =>
    fun x : expr (ℤ * ℤ * ℤ)%etype =>
    Base (#(fancy_addc log2wordmax imm)%expr @ x)%expr_pat
| fancy_sub log2wordmax imm =>
    fun x : expr (ℤ * ℤ)%etype =>
    Base (#(fancy_sub log2wordmax imm)%expr @ x)%expr_pat
| fancy_subb log2wordmax imm =>
    fun x : expr (ℤ * ℤ * ℤ)%etype =>
    Base (#(fancy_subb log2wordmax imm)%expr @ x)%expr_pat
| fancy_mulll log2wordmax =>
    fun x : expr (ℤ * ℤ)%etype =>
    Base (#(fancy_mulll log2wordmax)%expr @ x)%expr_pat
| fancy_mullh log2wordmax =>
    fun x : expr (ℤ * ℤ)%etype =>
    Base (#(fancy_mullh log2wordmax)%expr @ x)%expr_pat
| fancy_mulhl log2wordmax =>
    fun x : expr (ℤ * ℤ)%etype =>
    Base (#(fancy_mulhl log2wordmax)%expr @ x)%expr_pat
| fancy_mulhh log2wordmax =>
    fun x : expr (ℤ * ℤ)%etype =>
    Base (#(fancy_mulhh log2wordmax)%expr @ x)%expr_pat
| fancy_rshi log2wordmax x =>
    fun x0 : expr (ℤ * ℤ)%etype =>
    Base (#(fancy_rshi log2wordmax x)%expr @ x0)%expr_pat
| fancy_selc =>
    fun x : expr (ℤ * ℤ * ℤ)%etype => Base (#(fancy_selc)%expr @ x)%expr_pat
| fancy_selm log2wordmax =>
    fun x : expr (ℤ * ℤ * ℤ)%etype =>
    Base (#(fancy_selm log2wordmax)%expr @ x)%expr_pat
| fancy_sell =>
    fun x : expr (ℤ * ℤ * ℤ)%etype => Base (#(fancy_sell)%expr @ x)%expr_pat
| fancy_addm =>
    fun x : expr (ℤ * ℤ * ℤ)%etype => Base (#(fancy_addm)%expr @ x)%expr_pat
end
     : Compile.value' true t
