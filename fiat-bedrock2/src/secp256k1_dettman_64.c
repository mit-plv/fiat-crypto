/* Autogenerated: 'src/ExtractionOCaml/bedrock2_dettman_multiplication' --lang bedrock2 --static --no-wide-int --widen-carry --widen-bytes --split-multiret --no-select --no-field-element-typedefs secp256k1_dettman 64 5 48 2 '2^256 - 4294968273' mul square */
/* curve description: secp256k1_dettman */
/* machine_wordsize = 64 (from "64") */
/* requested operations: mul, square */
/* n = 5 (from "5") */
/* last_limb_width = 48 (from "48") */
/* last_reduction = 2 (from "2") */
/* s-c = 2^256 - [(1, 4294968273)] (from "2^256 - 4294968273") */
/* inbounds_multiplier: None (from "") */
/*  */
/* Computed values: */
/*  */
/*  */

// Generated from Bedrock code. Avoid editing directly.
#include <stdint.h>
#include <string.h>
#include <assert.h>

#define BR_WORD_MAX UINTPTR_MAX
typedef uintptr_t br_word_t;
typedef intptr_t br_signed_t;

static_assert(sizeof(br_word_t) == sizeof(br_signed_t), "signed size");
static_assert(UINTPTR_MAX <= BR_WORD_MAX, "pointer fits in int");
static_assert(~(br_signed_t)0 == -(br_signed_t)1, "two's complement");

#if __STDC_VERSION__ >= 202311L && __has_include(<stdbit.h>)
  #include <stdbit.h>
  static_assert(__STDC_ENDIAN_NATIVE__ == __STDC_ENDIAN_LITTLE__, "little-endian");
#elif defined(__GNUC__) && defined(__BYTE_ORDER__) && defined(__ORDER_LITTLE_ENDIAN__)
  static_assert(__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__, "little-endian");
#elif defined(_MSC_VER) && !defined(__clang__) &&                              \
    (defined(_M_IX86) || defined(_M_X64) || defined(_M_ARM) || defined(_M_ARM64))
  // these MSVC targets are little-endian
#else
  #error "failed to confirm that target is little-endian"
#endif

// "An object shall have its stored value accessed only ... a character type."
static inline br_word_t _br_load1(br_word_t a) {
  return *((uint8_t *)a);
}

static inline br_word_t _br_load2(br_word_t a) {
  uint16_t r = 0;
  memcpy(&r, (void *)a, sizeof(r));
  return r;
}

static inline br_word_t _br_load4(br_word_t a) {
  uint32_t r = 0;
  memcpy(&r, (void *)a, sizeof(r));
  return r;
}

static inline br_word_t _br_load(br_word_t a) {
  br_word_t r = 0;
  memcpy(&r, (void *)a, sizeof(r));
  return r;
}

static inline void _br_store1(br_word_t a, uint8_t v) {
  *((uint8_t *)a) = v;
}

static inline void _br_store2(br_word_t a, uint16_t v) {
  memcpy((void *)a, &v, sizeof(v));
}

static inline void _br_store4(br_word_t a, uint32_t v) {
  memcpy((void *)a, &v, sizeof(v));
}

static inline void _br_store(br_word_t a, br_word_t v) {
  memcpy((void *)a, &v, sizeof(v));
}

static inline br_word_t _br_mulhuu(br_word_t a, br_word_t b) {
  #if BR_WORD_MAX == UINT32_MAX
	  return ((uint64_t)a * b) >> 32;
  #elif BR_WORD_MAX == UINT64_MAX && (defined(__GNUC__) || defined(__clang__))
    return ((unsigned __int128)a * b) >> 64;
  #elif defined(_M_X64)
    uint64_t hi;
    _umul128(a, b, &hi);
    return hi;
  #elif defined(_M_ARM64)
    return __umulh(a, b);
  #else
    // See full_mul.v
    br_word_t hh, lh, hl, low, second_halfword_w_oflow, n, ll, M;
    n = ((((0u-(br_word_t)0x1)>>27)&0x3f)+0x1)>>1;
    M = ((br_word_t)0x1<<n)-0x1;
    ll = (a&M)*(b&M);
    lh = (a&M)*(b>>n);
    hl = (a>>n)*(b&M);
    hh = (a>>n)*(b>>n);
    second_halfword_w_oflow = ((ll>>n)+(lh&M))+(hl&M);
    return ((hh+(lh>>n))+(hl>>n))+(second_halfword_w_oflow>>n);
  #endif
}

static inline br_word_t _br_divu(br_word_t a, br_word_t b) {
  if (!b) return -1;
  return a/b;
}

static inline br_word_t _br_remu(br_word_t a, br_word_t b) {
  if (!b) return a;
  return a%b;
}


/*
 * Input Bounds:
 *   in0: [[0x0 ~> 0x1ffffffffffffe], [0x0 ~> 0x1ffffffffffffe], [0x0 ~> 0x1ffffffffffffe], [0x0 ~> 0x1ffffffffffffe], [0x0 ~> 0x1fffffffffffe]]
 *   in1: [[0x0 ~> 0x1ffffffffffffe], [0x0 ~> 0x1ffffffffffffe], [0x0 ~> 0x1ffffffffffffe], [0x0 ~> 0x1ffffffffffffe], [0x0 ~> 0x1fffffffffffe]]
 * Output Bounds:
 *   out0: [[0x0 ~> 0x1ffffffffffffe], [0x0 ~> 0x1ffffffffffffe], [0x0 ~> 0x1ffffffffffffe], [0x0 ~> 0x1ffffffffffffe], [0x0 ~> 0x17fffffffffff]]
 */
static
void internal_fiat_secp256k1_dettman_mul(br_word_t out0, br_word_t in0, br_word_t in1) {
  br_word_t x10, x14, x16, x19, x17, x20, x15, x18, x22, x25, x23, x26, x21, x24, x28, x31, x29, x32, x27, x12, x30, x35, x33, x36, x13, x37, x34, x11, x42, x44, x47, x45, x48, x43, x46, x50, x53, x51, x54, x49, x52, x56, x59, x57, x60, x55, x58, x62, x65, x63, x66, x61, x64, x38, x69, x67, x40, x68, x72, x70, x73, x41, x74, x71, x77, x79, x82, x80, x83, x78, x81, x85, x88, x86, x89, x84, x87, x91, x94, x92, x95, x90, x93, x75, x98, x96, x99, x97, x76, x102, x101, x104, x106, x109, x107, x110, x105, x111, x108, x114, x116, x119, x117, x120, x115, x118, x122, x125, x123, x126, x121, x124, x100, x129, x127, x130, x128, x132, x135, x137, x140, x138, x141, x136, x139, x112, x144, x142, x133, x143, x147, x145, x148, x134, x149, x146, x4, x8, x3, x9, x152, x154, x157, x155, x158, x153, x156, x131, x161, x159, x160, x2, x5, x1, x6, x165, x167, x170, x168, x171, x166, x0, x7, x169, x173, x176, x174, x177, x172, x175, x150, x180, x178, x163, x179, x183, x181, x184, x164, x185, x182, x162, x188, x186, x39, x191, x189, x192, x190, x193, x103, x113, x151, x187, x194, x195, x196, x197, x198, x199, x200;
  x0 = _br_load(in0+0);
  x1 = _br_load(in0+8);
  x2 = _br_load(in0+16);
  x3 = _br_load(in0+24);
  x4 = _br_load(in0+32);
  /*skip*/
  x5 = _br_load(in1+0);
  x6 = _br_load(in1+8);
  x7 = _br_load(in1+16);
  x8 = _br_load(in1+24);
  x9 = _br_load(in1+32);
  /*skip*/
  /*skip*/
  x10 = x4*x9;
  x11 = _br_mulhuu(x4, x9);
  x12 = x10*0x1000003d10;
  x13 = _br_mulhuu(x10, (br_word_t)0x1000003d10);
  x14 = x3*x5;
  x15 = _br_mulhuu(x3, x5);
  x16 = x2*x6;
  x17 = _br_mulhuu(x2, x6);
  x18 = x16+x14;
  x19 = (br_word_t)(x18<x16);
  x20 = x19+x17;
  x21 = x20+x15;
  x22 = x1*x7;
  x23 = _br_mulhuu(x1, x7);
  x24 = x22+x18;
  x25 = (br_word_t)(x24<x22);
  x26 = x25+x23;
  x27 = x26+x21;
  x28 = x0*x8;
  x29 = _br_mulhuu(x0, x8);
  x30 = x28+x24;
  x31 = (br_word_t)(x30<x28);
  x32 = x31+x29;
  x33 = x32+x27;
  x34 = x30+x12;
  x35 = (br_word_t)(x34<x30);
  x36 = x35+x33;
  x37 = x36+x13;
  x38 = (x34>>((br_word_t)52&(sizeof(br_word_t)*8-1)))|(x37<<12);
  x39 = x34&0xfffffffffffff;
  x40 = x11*0x1000003d10000;
  x41 = _br_mulhuu(x11, (br_word_t)0x1000003d10000);
  x42 = x4*x5;
  x43 = _br_mulhuu(x4, x5);
  x44 = x3*x6;
  x45 = _br_mulhuu(x3, x6);
  x46 = x44+x42;
  x47 = (br_word_t)(x46<x44);
  x48 = x47+x45;
  x49 = x48+x43;
  x50 = x2*x7;
  x51 = _br_mulhuu(x2, x7);
  x52 = x50+x46;
  x53 = (br_word_t)(x52<x50);
  x54 = x53+x51;
  x55 = x54+x49;
  x56 = x1*x8;
  x57 = _br_mulhuu(x1, x8);
  x58 = x56+x52;
  x59 = (br_word_t)(x58<x56);
  x60 = x59+x57;
  x61 = x60+x55;
  x62 = x0*x9;
  x63 = _br_mulhuu(x0, x9);
  x64 = x62+x58;
  x65 = (br_word_t)(x64<x62);
  x66 = x65+x63;
  x67 = x66+x61;
  x68 = x38+x64;
  x69 = (br_word_t)(x68<x38);
  x70 = x69+x67;
  x71 = x68+x40;
  x72 = (br_word_t)(x71<x68);
  x73 = x72+x70;
  x74 = x73+x41;
  x75 = (x71>>((br_word_t)52&(sizeof(br_word_t)*8-1)))|(x74<<12);
  x76 = x71&0xfffffffffffff;
  x77 = x4*x6;
  x78 = _br_mulhuu(x4, x6);
  x79 = x3*x7;
  x80 = _br_mulhuu(x3, x7);
  x81 = x79+x77;
  x82 = (br_word_t)(x81<x79);
  x83 = x82+x80;
  x84 = x83+x78;
  x85 = x2*x8;
  x86 = _br_mulhuu(x2, x8);
  x87 = x85+x81;
  x88 = (br_word_t)(x87<x85);
  x89 = x88+x86;
  x90 = x89+x84;
  x91 = x1*x9;
  x92 = _br_mulhuu(x1, x9);
  x93 = x91+x87;
  x94 = (br_word_t)(x93<x91);
  x95 = x94+x92;
  x96 = x95+x90;
  x97 = x75+x93;
  x98 = (br_word_t)(x97<x75);
  x99 = x98+x96;
  x100 = (x97>>((br_word_t)52&(sizeof(br_word_t)*8-1)))|(x99<<12);
  x101 = x97&0xfffffffffffff;
  x102 = x76>>((br_word_t)48&(sizeof(br_word_t)*8-1));
  x103 = x76&0xffffffffffff;
  x104 = (x102+(x101<<4))*0x1000003d1;
  x105 = _br_mulhuu((x102+(x101<<4)), (br_word_t)0x1000003d1);
  x106 = x0*x5;
  x107 = _br_mulhuu(x0, x5);
  x108 = x106+x104;
  x109 = (br_word_t)(x108<x106);
  x110 = x109+x107;
  x111 = x110+x105;
  x112 = (x108>>((br_word_t)52&(sizeof(br_word_t)*8-1)))|(x111<<12);
  x113 = x108&0xfffffffffffff;
  x114 = x4*x7;
  x115 = _br_mulhuu(x4, x7);
  x116 = x3*x8;
  x117 = _br_mulhuu(x3, x8);
  x118 = x116+x114;
  x119 = (br_word_t)(x118<x116);
  x120 = x119+x117;
  x121 = x120+x115;
  x122 = x2*x9;
  x123 = _br_mulhuu(x2, x9);
  x124 = x122+x118;
  x125 = (br_word_t)(x124<x122);
  x126 = x125+x123;
  x127 = x126+x121;
  x128 = x100+x124;
  x129 = (br_word_t)(x128<x100);
  x130 = x129+x127;
  x131 = (x128>>((br_word_t)52&(sizeof(br_word_t)*8-1)))|(x130<<12);
  x132 = x128&0xfffffffffffff;
  x133 = x132*0x1000003d10;
  x134 = _br_mulhuu(x132, (br_word_t)0x1000003d10);
  x135 = x1*x5;
  x136 = _br_mulhuu(x1, x5);
  x137 = x0*x6;
  x138 = _br_mulhuu(x0, x6);
  x139 = x137+x135;
  x140 = (br_word_t)(x139<x137);
  x141 = x140+x138;
  x142 = x141+x136;
  x143 = x112+x139;
  x144 = (br_word_t)(x143<x112);
  x145 = x144+x142;
  x146 = x143+x133;
  x147 = (br_word_t)(x146<x143);
  x148 = x147+x145;
  x149 = x148+x134;
  x150 = (x146>>((br_word_t)52&(sizeof(br_word_t)*8-1)))|(x149<<12);
  x151 = x146&0xfffffffffffff;
  x152 = x4*x8;
  x153 = _br_mulhuu(x4, x8);
  x154 = x3*x9;
  x155 = _br_mulhuu(x3, x9);
  x156 = x154+x152;
  x157 = (br_word_t)(x156<x154);
  x158 = x157+x155;
  x159 = x158+x153;
  x160 = x131+x156;
  x161 = (br_word_t)(x160<x131);
  x162 = x161+x159;
  x163 = x160*0x1000003d10;
  x164 = _br_mulhuu(x160, (br_word_t)0x1000003d10);
  x165 = x2*x5;
  x166 = _br_mulhuu(x2, x5);
  x167 = x1*x6;
  x168 = _br_mulhuu(x1, x6);
  x169 = x167+x165;
  x170 = (br_word_t)(x169<x167);
  x171 = x170+x168;
  x172 = x171+x166;
  x173 = x0*x7;
  x174 = _br_mulhuu(x0, x7);
  x175 = x173+x169;
  x176 = (br_word_t)(x175<x173);
  x177 = x176+x174;
  x178 = x177+x172;
  x179 = x150+x175;
  x180 = (br_word_t)(x179<x150);
  x181 = x180+x178;
  x182 = x179+x163;
  x183 = (br_word_t)(x182<x179);
  x184 = x183+x181;
  x185 = x184+x164;
  x186 = (x182>>((br_word_t)52&(sizeof(br_word_t)*8-1)))|(x185<<12);
  x187 = x182&0xfffffffffffff;
  x188 = x162*0x1000003d10000;
  x189 = _br_mulhuu(x162, (br_word_t)0x1000003d10000);
  x190 = (x186+x39)+x188;
  x191 = (br_word_t)(x190<(x186+x39));
  x192 = x191+x189;
  x193 = (x190>>((br_word_t)52&(sizeof(br_word_t)*8-1)))|(x192<<12);
  x194 = x190&0xfffffffffffff;
  x195 = x193+x103;
  x196 = x113;
  x197 = x151;
  x198 = x187;
  x199 = x194;
  x200 = x195;
  /*skip*/
  _br_store(out0+0, x196);
  _br_store(out0+8, x197);
  _br_store(out0+16, x198);
  _br_store(out0+24, x199);
  _br_store(out0+32, x200);
  /*skip*/
}

/* NOTE: The following wrapper function is not covered by Coq proofs */
static void fiat_secp256k1_dettman_mul(uint64_t out1[5], const uint64_t arg1[5], const uint64_t arg2[5]) {
  internal_fiat_secp256k1_dettman_mul((uintptr_t)out1, (uintptr_t)arg1, (uintptr_t)arg2);
}


/*
 * Input Bounds:
 *   in0: [[0x0 ~> 0x1ffffffffffffe], [0x0 ~> 0x1ffffffffffffe], [0x0 ~> 0x1ffffffffffffe], [0x0 ~> 0x1ffffffffffffe], [0x0 ~> 0x1fffffffffffe]]
 * Output Bounds:
 *   out0: [[0x0 ~> 0x1ffffffffffffe], [0x0 ~> 0x1ffffffffffffe], [0x0 ~> 0x1ffffffffffffe], [0x0 ~> 0x1ffffffffffffe], [0x0 ~> 0x17fffffffffff]]
 */
static
void internal_fiat_secp256k1_dettman_square(br_word_t out0, br_word_t in0) {
  br_word_t x9, x13, x15, x18, x16, x19, x14, x11, x17, x22, x20, x23, x12, x24, x21, x10, x29, x31, x34, x32, x35, x30, x33, x37, x40, x38, x41, x36, x39, x25, x44, x42, x27, x43, x47, x45, x48, x28, x49, x46, x7, x52, x54, x57, x55, x58, x53, x56, x50, x61, x59, x62, x60, x51, x65, x64, x0, x67, x69, x72, x70, x73, x68, x74, x71, x3, x6, x77, x79, x82, x80, x83, x78, x81, x63, x86, x84, x87, x85, x89, x92, x75, x95, x93, x90, x94, x98, x96, x99, x91, x100, x97, x5, x4, x103, x88, x106, x104, x105, x1, x8, x2, x110, x112, x115, x113, x116, x111, x114, x101, x119, x117, x108, x118, x122, x120, x123, x109, x124, x121, x107, x127, x125, x26, x130, x128, x131, x129, x132, x66, x76, x102, x126, x133, x134, x135, x136, x137, x138, x139;
  x0 = _br_load(in0+0);
  x1 = _br_load(in0+8);
  x2 = _br_load(in0+16);
  x3 = _br_load(in0+24);
  x4 = _br_load(in0+32);
  /*skip*/
  /*skip*/
  x5 = x3*2;
  x6 = x2*2;
  x7 = x1*2;
  x8 = x0*2;
  x9 = x4*x4;
  x10 = _br_mulhuu(x4, x4);
  x11 = x9*0x1000003d10;
  x12 = _br_mulhuu(x9, (br_word_t)0x1000003d10);
  x13 = x7*x2;
  x14 = _br_mulhuu(x7, x2);
  x15 = x8*x3;
  x16 = _br_mulhuu(x8, x3);
  x17 = x15+x13;
  x18 = (br_word_t)(x17<x15);
  x19 = x18+x16;
  x20 = x19+x14;
  x21 = x17+x11;
  x22 = (br_word_t)(x21<x17);
  x23 = x22+x20;
  x24 = x23+x12;
  x25 = (x21>>((br_word_t)52&(sizeof(br_word_t)*8-1)))|(x24<<12);
  x26 = x21&0xfffffffffffff;
  x27 = x10*0x1000003d10000;
  x28 = _br_mulhuu(x10, (br_word_t)0x1000003d10000);
  x29 = x2*x2;
  x30 = _br_mulhuu(x2, x2);
  x31 = x7*x3;
  x32 = _br_mulhuu(x7, x3);
  x33 = x31+x29;
  x34 = (br_word_t)(x33<x31);
  x35 = x34+x32;
  x36 = x35+x30;
  x37 = x8*x4;
  x38 = _br_mulhuu(x8, x4);
  x39 = x37+x33;
  x40 = (br_word_t)(x39<x37);
  x41 = x40+x38;
  x42 = x41+x36;
  x43 = x25+x39;
  x44 = (br_word_t)(x43<x25);
  x45 = x44+x42;
  x46 = x43+x27;
  x47 = (br_word_t)(x46<x43);
  x48 = x47+x45;
  x49 = x48+x28;
  x50 = (x46>>((br_word_t)52&(sizeof(br_word_t)*8-1)))|(x49<<12);
  x51 = x46&0xfffffffffffff;
  x52 = x6*x3;
  x53 = _br_mulhuu(x6, x3);
  x54 = x7*x4;
  x55 = _br_mulhuu(x7, x4);
  x56 = x54+x52;
  x57 = (br_word_t)(x56<x54);
  x58 = x57+x55;
  x59 = x58+x53;
  x60 = x50+x56;
  x61 = (br_word_t)(x60<x50);
  x62 = x61+x59;
  x63 = (x60>>((br_word_t)52&(sizeof(br_word_t)*8-1)))|(x62<<12);
  x64 = x60&0xfffffffffffff;
  x65 = x51>>((br_word_t)48&(sizeof(br_word_t)*8-1));
  x66 = x51&0xffffffffffff;
  x67 = (x65+(x64<<4))*0x1000003d1;
  x68 = _br_mulhuu((x65+(x64<<4)), (br_word_t)0x1000003d1);
  x69 = x0*x0;
  x70 = _br_mulhuu(x0, x0);
  x71 = x69+x67;
  x72 = (br_word_t)(x71<x69);
  x73 = x72+x70;
  x74 = x73+x68;
  x75 = (x71>>((br_word_t)52&(sizeof(br_word_t)*8-1)))|(x74<<12);
  x76 = x71&0xfffffffffffff;
  x77 = x3*x3;
  x78 = _br_mulhuu(x3, x3);
  x79 = x6*x4;
  x80 = _br_mulhuu(x6, x4);
  x81 = x79+x77;
  x82 = (br_word_t)(x81<x79);
  x83 = x82+x80;
  x84 = x83+x78;
  x85 = x63+x81;
  x86 = (br_word_t)(x85<x63);
  x87 = x86+x84;
  x88 = (x85>>((br_word_t)52&(sizeof(br_word_t)*8-1)))|(x87<<12);
  x89 = x85&0xfffffffffffff;
  x90 = x89*0x1000003d10;
  x91 = _br_mulhuu(x89, (br_word_t)0x1000003d10);
  x92 = x8*x1;
  x93 = _br_mulhuu(x8, x1);
  x94 = x75+x92;
  x95 = (br_word_t)(x94<x75);
  x96 = x95+x93;
  x97 = x94+x90;
  x98 = (br_word_t)(x97<x94);
  x99 = x98+x96;
  x100 = x99+x91;
  x101 = (x97>>((br_word_t)52&(sizeof(br_word_t)*8-1)))|(x100<<12);
  x102 = x97&0xfffffffffffff;
  x103 = x5*x4;
  x104 = _br_mulhuu(x5, x4);
  x105 = x88+x103;
  x106 = (br_word_t)(x105<x88);
  x107 = x106+x104;
  x108 = x105*0x1000003d10;
  x109 = _br_mulhuu(x105, (br_word_t)0x1000003d10);
  x110 = x1*x1;
  x111 = _br_mulhuu(x1, x1);
  x112 = x8*x2;
  x113 = _br_mulhuu(x8, x2);
  x114 = x112+x110;
  x115 = (br_word_t)(x114<x112);
  x116 = x115+x113;
  x117 = x116+x111;
  x118 = x101+x114;
  x119 = (br_word_t)(x118<x101);
  x120 = x119+x117;
  x121 = x118+x108;
  x122 = (br_word_t)(x121<x118);
  x123 = x122+x120;
  x124 = x123+x109;
  x125 = (x121>>((br_word_t)52&(sizeof(br_word_t)*8-1)))|(x124<<12);
  x126 = x121&0xfffffffffffff;
  x127 = x107*0x1000003d10000;
  x128 = _br_mulhuu(x107, (br_word_t)0x1000003d10000);
  x129 = (x125+x26)+x127;
  x130 = (br_word_t)(x129<(x125+x26));
  x131 = x130+x128;
  x132 = (x129>>((br_word_t)52&(sizeof(br_word_t)*8-1)))|(x131<<12);
  x133 = x129&0xfffffffffffff;
  x134 = x132+x66;
  x135 = x76;
  x136 = x102;
  x137 = x126;
  x138 = x133;
  x139 = x134;
  /*skip*/
  _br_store(out0+0, x135);
  _br_store(out0+8, x136);
  _br_store(out0+16, x137);
  _br_store(out0+24, x138);
  _br_store(out0+32, x139);
  /*skip*/
}

/* NOTE: The following wrapper function is not covered by Coq proofs */
static void fiat_secp256k1_dettman_square(uint64_t out1[5], const uint64_t arg1[5]) {
  internal_fiat_secp256k1_dettman_square((uintptr_t)out1, (uintptr_t)arg1);
}
