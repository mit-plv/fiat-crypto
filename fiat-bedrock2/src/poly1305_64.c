/* Autogenerated: 'src/ExtractionOCaml/bedrock2_unsaturated_solinas' --lang bedrock2 --static --no-wide-int --widen-carry --widen-bytes --split-multiret --no-select --no-field-element-typedefs poly1305 64 3 '2^130 - 5' carry_mul carry_square carry add sub opp selectznz to_bytes from_bytes relax */
/* curve description: poly1305 */
/* machine_wordsize = 64 (from "64") */
/* requested operations: carry_mul, carry_square, carry, add, sub, opp, selectznz, to_bytes, from_bytes, relax */
/* n = 3 (from "3") */
/* s-c = 2^130 - [(1, 5)] (from "2^130 - 5") */
/* tight_bounds_multiplier = 1 (from "") */
/*  */
/* Computed values: */
/*   carry_chain = [0, 1, 2, 0, 1] */
/*   eval z = z[0] + (z[1] << 44) + (z[2] << 87) */
/*   bytes_eval z = z[0] + (z[1] << 8) + (z[2] << 16) + (z[3] << 24) + (z[4] << 32) + (z[5] << 40) + (z[6] << 48) + (z[7] << 56) + (z[8] << 64) + (z[9] << 72) + (z[10] << 80) + (z[11] << 88) + (z[12] << 96) + (z[13] << 104) + (z[14] << 112) + (z[15] << 120) + (z[16] << 128) */
/*   balance = [0x1ffffffffff6, 0xffffffffffe, 0xffffffffffe] */

// Generated from Bedrock code. Avoid editing directly.
#include <stdint.h>
#include <string.h>
#include <assert.h>

#define BR_WORD_MAX UINTPTR_MAX
typedef uintptr_t br_word_t;
typedef intptr_t br_signed_t;

static_assert(sizeof(br_word_t) == sizeof(br_signed_t), "signed size");
static_assert(UINTPTR_MAX <= BR_WORD_MAX, "pointer fits in int");
static_assert(~(br_signed_t)0 == -(br_signed_t)1, "two's complement");

#if __STDC_VERSION__ >= 202311L && __has_include(<stdbit.h>)
  #include <stdbit.h>
  static_assert(__STDC_ENDIAN_NATIVE__ == __STDC_ENDIAN_LITTLE__, "little-endian");
#elif defined(__GNUC__) && defined(__BYTE_ORDER__) && defined(__ORDER_LITTLE_ENDIAN__)
  static_assert(__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__, "little-endian");
#elif defined(_MSC_VER) && !defined(__clang__) &&                              \
    (defined(_M_IX86) || defined(_M_X64) || defined(_M_ARM) || defined(_M_ARM64))
  // these MSVC targets are little-endian
#else
  #error "failed to confirm that target is little-endian"
#endif

// "An object shall have its stored value accessed only ... a character type."
static inline br_word_t _br_load1(br_word_t a) {
  return *((uint8_t *)a);
}

static inline br_word_t _br_load2(br_word_t a) {
  uint16_t r = 0;
  memcpy(&r, (void *)a, sizeof(r));
  return r;
}

static inline br_word_t _br_load4(br_word_t a) {
  uint32_t r = 0;
  memcpy(&r, (void *)a, sizeof(r));
  return r;
}

static inline br_word_t _br_load(br_word_t a) {
  br_word_t r = 0;
  memcpy(&r, (void *)a, sizeof(r));
  return r;
}

static inline void _br_store1(br_word_t a, uint8_t v) {
  *((uint8_t *)a) = v;
}

static inline void _br_store2(br_word_t a, uint16_t v) {
  memcpy((void *)a, &v, sizeof(v));
}

static inline void _br_store4(br_word_t a, uint32_t v) {
  memcpy((void *)a, &v, sizeof(v));
}

static inline void _br_store(br_word_t a, br_word_t v) {
  memcpy((void *)a, &v, sizeof(v));
}

static inline br_word_t _br_mulhuu(br_word_t a, br_word_t b) {
  #if BR_WORD_MAX == UINT32_MAX
	  return ((uint64_t)a * b) >> 32;
  #elif BR_WORD_MAX == UINT64_MAX && (defined(__GNUC__) || defined(__clang__))
    return ((unsigned __int128)a * b) >> 64;
  #elif defined(_M_X64)
    uint64_t hi;
    _umul128(a, b, &hi);
    return hi;
  #elif defined(_M_ARM64)
    return __umulh(a, b);
  #else
    // See full_mul.v
    br_word_t hh, lh, hl, low, second_halfword_w_oflow, n, ll, M;
    n = ((((0u-(br_word_t)0x1)>>27)&0x3f)+0x1)>>1;
    M = ((br_word_t)0x1<<n)-0x1;
    ll = (a&M)*(b&M);
    lh = (a&M)*(b>>n);
    hl = (a>>n)*(b&M);
    hh = (a>>n)*(b>>n);
    second_halfword_w_oflow = ((ll>>n)+(lh&M))+(hl&M);
    return ((hh+(lh>>n))+(hl>>n))+(second_halfword_w_oflow>>n);
  #endif
}

static inline br_word_t _br_divu(br_word_t a, br_word_t b) {
  if (!b) return -1;
  return a/b;
}

static inline br_word_t _br_remu(br_word_t a, br_word_t b) {
  if (!b) return a;
  return a%b;
}


/*
 * Input Bounds:
 *   in0: [[0x0 ~> 0x300000000000], [0x0 ~> 0x180000000000], [0x0 ~> 0x180000000000]]
 *   in1: [[0x0 ~> 0x300000000000], [0x0 ~> 0x180000000000], [0x0 ~> 0x180000000000]]
 * Output Bounds:
 *   out0: [[0x0 ~> 0x100000000000], [0x0 ~> 0x80000000000], [0x0 ~> 0x80000000000]]
 */
static
void internal_fiat_poly1305_carry_mul(br_word_t out0, br_word_t in0, br_word_t in1) {
  br_word_t x2, x1, x5, x4, x0, x3, x8, x10, x25, x11, x26, x9, x24, x22, x29, x23, x30, x27, x31, x28, x12, x14, x35, x15, x36, x13, x34, x18, x39, x19, x40, x37, x6, x16, x43, x17, x44, x7, x42, x20, x47, x21, x48, x45, x46, x32, x51, x49, x52, x50, x38, x53, x56, x41, x57, x55, x58, x33, x60, x61, x62, x54, x64, x65, x59, x63, x66, x67, x68, x69, x70;
  x0 = _br_load(in0+0);
  x1 = _br_load(in0+8);
  x2 = _br_load(in0+16);
  /*skip*/
  x3 = _br_load(in1+0);
  x4 = _br_load(in1+8);
  x5 = _br_load(in1+16);
  /*skip*/
  /*skip*/
  x6 = x2*(x5*5);
  x7 = _br_mulhuu(x2, (x5*5));
  x8 = x2*(x4*10);
  x9 = _br_mulhuu(x2, (x4*10));
  x10 = x1*(x5*10);
  x11 = _br_mulhuu(x1, (x5*10));
  x12 = x2*x3;
  x13 = _br_mulhuu(x2, x3);
  x14 = x1*(x4*2);
  x15 = _br_mulhuu(x1, (x4*2));
  x16 = x1*x3;
  x17 = _br_mulhuu(x1, x3);
  x18 = x0*x5;
  x19 = _br_mulhuu(x0, x5);
  x20 = x0*x4;
  x21 = _br_mulhuu(x0, x4);
  x22 = x0*x3;
  x23 = _br_mulhuu(x0, x3);
  x24 = x10+x8;
  x25 = (br_word_t)(x24<x10);
  x26 = x25+x11;
  x27 = x26+x9;
  x28 = x22+x24;
  x29 = (br_word_t)(x28<x22);
  x30 = x29+x23;
  x31 = x30+x27;
  x32 = (x28>>((br_word_t)44&(sizeof(br_word_t)*8-1)))|(x31<<20);
  x33 = x28&0xfffffffffff;
  x34 = x14+x12;
  x35 = (br_word_t)(x34<x14);
  x36 = x35+x15;
  x37 = x36+x13;
  x38 = x18+x34;
  x39 = (br_word_t)(x38<x18);
  x40 = x39+x19;
  x41 = x40+x37;
  x42 = x16+x6;
  x43 = (br_word_t)(x42<x16);
  x44 = x43+x17;
  x45 = x44+x7;
  x46 = x20+x42;
  x47 = (br_word_t)(x46<x20);
  x48 = x47+x21;
  x49 = x48+x45;
  x50 = x32+x46;
  x51 = (br_word_t)(x50<x32);
  x52 = x51+x49;
  x53 = (x50>>((br_word_t)43&(sizeof(br_word_t)*8-1)))|(x52<<21);
  x54 = x50&0x7ffffffffff;
  x55 = x53+x38;
  x56 = (br_word_t)(x55<x53);
  x57 = x56+x41;
  x58 = (x55>>((br_word_t)43&(sizeof(br_word_t)*8-1)))|(x57<<21);
  x59 = x55&0x7ffffffffff;
  x60 = x58*5;
  x61 = x33+x60;
  x62 = x61>>((br_word_t)44&(sizeof(br_word_t)*8-1));
  x63 = x61&0xfffffffffff;
  x64 = x62+x54;
  x65 = x64>>((br_word_t)43&(sizeof(br_word_t)*8-1));
  x66 = x64&0x7ffffffffff;
  x67 = x65+x59;
  x68 = x63;
  x69 = x66;
  x70 = x67;
  /*skip*/
  _br_store(out0+0, x68);
  _br_store(out0+8, x69);
  _br_store(out0+16, x70);
  /*skip*/
}

/* NOTE: The following wrapper function is not covered by Coq proofs */
static void fiat_poly1305_carry_mul(uint64_t out1[3], const uint64_t arg1[3], const uint64_t arg2[3]) {
  internal_fiat_poly1305_carry_mul((uintptr_t)out1, (uintptr_t)arg1, (uintptr_t)arg2);
}


/*
 * Input Bounds:
 *   in0: [[0x0 ~> 0x300000000000], [0x0 ~> 0x180000000000], [0x0 ~> 0x180000000000]]
 * Output Bounds:
 *   out0: [[0x0 ~> 0x100000000000], [0x0 ~> 0x80000000000], [0x0 ~> 0x80000000000]]
 */
static
void internal_fiat_poly1305_carry_square(br_word_t out0, br_word_t in0) {
  br_word_t x2, x3, x4, x1, x5, x6, x0, x9, x17, x20, x18, x21, x10, x22, x19, x11, x13, x26, x14, x27, x12, x7, x15, x30, x16, x31, x8, x29, x23, x34, x32, x35, x33, x25, x36, x39, x28, x40, x38, x41, x24, x43, x44, x45, x37, x47, x48, x42, x46, x49, x50, x51, x52, x53;
  x0 = _br_load(in0+0);
  x1 = _br_load(in0+8);
  x2 = _br_load(in0+16);
  /*skip*/
  /*skip*/
  x3 = x2*5;
  x4 = x3*2;
  x5 = x2*2;
  x6 = x1*2;
  x7 = x2*x3;
  x8 = _br_mulhuu(x2, x3);
  x9 = x1*(x4*2);
  x10 = _br_mulhuu(x1, (x4*2));
  x11 = x1*(x1*2);
  x12 = _br_mulhuu(x1, (x1*2));
  x13 = x0*x5;
  x14 = _br_mulhuu(x0, x5);
  x15 = x0*x6;
  x16 = _br_mulhuu(x0, x6);
  x17 = x0*x0;
  x18 = _br_mulhuu(x0, x0);
  x19 = x17+x9;
  x20 = (br_word_t)(x19<x17);
  x21 = x20+x18;
  x22 = x21+x10;
  x23 = (x19>>((br_word_t)44&(sizeof(br_word_t)*8-1)))|(x22<<20);
  x24 = x19&0xfffffffffff;
  x25 = x13+x11;
  x26 = (br_word_t)(x25<x13);
  x27 = x26+x14;
  x28 = x27+x12;
  x29 = x15+x7;
  x30 = (br_word_t)(x29<x15);
  x31 = x30+x16;
  x32 = x31+x8;
  x33 = x23+x29;
  x34 = (br_word_t)(x33<x23);
  x35 = x34+x32;
  x36 = (x33>>((br_word_t)43&(sizeof(br_word_t)*8-1)))|(x35<<21);
  x37 = x33&0x7ffffffffff;
  x38 = x36+x25;
  x39 = (br_word_t)(x38<x36);
  x40 = x39+x28;
  x41 = (x38>>((br_word_t)43&(sizeof(br_word_t)*8-1)))|(x40<<21);
  x42 = x38&0x7ffffffffff;
  x43 = x41*5;
  x44 = x24+x43;
  x45 = x44>>((br_word_t)44&(sizeof(br_word_t)*8-1));
  x46 = x44&0xfffffffffff;
  x47 = x45+x37;
  x48 = x47>>((br_word_t)43&(sizeof(br_word_t)*8-1));
  x49 = x47&0x7ffffffffff;
  x50 = x48+x42;
  x51 = x46;
  x52 = x49;
  x53 = x50;
  /*skip*/
  _br_store(out0+0, x51);
  _br_store(out0+8, x52);
  _br_store(out0+16, x53);
  /*skip*/
}

/* NOTE: The following wrapper function is not covered by Coq proofs */
static void fiat_poly1305_carry_square(uint64_t out1[3], const uint64_t arg1[3]) {
  internal_fiat_poly1305_carry_square((uintptr_t)out1, (uintptr_t)arg1);
}


/*
 * Input Bounds:
 *   in0: [[0x0 ~> 0x300000000000], [0x0 ~> 0x180000000000], [0x0 ~> 0x180000000000]]
 * Output Bounds:
 *   out0: [[0x0 ~> 0x100000000000], [0x0 ~> 0x80000000000], [0x0 ~> 0x80000000000]]
 */
static
void internal_fiat_poly1305_carry(br_word_t out0, br_word_t in0) {
  br_word_t x0, x1, x2, x3, x4, x6, x7, x5, x8, x9, x10, x11, x12, x13;
  x0 = _br_load(in0+0);
  x1 = _br_load(in0+8);
  x2 = _br_load(in0+16);
  /*skip*/
  /*skip*/
  x3 = x0;
  x4 = (x3>>((br_word_t)44&(sizeof(br_word_t)*8-1)))+x1;
  x5 = (x4>>((br_word_t)43&(sizeof(br_word_t)*8-1)))+x2;
  x6 = (x3&0xfffffffffff)+((x5>>((br_word_t)43&(sizeof(br_word_t)*8-1)))*5);
  x7 = (x6>>((br_word_t)44&(sizeof(br_word_t)*8-1)))+(x4&0x7ffffffffff);
  x8 = x6&0xfffffffffff;
  x9 = x7&0x7ffffffffff;
  x10 = (x7>>((br_word_t)43&(sizeof(br_word_t)*8-1)))+(x5&0x7ffffffffff);
  x11 = x8;
  x12 = x9;
  x13 = x10;
  /*skip*/
  _br_store(out0+0, x11);
  _br_store(out0+8, x12);
  _br_store(out0+16, x13);
  /*skip*/
}

/* NOTE: The following wrapper function is not covered by Coq proofs */
static void fiat_poly1305_carry(uint64_t out1[3], const uint64_t arg1[3]) {
  internal_fiat_poly1305_carry((uintptr_t)out1, (uintptr_t)arg1);
}


/*
 * Input Bounds:
 *   in0: [[0x0 ~> 0x100000000000], [0x0 ~> 0x80000000000], [0x0 ~> 0x80000000000]]
 *   in1: [[0x0 ~> 0x100000000000], [0x0 ~> 0x80000000000], [0x0 ~> 0x80000000000]]
 * Output Bounds:
 *   out0: [[0x0 ~> 0x300000000000], [0x0 ~> 0x180000000000], [0x0 ~> 0x180000000000]]
 */
static
void internal_fiat_poly1305_add(br_word_t out0, br_word_t in0, br_word_t in1) {
  br_word_t x0, x3, x1, x4, x2, x5, x6, x7, x8, x9, x10, x11;
  x0 = _br_load(in0+0);
  x1 = _br_load(in0+8);
  x2 = _br_load(in0+16);
  /*skip*/
  x3 = _br_load(in1+0);
  x4 = _br_load(in1+8);
  x5 = _br_load(in1+16);
  /*skip*/
  /*skip*/
  x6 = x0+x3;
  x7 = x1+x4;
  x8 = x2+x5;
  x9 = x6;
  x10 = x7;
  x11 = x8;
  /*skip*/
  _br_store(out0+0, x9);
  _br_store(out0+8, x10);
  _br_store(out0+16, x11);
  /*skip*/
}

/* NOTE: The following wrapper function is not covered by Coq proofs */
static void fiat_poly1305_add(uint64_t out1[3], const uint64_t arg1[3], const uint64_t arg2[3]) {
  internal_fiat_poly1305_add((uintptr_t)out1, (uintptr_t)arg1, (uintptr_t)arg2);
}


/*
 * Input Bounds:
 *   in0: [[0x0 ~> 0x100000000000], [0x0 ~> 0x80000000000], [0x0 ~> 0x80000000000]]
 *   in1: [[0x0 ~> 0x100000000000], [0x0 ~> 0x80000000000], [0x0 ~> 0x80000000000]]
 * Output Bounds:
 *   out0: [[0x0 ~> 0x300000000000], [0x0 ~> 0x180000000000], [0x0 ~> 0x180000000000]]
 */
static
void internal_fiat_poly1305_sub(br_word_t out0, br_word_t in0, br_word_t in1) {
  br_word_t x0, x3, x1, x4, x2, x5, x6, x7, x8, x9, x10, x11;
  x0 = _br_load(in0+0);
  x1 = _br_load(in0+8);
  x2 = _br_load(in0+16);
  /*skip*/
  x3 = _br_load(in1+0);
  x4 = _br_load(in1+8);
  x5 = _br_load(in1+16);
  /*skip*/
  /*skip*/
  x6 = ((br_word_t)0x1ffffffffff6+x0)-x3;
  x7 = ((br_word_t)0xffffffffffe +x1)-x4;
  x8 = ((br_word_t)0xffffffffffe +x2)-x5;
  x9 = x6;
  x10 = x7;
  x11 = x8;
  /*skip*/
  _br_store(out0+0, x9);
  _br_store(out0+8, x10);
  _br_store(out0+16, x11);
  /*skip*/
}

/* NOTE: The following wrapper function is not covered by Coq proofs */
static void fiat_poly1305_sub(uint64_t out1[3], const uint64_t arg1[3], const uint64_t arg2[3]) {
  internal_fiat_poly1305_sub((uintptr_t)out1, (uintptr_t)arg1, (uintptr_t)arg2);
}


/*
 * Input Bounds:
 *   in0: [[0x0 ~> 0x100000000000], [0x0 ~> 0x80000000000], [0x0 ~> 0x80000000000]]
 * Output Bounds:
 *   out0: [[0x0 ~> 0x300000000000], [0x0 ~> 0x180000000000], [0x0 ~> 0x180000000000]]
 */
static
void internal_fiat_poly1305_opp(br_word_t out0, br_word_t in0) {
  br_word_t x0, x1, x2, x3, x4, x5, x6, x7, x8;
  x0 = _br_load(in0+0);
  x1 = _br_load(in0+8);
  x2 = _br_load(in0+16);
  /*skip*/
  /*skip*/
  x3 = (br_word_t)0x1ffffffffff6-x0;
  x4 = (br_word_t)0xffffffffffe -x1;
  x5 = (br_word_t)0xffffffffffe -x2;
  x6 = x3;
  x7 = x4;
  x8 = x5;
  /*skip*/
  _br_store(out0+0, x6);
  _br_store(out0+8, x7);
  _br_store(out0+16, x8);
  /*skip*/
}

/* NOTE: The following wrapper function is not covered by Coq proofs */
static void fiat_poly1305_opp(uint64_t out1[3], const uint64_t arg1[3]) {
  internal_fiat_poly1305_opp((uintptr_t)out1, (uintptr_t)arg1);
}


/*
 * Input Bounds:
 *   in0: [0x0 ~> 0x1]
 *   in1: [[0x0 ~> 0xffffffffffffffff], [0x0 ~> 0xffffffffffffffff], [0x0 ~> 0xffffffffffffffff]]
 *   in2: [[0x0 ~> 0xffffffffffffffff], [0x0 ~> 0xffffffffffffffff], [0x0 ~> 0xffffffffffffffff]]
 * Output Bounds:
 *   out0: [[0x0 ~> 0xffffffffffffffff], [0x0 ~> 0xffffffffffffffff], [0x0 ~> 0xffffffffffffffff]]
 */
static
void internal_fiat_poly1305_selectznz(br_word_t out0, br_word_t in0, br_word_t in1, br_word_t in2) {
  br_word_t x3, x6, x0, x7, x4, x9, x1, x10, x5, x12, x2, x13, x8, x11, x14, x15, x16, x17;
  /*skip*/
  x0 = _br_load(in1+0);
  x1 = _br_load(in1+8);
  x2 = _br_load(in1+16);
  /*skip*/
  x3 = _br_load(in2+0);
  x4 = _br_load(in2+8);
  x5 = _br_load(in2+16);
  /*skip*/
  /*skip*/
  x6 = (0u-(br_word_t)1)+((br_word_t)(in0==(br_word_t)0));
  x7 = x6^0xffffffffffffffff;
  x8 = (x3&x6)|(x0&x7);
  x9 = (0u-(br_word_t)1)+((br_word_t)(in0==(br_word_t)0));
  x10 = x9^0xffffffffffffffff;
  x11 = (x4&x9)|(x1&x10);
  x12 = (0u-(br_word_t)1)+((br_word_t)(in0==(br_word_t)0));
  x13 = x12^0xffffffffffffffff;
  x14 = (x5&x12)|(x2&x13);
  x15 = x8;
  x16 = x11;
  x17 = x14;
  /*skip*/
  _br_store(out0+0, x15);
  _br_store(out0+8, x16);
  _br_store(out0+16, x17);
  /*skip*/
}

/* NOTE: The following wrapper function is not covered by Coq proofs */
static void fiat_poly1305_selectznz(uint64_t out1[3], uint8_t arg1, const uint64_t arg2[3], const uint64_t arg3[3]) {
  internal_fiat_poly1305_selectznz((uintptr_t)out1, (uintptr_t)arg1, (uintptr_t)arg2, (uintptr_t)arg3);
}


/*
 * Input Bounds:
 *   in0: [[0x0 ~> 0x100000000000], [0x0 ~> 0x80000000000], [0x0 ~> 0x80000000000]]
 * Output Bounds:
 *   out0: [[0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0x3]]
 */
static
void internal_fiat_poly1305_to_bytes(br_word_t out0, br_word_t in0) {
  br_word_t x0, x4, x3, x1, x6, x7, x8, x10, x11, x9, x2, x13, x14, x15, x17, x18, x16, x20, x5, x22, x23, x25, x12, x26, x27, x29, x28, x30, x32, x19, x33, x21, x34, x35, x31, x24, x39, x41, x43, x45, x37, x47, x48, x50, x52, x54, x56, x36, x58, x59, x61, x63, x65, x67, x69, x38, x40, x42, x44, x46, x49, x51, x53, x55, x57, x60, x62, x64, x66, x68, x70, x71, x72, x73, x74, x75, x76, x77, x78, x79, x80, x81, x82, x83, x84, x85, x86, x87, x88;
  x0 = _br_load(in0+0);
  x1 = _br_load(in0+8);
  x2 = _br_load(in0+16);
  /*skip*/
  /*skip*/
  x3 = x0-0xffffffffffb;
  x4 = (br_word_t)(x0<x3);
  x5 = x3&0xfffffffffff;
  x6 = (x4<<20)-(x3>>((br_word_t)44&(sizeof(br_word_t)*8-1)));
  x7 = x1-0x7ffffffffff;
  x8 = (br_word_t)(x1<x7);
  x9 = x7-x6;
  x10 = (br_word_t)(x7<x9);
  x11 = x8+x10;
  x12 = x9&0x7ffffffffff;
  x13 = (x11<<21)-(x9>>((br_word_t)43&(sizeof(br_word_t)*8-1)));
  x14 = x2-0x7ffffffffff;
  x15 = (br_word_t)(x2<x14);
  x16 = x14-x13;
  x17 = (br_word_t)(x14<x16);
  x18 = x15+x17;
  x19 = x16&0x7ffffffffff;
  x20 = (x18<<21)-(x16>>((br_word_t)43&(sizeof(br_word_t)*8-1)));
  x21 = (0u-(br_word_t)1)+((br_word_t)(x20==(br_word_t)0));
  x22 = x5+(x21&0xffffffffffb);
  x23 = (br_word_t)(x22<x5);
  x24 = x22&0xfffffffffff;
  x25 = (x22>>((br_word_t)44&(sizeof(br_word_t)*8-1)))+(x23<<20);
  x26 = x25+x12;
  x27 = (br_word_t)(x26<x12);
  x28 = x26+(x21&0x7ffffffffff);
  x29 = (br_word_t)(x28<(x21&0x7ffffffffff));
  x30 = x27+x29;
  x31 = x28&0x7ffffffffff;
  x32 = (x28>>((br_word_t)43&(sizeof(br_word_t)*8-1)))+(x30<<21);
  x33 = x32+x19;
  x34 = x33+(x21&0x7ffffffffff);
  x35 = x34&0x7ffffffffff;
  x36 = x35<<7;
  x37 = x31<<4;
  x38 = x24&0xff;
  x39 = x24>>8;
  x40 = x39&0xff;
  x41 = x39>>8;
  x42 = x41&0xff;
  x43 = x41>>8;
  x44 = x43&0xff;
  x45 = x43>>8;
  x46 = x45&0xff;
  x47 = x45>>8;
  x48 = x37+x47;
  x49 = x48&0xff;
  x50 = x48>>8;
  x51 = x50&0xff;
  x52 = x50>>8;
  x53 = x52&0xff;
  x54 = x52>>8;
  x55 = x54&0xff;
  x56 = x54>>8;
  x57 = x56&0xff;
  x58 = x56>>8;
  x59 = x36+x58;
  x60 = x59&0xff;
  x61 = x59>>8;
  x62 = x61&0xff;
  x63 = x61>>8;
  x64 = x63&0xff;
  x65 = x63>>8;
  x66 = x65&0xff;
  x67 = x65>>8;
  x68 = x67&0xff;
  x69 = x67>>8;
  x70 = x69&0xff;
  x71 = x69>>8;
  x72 = x38;
  x73 = x40;
  x74 = x42;
  x75 = x44;
  x76 = x46;
  x77 = x49;
  x78 = x51;
  x79 = x53;
  x80 = x55;
  x81 = x57;
  x82 = x60;
  x83 = x62;
  x84 = x64;
  x85 = x66;
  x86 = x68;
  x87 = x70;
  x88 = x71;
  /*skip*/
  _br_store1(out0+0, x72);
  _br_store1(out0+1, x73);
  _br_store1(out0+2, x74);
  _br_store1(out0+3, x75);
  _br_store1(out0+4, x76);
  _br_store1(out0+5, x77);
  _br_store1(out0+6, x78);
  _br_store1(out0+7, x79);
  _br_store1(out0+8, x80);
  _br_store1(out0+9, x81);
  _br_store1(out0+10, x82);
  _br_store1(out0+11, x83);
  _br_store1(out0+12, x84);
  _br_store1(out0+13, x85);
  _br_store1(out0+14, x86);
  _br_store1(out0+15, x87);
  _br_store1(out0+16, x88);
  /*skip*/
}

/* NOTE: The following wrapper function is not covered by Coq proofs */
static void fiat_poly1305_to_bytes(uint8_t out1[17], const uint64_t arg1[3]) {
  internal_fiat_poly1305_to_bytes((uintptr_t)out1, (uintptr_t)arg1);
}


/*
 * Input Bounds:
 *   in0: [[0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0x3]]
 * Output Bounds:
 *   out0: [[0x0 ~> 0x100000000000], [0x0 ~> 0x80000000000], [0x0 ~> 0x80000000000]]
 */
static
void internal_fiat_poly1305_from_bytes(br_word_t out0, br_word_t in0) {
  br_word_t x16, x15, x14, x13, x12, x11, x10, x9, x8, x7, x6, x5, x4, x3, x2, x1, x0, x32, x33, x31, x34, x30, x35, x29, x36, x28, x37, x38, x27, x40, x26, x41, x25, x42, x24, x43, x23, x44, x45, x22, x47, x21, x48, x20, x49, x19, x50, x18, x51, x17, x52, x39, x46, x53, x54, x55, x56;
  x0 = _br_load1(in0+0);
  x1 = _br_load1(in0+1);
  x2 = _br_load1(in0+2);
  x3 = _br_load1(in0+3);
  x4 = _br_load1(in0+4);
  x5 = _br_load1(in0+5);
  x6 = _br_load1(in0+6);
  x7 = _br_load1(in0+7);
  x8 = _br_load1(in0+8);
  x9 = _br_load1(in0+9);
  x10 = _br_load1(in0+10);
  x11 = _br_load1(in0+11);
  x12 = _br_load1(in0+12);
  x13 = _br_load1(in0+13);
  x14 = _br_load1(in0+14);
  x15 = _br_load1(in0+15);
  x16 = _br_load1(in0+16);
  /*skip*/
  /*skip*/
  x17 = x16<<((br_word_t)41&(sizeof(br_word_t)*8-1));
  x18 = x15<<((br_word_t)33&(sizeof(br_word_t)*8-1));
  x19 = x14<<25;
  x20 = x13<<17;
  x21 = x12<<9;
  x22 = x11*2;
  x23 = x10<<((br_word_t)36&(sizeof(br_word_t)*8-1));
  x24 = x9<<28;
  x25 = x8<<20;
  x26 = x7<<12;
  x27 = x6<<4;
  x28 = x5<<((br_word_t)40&(sizeof(br_word_t)*8-1));
  x29 = x4<<((br_word_t)32&(sizeof(br_word_t)*8-1));
  x30 = x3<<24;
  x31 = x2<<16;
  x32 = x1<<8;
  x33 = x0;
  x34 = x32+x33;
  x35 = x31+x34;
  x36 = x30+x35;
  x37 = x29+x36;
  x38 = x28+x37;
  x39 = x38&0xfffffffffff;
  x40 = x38>>((br_word_t)44&(sizeof(br_word_t)*8-1));
  x41 = x27+x40;
  x42 = x26+x41;
  x43 = x25+x42;
  x44 = x24+x43;
  x45 = x23+x44;
  x46 = x45&0x7ffffffffff;
  x47 = x45>>((br_word_t)43&(sizeof(br_word_t)*8-1));
  x48 = x22+x47;
  x49 = x21+x48;
  x50 = x20+x49;
  x51 = x19+x50;
  x52 = x18+x51;
  x53 = x17+x52;
  x54 = x39;
  x55 = x46;
  x56 = x53;
  /*skip*/
  _br_store(out0+0, x54);
  _br_store(out0+8, x55);
  _br_store(out0+16, x56);
  /*skip*/
}

/* NOTE: The following wrapper function is not covered by Coq proofs */
static void fiat_poly1305_from_bytes(uint64_t out1[3], const uint8_t arg1[17]) {
  internal_fiat_poly1305_from_bytes((uintptr_t)out1, (uintptr_t)arg1);
}


/*
 * Input Bounds:
 *   in0: [[0x0 ~> 0x100000000000], [0x0 ~> 0x80000000000], [0x0 ~> 0x80000000000]]
 * Output Bounds:
 *   out0: [[0x0 ~> 0x300000000000], [0x0 ~> 0x180000000000], [0x0 ~> 0x180000000000]]
 */
static
void internal_fiat_poly1305_relax(br_word_t out0, br_word_t in0) {
  br_word_t x0, x1, x2, x3, x4, x5, x6, x7, x8;
  x0 = _br_load(in0+0);
  x1 = _br_load(in0+8);
  x2 = _br_load(in0+16);
  /*skip*/
  /*skip*/
  x3 = x0;
  x4 = x1;
  x5 = x2;
  x6 = x3;
  x7 = x4;
  x8 = x5;
  /*skip*/
  _br_store(out0+0, x6);
  _br_store(out0+8, x7);
  _br_store(out0+16, x8);
  /*skip*/
}

/* NOTE: The following wrapper function is not covered by Coq proofs */
static void fiat_poly1305_relax(uint64_t out1[3], const uint64_t arg1[3]) {
  internal_fiat_poly1305_relax((uintptr_t)out1, (uintptr_t)arg1);
}
